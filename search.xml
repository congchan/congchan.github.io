<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[æ·±å…¥ç†è§£word2vecç»†èŠ‚ä»¥åŠTensorFlowå®žçŽ°]]></title>
    <url>%2Fword2vec%2F</url>
    <content type="text"><![CDATA[Word2vec Mikolov et al. How to represent meanings?å¦‚ä½•åœ¨æ•°å­¦ä¸Šè¡¨è¾¾è¯ä¹‰ï¼Ÿ Vector space models (VSMs) è¡¨ç¤ºæŠŠå•è¯æ˜ å°„åˆ°(åµŒå…¥)è¿žç»­çš„çŸ¢é‡ç©ºé—´, è€Œä¸”ç†è®ºä¸Šè¯­ä¹‰ç›¸ä¼¼çš„å•è¯ä¼šæ˜ å°„åˆ°ç©ºé—´ä¸­ä¸´è¿‘çš„ä½ç½®ã€‚VSMsæ˜¯ä¸€ä¸ªåŽ†å²æ‚ ä¹…çš„NLPç†è®ºï¼Œä½†æ‰€æœ‰å®žçŽ°æ–¹æ³•éƒ½ä¸åŒç¨‹åº¦ä¾èµ–äºŽDistributional Hypothesis, å³å‡ºçŽ°åœ¨ç›¸åŒï¼ˆç›¸ä¼¼ï¼‰çš„ä¸Šä¸‹æ–‡ä¸­çš„å•è¯å…·æœ‰ç›¸åŒï¼ˆç›¸ä¼¼ï¼‰çš„è¯­ä¹‰æ„ä¹‰ã€‚åˆ©ç”¨æ­¤åŽŸåˆ™çš„æ–¹æ³•å¤§è‡´å¯ä»¥åˆ†ä¸ºä¸¤ç±»: Count-based methods (ä¾‹å¦‚, Latent Semantic Analysis))å’ŒPredictive models(ä¾‹å¦‚ neural net language models (NNLM))ã€‚ å…·ä½“çš„åŒºåˆ«è¯¦è§Baroni et al.. ä½†æ€»çš„æ¥è¯´ï¼ŒCount-based methods ç»Ÿè®¡è¯æ±‡é—´çš„å…±çŽ°é¢‘çŽ‡ï¼Œç„¶åŽæŠŠco-occurs matrix æ˜ å°„åˆ°å‘é‡ç©ºé—´ä¸­ï¼›è€ŒPredictive modelsç›´æŽ¥é€šè¿‡ä¸Šä¸‹æ–‡é¢„æµ‹å•è¯çš„æ–¹å¼æ¥å­¦ä¹ å‘é‡ç©ºé—´ï¼ˆä¹Ÿå°±æ˜¯æ¨¡åž‹å‚æ•°ç©ºé—´ï¼‰ã€‚ Word2vec æ˜¯ä¸€ç§è®¡ç®—ç‰¹åˆ«é«˜æ•ˆçš„predictive model, ç”¨äºŽä»Žæ–‡æœ¬ä¸­å­¦ä¹ word embeddingsã€‚å®ƒæœ‰ä¸¤ç§æ–¹æ¡ˆ, Continuous Bag-of-Words model (CBOW) å’Œ Skip-Gram model (Section 3.1 and 3.2 in Mikolov et al.). ä»Žç®—æ³•ä¸Šè®², ä¸¤ç§æ–¹æ¡ˆæ˜¯ç›¸ä¼¼çš„, åªä¸è¿‡ CBOW ä¼šä»Žsource context-words (&#39;the cat sits on the&#39;)é¢„æµ‹ç›®æ ‡å•è¯(ä¾‹å¦‚&quot;mat&quot;); è€Œskip-gramåˆ™ç›¸å, é¢„æµ‹ç›®æ ‡å•è¯çš„source context-wordsã€‚Skip-gramè¿™ç§åšæ³•å¯èƒ½çœ‹èµ·æ¥æœ‰ç‚¹éšæ„. ä½†ä»Žç»Ÿè®¡ä¸Šçœ‹, CBOW ä¼šå¹³æ»‘å¤§é‡åˆ†å¸ƒä¿¡æ¯(é€šè¿‡å°†æ•´ä¸ªä¸Šä¸‹æ–‡è§†ä¸ºä¸€ä¸ªè§‚æµ‹å€¼), åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹, è¿™å¯¹è¾ƒå°çš„æ•°æ®é›†æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚ä½†æ˜¯, Skip-gramå°†æ¯ä¸ªcontext-target pairè§†ä¸ºæ–°çš„è§‚æµ‹å€¼, å½“æ•°æ®é›†è¾ƒå¤§æ—¶, è¿™å¾€å¾€å¸¦æ¥æ›´å¥½çš„æ•ˆæžœã€‚ ä¼˜åŒ–ç›®æ ‡å‡½æ•°NNLM çš„è®­ç»ƒæ˜¯åˆ©ç”¨ æœ€å¤§ä¼¼ç„¶ maximum likelihood (ML) åŽŸåˆ™æ¥æœ€å¤§åŒ–ç»™å®šä¸Šæ–‡å•è¯\(h\) (for â€œhistoryâ€) é¢„æµ‹ä¸‹ä¸€ä¸ªè¯çš„æ¦‚çŽ‡ \(w_t\) (for â€œtargetâ€)ã€‚ $$\begin{align}P(w_t | h) &amp;= \text{softmax}(\text{score}(w_t, h)) \ &amp;= \frac{\exp { \text{score}(w_t, h) } } {\sum_\text{Word wâ€™ in Vocab} \exp { \text{score}(wâ€™, h) } }\end{align}$$ å…¶ä¸­ \(\text{score}(w_t, h)\) è®¡ç®— word \(w_t\) å’Œ context \(h\) çš„ç›¸å…³æ€§ (ä¸€èˆ¬ç”¨ç‚¹ä¹˜). è®­ç»ƒæ—¶ï¼Œæœ€å¤§åŒ– $$\begin{align} J_\text{ML} &amp;= \log P(w_t | h) \ &amp;= \text{score}(w_t, h) - \log \left( \sum_\text{Word wâ€™ in Vocab} \exp { \text{score}(wâ€™, h) } \right).\end{align}$$ è¿™ä¹ˆè®¡ç®—æˆæœ¬å¾ˆé«˜ï¼Œ å› ä¸ºåœ¨æ¯ä¸€è®­ç»ƒæ­¥ï¼Œéœ€è¦ä¸ºè¯æ±‡è¡¨ \(V\) ä¸­çš„æ¯ä¸€ä¸ªè¯æ±‡ \(wâ€™\) è®¡ç®—åœ¨å½“å‰ä¸Šä¸‹æ–‡ \(h\) çš„åˆ†æ•°æ¦‚çŽ‡ã€‚ Negative samplingä½†æ˜¯ï¼Œword2vecçš„ç›®çš„æ˜¯ç‰¹å¾å­¦ä¹ ï¼Œè€Œä¸æ˜¯å­¦ä¹ å®Œæ•´çš„æ¦‚çŽ‡è¯­è¨€æ¨¡åž‹ã€‚æ‰€ä»¥word2vecï¼ˆCBOWå’ŒSkip gramä¸€æ ·ï¼‰çš„è®­ç»ƒç›®æ ‡å‡½æ•°å…¶å®žæ˜¯ä¸€ä¸ªäºŒåˆ†ç±»æ¨¡åž‹(logistic regression)ï¼Œç»™å®šä¸€ä¸ªä¸Šä¸‹æ–‡ï¼Œåœ¨ \(k\) ä¸ªå™ªå£°è¯ï¼ˆæ ¹æ®ç®—æ³•é€‰å‡ºï¼‰å’Œä¸€ä¸ªçœŸæ­£çš„ç›®æ ‡è¯æ±‡\(w_t\)ä¸­è¯†åˆ«å‡ºç›®æ ‡è¯\(w_t\)ã€‚å¦‚ä¸‹å›¾(ä»¥CBOWä¸ºä¾‹, Skip gramæ–¹å‘åè¿‡æ¥) ç›®æ ‡å‡½æ•°å˜ä¸ºæœ€å¤§åŒ–:$$J_\text{NEG} = \log Q_\theta(D=1 |w_t, h) + k \mathop{\mathbb{E}}_{\tilde w \sim P_n}\left[ \log Q_\theta(D = 0 |\tilde w, h) \right]$$ where \(Q_\theta(D=1 | w, h)\) is the binary logistic regression probabilityunder the model of seeing the word \(w\) in the context \(h\) in the dataset\(D\), calculated in terms of the learned embedding vectors \(\theta\). Inpractice we approximate the expectation by drawing \(k\) contrastive wordsfrom the noise distribution (i.e. we compute aMonte Carlo average). è´Ÿé‡‡æ ·æ˜¯æŒ‡æ¯ä¸ªè®­ç»ƒæ ·æœ¬ä»…æ›´æ–°æ¨¡åž‹æƒé‡çš„ä¸€å°éƒ¨åˆ†ï¼š è´Ÿé‡‡æ ·çš„é€‰æ‹©æ˜¯åŸºäºŽ unigram åˆ†å¸ƒ $f(w_i)$: ä¸€ä¸ªè¯ä½œä¸ºè´Ÿé¢æ ·æœ¬è¢«é€‰æ‹©çš„æ¦‚çŽ‡ä¸Žå…¶å‡ºçŽ°çš„é¢‘çŽ‡æœ‰å…³ï¼Œæ›´é¢‘ç¹çš„è¯æ›´å¯èƒ½è¢«é€‰ä½œè´Ÿé¢æ ·æœ¬ã€‚$$P(w_i) = \frac{ {f(w_i)}^{3/4} }{\sum_{j=0}^{n}\left( {f(w_j)}^{3/4} \right) }$$è´Ÿé‡‡æ ·å¸¦æ¥çš„å¥½å¤„æ˜¯ è®­ç»ƒé€Ÿåº¦ä¸å†å—é™äºŽ vocabulary size èƒ½å¤Ÿå¹¶è¡Œå®žçŽ° æ¨¡åž‹çš„è¡¨çŽ°æ›´å¥½ã€‚å› ä¸ºè´Ÿé‡‡æ ·å¥‘åˆNLPçš„ç¨€ç–æ€§è´¨ï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œè™½ç„¶è¯­æ–™åº“å¾ˆå¤§ï¼Œä½†æ˜¯æ¯ä¸€ä¸ªè¯åªè·Ÿå¾ˆå°éƒ¨åˆ†è¯ç”±å…³è”ï¼Œå¤§éƒ¨åˆ†è¯ä¹‹é—´æ˜¯æ¯«æ— å…³è”çš„ï¼Œä»Žæ— å…³è”çš„ä¸¤ä¸ªè¯ä¹‹é—´ä¹Ÿåˆ«æŒ‡æœ›èƒ½å­¦åˆ°ä»€ä¹ˆæœ‰ç”¨çš„ä¿¡æ¯ï¼Œä¸å¦‚ç›´æŽ¥å¿½ç•¥ã€‚æ¨¡åž‹çš„è¡¨çŽ°æ›´å¥½ã€‚å› ä¸ºè´Ÿé‡‡æ ·å¥‘åˆNLPçš„ç¨€ç–æ€§è´¨ï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œè™½ç„¶è¯­æ–™åº“å¾ˆå¤§ï¼Œä½†æ˜¯æ¯ä¸€ä¸ªè¯åªè·Ÿå¾ˆå°éƒ¨åˆ†è¯ç”±å…³è”ï¼Œå¤§éƒ¨åˆ†è¯ä¹‹é—´æ˜¯æ¯«æ— å…³è”çš„ï¼Œä»Žæ— å…³è”çš„ä¸¤ä¸ªè¯ä¹‹é—´ä¹Ÿåˆ«æŒ‡æœ›èƒ½å­¦åˆ°ä»€ä¹ˆæœ‰ç”¨çš„ä¿¡æ¯ï¼Œä¸å¦‚ç›´æŽ¥å¿½ç•¥ã€‚ æ¯ä¸ªè¯ç”±ä¸¤ä¸ªå‘é‡è¡¨ç¤ºï¼š $v_w$, è¡¨ç¤ºè¿™ä¸ªè¯ä½œä¸ºä¸­å¿ƒè¯ (Focus Word) æ—¶çš„æ ·å­ã€‚ $u_w$, è¡¨ç¤ºå®ƒä½œä¸ºå¦ä¸€ä¸ªä¸­å¿ƒè¯çš„ä¸Šä¸‹æ–‡ (Context Word) æ—¶çš„æ ·å­ã€‚ è¿™æ ·, å¯¹äºŽä¸€ä¸ªä¸­å¿ƒè¯ $c$ å’Œå¤–å›´è¯$o$:$$P(o|c) = \frac{exp(u^T_o v_c)}{\sum_{w \in V} \left( {exp(u^T_w v_c)} \right)}$$ åœ¨Cè¯­è¨€çš„æºä»£ç é‡Œï¼Œè¿™äº›å‘é‡ç”±ä¸¤ä¸ªæ•°ç»„ (Array) åˆ†åˆ«è´Ÿè´£ï¼šsyn0æ•°ç»„ï¼Œè´Ÿè´£æŸä¸ªè¯ä½œä¸ºä¸­å¿ƒè¯æ—¶çš„å‘é‡ã€‚æ˜¯éšæœºåˆå§‹åŒ–çš„ã€‚123456// https://github.com/tmikolov/word2vec/blob/20c129af10659f7c50e86e3be406df663beff438/word2vec.c#L369for (a = 0; a &lt; vocab_size; a++) for (b = 0; b &lt; layer1_size; b++) &#123; next_random = next_random * (unsigned long long)25214903917 + 11; syn0[a * layer1_size + b] = (((next_random &amp; 0xFFFF) / (real)65536) - 0.5) / layer1_size; &#125; syn1negæ•°ç»„ï¼Œè´Ÿè´£è¿™ä¸ªè¯ä½œä¸ºä¸Šä¸‹æ–‡æ—¶çš„å‘é‡ã€‚æ˜¯é›¶åˆå§‹åŒ–çš„ã€‚123// https://github.com/tmikolov/word2vec/blob/20c129af10659f7c50e86e3be406df663beff438/word2vec.c#L365for (a = 0; a &lt; vocab_size; a++) for (b = 0; b &lt; layer1_size; b++) syn1neg[a * layer1_size + b] = 0; è®­ç»ƒæ—¶ï¼Œå…ˆé€‰å‡ºä¸€ä¸ªä¸­å¿ƒè¯ã€‚åœ¨æ­£ã€è´Ÿæ ·æœ¬è®­ç»ƒçš„æ—¶å€™ï¼Œè¿™ä¸ªä¸­å¿ƒè¯å°±ä¿æŒä¸å˜ (Constant) äº†ã€‚ 12345678910# https://github.com/tensorflow/models/blob/8c7a0e752f9605d284b2f08a346fdc1d51935d75/tutorials/embedding/word2vec.py#L226# Negative sampling.sampled_ids, _, _ = (tf.nn.fixed_unigram_candidate_sampler( true_classes=labels_matrix, num_true=1, num_sampled=opts.num_samples, unique=True, range_max=opts.vocab_size, distortion=0.75, unigrams=opts.vocab_counts.tolist())) ç”¨TensorFlowå®žçŽ°word2vecNegative Sampling å¯ä»¥åˆ©ç”¨åŽŸç†è¿‘ä¼¼çš„ noise-contrastive estimation (NCE) loss, å·²ç»åœ¨TFçš„tf.nn.nce_loss()å®žçŽ°äº†. Building the graphåˆå§‹åŒ–ä¸€ä¸ªåœ¨-1: 1ä¹‹é—´éšæœºå‡åŒ€åˆ†å¸ƒçš„çŸ©é˜µ12embeddings = tf.Variable( tf.random_uniform([vocabulary_size, embedding_size], -1.0, 1.0)) NCE loss ä¾é™„äºŽ logistic regression æ¨¡åž‹ã€‚ä¸ºæ­¤, æˆ‘ä»¬éœ€è¦å®šä¹‰è¯æ±‡ä¸­æ¯ä¸ªå•è¯çš„weightså’Œbiasã€‚1234nce_weights = tf.Variable( tf.truncated_normal([vocabulary_size, embedding_size], stddev=1.0 / math.sqrt(embedding_size)))nce_biases = tf.Variable(tf.zeros([vocabulary_size])) å‚æ•°å·²ç»å°±ä½, æŽ¥ä¸‹æ¥å®šä¹‰æ¨¡åž‹å›¾. The skip-gram model æœ‰ä¸¤ä¸ªè¾“å…¥. ä¸€ä¸ªæ˜¯ä»¥word indiceè¡¨è¾¾çš„ä¸€ä¸ªbatchçš„context words, å¦ä¸€ä¸ªæ˜¯ç›®æ ‡å•è¯ã€‚ä¸ºè¿™äº›è¾“å…¥åˆ›å»ºplaceholderèŠ‚ç‚¹, ä»¥ä¾¿åŽç»­é¦ˆé€æ•°æ®ã€‚123# Placeholders for inputstrain_inputs = tf.placeholder(tf.int32, shape=[batch_size])train_labels = tf.placeholder(tf.int32, shape=[batch_size, 1]) åˆ©ç”¨embedding_lookupæ¥é«˜æ•ˆæŸ¥æ‰¾word indiceå¯¹åº”çš„vector.1embed = tf.nn.embedding_lookup(embeddings, train_inputs) ä½¿ç”¨NCEä½œä¸ºè®­ç»ƒç›®æ ‡å‡½æ•°æ¥é¢„æµ‹target word:12345678# Compute the NCE loss, using a sample of the negative labels each time.loss = tf.reduce_mean( tf.nn.nce_loss(weights=nce_weights, biases=nce_biases, labels=train_labels, inputs=embed, num_sampled=num_sampled, num_classes=vocabulary_size)) ç„¶åŽæ·»åŠ è®¡ç®—æ¢¯åº¦å’Œæ›´æ–°å‚æ•°ç­‰æ‰€éœ€çš„èŠ‚ç‚¹ã€‚12# We use the SGD optimizer.optimizer = tf.train.GradientDescentOptimizer(learning_rate=1.0).minimize(loss) Training the modelä½¿ç”¨feed_dictæŽ¨é€æ•°æ®åˆ°placeholders, è°ƒç”¨tf.Session.run123for inputs, labels in generate_batch(...): feed_dict = &#123;train_inputs: inputs, train_labels: labels&#125; _, cur_loss = session.run([optimizer, loss], feed_dict=feed_dict) Evaluating the modelEmbeddings å¯¹äºŽ NLP ä¸­çš„å„ç§ä¸‹æ¸¸é¢„æµ‹ä»»åŠ¡éžå¸¸æœ‰ç”¨ã€‚å¯ä»¥åˆ©ç”¨analogical reasoning, ä¹Ÿå°±æ˜¯é¢„æµ‹å¥æ³•å’Œè¯­ä¹‰å…³ç³»æ¥ç®€å•è€Œç›´è§‚åœ°è¯„ä¼°embeddings, å¦‚king is to queen as father is to ?12345678910111213141516171819202122232425262728293031323334353637383940414243# https://github.com/tensorflow/models/blob/8c7a0e752f9605d284b2f08a346fdc1d51935d75/tutorials/embedding/word2vec.py#L292def build_eval_graph(self): """Build the eval graph.""" # Eval graph # Each analogy task is to predict the 4th word (d) given three # words: a, b, c. E.g., a=italy, b=rome, c=france, we should # predict d=paris. # The eval feeds three vectors of word ids for a, b, c, each of # which is of size N, where N is the number of analogies we want to # evaluate in one batch. analogy_a = tf.placeholder(dtype=tf.int32) # [N] analogy_b = tf.placeholder(dtype=tf.int32) # [N] analogy_c = tf.placeholder(dtype=tf.int32) # [N] # Normalized word embeddings of shape [vocab_size, emb_dim]. nemb = tf.nn.l2_normalize(self._emb, 1) # Each row of a_emb, b_emb, c_emb is a word's embedding vector. # They all have the shape [N, emb_dim] a_emb = tf.gather(nemb, analogy_a) # a's embs b_emb = tf.gather(nemb, analogy_b) # b's embs c_emb = tf.gather(nemb, analogy_c) # c's embs # We expect that d's embedding vectors on the unit hyper-sphere is # near: c_emb + (b_emb - a_emb), which has the shape [N, emb_dim]. target = c_emb + (b_emb - a_emb) # Compute cosine distance between each pair of target and vocab. # dist has shape [N, vocab_size]. dist = tf.matmul(target, nemb, transpose_b=True) # For each question (row in dist), find the top 4 words. _, pred_idx = tf.nn.top_k(dist, 4) # Nodes for computing neighbors for a given word according to # their cosine distance. nearby_word = tf.placeholder(dtype=tf.int32) # word id nearby_emb = tf.gather(nemb, nearby_word) nearby_dist = tf.matmul(nearby_emb, nemb, transpose_b=True) nearby_val, nearby_idx = tf.nn.top_k(nearby_dist, min(1000, self._options.vocab_size)) Reference https://tensorflow.google.cn/tutorials/representation/word2vec Learning word embeddings efficiently with noise-contrastive estimation]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Programming Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pythonä¹‹ å¥‡æŠ€æ·«å·§]]></title>
    <url>%2Fpython-digest-cn%2F</url>
    <content type="text"><![CDATA[å‡½æ•° Fundamentally, the qualities of good functions all reinforce the idea that functions are abstractions. å‡½æ•°ä½œä¸ºä¸€ç§æœºåˆ¶, æä¾›äº†ç”¨äºŽæŠ½è±¡æ•°å€¼è¿ç®—çš„æ¨¡å¼, ä½¿å…¶ç‹¬ç«‹äºŽæ‰€æ¶‰åŠçš„ç‰¹å®šå€¼ã€‚ æ–‡æ¡£ code is written only once, but often read many times. docstring123456789def pressure(v, t, n): """Compute the pressure in pascals of an ideal gas. Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law v -- volume of gas, in cubic meters t -- absolute temperature in degrees kelvin n -- particles of gas """ help(pressure) Python docstring guidelines é«˜é˜¶å‡½æ•° Functions that manipulate functions are called higher-order functions. é«˜é˜¶å‡½æ•°è¿›ä¸€æ­¥æ‰©å±•ä¸€èˆ¬å‡½æ•°ï¼Œèƒ½è¡¨è¾¾é€šç”¨çš„, ç‹¬ç«‹äºŽå…¶è°ƒç”¨çš„ç‰¹å®šå‡½æ•°çš„è®¡ç®—æ–¹æ¡ˆã€‚ Functions as Arguments1234567891011def summation(n, term): total, k = 0, 1 while k &lt;= n: total, k = total + term(k), k + 1 return totaldef cube(x): return x*x*xdef sum_cubes(n): return summation(n, cube) Nested Definitions One negative consequence of this approach is that the global frame becomes cluttered with names of small functions, which must all be unique. Another problem is that we are constrained by particular function signatures. å½“åŒä¸€çŽ¯å¢ƒä¸‹ï¼Œå½“å‡ºçŽ°éœ€è¦ç›¸ä¼¼åŠŸèƒ½ä½†ä¸Žå·²æœ‰å‡½æ•°çš„å‚æ•°ä¸åŒæ—¶ï¼Œæ­¤æ—¶åµŒå¥—å‡½æ•°å¯ä»¥æ–¹ä¾¿æˆ‘ä»¬å®šä¹‰å‡½æ•°.1234def improve(update, close, guess=1): while not close(guess): guess = update(guess) return guess è¿™é‡Œçš„updateåªæŽ¥å—ä¸€ä¸ªå‚æ•°, å‡å¦‚æˆ‘ä»¬åˆšå¥½æœ‰éœ€è¦ä¸¤ä¸ªå‚æ•°çš„123def sqrt_update(x, a): """square root""" return average(x, a/x) è¿™ä¸ªå‡½æ•°å°±æ— æ³•ä¼ å…¥improveä¸­. åµŒå¥—å‡½æ•°, è®©sqrt_updateä¼ å…¥å‚æ•°ä¿æŒä¸€ä¸ª, åŒæ—¶é¢å¤–èƒ½å¤ŸèŽ·å–å…¶æœ¬åœ°çŽ¯å¢ƒframeçš„å…¶ä»–å‚æ•°123456def sqrt(a): def sqrt_update(x): return average(x, a/x) def sqrt_close(x): return approx_eq(x * x, a) return improve(sqrt_update, sqrt_close) local def statements only affect the current local frame.lexical scoping: sharing names among nested definitions Functions as Returned Values1234def compose1(f, g): def h(x): return f(g(x)) return h æ¯”å¦‚TensorFlowä¸­å¸¸ç”¨çš„12345678def model_fn_builder(...): """Returns `model_fn` closure.""" def model_fn(features, labels, mode, params): # pylint: disable=unused-argument """The actual `model_fn`.""" ... return ... return model_fn]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Programming Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ©ç”¨bertè¿›è¡Œè¿ç§»å­¦ä¹ ]]></title>
    <url>%2FNLP-transfer-learning-with-bert%2F</url>
    <content type="text"><![CDATA[NLPä»»åŠ¡çš„éš¾ç‚¹ä¸åƒå›¾åƒçš„æ™®é€‚æ€§, è¯­è¨€æœ¬èº«æœ‰å…¶å¤šæ ·æ€§, å¦‚è¯­å¢ƒçš„åç§», èƒŒæ™¯çš„å˜åŒ–, äººä¸Žäººé—´çš„åˆ†æ­§, è¿™å¯¼è‡´ä»¥ä¸‹é—®é¢˜: æœ‰æ ‡æ³¨æ•°æ®çš„é€šç”¨æ€§ä½Ž æ ‡æ³¨æ•°æ®è´¨é‡ä¸ç¨³å®š çŽ°å®žä¸–ç•Œçš„è¯­è¨€å’Œä½¿ç”¨åœºæ™¯ä¸æ–­æ›´æ–°, å¯¼è‡´æ¨¡åž‹çš„ç»´æŠ¤æ›´æ–°æ¢ä»£æˆæœ¬æžé«˜ â€¦ ä¸ºäº†åº”å¯¹NLPçš„éš¾ç‚¹, éœ€è¦å……åˆ†åˆ©ç”¨å„ç§å¯ç”¨çš„ç›‘ç£ä¿¡å·ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºŽä¼ ç»Ÿç›‘ç£å­¦ä¹ ï¼ˆsupervisionï¼‰ï¼Œè‡ªç›‘ç£å­¦ä¹ ï¼ˆself-supervisedï¼‰ï¼Œå¼±ç›‘ç£(weak supervision)ï¼Œè¿ç§»å­¦ä¹ ï¼ˆtransfer learningï¼‰ï¼Œå¤šä»»åŠ¡å­¦ä¹ ï¼ˆmulti-task learning, MTLï¼‰ã€‚ Near-term improvements in NLP will be mostly about making clever use of â€œfreeâ€ data. è¯­è¨€æ¨¡åž‹ - ç»å…¸çš„è‡ªç›‘ç£å­¦ä¹ æ¨¡åž‹Lecunæœ‰ç»™è‡ªç›‘ç£å­¦ä¹ ä¸‹å®šä¹‰ï¼Œä½†æˆ‘ä¸ªäººå¯¹è‡ªç›‘ç£çš„ç†è§£æ˜¯ï¼ŒåŸºäºŽæ•°æ®æœ¬èº«è¿›è¡Œå­¦ä¹ ï¼Œè®©æ¨¡åž‹å­¦ä¹ åˆ°æ•°æ®éšå«çš„ç‰¹å¾ã€‚ æ¯”å¦‚è¯­è¨€æ¨¡åž‹çš„æ ¹æ®å‰æ–‡é¢„æµ‹ä¸‹ä¸€ä¸ªå•è¯ã€‚ æœ€è¿‘çš„BERTä¸°å¯Œäº†çŽ©æ³•ï¼Œæå‡ºäº†Mask language modelï¼Œå°±æ˜¯é€šè¿‡ä¸Šä¸‹æ–‡é¢„æµ‹æŽ©ç ä½ç½®çš„å•è¯ï¼Œä½œä¸ºå…¶æ ¸å¿ƒå­¦ä¹ ä»»åŠ¡ï¼›BERTçš„è®­ç»ƒè¿‡ç¨‹è¿˜åº”ç”¨äº†å¤šä»»åŠ¡å­¦ä¹ ï¼ŒæŠŠ next sentence prediction ä¹Ÿä½œä¸ºä»»åŠ¡ä¹‹ä¸€ä¸€èµ·å­¦ä¹ ã€‚ ç›®å‰é™¤äº†è¯­è¨€æ¨¡åž‹å’Œå¥æ¨¡åž‹(next sentence)ï¼Œæ˜¯å¦è¿˜æœ‰å…¶ä»–ä»»åŠ¡? Baidu ERNIE: å¼•å…¥äº†è®ºå›å¯¹è¯ç±»æ•°æ®ï¼Œåˆ©ç”¨ DLMï¼ˆDialogue Language Modelï¼‰å»ºæ¨¡ Query-Response å¯¹è¯ç»“æž„ï¼Œå°†å¯¹è¯ Pair å¯¹ä½œä¸ºè¾“å…¥ï¼Œå¼•å…¥ Dialogue Embedding æ ‡è¯†å¯¹è¯çš„è§’è‰²ï¼Œåˆ©ç”¨ Dialogue Response Loss å­¦ä¹ å¯¹è¯çš„éšå¼å…³ç³»ã€‚ ELMo vs GPT vs BERTç»å…¸Word2vecè¡¨è¾¾æ˜¯context freeçš„ï¼Œopen a bank accountå’Œon the river bankçš„bankå…±ç”¨ä¸€ä¸ªå‘é‡å€¼[0.3, 0.2, -0.8, â€¦]. å¦‚æŒ‡å…¬å¸çš„è‹¹æžœå’ŒæŒ‡æ°´æžœçš„è‹¹æžœå…±ç”¨ä¸€ä¸ªå‘é‡. è§£å†³æ–¹æ¡ˆï¼šåœ¨æ–‡æœ¬è¯­æ–™ä¸­è®­ç»ƒä¸Šä¸‹æ–‡è¡¨è¾¾contextual representations è€Œ ELMo, GPT, å’Œ BERT éƒ½ç€çœ¼äºŽcontextual representations ELMo : Deep Contextual Word Embeddings, è®­ç»ƒç‹¬ç«‹çš„left-to-rightå’Œright-to-leftçš„LMs, å¤–åŠ ä¸€ä¸ªWord Embeddingå±‚, ä½œä¸ºé¢„è®­ç»ƒçš„è¯å‘é‡ä½¿ç”¨ OpenAI GPT : Improving Language Understanding by Generative Pre-Training. ä½¿ç”¨ left-to-right Transformer LM, ç„¶åŽåœ¨ä¸‹æ¸¸ä»»åŠ¡ä¸­fine-tune BERT : Bidirectional Encoder Representations from Transformers ä½†æ˜¯, ä¸ºä½•2018å¹´ä¹‹å‰ç±»ä¼¼ELMoçš„contextual representationså¹¶ä¸æµè¡Œï¼Ÿ å› ä¸ºå¥½çš„é¢„è®­ç»ƒç»“æžœæ¯”æœ‰ç›‘ç£è®­ç»ƒä»£ä»·é«˜1000å€ç”šè‡³100,000å€ã€‚2013å¹´å¾®è°ƒå¥½çš„äºŒå±‚512ç»´åº¦çš„LSTM sentiment analysis æœ‰ 80% å‡†ç¡®åº¦, è®­ç»ƒæ—¶é—´ 8 å°æ—¶. åŒæœŸçš„ç›¸åŒç»“æž„çš„é¢„è®­ç»ƒæ¨¡åž‹éœ€è¦è®­ç»ƒä¸€å‘¨, å‡†ç¡®çŽ‡ç¨å¾®å¥½ç‚¹, 80.5%. è¿ç§»å­¦ä¹ çš„ä¸¤ç§æ€è·¯: Feature based å’Œ Fine-tune basedELMOåŒºåˆ†ä¸åŒåŒè¯ä¸åŒæ„çš„æ–¹æ³•æ˜¯é€šè¿‡å®ƒçš„ä¸‰å±‚å‘é‡çš„åŠ æƒç»„åˆ(concat or sum whatever), æƒé‡å¯ä»¥åœ¨ä¸‹æ¸¸ä»»åŠ¡ä¸­å­¦ä¹ è°ƒæ•´. è€ŒGPTå’ŒBERTæ˜¯é€šè¿‡åœ¨ä¸‹æ¸¸ä»»åŠ¡ä¸­fine-tuneæ¨¡åž‹å‚æ•°, åŒæ—¶ä¹Ÿåˆ©ç”¨äº†transformerçš„self-attentionæœºåˆ¶è§£å†³å…±æŒ‡æ¶ˆè§£ è€Œè¿™ä¸‰ä¸ªæ¨¡åž‹æ˜¯ä¸€ä¸ªä¸æ–­è¿›åŒ–çš„è¿‡ç¨‹: ELMO ç‹¬ç«‹åœ°è®­ç»ƒå‰åŽå‘LSTM, æ¯ä¸€ä¸ªä½ç½®åªèƒ½ç›´æŽ¥æŽ¥æ”¶å…¶å·¦å³ç›¸é‚»ä½ç½®çš„ä¿¡æ¯, è€Œä¸”å› ä¸ºå®žè·µä¸ŠLSTM cell èƒ½å¤Ÿè®°å¿†çš„è·ç¦»å¾ˆæœ‰é™(èƒ½å¤Ÿè®°å¿†çš„ä¿¡æ¯ä¹Ÿå¾ˆæœ‰é™), è¿™å¯¼è‡´ELMOçš„å…¨å±€è¯­å¢ƒç†è§£èƒ½åŠ›å¾ˆæœ‰é™. GPT æ˜¯ä»Žå·¦åˆ°å³ BERT æ”¾å¼ƒäº†â€é¢„æµ‹ä¸‹ä¸€ä¸ªè¯â€çš„ä¼ ç»ŸLMä»»åŠ¡, æ”¹ç”¨Mask-LMä»»åŠ¡. BERTæ¨¡åž‹å­¦ä¹ çš„åº”è¯¥ä¸ä»…ä»…æ˜¯contextual embeddingsï¼šé¢„æµ‹ç¼ºå¤±çš„å•è¯ï¼ˆæˆ–ä¸‹ä¸€ä¸ªå•è¯ï¼‰éœ€è¦å­¦ä¹ è®¸å¤šç±»åž‹çš„è¯­ä¹‰ç†è§£features: è¯­æ³•ï¼Œè¯­ä¹‰ï¼Œè¯­ç”¨ï¼Œå…±æŒ‡ç­‰.è¿™è¯´æ˜Žé¢„è®­ç»ƒæ¨¡åž‹å…¶å®žè¿œè¿œå¤§äºŽå®ƒæ‰€éœ€è¦è§£å†³çš„ä»»ä½•ç‰¹å®šä¸‹æ¸¸ä»»åŠ¡ è¿ç§»å­¦ä¹ è¿ç§»å­¦ä¹ çš„ä¸»æµæ€è·¯æ˜¯çŸ¥è¯†å…±äº«, è®©æ¨¡åž‹åœ¨ä¸€ç§è¾ƒä¸ºé€šç”¨çš„æ•°æ®ä¸Šé¢„è®­ç»ƒ, ç„¶åŽæŠŠé¢„è®­ç»ƒçš„æ¨¡åž‹è¿ç§»åˆ°ä¸‹æ¸¸çš„å…·ä½“ä»»åŠ¡ä¸­. è¿ç§»å­¦ä¹ åœ¨å›¾åƒé¢†åŸŸå¤§èŽ·æˆåŠŸï¼ˆImageNet + resnetï¼‰ï¼Œè§£å†³äº†åˆ†ç±»è¿™ä¸€å›¾åƒé¢†åŸŸçš„ç“¶é¢ˆã€‚ è¿‘å¹´æ¥æ¶ŒçŽ°å‡ºULMFit, ELMOï¼ŒGPT, BERTè¿™äº›ä¼˜ç§€çš„é¢„è®­ç»ƒæ¨¡åž‹ï¼Œä½†æ²¡æœ‰CVé¢†åŸŸé‚£ä¹ˆè€€çœ¼ã€‚ä¸»è¦åŽŸå› æ˜¯NLPç›®å‰æ²¡æœ‰å•ä¸ªæ˜Žç¡®çš„ç“¶é¢ˆï¼Œ NLPéœ€è¦å¤šç§å¤šæ ·çš„æŽ¨ç†ï¼šé€»è¾‘ï¼Œè¯­è¨€è¯­ä¹‰ï¼Œæƒ…æ„Ÿï¼Œå’Œè§†è§‰ã€‚ NLPè¦æ±‚é•¿æœŸçŸ­æœŸç»“åˆçš„è®°å¿† æ¯”è¾ƒç»¼åˆçš„è¯­è¨€ç†è§£ä»»åŠ¡æ˜¯GLUEã€‚ BERTï¼ŒGPT-2 ç­‰ç®—æ³•æŒ‡æ˜Žäº†ä¸€æ¡å¯è¡Œçš„ NLP åœ¨å®žé™…å·¥ä¸šåº”ç”¨çš„å¯è¡Œè·¯å¾„ï¼š é¢„è®­ç»ƒï¼šåˆ©ç”¨è¶…å¤§è§„æ¨¡æ— ç›‘ç£æ•°æ®é¢„è®­ç»ƒç¥žç»ç½‘ç»œæ¨¡åž‹ (å¯é€‰) çŸ¥è¯†æ³¨å…¥, åŠ å…¥çŸ¥è¯†å›¾è°±çš„ç»“æž„åŒ–ä¿¡æ¯, å¦‚åŸºäºŽBERTçš„ERNIE çŸ¥è¯†è¿ç§»ï¼ŒäºŒä¸ªæ€è·¯ï¼š å¾®è°ƒ Fine-tune å•ä»»åŠ¡/å¤šä»»åŠ¡å­¦ä¹  é¢„è®­ç»ƒé¢„è®­ç»ƒé˜¶æ®µçš„æ ¸å¿ƒæ˜¯ä»€ä¹ˆï¼Ÿ resnet, BERT å’Œ GPT-2 å‘Šè¯‰æˆ‘ä»¬: æ›´å¤§çš„æ•°æ®è§„æ¨¡ï¼Œæ›´å¤šæ ·æ€§çš„æ•°æ®ï¼Œæ›´é«˜çš„æ•°æ®è´¨é‡ã€‚è¿™ä¸‰ç‚¹çš„å°ºåº¦ä¸Šé™éƒ½æŽ¥è¿‘æ— ç©·å¤§ï¼Œæ‰€ä»¥å¤©èŠ±æ¿å¾ˆé«˜ï¼Œæœªæ¥æ¨¡åž‹çš„æ€§èƒ½è¿˜æœ‰æå‡ç©ºé—´ã€‚ é’ˆå¯¹æ•°æ®é‡å¤§å’Œå¤šæ ·æ€§ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§è§£å†³æ€è·¯, é¢„è®­ç»ƒé˜¶æ®µéœ€è¦è‡ªç›‘ç£æˆ–è€…æ— ç›‘ç£çš„ä»»åŠ¡ï¼Œæ˜¾è€Œæ˜“è§çš„ä»»åŠ¡æ˜¯è¯­è¨€æ¨¡åž‹, ELMo, GPT, å’Œ BERT éƒ½ç”¨åˆ°äº†è¿™ä¸ªä»»åŠ¡. ä½¿ç”¨å¼±ç›‘ç£(è¿œç¨‹ç›‘ç£) çŸ¥è¯†æ³¨å…¥ç™¾åº¦çš„ERNIEçš„åšæ³•æ˜¯: åŸºäºŽç™¾åº¦çš„è¯åº“, æŠŠBERTä¸­å¯¹token level çš„ mask æ”¹è¿›ä¸º å¯¹ word level çš„ mask. å¯¹äºŽæ¯ä¸€ä¸ªåºåˆ—, æˆ‘ä»¬éœ€è¦è¿›è¡Œ word level çš„æ ‡è®°, æ¥åŒºåˆ†å„ä¸ª token æ˜¯å¦å±žäºŽåŒä¸€ä¸ªè¯. å¯¹åºåˆ—è¿›è¡ŒæŽ©ç æ—¶, ä¸å†æ˜¯éšæœºé€‰æ‹© token, è€Œæ˜¯é€‰æ‹©è¯ å¤šä»»åŠ¡å­¦ä¹ ä¸Žå•ç‹¬è®­ç»ƒæ¨¡åž‹ç›¸æ¯”ï¼Œå¤šä»»åŠ¡å­¦ä¹ åœ¨ä½¿ç”¨shared representationçš„åŒæ—¶å¹¶è¡Œåœ°å­¦ä¹ ä»»åŠ¡ã€‚é€šè¿‡shared representationåœ¨ä»»åŠ¡ä¹‹é—´ä¼ é€’çŸ¥è¯†ï¼Œå¯ä»¥æé«˜ç‰¹å®šä»»åŠ¡æ¨¡åž‹çš„å­¦ä¹ æ•ˆçŽ‡å’Œé¢„æµ‹å‡†ç¡®æ€§ã€‚ æœ‰ä¸¤ç§MTæ€è·¯ï¼š Hard parameter sharingï¼šä¸åŒä»»åŠ¡å…±äº«åº•å±‚çš„ç¥žç»ç½‘ç»œå±‚ï¼Œä½†å„ä¸ªä»»åŠ¡æœ‰è‡ªå·±ç‰¹å®šä»»åŠ¡çš„output layerã€‚åŒæ—¶å­¦ä¹ çš„ä»»åŠ¡è¶Šå¤šï¼Œæ¨¡åž‹åº•å±‚å°±è¶Šèƒ½æ‰¾åˆ°æ•æ‰æ‰€æœ‰ä»»åŠ¡çš„è¡¨è¾¾ï¼Œè€Œå¯¹å•ä¸ªä»»åŠ¡è¿‡åº¦æ‹Ÿåˆçš„å¯èƒ½æ€§å°±è¶Šå°ã€‚ Soft parameter sharingï¼šæ¯ä¸ªä»»åŠ¡æœ‰è‡ªå·±çš„æ¨¡åž‹è‡ªå·±çš„å‚æ•°ï¼Œç„¶åŽå¯¹å„ä¸ªæ¨¡åž‹çš„å‚æ•°ä¹‹é—´çš„è·ç¦»è¿›è¡Œæ­£åˆ™åŒ–ï¼Œä»¥é¼“åŠ±å‚æ•°è¶‹è¿‘ã€‚ Hard parameter sharingçš„è®­ç»ƒï¼Œç›®å‰è‡³å°‘æœ‰ä¸¤ç§æ–¹å¼ã€‚ äº¤æ›¿åœ°ä¼˜åŒ–æ¯ä¸ªä»»åŠ¡ç‰¹å®šçš„task_loss[k]. è¿™ç§æ–¹æ³•ä¸éœ€è¦å„ä¸ªä»»åŠ¡çš„è®­ç»ƒæ•°æ®æœ‰ä»»ä½•å¯¹é½å…³è” è”åˆä¼˜åŒ–total_loss=Î£(task_loss[k])ã€‚ è¿™ä¸ªæ–¹æ³•è¦æ±‚å„ä¸ªä»»åŠ¡çš„batchè®­ç»ƒæ•°æ®ç›¸åŒæˆ–è€…æœ‰keyæ¥å¯¹é½ é™¤æ­¤ä¹‹å¤–, ç¬¬äºŒç§æ–¹æ³•è¿˜æ–¹ä¾¿æˆ‘ä»¬ä¸ºæ¯ä¸ªä»»åŠ¡æ·»åŠ è‡ªé€‚åº”æƒé‡(adaptive weight)ï¼Œä»¥èŽ·å¾—æ›´å¤štask-sensitive learningã€‚ å¼±ï¼ˆè¿œç¨‹ï¼‰ç›‘ç£Snorkel MeTaLIn Snorkel, the heuristics are called Labeling Functions (LFs). Here are some common types of LFs: Hard-coded heuristics: usually regular expressions (regexes) Syntactics: for instance, Spacyâ€™s dependency trees Distant supervision: external knowledge bases Noisy manual labels: crowdsourcing External models: other models with useful signals Reference Building NLP Classifiers Cheaply With Transfer Learning and Weak Supervision Snorkel DryBell: A Case Study in Deploying Weak Supervision at Industrial Scale Data Programming: Creating Large Training Sets, Quickly Improving Language Understanding by Generative Pre-Training https://github.com/kweonwooj/papers/issues/114 Massive Multi-Task Learning with Snorkel MeTaL: Bringing More Supervision to Bear An Overview of Multi-Task Learning in Deep Neural Networks Training Complex Models with Multi-Task Weak Supervision https://nlp.stanford.edu/seminar/details/jdevlin.pdf Get 10x Speedup in Tensorflow Multi-Task Learning using Python Multiprocessing]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Transformer - å¤šå¤´è‡ªæ³¨æ„åŠ›ç¼–ç æœºåˆ¶]]></title>
    <url>%2FNLP-attention-03-self-attention%2F</url>
    <content type="text"><![CDATA[æ³¨æ„åŠ›æœºåˆ¶çš„åŽŸç†æ˜¯è®¡ç®—queryå’Œæ¯ä¸ªkeyä¹‹é—´çš„ç›¸ä¼¼æ€§$f_c(q,k_i)$ä»¥èŽ·å¾—æ³¨æ„åŠ›åˆ†é…æƒé‡ã€‚åœ¨å¤§éƒ¨åˆ†NLPä»»åŠ¡ä¸­ï¼Œkeyä¸€èˆ¬ä¹Ÿæ˜¯valueã€‚ æ³¨æ„åŠ›æœºåˆ¶ä¸€èˆ¬æ˜¯ç”¨äºŽæå‡seq2seqæˆ–è€…encoder-decoderæž¶æž„çš„è¡¨çŽ°ã€‚ä½†è¿™ç¯‡2017 NIPSçš„æ–‡ç« Attention is all you needæå‡ºæˆ‘ä»¬å¯ä»¥ä»…ä¾èµ–æ³¨æ„åŠ›æœºåˆ¶å°±å¯ä»¥å®Œæˆå¾ˆå¤šä»»åŠ¡, å³æ‰€è°“è‡ªæ³¨æ„åŠ›æœºåˆ¶. ä¸Žè¿‡åŽ»æµè¡Œçš„ä½¿ç”¨åŸºäºŽRNNçš„Seq2Seqæ¨¡åž‹æ¡†æž¶ä¸åŒ: æ–‡ç« ä¸­ä½¿ç”¨æ³¨æ„æœºåˆ¶å®Œå…¨å–ä»£äº†RNNæ¥æž„å»ºæ•´ä¸ªæ¨¡åž‹æ¡†æž¶ã€‚ Multi-Headed Attention Mechanism: åœ¨ç¼–ç å™¨å’Œè§£ç å™¨ä¸­ä½¿ç”¨ Multi-Headed self-attentionã€‚ æ¯”LSTMæ›´å¿«çš„è®¡ç®—é€Ÿåº¦ã€‚ æ–‡ç« çš„å®žéªŒæ•°æ®æš‚ä¸”ä¸è®ºï¼Œå…¶æå‡ºçš„æ ¸å¿ƒæƒ³æ³•å¾ˆé‡è¦ï¼Œå°±æ˜¯LSTMè¿™ç§æ—¶åºæ¨¡åž‹é€Ÿåº¦å®žåœ¨æ˜¯å¤ªæ…¢äº†ï¼Œå¾ˆéš¾åº”ç”¨åˆ°è¶…å¤§è§„æ¨¡çš„æ•°æ®å’Œçº¿ä¸Šçš„åº”ç”¨ä¸­ã€‚Googleå› å…¶è‡ªèº«ä¸šåŠ¡çš„å¤§è§„æ¨¡æ€§è´¨ï¼Œæœ¬èº«æ˜¯å¾ˆå·¥ç¨‹åŒ–çš„ã€‚æ‰€ä»¥ä»–ä»¬éžå¸¸åæ„Ÿéœ€è¦ç¹çç‰¹å¾æå–çš„ä»»åŠ¡ï¼Œæ‰€ä»¥ä»–ä»¬æ—©æ—©å°±è½¬æŠ•äº†ç¥žç»ç½‘ç»œã€‚ä¹Ÿéžå¸¸ä¸çœ‹å¥½ç¹ççš„ç¥žç»ç½‘ç»œï¼Œç‰¹åˆ«æ˜¯é‚£äº›æ— æ³•å¹¶è¡ŒåŒ–è®¡ç®—çš„ã€‚ è¿‘äº›å¹´æ¥ï¼ŒRNNï¼ˆåŠå…¶å˜ç§ LSTM, GRUï¼‰å·²æˆä¸ºå¾ˆå¤šnlpä»»åŠ¡å¦‚æœºå™¨ç¿»è¯‘çš„ç»å…¸ç½‘ç»œç»“æž„ã€‚RNNä»Žå·¦åˆ°å³æˆ–ä»Žå³åˆ°å·¦çš„æ–¹å¼é¡ºåºå¤„ç†è¯­è¨€ã€‚RNNçš„æŒ‰é¡ºåºå¤„ç†çš„æ€§è´¨ä¹Ÿä½¿å¾—å…¶æ›´éš¾ä»¥å……åˆ†åˆ©ç”¨çŽ°ä»£å¿«é€Ÿè®¡ç®—è®¾å¤‡ï¼Œä¾‹å¦‚GPUç­‰ä¼˜äºŽå¹¶è¡Œè€Œéžé¡ºåºå¤„ç†çš„è®¡ç®—å•å…ƒã€‚è™½ç„¶å·ç§¯ç¥žç»ç½‘ç»œï¼ˆCNNï¼‰çš„æ—¶åºæ€§è¿œå°äºŽRNNï¼Œä½†CNNä½“ç³»ç»“æž„å¦‚ByteNetæˆ–ConvS2Sä¸­ï¼Œç³…åˆè¿œè·ç¦»éƒ¨åˆ†çš„ä¿¡æ¯æ‰€éœ€çš„æ­¥éª¤æ•°ä»éšç€è·ç¦»çš„å¢žåŠ è€Œå¢žé•¿ã€‚ å› ä¸ºä¸€æ¬¡å¤„ç†ä¸€ä¸ªå•è¯ï¼ŒRNNéœ€è¦å¤„ç†å¤šä¸ªæ—¶åºçš„å•è¯æ¥åšå‡ºä¾èµ–äºŽé•¿è¿œç¦»å•è¯çš„å†³å®šã€‚ä½†å„ç§ç ”ç©¶å’Œå®žéªŒé€æ¸è¡¨æ˜Žï¼Œå†³ç­–éœ€è¦çš„æ­¥éª¤è¶Šå¤šï¼Œå¾ªçŽ¯ç½‘ç»œå°±è¶Šéš¾ä»¥å­¦ä¹ å¦‚ä½•åšå‡ºè¿™äº›å†³å®šã€‚è€Œæœ¬èº«LSTMå°±æ˜¯ä¸ºäº†è§£å†³long term dependencyé—®é¢˜ï¼Œä½†æ˜¯è§£å†³å¾—å¹¶ä¸å¥½ã€‚å¾ˆå¤šæ—¶å€™è¿˜éœ€è¦é¢å¤–åŠ ä¸€å±‚æ³¨æ„åŠ›å±‚æ¥å¤„ç†long term dependencyã€‚ æ‰€ä»¥è¿™æ¬¡ä»–ä»¬ç›´æŽ¥åœ¨ç¼–ç å™¨å’Œè§£ç å™¨ä¹‹é—´ç›´æŽ¥ç”¨attentionï¼Œè¿™æ ·å¥å­å•è¯çš„ä¾èµ–é•¿åº¦æœ€å¤šåªæœ‰1ï¼Œå‡å°‘äº†ä¿¡æ¯ä¼ è¾“è·¯å¾„ã€‚ä»–ä»¬ç§°ä¹‹ä¸ºTransformerã€‚Transformeråªæ‰§è¡Œä¸€å°æ®µconstantçš„æ­¥éª¤ï¼ˆæ ¹æ®ç»éªŒé€‰æ‹©ï¼‰ã€‚åœ¨æ¯ä¸ªæ­¥éª¤ä¸­ï¼Œåº”ç”¨self-attentionæœºåˆ¶ï¼Œç›´æŽ¥æ¨¡æ‹Ÿå¥å­ä¸­æ‰€æœ‰å•è¯ä¹‹é—´çš„å…³ç³»ï¼Œä¸ç®¡å®ƒä»¬ä¹‹é—´çš„ä½ç½®å¦‚ä½•ã€‚æ¯”å¦‚å­â€œI arrived at the bank after crossing the riverâ€ï¼Œè¦ç¡®å®šâ€œbankâ€ä¸€è¯æ˜¯æŒ‡æ²³å²¸è€Œä¸æ˜¯é‡‘èžæœºæž„ï¼ŒTransformerå¯ä»¥å­¦ä¼šç«‹å³å…³æ³¨â€œriverâ€è¿™ä¸ªè¯å¹¶åœ¨ä¸€æ­¥ä¹‹å†…åšå‡ºè¿™ä¸ªå†³å®šã€‚ Transformeræ€»ä½“æž¶æž„Transformerä¹Ÿæ˜¯åŸºäºŽç¼–ç å™¨ï¼ˆè¯»å–è¾“å…¥å¥å­å¹¶ç”Ÿæˆå…¶è¡¨è¾¾ï¼‰-è§£ç å™¨ï¼ˆæŠŠæ–°è¡¨è¾¾è½¬æ¢ä¸ºç›®çš„è¯ï¼‰çš„æž¶æž„ã€‚å…·ä½“åœ°è¯´ï¼Œä¸ºäº†è®¡ç®—ç»™å®šå•è¯çš„ä¸‹ä¸€ä¸ªè¡¨ç¤º - ä¾‹å¦‚â€œbankâ€ - Transformerå°†å…¶ä¸Žå¥å­ä¸­çš„æ‰€æœ‰å…¶ä»–å•è¯è¿›è¡Œæ¯”è¾ƒã€‚è¿™äº›æ¯”è¾ƒçš„ç»“æžœå°±æ˜¯å…¶ä»–å•è¯çš„æ³¨æ„åŠ›æƒé‡ã€‚è¿™äº›æ³¨æ„åŠ›æƒé‡å†³å®šäº†å…¶ä»–å•è¯åº”è¯¥ä¸ºâ€œbankâ€çš„ä¸‹ä¸€ä¸ªè¡¨è¾¾åšå‡ºå¤šå°‘è´¡çŒ®ã€‚åœ¨è®¡ç®—â€œbankâ€çš„æ–°è¡¨ç¤ºæ—¶ï¼Œèƒ½å¤Ÿæ¶ˆé™¤æ­§ä¹‰çš„â€œriverâ€å¯ä»¥èŽ·å¾—æ›´é«˜çš„å…³æ³¨ã€‚å°†æ³¨æ„åŠ›æƒé‡ç”¨æ¥åŠ æƒå¹³å‡æ‰€æœ‰å•è¯çš„è¡¨è¾¾ï¼Œç„¶åŽå°†åŠ æƒå¹³å‡çš„è¡¨è¾¾å–‚ç»™ä¸€ä¸ªå…¨è¿žæŽ¥ç½‘ç»œä»¥ç”Ÿæˆâ€œbankâ€çš„æ–°è¡¨è¾¾ï¼Œä»¥åæ˜ å‡ºè¯¥å¥å­æ­£åœ¨è°ˆè®ºçš„æ˜¯â€œæ²³å²¸â€ã€‚ Transformerçš„ç¼–ç é˜¶æ®µæ¦‚æ‹¬èµ·æ¥å°±æ˜¯ï¼š é¦–å…ˆä¸ºæ¯ä¸ªå•è¯ç”Ÿæˆåˆå§‹è¡¨è¾¾æˆ–embeddingsã€‚è¿™äº›ç”±ç©ºå¿ƒåœ†è¡¨ç¤ºã€‚ ç„¶åŽï¼Œå¯¹äºŽæ¯ä¸€ä¸ªè¯, ä½¿ç”¨è‡ªæ³¨æ„åŠ›èšåˆæ¥è‡ªæ‰€æœ‰å…¶ä»–ä¸Šä¸‹æ–‡å•è¯çš„ä¿¡æ¯ï¼Œç”Ÿæˆå‚è€ƒäº†æ•´ä¸ªä¸Šä¸‹æ–‡çš„æ¯ä¸ªå•è¯çš„æ–°è¡¨è¾¾ï¼Œç”±å®žå¿ƒçƒè¡¨ç¤ºã€‚å¹¶åŸºäºŽå‰é¢ç”Ÿæˆçš„è¡¨è¾¾, è¿žç»­åœ°æž„å»ºæ–°çš„è¡¨è¾¾ï¼ˆä¸‹ä¸€å±‚çš„å®žå¿ƒåœ†ï¼‰å¯¹æ¯ä¸ªå•è¯å¹¶è¡Œåœ°é‡å¤å¤šæ¬¡è¿™ç§å¤„ç†ã€‚ è§£ç å™¨æ“ä½œç±»ä¼¼ï¼Œåªæ˜¯ä»Žå·¦åˆ°å³ä¾æ¬¡ç”Ÿæˆä¸€ä¸ªå­—ã€‚å®ƒä¸ä»…å…³æ³¨å…ˆå‰ç”Ÿæˆçš„å•è¯ï¼Œè€Œä¸”è¿˜å‚è€ƒç¼–ç å™¨ç”Ÿæˆçš„æœ€ç»ˆè¡¨ç¤ºã€‚ N = 6å®žé™…è¶…è¿‡6å±‚ã€‚è¿™äº›â€œå±‚â€ä¸­çš„æ¯ä¸€ä¸ªå®žé™…ä¸Šç”±ä¸¤å±‚ç»„æˆï¼šposition-wise FNN å’Œä¸€ä¸ªï¼ˆç¼–ç å™¨ï¼‰ï¼Œæˆ–ä¸¤ä¸ªï¼ˆè§£ç å™¨ï¼‰ï¼ŒåŸºäºŽæ³¨æ„åŠ›çš„å­å±‚ã€‚å…¶ä¸­æ¯ä¸ªè¿˜åŒ…å«4ä¸ªçº¿æ€§æŠ•å½±å’Œæ³¨æ„é€»è¾‘ã€‚ ç¼–ç å™¨: Stage 1 - è¾“å…¥ç¼–ç : åºåˆ—çš„é¡ºåºä¿¡æ¯æ˜¯éžå¸¸é‡è¦çš„ã€‚ç”±äºŽæ²¡æœ‰å¾ªçŽ¯ï¼Œä¹Ÿæ²¡æœ‰å·ç§¯ï¼Œå› æ­¤ä½¿ç”¨â€œä½ç½®ç¼–ç â€è¡¨ç¤ºåºåˆ—ä¸­æ¯ä¸ªæ ‡è®°çš„ç»å¯¹ï¼ˆæˆ–ç›¸å¯¹ï¼‰ä½ç½®çš„ä¿¡æ¯ã€‚ positional encodings $\oplus$ embedded input Stage 2 â€“ Multi-head attention å’Œ Stage 3 â€“ position-wise FFN. ä¸¤ä¸ªé˜¶æ®µéƒ½æ˜¯ç”¨æ¥æ®‹å·®è¿žæŽ¥, æŽ¥ç€æ­£åˆ™åŒ–è¾“å‡ºå±‚ 12345Stage1_out = Embedding512 + TokenPositionEncoding512Stage2_out = layer_normalization(multihead_attention(Stage1_out) + Stage1_out)Stage3_out = layer_normalization(FFN(Stage2_out) + Stage2_out)out_enc = Stage3_out è§£ç å™¨çš„æž¶æž„ç±»ä¼¼ï¼Œä½†å®ƒåœ¨ç¬¬3é˜¶æ®µé‡‡ç”¨äº†é™„åŠ å±‚, åœ¨è¾“å‡ºå±‚ä¸Šçš„ mask multi-head attention: Stage 1 â€“ è¾“å…¥è§£ç : è¾“å…¥ output embeddingï¼Œåç§»ä¸€ä¸ªä½ç½®ä»¥ç¡®ä¿å¯¹ä½ç½®içš„é¢„æµ‹ä»…å–å†³äºŽ&lt; içš„ä½ç½®ã€‚ Stage 2 - Masked Multi-head attention: éœ€è¦æœ‰ä¸€ä¸ªmaskæ¥é˜²æ­¢å½“å‰ä½ç½®içš„ç”Ÿæˆä»»åŠ¡çœ‹åˆ°åŽç»­&gt; iä½ç½®çš„ä¿¡æ¯ã€‚123456789101112# ä½¿ç”¨pytorchç‰ˆæœ¬çš„æ•™ç¨‹ä¸­æä¾›çš„èŒƒä¾‹# http://nlp.seas.harvard.edu/2018/04/03/attention.htmldef subsequent_mask(size): "Mask out subsequent positions." attn_shape = (1, size, size) subsequent_mask = np.triu(np.ones(attn_shape), k=1).astype('uint8') return torch.from_numpy(subsequent_mask) == 0# # The attention mask shows the position each tgt word (row) is allowed to look at (column).# Words are blocked for attending to future words during training.plt.figure(figsize=(5,5))plt.imshow(subsequent_mask(20)[0]) é˜¶æ®µ2,3å’Œ4åŒæ ·ä½¿ç”¨äº†æ®‹å·®è¿žæŽ¥ï¼Œç„¶åŽåœ¨è¾“å‡ºä½¿ç”¨å½’ä¸€åŒ–å±‚ã€‚1234567891011Stage1_out = OutputEmbedding512 + TokenPositionEncoding512Stage2_Mask = masked_multihead_attention(Stage1_out)Stage2_Norm1 = layer_normalization(Stage2_Mask) + Stage1_outStage2_Multi = multihead_attention(Stage2_Norm1 + out_enc) + Stage2_Norm1Stage2_Norm2 = layer_normalization(Stage2_Multi) + Stage2_MultiStage3_FNN = FNN(Stage2_Norm2)Stage3_Norm = layer_normalization(Stage3_FNN) + Stage2_Norm2out_dec = Stage3_Norm å¯ä»¥åˆ©ç”¨å¼€æºçš„Tensor2Tensorï¼Œé€šè¿‡è°ƒç”¨å‡ ä¸ªå‘½ä»¤æ¥è®­ç»ƒTransformerç½‘ç»œè¿›è¡Œç¿»è¯‘å’Œè§£æžã€‚ å¯ä»¥çœ‹åˆ°ï¼ŒSAç®—æ³•è¿˜æœ‰ä¸€ä¸ªå¥½å¤„ï¼Œå¤„ç†å…±æŒ‡æ¶ˆè§£ï¼ˆcoreference resolutionï¼‰ï¼Œä¾‹å¦‚å¥å­ä¸­çš„å•è¯â€œitâ€å¯ä»¥æ ¹æ®ä¸Šä¸‹æ–‡å¼•ç”¨å¥å­çš„ä¸åŒåè¯ã€‚ AttentionGoogleæ–‡ç« åŽŸæ–‡æ˜Žç¡®å®šä¹‰äº†ä½¿ç”¨çš„æ³¨æ„åŠ›ç®—æ³•$$\begin{eqnarray} Attention (Q,K,V) = softmax \Big( \frac{QK^T}{\sqrt{d_k}} \Big) V \end{eqnarray},$$å…¶ä¸­$\boldsymbol{Q}\in\mathbb{R}^{n\times d_k}, \boldsymbol{K}\in\mathbb{R}^{m\times d_k}, \boldsymbol{V}\in\mathbb{R}^{m\times d_v}$. è¿™å°±æ˜¯ä¼ ç»Ÿçš„Scaled Dot-Product Attention, æŠŠè¿™ä¸ªAttentionç†è§£ä¸ºä¸€ä¸ªç¥žç»ç½‘ç»œå±‚ï¼Œå°†$n\times d_k$çš„åºåˆ—$Q$ç¼–ç æˆäº†ä¸€ä¸ªæ–°çš„$n\times d_v$çš„åºåˆ—ã€‚å› ä¸ºå¯¹äºŽè¾ƒå¤§çš„$d_k$ï¼Œå†…ç§¯ä¼šæ•°é‡çº§åœ°æ”¾å¤§, å¤ªå¤§çš„è¯softmaxå¯èƒ½ä¼šè¢«æŽ¨åˆ°æ¢¯åº¦æ¶ˆå¤±åŒºåŸŸ, softmaxåŽå°±éž0å³1(é‚£å°±æ˜¯hardmax), æ‰€ä»¥$q \cdot k = \sum_{i=1}^{d_k}q_i k_i$æŒ‰ç…§æ¯”ä¾‹å› å­$\sqrt{d_k}$ç¼©æ”¾.12345678910111213# ä½¿ç”¨pytorchç‰ˆæœ¬çš„æ•™ç¨‹ä¸­æä¾›çš„èŒƒä¾‹# http://nlp.seas.harvard.edu/2018/04/03/attention.htmldef attention(query, key, value, mask=None, dropout=0.0): "Compute 'Scaled Dot Product Attention'" d_k = query.size(-1) scores = torch.matmul(query, key.transpose(-2, -1)) \ / math.sqrt(d_k) if mask is not None: scores = scores.masked_fill(mask == 0, -1e9) p_attn = F.softmax(scores, dim = -1) # (Dropout described below) p_attn = F.dropout(p_attn, p=dropout) return torch.matmul(p_attn, value), p_attn è¿™åªæ˜¯æ³¨æ„åŠ›çš„ä¸€ç§å½¢å¼ï¼Œè¿˜æœ‰å…¶ä»–æ¯”å¦‚queryè·Ÿkeyçš„è¿ç®—æ–¹å¼æ˜¯æ‹¼æŽ¥åŽå†å†…ç§¯ä¸€ä¸ªå‚æ•°å‘é‡ï¼Œæƒé‡ä¹Ÿä¸ä¸€å®šè¦å½’ä¸€åŒ–ï¼Œç­‰ç­‰ã€‚ Self-Attention (SA)åœ¨å®žé™…çš„åº”ç”¨ä¸­, ä¸åŒçš„åœºæ™¯çš„$Q,K,V$æ˜¯ä¸ä¸€æ ·çš„, å¦‚æžœæ˜¯SQuADçš„è¯ï¼Œ$Q$æ˜¯æ–‡ç« çš„å‘é‡åºåˆ—ï¼Œ$K=V$ä¸ºé—®é¢˜çš„å‘é‡åºåˆ—ï¼Œè¾“å‡ºå°±æ˜¯Aligned Question Embeddingã€‚ Googleæ‰€è¯´çš„è‡ªæ³¨æ„åŠ›(SA), å°±æ˜¯$Attention(\boldsymbol{X},\boldsymbol{X},\boldsymbol{X})$, é€šè¿‡åœ¨åºåˆ—è‡ªèº«åšAttentionï¼Œå¯»æ‰¾åºåˆ—è‡ªèº«å†…éƒ¨çš„è”ç³»ã€‚Googleè®ºæ–‡çš„ä¸»è¦è´¡çŒ®ä¹‹ä¸€æ˜¯å®ƒè¡¨æ˜Žäº†SAåœ¨åºåˆ—ç¼–ç éƒ¨åˆ†æ˜¯ç›¸å½“é‡è¦çš„ï¼Œç”šè‡³å¯ä»¥æ›¿ä»£ä¼ ç»Ÿçš„RNN(LSTM), CNN, è€Œä¹‹å‰å…³äºŽSeq2Seqçš„ç ”ç©¶åŸºæœ¬éƒ½æ˜¯å…³æ³¨å¦‚ä½•æŠŠæ³¨æ„åŠ›æœºåˆ¶ç”¨åœ¨è§£ç éƒ¨åˆ†ã€‚ ç¼–ç æ—¶ï¼Œè‡ªæ³¨æ„åŠ›å±‚å¤„ç†æ¥è‡ªç›¸åŒä½ç½®çš„è¾“å…¥$queries, keys, value$ï¼Œå³ç¼–ç å™¨å‰ä¸€å±‚çš„è¾“å‡ºã€‚ç¼–ç å™¨ä¸­çš„æ¯ä¸ªä½ç½®éƒ½å¯ä»¥å…³æ³¨å‰ä¸€å±‚çš„æ‰€æœ‰ä½ç½®. åœ¨è§£ç å™¨ä¸­ï¼ŒSAå±‚ä½¿æ¯ä¸ªä½ç½®èƒ½å¤Ÿå…³æ³¨è§£ç å™¨ä¸­å½“å‰åŠä¹‹å‰çš„æ‰€æœ‰ä½ç½®ã€‚ä¸ºäº†ä¿æŒ auto-regressive å±žæ€§ï¼Œéœ€è¦é˜»æ­¢è§£ç å™¨ä¸­çš„å‘å·¦ä¿¡æ¯æµ, æ‰€ä»¥è¦åœ¨scaled dot-product attentionå±‚ä¸­å±è”½ï¼ˆè®¾ç½®ä¸º-âˆžï¼‰softmaxè¾“å…¥ä¸­ä¸Žéžæ³•è¿žæŽ¥ç›¸å¯¹åº”çš„æ‰€æœ‰å€¼. ä½œè€…ä½¿ç”¨SAå±‚è€Œä¸æ˜¯CNNæˆ–RNNå±‚çš„åŠ¨æœºæ˜¯: æœ€å°åŒ–æ¯å±‚çš„æ€»è®¡ç®—å¤æ‚åº¦: SAå±‚é€šè¿‡$O(1)$æ•°é‡çš„åºåˆ—æ“ä½œè¿žæŽ¥æ‰€æœ‰ä½ç½®. ($O(n)$ in RNN) æœ€å¤§åŒ–å¯å¹¶è¡ŒåŒ–è®¡ç®—ï¼šå¯¹äºŽåºåˆ—é•¿åº¦$n$ &lt; representation dimensionality $d$ï¼ˆå¯¹äºŽSOTAåºåˆ—è¡¨è¾¾æ¨¡åž‹ï¼Œå¦‚word-piece, byte-pairï¼‰ã€‚å¯¹äºŽéžå¸¸é•¿çš„åºåˆ—$n &gt; d$, SAå¯ä»¥ä»…è€ƒè™‘ä»¥ç›¸åº”è¾“å‡ºä½ç½®ä¸ºä¸­å¿ƒçš„è¾“å…¥åºåˆ—ä¸­çš„æŸä¸ªå¤§å°$r$çš„é‚»åŸŸï¼Œä»Žè€Œå°†æœ€å¤§è·¯å¾„é•¿åº¦å¢žåŠ åˆ°$O(n/r)$ æœ€å°åŒ–ç”±ä¸åŒç±»åž‹å±‚ç»„æˆçš„ç½‘ç»œä¸­ä»»æ„ä¸¤ä¸ªè¾“å…¥å’Œè¾“å‡ºä½ç½®ä¹‹é—´çš„æœ€å¤§è·¯å¾„é•¿åº¦ã€‚ä»»ä½•è¾“å…¥å’Œè¾“å‡ºåºåˆ—ä¸­çš„ä½ç½®ç»„åˆä¹‹é—´çš„è·¯å¾„è¶ŠçŸ­ï¼Œè¶Šå®¹æ˜“å­¦ä¹ é•¿è·ç¦»ä¾èµ–ã€‚ Multi-head AttentionTransformerçš„SAå°†å…³è”è¾“å…¥å’Œè¾“å‡ºåºåˆ—ä¸­çš„ï¼ˆç‰¹åˆ«æ˜¯è¿œç¨‹ï¼‰ä½ç½®çš„è®¡ç®—é‡å‡å°‘åˆ°$O(1)$ã€‚ç„¶è€Œï¼Œè¿™æ˜¯ä»¥é™ä½Žæœ‰æ•ˆåˆ†è¾¨çŽ‡ä¸ºä»£ä»·çš„ï¼Œå› ä¸ºæ³¨æ„åŠ›åŠ æƒä½ç½®è¢«å¹³å‡äº†ã€‚ä¸ºäº†å¼¥è¡¥è¿™ç§æŸå¤±, æ–‡ç« æå‡ºäº† Multi-head Attention: $h=8$ attention layers (â€œheadsâ€): å°†key $K$ å’Œ query $Q$ çº¿æ€§æŠ•å½±åˆ° $d_k$ ç»´åº¦, å°†value $V$ æŠ•å½±åˆ°$d_v$ç»´åº¦, (çº¿æ€§æŠ•å½±çš„ç›®çš„æ˜¯å‡å°‘ç»´åº¦) $$head_i = Attention(Q W^Q_i, K W^K_i, V W^V_i) , i=1,\dots,h$$ æŠ•å½±æ˜¯å‚æ•°çŸ©é˜µ$W^Q_i, W^K_i\in\mathbb{R}^{d_{model}\times d_k}, W^V_i\in\mathbb{R}^{d_{model}\times d_v}$ $d_k=d_v=d_{model}/h = 64$ æ¯å±‚å¹¶è¡Œåœ°åº”ç”¨ scaled-dot attention(ç”¨ä¸åŒçš„çº¿æ€§å˜æ¢), å¾—åˆ°$d_v$ç»´åº¦çš„è¾“å‡º æŠŠæ¯ä¸€å±‚çš„è¾“å‡ºæ‹¼æŽ¥åœ¨ä¸€èµ· $Concat(head_1,\dots,head_h)$ å†çº¿æ€§å˜æ¢ä¸Šä¸€æ­¥çš„æ‹¼æŽ¥å‘é‡$MultiHeadAttention(Q,K,V) = Concat(head_1,\dots,head_h) W^O$, where $W^0\in\mathbb{R}^{d_{hd_v}\times d_{model}}$ å› ä¸ºTransformeråªæ˜¯æŠŠåŽŸæ¥$d_{model}$ç»´åº¦çš„æ³¨æ„åŠ›å‡½æ•°è®¡ç®—å¹¶è¡Œåˆ†å‰²ä¸º$h$ä¸ªç‹¬ç«‹çš„$d_{model}/h$ç»´åº¦çš„head, æ‰€ä»¥è®¡ç®—é‡ç›¸å·®ä¸å¤§.123456789101112131415161718192021222324252627282930# ä½¿ç”¨pytorchç‰ˆæœ¬çš„æ•™ç¨‹ä¸­æä¾›çš„èŒƒä¾‹# http://nlp.seas.harvard.edu/2018/04/03/attention.htmlclass MultiHeadedAttention(nn.Module): def __init__(self, h, d_model, dropout=0.1): "Take in model size and number of heads." super(MultiHeadedAttention, self).__init__() assert d_model % h == 0 # We assume d_v always equals d_k self.d_k = d_model // h self.h = h self.p = dropout self.linears = clones(nn.Linear(d_model, d_model), 4) self.attn = None def forward(self, query, key, value, mask=None): if mask is not None: # Same mask applied to all h heads. mask = mask.unsqueeze(1) nbatches = query.size(0) # 1) Do all the linear projections in batch from d_model =&gt; h x d_k query, key, value = [l(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2) for l, x in zip(self.linears, (query, key, value))] # 2) Apply attention on all the projected vectors in batch. x, self.attn = attention(query, key, value, mask=mask, dropout=self.p) # 3) "Concat" using a view and apply a final linear. x = x.transpose(1, 2).contiguous().view(nbatches, -1, self.h * self.d_k) return self.linears[-1](x) Transformerä»¥ä¸‰ç§ä¸åŒçš„æ–¹å¼ä½¿ç”¨Multi-head Attentionï¼š åœ¨encoder-decoder attentionå±‚ä¸­ï¼Œqueriesæ¥è‡ªå‰ä¸€å±‚decoderå±‚ï¼Œå¹¶ä¸” memory keys and values æ¥è‡ªencoderçš„è¾“å‡ºã€‚è¿™è®©decoderçš„æ¯ä¸ªä½ç½®éƒ½å¯ä»¥æ³¨æ„åˆ°è¾“å…¥åºåˆ—çš„æ‰€æœ‰ä½ç½®ã€‚è¿™å…¶å®žè¿˜åŽŸäº†å…¸åž‹çš„seq2seqæ¨¡åž‹é‡Œå¸¸ç”¨çš„ç¼–ç å™¨ - è§£ç å™¨æ³¨æ„åŠ›æœºåˆ¶ï¼ˆä¾‹å¦‚Bahdanau et al., 2014æˆ–Conv2S2ï¼‰ã€‚ ç¼–ç å™¨æœ¬èº«ä¹ŸåŒ…å«äº†self-attention layersã€‚åœ¨self-attention layersä¸­ï¼Œæ‰€æœ‰ keys, values and queries æ¥è‡ªç›¸åŒçš„ä½ç½®ï¼Œåœ¨è¿™é‡Œæ˜¯ç¼–ç å™¨ä¸­å‰ä¸€å±‚çš„è¾“å‡ºã€‚è¿™æ ·ï¼Œç¼–ç å™¨çš„æ¯ä¸ªä½ç½®éƒ½å¯ä»¥æ³¨æ„åˆ°å‰ä¸€å±‚çš„æ‰€æœ‰ä½ç½®ã€‚ ç±»ä¼¼åœ°ï¼Œè§£ç å™¨ä¸­çš„ self-attention layers å…è®¸è§£ç å™¨çš„æ¯ä¸ªä½ç½®æ³¨æ„åˆ°è§£ç å™¨ä¸­åŒ…æ‹¬è¯¥ä½ç½®åœ¨å†…çš„æ‰€æœ‰å‰é¢çš„ä½ç½®ï¼ˆæœ‰maskå±è”½äº†åŽé¢çš„ä½ç½®ï¼‰ã€‚éœ€è¦é˜»æ­¢è§£ç å™¨ä¸­çš„å‘å·¦ä¿¡æ¯æµä»¥ä¿æŒè‡ªå›žå½’å±žæ€§(auto-regressive å¯ä»¥ç®€å•ç†è§£ä¸ºæ—¶åºåºåˆ—çš„ç‰¹æ€§, åªèƒ½ä»Žå·¦åˆ°å³, ä»Žè¿‡åŽ»åˆ°æœªæ¥)ã€‚æˆ‘ä»¬é€šè¿‡åœ¨scaled dot-product attentionå±‚ä¸­å±è”½ï¼ˆè®¾ç½®ä¸º-âˆžï¼‰softmaxè¾“å…¥ä¸­ä¸Žéžæ³•è¿žæŽ¥ç›¸å¯¹åº”çš„æ‰€æœ‰å€¼æ¥ç»´æŒè¯¥ç‰¹æ€§ã€‚ Position-wise Feed-Forward Networksåœ¨ç¼–ç å™¨å’Œè§£ç å™¨ä¸­ï¼Œæ¯ä¸ªå±‚éƒ½åŒ…å«ä¸€ä¸ªå…¨è¿žæŽ¥çš„å‰é¦ˆç½‘ç»œ(FFN)ï¼ŒFFN åˆ†åˆ«åº”ç”¨äºŽæ¯ä¸ªä½ç½®ï¼Œä½¿ç”¨ç›¸åŒçš„ä¸¤ä¸ªçº¿æ€§å˜æ¢å’Œä¸€ä¸ªReLU $$FFN(x) = max(0, xW_1+b_1) W_2 + b_2$$è™½ç„¶çº¿æ€§å˜æ¢åœ¨ä¸åŒä½ç½®ä¸Šæ˜¯ç›¸åŒçš„ï¼Œä½†å®ƒä»¬åœ¨å±‚ä¸Žå±‚ä¹‹é—´ä½¿ç”¨ä¸åŒçš„å‚æ•°ã€‚å®ƒçš„å·¥ä½œæ–¹å¼ç±»ä¼¼äºŽä¸¤ä¸ªå†…æ ¸å¤§å°ä¸º1çš„å·ç§¯å±‚. è¾“å…¥/è¾“å‡ºç»´åº¦æ˜¯$d_{model}=512$, å†…å±‚çš„ç»´åº¦$d_{ff} = 2048$.12345678910111213# ä½¿ç”¨pytorchç‰ˆæœ¬çš„æ•™ç¨‹ä¸­æä¾›çš„èŒƒä¾‹# http://nlp.seas.harvard.edu/2018/04/03/attention.htmlclass PositionwiseFeedForward(nn.Module): "Implements FFN equation." def __init__(self, d_model, d_ff, dropout=0.1): super(PositionwiseFeedForward, self).__init__() # Torch linears have a `b` by default. self.w_1 = nn.Linear(d_model, d_ff) self.w_2 = nn.Linear(d_ff, d_model) self.dropout = nn.Dropout(dropout) def forward(self, x): return self.w_2(self.dropout(F.relu(self.w_1(x)))) Positional Encodingåœ¨è§£ç æ—¶åºä¿¡æ¯æ—¶ï¼ŒLSTMæ¨¡åž‹é€šè¿‡æ—¶é—´æ­¥çš„æ¦‚å¿µä»¥è¾“å…¥/è¾“å‡ºæµä¸€æ¬¡ä¸€ä¸ªçš„å½¢å¼ç¼–ç çš„. è€ŒTransformeré€‰æ‹©æŠŠæ—¶åºç¼–ç ä¸ºæ­£å¼¦æ³¢ã€‚è¿™äº›ä¿¡å·ä½œä¸ºé¢å¤–çš„ä¿¡æ¯åŠ å…¥åˆ°è¾“å…¥å’Œè¾“å‡ºä¸­ä»¥è¡¨è¾¾æ—¶åºä¿¡æ¯. è¿™ç§ç¼–ç ä½¿æ¨¡åž‹èƒ½å¤Ÿæ„ŸçŸ¥åˆ°å½“å‰æ­£åœ¨å¤„ç†çš„æ˜¯è¾“å…¥ï¼ˆæˆ–è¾“å‡ºï¼‰åºåˆ—çš„å“ªä¸ªéƒ¨åˆ†ã€‚ä½ç½®ç¼–ç å¯ä»¥å­¦ä¹ æˆ–è€…ä½¿ç”¨å›ºå®šå‚æ•°ã€‚ä½œè€…è¿›è¡Œäº†æµ‹è¯•ï¼ˆPPLï¼ŒBLEUï¼‰ï¼Œæ˜¾ç¤ºä¸¤ç§æ–¹å¼è¡¨çŽ°ç›¸ä¼¼ã€‚æ–‡ä¸­ä½œè€…é€‰æ‹©ä½¿ç”¨å›ºå®šçš„ä½ç½®ç¼–ç å‚æ•°:$$ \begin{eqnarray} PE_{(pos,2i)} = sin(pos/10000^{2i/d_{model}}) \end{eqnarray} $$$$ \begin{eqnarray} PE_{(pos,2i+1)} = cos(pos/10000^{2i/d_{model}})\end{eqnarray} $$ å…¶ä¸­$pos$æ˜¯ä½ç½®ï¼Œ$i$æ˜¯ç»´åº¦ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ç½®ç¼–ç çš„æ¯ä¸ªç»´åº¦å¯¹åº”äºŽæ­£å¼¦ä½™å¼¦æ›²çº¿çš„æ‹¼æŽ¥ã€‚æ³¢é•¿å½¢æˆä»Ž2Ï€åˆ°10000â‹…2Ï€çš„å‡ ä½•çº§æ•°ã€‚é€‰æ‹©è¿™ä¸ªå‡½æ•°ï¼Œæ˜¯å› ä¸ºå‡è®¾å®ƒèƒ½è®©æ¨¡åž‹å®¹æ˜“åœ°å­¦ä¹ ç›¸å¯¹ä½ç½®ï¼Œå› ä¸ºå¯¹äºŽä»»æ„å›ºå®šåç§»$k$ï¼Œ$PE_{pos + k}$å¯ä»¥è¡¨ç¤ºä¸º$PE_{pos}$çš„çº¿æ€§å‡½æ•°ã€‚123456789101112131415161718192021# ä½¿ç”¨pytorchç‰ˆæœ¬çš„æ•™ç¨‹ä¸­æä¾›çš„èŒƒä¾‹# http://nlp.seas.harvard.edu/2018/04/03/attention.htmlclass PositionalEncoding(nn.Module): "Implement the PE function." def __init__(self, d_model, dropout, max_len=5000): super(PositionalEncoding, self).__init__() self.dropout = nn.Dropout(p=dropout) # Compute the positional encodings once in log space. pe = torch.zeros(max_len, d_model) position = torch.arange(0, max_len).unsqueeze(1) div_term = torch.exp(torch.arange(0, d_model, 2) * -(math.log(10000.0) / d_model)) pe[:, 0::2] = torch.sin(position * div_term) pe[:, 1::2] = torch.cos(position * div_term) pe = pe.unsqueeze(0) self.register_buffer('pe', pe) def forward(self, x): x = x + Variable(self.pe[:, :x.size(1)], requires_grad=False) return self.dropout(x) ä½ç½®ç¼–ç å°†æ ¹æ®ä½ç½®æ·»åŠ æ­£å¼¦ä½™å¼¦æ³¢ã€‚æ¯ä¸ªç»´åº¦çš„æ³¢çš„é¢‘çŽ‡å’Œåç§»æ˜¯ä¸åŒçš„ã€‚12345plt.figure(figsize=(15, 5))pe = PositionalEncoding(20, 0)y = pe.forward(Variable(torch.zeros(1, 100, 20)))plt.plot(np.arange(100), y[0, :, 4:8].data.numpy())plt.legend(["dim %d"%p for p in [4,5,6,7]]) ç›´è§‚çš„ç†è§£æ˜¯ï¼Œå°†è¿™äº›å€¼æ·»åŠ åˆ°embeddingä¸­ï¼Œä¸€æ—¦å®ƒä»¬è¢«æŠ•å½±åˆ°$Q / K / V$å‘é‡å’Œdot product attentionä¸­ï¼Œå°±ç»™embeddingå‘é‡ä¹‹é—´æä¾›äº†æœ‰æ„ä¹‰çš„ç›¸å¯¹è·ç¦»ã€‚ Shared-Weight Embeddings and Softmaxä¸Žå…¶ä»–åºåˆ—è½¬å¯¼æ¨¡åž‹ç±»ä¼¼ï¼Œä½¿ç”¨å¯å­¦ä¹ çš„Embeddingså°† input tokens and output tokens è½¬æ¢ä¸ºç»´åº¦$d_{model}$çš„å‘é‡ã€‚é€šè¿‡çº¿æ€§å˜æ¢å’Œsoftmaxå‡½æ•°å°†è§£ç å™¨çš„è¾“å‡ºå‘é‡è½¬æ¢ä¸ºé¢„æµ‹çš„tokenæ¦‚çŽ‡ã€‚åœ¨Transformeræ¨¡åž‹ä¸­ï¼Œä¸¤ä¸ªåµŒå…¥å±‚å’Œpre-softmaxçº¿æ€§å˜æ¢ä¹‹é—´å…±äº«ç›¸åŒçš„æƒé‡çŸ©é˜µï¼Œåœ¨Embeddingså±‚ä¸­ï¼Œå°†æƒé‡ä¹˜ä»¥$\sqrt{d_{\text{model}}}$. è¿™äº›éƒ½æ˜¯å½“å‰ä¸»æµçš„æ“ä½œã€‚12345678910# ä½¿ç”¨pytorchç‰ˆæœ¬çš„æ•™ç¨‹ä¸­æä¾›çš„èŒƒä¾‹# http://nlp.seas.harvard.edu/2018/04/03/attention.htmlclass Embeddings(nn.Module): def __init__(self, d_model, vocab): super(Embeddings, self).__init__() self.lut = nn.Embedding(vocab, d_model) self.d_model = d_model def forward(self, x): return self.lut(x) * math.sqrt(self.d_model) å¯å‘ä½œè€…å·²ç»è¿›è¡Œäº†ä¸€ç³»åˆ—æµ‹è¯•ï¼ˆè®ºæ–‡è¡¨3ï¼‰ï¼Œå…¶ä¸­ä»–ä»¬è®¨è®ºN = 6å±‚çš„å»ºè®®ï¼Œæ¨¡åž‹å¤§å°ä¸º512ï¼ŒåŸºäºŽh = 8ä¸ªheadsï¼Œé”®å€¼ç»´åº¦ä¸º64ï¼Œä½¿ç”¨100Kæ­¥ã€‚ è¿˜æŒ‡å‡ºï¼Œç”±äºŽæ¨¡åž‹è´¨é‡éšç€$d_k$ï¼ˆè¡ŒBï¼‰çš„å‡å°è€Œé™ä½Žï¼Œå› æ­¤å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ç‚¹ç§¯å…¼å®¹æ€§åŠŸèƒ½ã€‚ å…¶å£°ç§°æå‡ºçš„å›ºå®šæ­£å¼¦ä½ç½®ç¼–ç ï¼Œä¸Žå­¦ä¹ åˆ°çš„ä½ç½®ç¼–ç ç›¸æ¯”ï¼Œäº§ç”Ÿå‡ ä¹Žç›¸ç­‰çš„åˆ†æ•°ã€‚ ç®—æ³•é€‚åˆå“ªäº›ç±»åž‹çš„é—®é¢˜ï¼Ÿ åºåˆ—è½¬å¯¼ï¼ˆè¯­è¨€ç¿»è¯‘ï¼‰ è¯­æ³•é€‰åŒºè§£æžçš„ç»å…¸è¯­è¨€åˆ†æžä»»åŠ¡ syntactic constituency parsing å…±æŒ‡æ¶ˆè§£ coreference resolution å‚è€ƒèµ„æ–™https://research.googleblog.com/2017/08/transformer-novel-neural-network.htmlhttps://research.googleblog.com/2017/06/accelerating-deep-learning-research.htmlhttps://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/http://nlp.seas.harvard.edu/2018/04/03/attention.html]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç”¨äºŽæ–‡æœ¬åˆ†ç±»çš„ç¥žç»ç½‘ç»œå¼€æºå·¥å…·]]></title>
    <url>%2FNLP-text-classification%2F</url>
    <content type="text"><![CDATA[æ–‡æœ¬åˆ†ç±»æ–‡æœ¬åˆ†ç±»æ˜¯å¾ˆå¤šä¸šåŠ¡é—®é¢˜ä¸­å¹¿æ³›ä½¿ç”¨åˆ°çš„NLP/ç›‘ç£æœºå™¨å­¦ä¹ ï¼ˆMLï¼‰ã€‚æ–‡æœ¬åˆ†ç±»çš„ç›®æ ‡æ˜¯è‡ªåŠ¨å°†æ–‡æœ¬/æ–‡æ¡£åˆ†ç±»ä¸ºä¸€ä¸ªæˆ–å¤šä¸ªé¢„å®šä¹‰ç±»åˆ«ã€‚ç›®å‰çš„æˆç†Ÿæ€è·¯æ˜¯ç”¨è¯å‘é‡è§£ç æ–‡æœ¬ï¼Œç„¶åŽä½¿ç”¨ä¼ ç»Ÿæœºå™¨å­¦ä¹ æ¨¡åž‹æˆ–è€…æ·±åº¦ç¥žç»ç½‘ç»œæ¨¡åž‹æ¥åšåˆ†ç±»ã€‚ æ–‡æœ¬åˆ†ç±»æ˜¯å­¦æœ¯ç•Œå’Œå·¥ä¸šç•Œéžå¸¸æ´»è·ƒçš„ç ”ç©¶é¢†åŸŸã€‚æœ¬æ–‡ä¸»è¦ä»‹ç»ç”¨äºŽæ–‡æœ¬åˆ†ç±»çš„å‡ ç§ç¥žç»ç½‘ç»œæ¨¡åž‹æ–¹æ³•ï¼Œå¹¶æ¯”è¾ƒå®ƒä»¬çš„æ€§èƒ½ï¼Œä»£ç å®žçŽ°ä¸»è¦åŸºäºŽKerasã€‚æ–‡ä¸­ä»£ç éƒ½åœ¨è¿™ä¸ªDeepTextGitHubé¡¹ç›®ä¸­. æ–‡æœ¬åˆ†ç±»çš„ä¸€äº›ç¤ºä¾‹åŒ…æ‹¬ï¼š ä»Žç¤¾äº¤åª’ä½“ä¸­äº†è§£å—ä¼—æƒ…ç»ªï¼ˆðŸ˜ ðŸ˜ ðŸ˜¥ï¼‰ æ£€æµ‹åžƒåœ¾é‚®ä»¶å’Œéžåžƒåœ¾é‚®ä»¶ è‡ªåŠ¨æ ‡è®°å®¢æˆ·æŸ¥è¯¢ å°†æ–°é—»æ–‡ç« ðŸ“°åˆ†ç±»ä¸ºé¢„å®šä¹‰ä¸»é¢˜ ç«¯åˆ°ç«¯æ–‡æœ¬åˆ†ç±»æµæ°´çº¿ç«¯åˆ°ç«¯æ–‡æœ¬åˆ†ç±»æµæ°´çº¿ç”±ä»¥ä¸‹ç»„ä»¶ç»„æˆï¼š è®­ç»ƒæ–‡æœ¬ï¼šè¾“å…¥æ–‡æœ¬ï¼Œæœ‰ç›‘ç£æ¨¡åž‹èƒ½å¤Ÿé€šè¿‡å·²æ ‡æ³¨æ•°æ®æ¥å­¦ä¹ å’Œé¢„æµ‹æ‰€éœ€çš„ç±»ã€‚ ç‰¹å¾å‘é‡ï¼šç‰¹å¾å‘é‡æ˜¯ç”¨äºŽè§£ç è¾“å…¥æ•°æ®ç‰¹å¾çš„ä¿¡æ¯çš„å‘é‡ã€‚ æ ‡ç­¾ï¼šé¢„å®šä¹‰çš„ç±»åˆ«/ç±»ï¼Œä½œä¸ºæ¨¡åž‹é¢„æµ‹çš„ç›®æ ‡ã€‚ ç®—æ³•æ¨¡åž‹ï¼šèƒ½å¤Ÿå¤„ç†æ–‡æœ¬åˆ†ç±»çš„ç®—æ³•ï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼šCNNï¼ŒRNNï¼ŒHAN, Fasttextï¼‰ é¢„æµ‹ï¼šå·²ç»åœ¨åŽ†å²æ•°æ®é›†ä¸Šè®­ç»ƒè¿‡çš„æ¨¡åž‹ï¼Œå¯ä»¥ç”¨äºŽæ‰§è¡Œæ ‡ç­¾é¢„æµ‹ã€‚ è¿™é‡Œä½¿ç”¨æ±½è½¦æ¶ˆè´¹è€…çš„è¯„æµ‹æ•°æ®é›†ï¼Œåœ¨tsvæ–‡ä»¶ä¸­, ç¬¬ä¸€åˆ—æ˜¯åºå·å¯¹æˆ‘ä»¬æ²¡ç”¨, ç¬¬äºŒåˆ—æ˜¯label(0, 1)ï¼Œåˆ†åˆ«ä»£è¡¨ï¼ˆæ¶ˆæžï¼Œç§¯æžï¼‰è¯„ä»·ï¼Œç¬¬ä¸‰åˆ—æ˜¯æ–‡æœ¬.123451 æ“æŽ§æ€§èˆ’æœã€æ²¹è€—ä½Žï¼Œæ€§ä»·æ¯”é«˜0 åŠ¨åŠ›çš„ç¡®æœ‰ç‚¹ç‚¹è®©æˆ‘ç›¸ä¿¡äº†upçš„ç¡®æ˜¯ä¸ªä»£æ­¥è½¦è€Œå·²!1 1ã€‚è½¦çš„å¤–è§‚å¾ˆå–œæ¬¢ã€‚2ã€‚çœæ²¹ï¼ŒçŽ°åœ¨ç£¨åˆæœŸ7.3ï¼Œç›¸ä¿¡ä»¥åŽè¿˜ä¼šä¸‹é™ã€‚1 å†…é¥°çš„åšå·¥å’Œç”¨æ–™åŒçº§åˆ«åŒä»·ä½æœ€åŽšé“çš„0 å‡éœ‡ç³»ç»Ÿå¤ªç¡¬ï¼ æ•°æ®å¤„ç†ä½¿ç”¨çš„ç±»ï¼Œå…·ä½“è§ä»£ç é“¾æŽ¥123456789101112131415161718class DataProcessor(object): """ Base class for data converters for sequence classification data sets. helper funcitons [read_tsv, read_text, read_json] """ ...class SampleProcessor(DataProcessor): """ Sample processor for the classification data set. Tranform the text to tensor for training if use pre-train model, need vocabulary file usage: process data files &gt;&gt;&gt; processer = SampleProcessor(config, ) provide your own data in list format [train_X, train_Y, test_X, test_Y] &gt;&gt;&gt; processer = SampleProcessor(config, data) """ è¯å‘é‡ä½¿ç”¨åŒ…å«å¤–éƒ¨çŸ¥è¯†çš„embeddingè¡¨è¾¾å­—è¯æ˜¯ç›®å‰çš„ä¸»æµæ–¹æ³•ï¼Œç»å…¸çš„å¦‚word2vecï¼ŒGLoVeï¼Œè¾ƒæ–°è¿›çš„ ELMoï¼ŒBERTï¼Œç­‰é¢„è®­ç»ƒå‘é‡ï¼Œé›†æˆäº†å…³äºŽå•è¯çš„æ–°ä¿¡æ¯ï¼ˆè¯æ±‡å’Œè¯­ä¹‰ï¼‰ï¼Œè¿™äº›ä¿¡æ¯å·²ç»åœ¨éžå¸¸å¤§çš„æ•°æ®é›†ä¸Šè¿›è¡Œäº†è®­ç»ƒå’Œæç‚¼ã€‚ åœ¨è¿™é‡Œçš„æ¨¡åž‹ï¼Œéƒ½å…è®¸æˆ‘ä»¬ç›´æŽ¥è½½å…¥å¤–éƒ¨çš„ embedding å‚æ•°ã€‚ ç‰¹åˆ«æ˜¯æä¾›äº†é€šè¿‡é¢„è®­ç»ƒçš„BERTèŽ·å–ä¸­æ–‡å•è¯çš„å‘é‡è¡¨è¾¾çš„æŽ¥å£. æœ€å¥½æ˜¯ä½¿ç”¨åœ¨è‡ªå·±æ–‡æœ¬ä¸Šfine-tuneè¿‡çš„é¢„è®­ç»ƒBERTæ¨¡åž‹.12345678@staticmethoddef load_bert_embedding(vob_size, emb_size, word2id): """ Get bert pre-trained representation, for example, pre-trained chinese_L-12_H-768_A-12, the hidden_size is 768 """ ... return rep_matrix è¾“å…¥ä½ çš„è¯æ±‡è¡¨, è¿”å›žå„ä¸ªè¯æ±‡å¯¹åº”çš„å‘é‡, ä»¥è¯å…¸å½¢å¼è¿”å›ž. å†…éƒ¨çš„å·¥ä½œæœºåˆ¶æ˜¯æŠŠæ¯ä¸€ä¸ªå•è¯éƒ½ç”¨æ‹¼æŽ¥èµ·æ¥, ä¹‹é—´ç”¨BERTçš„å¥å­åˆ†éš”ç¬¦[SEP]éš”å¼€. åœ¨è¿”å›žçš„token level çš„å‘é‡ä¸­é‡æ–°poolå‡ºå„ä¸ªè¯æ±‡çš„è¡¨è¾¾. è¿™ä¸ªæ–¹æ³•å…·ä½“çš„æ•ˆæžœæœ‰å¾…éªŒè¯. Fasttextæ–‡æœ¬åˆ†ç±»Fasttext éžå¸¸é€‚åˆå¤„ç†ä¸€äº›æ˜¾è€Œæ˜“è§ï¼Œä¸éœ€è¦æŽ¨ç†ï¼Œæƒ…å†µæ¯”è¾ƒå•çº¯çš„æ–‡æœ¬åˆ†ç±»é—®é¢˜ã€‚å®ƒå°±æ˜¯ä¸€ä¸ªè¯è¢‹æ¨¡åž‹ï¼ŒæŠŠæ–‡æœ¬æ‰€æœ‰å•è¯çš„å‘é‡poolåœ¨ä¸€èµ·ï¼Œå¾—å‡ºæ•´ä¸ªæ–‡æœ¬çš„å‘é‡è¡¨è¾¾ï¼Œè¿™ä¸ªæ–‡æœ¬å‘é‡ä½¿ç”¨softmaxåˆ†ç±»å™¨å¾—å‡ºä¸åŒæ ‡ç­¾çš„æ¦‚çŽ‡åˆ†å¸ƒã€‚ä¸ºäº†æ•æ‰è¯ä¹‹é—´çš„é¡ºåºï¼ŒfasttextåŠ å…¥äº†ngramç‰¹å¾ã€‚è¯¦ç»†æŽ¨èçœ‹è¿™ä¸¤ç¯‡æ–‡ç«  Enriching Word Vectors with Subword Information, P. Bojanowski, E. Grave, A. Joulin, T. Mikolov Bag of Tricks for Efficient Text Classification, A. Joulin, E. Grave, P. Bojanowski, T. Mikolovä»£ç é“¾æŽ¥12345678910111213141516171819202122232425def fasttext(max_length, emb_size, max_words, class_num, pre_train_emb=None): """ return single label classification fasttext model paper: Bag of Tricks for Efficient Text Classification The original paper use average pooling. In many Kaggle application, Max Pooling is found to be useful """ input = Input(shape=(max_length,), dtype='int32', name='input') embeddings_initializer = 'uniform' if pre_train_emb is not None: embeddings_initializer = initializers.Constant(pre_train_emb) embed_input = Embedding(output_dim=emb_size, dtype='float32', input_dim=max_words + 1, input_length=max_length, embeddings_initializer=embeddings_initializer, trainable=True )(input) drop_out_input = Dropout(0.5, name='dropout_layer')(embed_input) ave_pool = GlobalAveragePooling1D()(drop_out_input) max_pool = GlobalMaxPooling1D()(drop_out_input) concat_pool = concatenate([ave_pool, max_pool]) output = Dense(class_num, activation='softmax', name='output')(concat_pool) model = Model(inputs=[input], outputs=output) model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy']) return model å¯¹äºŽä¸­æ–‡æ–‡æœ¬ï¼Œå¦‚æžœæ•°æ®é›†ä¸æ˜¯å¾ˆå¹²å‡€çš„è¯ï¼ˆæ¯”å¦‚æœ‰é”™åˆ«å­—ï¼‰ï¼Œè€ƒè™‘ä½¿ç”¨ç‰¹æ®Šè¶…å‚çš„fasttextã€‚ä¸€èˆ¬æ¥è¯´fasttextåœ¨è‹±æ–‡ä¸­çš„char+ngramçš„çª—å£å¤§å°ä¸€èˆ¬å–å€¼3 ~ 6ï¼Œä½†æ˜¯åœ¨å¤„ç†ä¸­æ–‡æ—¶ï¼Œä¸ºäº†åŽ»é™¤è¾“å…¥ä¸­çš„å™ªå£°ï¼Œé‚£ä¹ˆå¯ä»¥æŠŠè¿™ä¸ªçª—å£é™åˆ¶ä¸º1~2ï¼Œå› ä¸ºå°çª—å£æœ‰åˆ©äºŽæ¨¡åž‹åŽ»æ•èŽ·é”™åˆ«å­—ï¼ˆé”™è¯¯è¯ä¸€èˆ¬éƒ½æ˜¯å…¶ä¸­çš„ä¸€ä¸ªå­—è¡¨è¾¾æˆåŒéŸ³å¼‚å½¢çš„å¦ä¸€ä¸ªå­—ï¼‰ï¼Œæ¯”å¦‚å°ngramçª—å£fasttextå­¦å‡ºæ¥çš„&quot;ä¼¼ä¹Ž&quot;è¿‘ä¼¼è¯å¾ˆæœ‰å¯èƒ½åŒ…å«&quot;æ˜¯ä¹Ž&quot;ç­‰å†…éƒ¨åŒ…å«é”™åˆ«å­—çš„è¯ï¼Œè¿™æ ·ç­‰äºŽè®©fasttextæ‹¥æœ‰äº†è¯†åˆ«é”™åˆ«å­—çš„è¯çš„èƒ½åŠ›ã€‚ å·ç§¯ç¥žç»ç½‘ç»œï¼ˆCNNï¼‰æ–‡æœ¬åˆ†ç±»CNNé€šå¸¸ç”¨äºŽè®¡ç®—æœºè§†è§‰ï¼Œä½†å®ƒä»¬æœ€è¿‘å·²åº”ç”¨äºŽå„ç§NLPä»»åŠ¡ï¼Œç»“æžœå¾ˆæœ‰å‰æ™¯ã€‚ ç®€è¦åœ°è¯´ï¼Œåœ¨æ–‡æœ¬æ•°æ®ä¸Šä½¿ç”¨CNNæ—¶ï¼Œå½“æ£€æµ‹åˆ°ç‰¹æ®Šçš„ patternï¼Œæ¯ä¸ªå·ç§¯çš„ç»“æžœéƒ½å°†è§¦å‘ã€‚é€šè¿‡æ”¹å˜å†…æ ¸çš„å¤§å°å¹¶è¿žæŽ¥å®ƒä»¬çš„è¾“å‡ºï¼Œä½ å¯ä»¥è‡ªå·±æ£€æµ‹å¤šä¸ªå¤§å°çš„æ¨¡å¼ï¼ˆ2, 3æˆ–5ä¸ªç›¸é‚»çš„å•è¯ï¼‰ã€‚Patterns å¯ä»¥æ˜¯è¡¨è¾¾å¼ï¼ˆå¦‚ ngramsï¼‰ï¼Œå› æ­¤CNNå¯ä»¥åœ¨å¥å­ä¸­è¯†åˆ«å®ƒä»¬è€Œä¸ç®¡å®ƒä»¬çš„ä½ç½®å¦‚ä½•ã€‚ å‚æ•°ä½¿ç”¨ 128 ä¸ª filtersï¼Œå¤§å°ä»Ž1åˆ°4ã€‚æ¨¡åž‹æž¶æž„å¦‚å›¾ä»£ç é“¾æŽ¥123456789101112131415161718def text_cnn(max_length, emb_size, max_words, class_num, pre_train_emb=None): " textCNN model " ... cnn1_1 = Conv1D(128, 1, padding='same', strides=1)(drop_out_layer) ... cnn1 = GlobalMaxPooling1D()(cnn1_2_at) cnn2_1 = Conv1D(128, 2, padding='same', strides=1)(drop_out_layer) ... cnn2 = GlobalMaxPooling1D()(cnn2_2_at) cnn3_1 = Conv1D(128, 4, padding='same', strides=1)(drop_out_layer) ... cnn3 = GlobalMaxPooling1D()(cnn3_2_at) concat_cnn = concatenate([cnn1, cnn2, cnn3], axis=-1) ... return model ç”¨äºŽtextçš„CNNä¸ä»…æ›´å®¹æ˜“å¹¶è¡ŒåŒ–è¿ç®—ï¼Œè€Œä¸”å¾ˆå®¹æ˜“æˆä¸ºä¸€ä¸ªæ•°æ®é›†ä¸Šçš„å¾ˆå¼ºçš„baselineï¼ˆé™¤éžè¿™ä¸ªåˆ†ç±»ä»»åŠ¡å¾ˆéš¾ï¼‰ã€‚æ ¹æ®æ•°æ®çš„æƒ…å†µé€‰æ‹©æ¨¡åž‹ï¼Œå¦‚æžœngramç‰¹å¾å¾ˆé‡è¦ï¼Œä½¿ç”¨textCNNï¼Œå¦‚æžœæ–‡æœ¬é•¿è·ç¦»ä¾èµ–æ¯”è¾ƒæ˜Žæ˜¾ï¼Œè€ƒè™‘ä½¿ç”¨RNNã€‚ RNNç”¨äºŽæ–‡æœ¬åˆ†ç±»RNNç”¨äºŽæ–‡æœ¬åˆ†ç±»çš„è¯ï¼Œseq2one æž¶æž„ï¼ŒæŠŠä¸å®šé•¿åºåˆ—è§£ç ä¸ºå®šé•¿å‘é‡ï¼Œå†æŠŠè¿™ä¸ªè¾“å‡ºå‘é‡ç”¨softmaxå‡½æ•°è®¡ç®—å‡ºå„æ ‡ç­¾çš„æ¦‚çŽ‡åˆ†å¸ƒã€‚RNN(LSTM/GRU)å› ä¸ºå¤„ç†é•¿æ–‡æœ¬çš„èƒ½åŠ›è¾ƒå¼±ï¼Œç›®å‰ä¸€èˆ¬éœ€è¦åŠ ä¸Šæ³¨æ„åŠ›æœºåˆ¶ã€‚è¿™é‡Œæš‚æ—¶ç®€å•ç²—æš´çš„ç”¨åŒå‘GRUæ¥å®šä¹‰æ ¸å¿ƒçš„encoder.1234567def text_rnn(max_length, emb_size, max_words, class_num, pre_train_emb=None): " Text RNN model using GRU cell" return _bilstm_attention(max_length, emb_size, max_words, class_num, False, pre_train_emb)def text_rnn_attention(max_length, emb_size, max_words, class_num, pre_train_emb=None): " Text RNN model using GRU cell with attention mechanism" return _bilstm_attention(max_length, emb_size, max_words, class_num, True, pre_train_emb) RCNNHierarchical Attention Network (HAN)ReferenceEnriching Word Vectors with Subword Information, P. Bojanowski, E. Grave, A. Joulin, T. MikolovBag of Tricks for Efficient Text Classification, A. Joulin, E. Grave, P. Bojanowski, T. Mikolovhttps://arxiv.org/abs/1408.5882 Yoon Kimhttp://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/ by Denny Britz.Understanding convolutional neural networks for nlphttps://medium.com/jatana/report-on-text-classification-using-cnn-rnn-han-f0e887214d5fHierarchical Attention Networks for Document Classification]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ¦‚çŽ‡å›¾æ¨¡åž‹ - æœ´ç´ è´å¶æ–¯ - éšé©¬å°”ç§‘å¤« - æ¡ä»¶éšæœºåœº - é€»è¾‘å›žå½’]]></title>
    <url>%2FNLP-HMM-CRF%2F</url>
    <content type="text"><![CDATA[è¯æ€§æ ‡æ³¨ï¼ˆPart-of-Speech-Taggingï¼‰POSä»»åŠ¡æ˜¯æŒ‡æ ¹æ®è§‚å¯Ÿå¾—åˆ°çš„åºåˆ—, æŽ¨æ–­å‡ºå¯¹åº”çš„è¯æ€§æ ‡æ³¨, æ¯”å¦‚Bob drank coffee at Starbucks, æ ‡æ³¨å¯èƒ½ä¸ºBob (NOUN) drank (VERB) coffee (NOUN) at (PREPOSITION) Starbucks (NOUN). é™¤æ­¤ä¹‹å¤–, è¿˜æœ‰å‘½åå®žä½“è¯†åˆ«, ä»¥åŠå…¶ä»–æ¶‰åŠåˆ°éœ€è¦æ ¹æ®è§‚å¯Ÿåºåˆ—æŽ¨æ–­éšå«çŠ¶æ€çš„é—®é¢˜, éƒ½å¯ä»¥è€ƒè™‘ç”¨éšé©¬å°”å¯å¤«æ¨¡åž‹(Hidden Markov Model, HMM)æˆ–è€…æ¡ä»¶éšæœºåœº(conditional random fields, CRF)æ¥å¤„ç†. æ¦‚çŽ‡å›¾æ¨¡åž‹Graphical Models, ç”¨å›¾çš„å½¢å¼è¡¨ç¤ºéšæœºå˜é‡ä¹‹é—´æ¡ä»¶ä¾èµ–å…³ç³»çš„æ¦‚çŽ‡æ¨¡åž‹ï¼Œæ˜¯æ¦‚çŽ‡è®ºä¸Žå›¾è®ºçš„ç»“åˆã€‚å›¾ä¸­çš„èŠ‚ç‚¹è¡¨ç¤ºéšæœºå˜é‡ï¼Œç¼ºå°‘è¾¹è¡¨ç¤ºæ¡ä»¶ç‹¬ç«‹å‡è®¾ã€‚G = (V, E). å…¶ä¸­ V: vertex, é¡¶ç‚¹/èŠ‚ç‚¹, è¡¨ç¤ºéšæœºå˜é‡. E: edge, è¾¹/å¼§. å¦‚æžœä¸¤ä¸ªèŠ‚ç‚¹ä¸å­˜åœ¨è¾¹, åˆ™äºŒè€…æ¡ä»¶ç‹¬ç«‹.ä»Žå›¾ä¸Šå¯ä»¥çœ‹åˆ°, è´å¶æ–¯ç½‘ç»œ(Bayesian Networks, BNs)æ˜¯æœ‰å‘å›¾, æ¯ä¸ªèŠ‚ç‚¹çš„æ¡ä»¶æ¦‚çŽ‡åˆ†å¸ƒè¡¨ç¤ºä¸ºP(å½“å‰èŠ‚ç‚¹ | çˆ¶èŠ‚ç‚¹). è€Œé©¬å°”å¯å¤«ç½‘ç»œåˆ™æ˜¯æ— å‘å›¾, åŒ…å«äº†ä¸€ç»„å…·æœ‰é©¬å°”å¯å¤«æ€§è´¨çš„éšæœºå˜é‡. é©¬å°”å¯å¤«éšæœºåœº(Markov Random Fields, MRF)æ˜¯ç”±å‚æ•°$Î»=(S, Ï€, A)$è¡¨ç¤º, å…¶ä¸­Sæ˜¯çŠ¶æ€çš„é›†åˆï¼ŒÏ€æ˜¯åˆå§‹çŠ¶æ€çš„æ¦‚çŽ‡, Aæ˜¯çŠ¶æ€é—´çš„è½¬ç§»æ¦‚çŽ‡ã€‚ä¸€é˜¶é©¬å°”å¯å¤«é“¾å°±æ˜¯å‡è®¾tæ—¶åˆ»çš„çŠ¶æ€åªä¾èµ–äºŽå‰ä¸€æ—¶åˆ»çš„çŠ¶æ€ï¼Œä¸Žå…¶ä»–æ—¶åˆ»çš„çŠ¶æ€å’Œè§‚æµ‹æ— å…³ã€‚è¿™ä¸ªæ€§è´¨å¯ä»¥ç”¨äºŽç®€åŒ–æ¦‚çŽ‡é“¾çš„è®¡ç®—ã€‚ä½¿ç”¨ç±»ä¼¼æ€§è´¨ä½œä¸ºå‡è®¾çš„æ¨¡åž‹è¿˜æœ‰Bi-gramè¯­è¨€æ¨¡åž‹ç­‰. æœ´ç´ è´å¶æ–¯åˆ†ç±»å™¨ä¸Žéšé©¬å°”å¯å¤«æ¨¡åž‹æœ´ç´ è´å¶æ–¯åˆ†ç±»å™¨(NBs)å‡è®¾æ¡ä»¶ç‹¬ç«‹æ€§(æœ´ç´ è´å¶æ–¯å‡è®¾, Hand and Yu, 2001)ï¼š$p(x_i | y, x_j) = p(x_i | y)$, åœ¨ç»™å®šç›®æ ‡å€¼ y æ—¶ï¼Œxçš„å±žæ€§å€¼ä¹‹é—´ç›¸äº’æ¡ä»¶ç‹¬ç«‹ã€‚è¿™æ ·, è®¡ç®—å¯ä»¥ç®€åŒ–ä¸º $$p(y | \overrightarrow{x}) \propto p(y, \overrightarrow{x}) = p(y) \prod_{i=1} p(x_i | y).$$ æœ´ç´ è´å¶æ–¯æ¨¡åž‹åªè€ƒè™‘äº†å•ä¸ªè¾“å‡ºå˜é‡yã€‚å¦‚æžœè¦ä¸ºä¸€ä¸ªè§‚å¯Ÿåºåˆ—$\overrightarrow{x} =(x_1, â€¦, x_n)$é¢„æµ‹å¯¹åº”çš„åˆ†ç±»åºåˆ—$\overrightarrow{y} =ï¼ˆy_1, â€¦, y_n)$ ï¼Œä¸€ä¸ªç®€å•çš„åºåˆ—æ¨¡åž‹å¯ä»¥è¡¨ç¤ºä¸ºå¤šä¸ªNBsçš„ä¹˜ç§¯ã€‚æ­¤æ—¶ä¸è€ƒè™‘åºåˆ—å•ä¸ªä½ç½®ä¹‹é—´çš„ç›¸äº’ä¾èµ–ã€‚$$p(\overrightarrow{y}, \overrightarrow{x}) = \prod^n_{i=1} p(y_i) p(x_i | y_i).$$æ­¤æ—¶æ¯ä¸ªè§‚å¯Ÿå€¼$x_i$ä»…å–å†³äºŽå¯¹åº”åºåˆ—ä½ç½®çš„ç±»å˜é‡$y_i$ã€‚ç”±äºŽè¿™ç§ç‹¬ç«‹æ€§å‡è®¾ï¼Œä»Žä¸€ä¸ªæ­¥éª¤åˆ°å¦ä¸€ä¸ªæ­¥éª¤çš„è½¬æ¢æ¦‚çŽ‡ä¸åŒ…æ‹¬åœ¨è¯¥æ¨¡åž‹ä¸­ã€‚ç„¶è€Œè¿™ç§å‡è®¾åœ¨å®žè·µä¸­å‡ ä¹Žä¸ä¼šç¬¦åˆï¼Œè¿™å¯¼è‡´è¿™ç§æ¨¡åž‹çš„æ€§èƒ½å¾ˆæœ‰é™ã€‚ å› æ­¤ï¼Œæ¯”è¾ƒåˆç†çš„å‡è®¾æ˜¯è§‚æµ‹åºåˆ—åœ¨è¿žç»­ç›¸é‚»ä½ç½®é—´çš„è§‚æµ‹å€¼å­˜åœ¨ä¾èµ–ã€‚è¦æ¨¡æ‹Ÿè¿™ç§ä¾èµ–å…³ç³», å°±è¦å¼•å…¥çŠ¶æ€è½¬ç§»æ¦‚çŽ‡$p(y_i | y_{i-1})$, ç”±æ­¤å¼•å‡ºè‘—åçš„éšé©¬å°”å¯å¤«æ¨¡åž‹ Hidden Markov model, HMM, Rabiner (1989):$$p(\overrightarrow{y}, \overrightarrow{x}) = \prod^n_{i=1} p(y_i | y_{i-1}) p(x_i | y_i).$$ $$p(\overrightarrow{x}) = \sum_{y\in \mathcal{Y}} \prod^n_{i=1} p(y_i | y_{i-1}) p(x_i | y_i).$$ HMMå‚æ•°$Î» = (Y, X, Ï€, A, B)$ ï¼Œå…¶ä¸­Yæ˜¯éšçŠ¶æ€ï¼ˆè¾“å‡ºå˜é‡ï¼‰çš„é›†åˆï¼ŒXæ˜¯è§‚å¯Ÿå€¼ï¼ˆè¾“å…¥ï¼‰é›†åˆï¼ŒÏ€æ˜¯åˆå§‹çŠ¶æ€çš„æ¦‚çŽ‡ï¼ŒAæ˜¯çŠ¶æ€è½¬ç§»æ¦‚çŽ‡çŸ©é˜µ$p(y_i | y_{i-1})$ï¼ŒBæ˜¯è¾“å‡ºè§‚å¯Ÿå€¼æ¦‚çŽ‡çŸ©é˜µ$p(x_i | y_{i})$ã€‚åœ¨POSä»»åŠ¡ä¸­, Xå°±æ˜¯è§‚å¯Ÿåˆ°çš„å¥å­, Yå°±æ˜¯å¾…æŽ¨å¯¼çš„æ ‡æ³¨åºåˆ—, å› ä¸ºè¯æ€§å¾…æ±‚çš„, æ‰€ä»¥äººä»¬ç§°ä¹‹ä¸ºéšå«çŠ¶æ€. HMMçš„ç¼ºé™·æ˜¯å…¶åŸºäºŽè§‚å¯Ÿåºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ç›¸äº’æ¡ä»¶ç‹¬ç«‹çš„å‡è®¾ã€‚å³åœ¨ä»»ä½•æ—¶åˆ»è§‚å¯Ÿå€¼ä»…ä»…ä¸ŽçŠ¶æ€ï¼ˆå³è¦æ ‡æ³¨çš„æ ‡ç­¾ï¼‰æœ‰å…³ã€‚å¯¹äºŽç®€å•çš„æ•°æ®é›†ï¼Œè¿™ä¸ªå‡è®¾å€’æ˜¯åˆç†ã€‚ä½†å¤§å¤šæ•°çŽ°å®žä¸–ç•Œä¸­çš„çœŸå®žè§‚å¯Ÿåºåˆ—æ˜¯ç”±å¤šä¸ªç›¸äº’ä½œç”¨çš„ç‰¹å¾å’Œè§‚å¯Ÿåºåˆ—ä¸­è¾ƒé•¿èŒƒå›´å†…çš„å…ƒç´ ä¹‹é—´çš„ä¾èµ–è€Œå½¢æˆçš„ã€‚è€Œæ¡ä»¶éšæœºåœº(conditional random fiel, CRF)æ°æ°å°±å¼¥è¡¥äº†è¿™ä¸ªç¼ºé™·. æ¡ä»¶éšæœºåœºéšæœºåœº, å¯ä»¥çœ‹æˆæ˜¯ä¸€ç»„éšæœºå˜é‡çš„é›†åˆï¼ˆè¿™ç»„éšæœºå˜é‡å¯¹åº”åŒä¸€ä¸ªæ ·æœ¬ç©ºé—´ï¼‰ã€‚å½“ç»™æ¯ä¸€ä¸ªä½ç½®æŒ‰ç…§æŸç§åˆ†å¸ƒéšæœºèµ‹äºˆä¸€ä¸ªå€¼ä¹‹åŽï¼Œå…¶å…¨ä½“å°±å«åšéšæœºåœºã€‚è¿™äº›éšæœºå˜é‡ä¹‹é—´å¯èƒ½æœ‰ä¾èµ–å…³ç³»ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œä¹Ÿåªæœ‰å½“è¿™äº›å˜é‡ä¹‹é—´æœ‰ä¾èµ–å…³ç³»çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°†å…¶å•ç‹¬æ‹¿å‡ºæ¥çœ‹æˆä¸€ä¸ªéšæœºåœºæ‰æœ‰å®žé™…æ„ä¹‰ã€‚ å¦‚æžœç»™å®šçš„MRFä¸­æ¯ä¸ªéšæœºå˜é‡ä¸‹é¢è¿˜æœ‰è§‚å¯Ÿå€¼ï¼Œæˆ‘ä»¬è¦ç¡®å®šçš„æ˜¯ç»™å®šè§‚å¯Ÿé›†åˆä¸‹ï¼Œè¿™ä¸ªMRFçš„åˆ†å¸ƒï¼Œä¹Ÿå°±æ˜¯æ¡ä»¶åˆ†å¸ƒï¼Œé‚£ä¹ˆè¿™ä¸ªMRFå°±ç§°ä¸º conditional random fields (CRF)ã€‚å®ƒçš„æ¡ä»¶åˆ†å¸ƒå½¢å¼å®Œå…¨ç±»ä¼¼äºŽMRFçš„åˆ†å¸ƒå½¢å¼ï¼Œåªä¸è¿‡å¤šäº†ä¸€ä¸ªè§‚å¯Ÿé›†åˆXã€‚æ‰€ä»¥, CRFæœ¬è´¨ä¸Šæ˜¯ç»™å®šäº†æ¡ä»¶(è§‚å¯Ÿå€¼observations)é›†åˆçš„MRF 1.ç‰¹å¾å‡½æ•°çš„é€‰æ‹©: ç‰¹å¾å‡½æ•°çš„é€‰å–ç›´æŽ¥å…³ç³»æ¨¡åž‹çš„æ€§èƒ½ã€‚2.å‚æ•°ä¼°è®¡: ä»Žå·²ç»æ ‡æ³¨å¥½çš„è®­ç»ƒæ•°æ®é›†å­¦ä¹ æ¡ä»¶éšæœºåœºæ¨¡åž‹çš„å‚æ•°ï¼Œå³å„ç‰¹å¾å‡½æ•°çš„æƒé‡å‘é‡Î»ã€‚3.æ¨¡åž‹æŽ¨æ–­: åœ¨ç»™å®šæ¡ä»¶éšæœºåœºæ¨¡åž‹å‚æ•°Î»ä¸‹ï¼Œé¢„æµ‹å‡ºæœ€å¯èƒ½çš„çŠ¶æ€åºåˆ—ã€‚ CRFç‰¹å¾å‡½æ•°åœ¨CRFä¸­ï¼Œé¦–å…ˆéœ€è¦å®šä¹‰ç‰¹å¾å‡½æ•°. ç‰¹å¾å‡½æ•°çš„å®šä¹‰éžå¸¸çµæ´», å¯ä»¥æ˜¯ï¼š ä¸€ä¸ªå¥å­ s å¥å­ä¸­å•è¯çš„ä½ç½® i å½“å‰å•è¯çš„æ ‡ç­¾$l_i$ å‰ä¸€ä¸ªå•è¯çš„æ ‡ç­¾$l_{i-1}$ (å¦‚æžœä»…é™äºŽç›¸é‚»ä½ç½®çš„å•è¯, é‚£ä¹ˆå°±æ˜¯ linear-chain CRF). ä»»æ„å…¶ä»–å•è¯çš„æ ‡ç­¾$l_{j}$ ç„¶åŽä¸ºæ¯ä¸ªç‰¹å¾å‡½æ•°$f_{j}$åˆ†é…æƒé‡$\lambda_j$, æƒé‡æ˜¯ä»Žæ•°æ®ä¸­å­¦ä¹ è€Œæ¥. å¯¹$j$ä¸ªç‰¹å¾æ–¹ç¨‹æ±‚å’Œ, å¯¹åºåˆ—æ¯ä¸ªä½ç½®$i$æ±‚å’Œ:$$ score(l | s) = \sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})$$CRFçš„æ¯ä¸ªç‰¹å¾å‡½æ•°éƒ½æ˜¯ä¸€ä¸ªè¾“å…¥çš„å‡½æ•°, å¯¹åº”çš„è¾“å‡ºæ˜¯ä¸€ä¸ªå®žæ•°å€¼ï¼ˆåªæ˜¯0æˆ–1ï¼‰ã€‚ä¾‹å¦‚, é€‰æ‹©ç‰¹å¾å‡½æ•°$f_1(s, i, l_i, l_{i-1}) = 1$, å½“ä¸”ä»…å½“$l_i = ADVERB$, ä¸”ç¬¬iä¸ªå•è¯ä»¥â€œ-lyâ€ç»“å°¾; å¦åˆ™ä¸º0. å¦‚æžœä¸Žæ­¤ç‰¹å¾ç›¸å…³çš„æƒé‡$\lambda_j$å¾ˆå¤§ä¸”ä¸ºæ­£ï¼Œé‚£ä¹ˆè¿™ä¸ªç‰¹å¾ç­‰åŒäºŽè¯´æ¨¡åž‹å€¾å‘äºŽæŠŠä»¥-lyç»“å°¾çš„å•è¯æ ‡è®°ä¸ºADVERBã€‚ é€šè¿‡æŒ‡æ•°åŒ–å’Œå½’ä¸€åŒ–æŠŠè¿™äº›å¾—åˆ†è½¬æ¢ä¸ºæ¦‚çŽ‡å€¼:$$p(l | s) = \frac{exp[score(l|s)]}{\sum_{l^\prime} exp[score(l^\prime|s)]} = \frac{exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})]}{\sum_{lâ€™} exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l^\prime_i, l^\prime_{i-1})]} $$ CRFä¸ŽHMMåªéœ€è¦åœ¨CRFçš„å¯¹æ•°çº¿æ€§å½¢å¼ä¸­, è®¾ç½®æƒé‡ä¸ºå¯¹åº”HMMå–å¯¹æ•°åŽçš„äºŒå…ƒè½¬æ¢å’Œå‘å°„æ¦‚çŽ‡: $\log p(l,s) = \log p(l_0) + \sum_i \log p(l_i | l_{i-1}) + \sum_i \log p(w_i | l_i)$ å¯¹äºŽHMMçš„æ¯ä¸ªçŠ¶æ€è½¬æ¢æ¦‚çŽ‡$p(l_i = y | l_{i-1} = x)$, CRFå®šä¹‰ä¸€ç»„ç‰¹å¾å‡½æ•°ä¸º$f_{x,y}(s, i, l_i, l_{i-1}) = 1$ å¦‚æžœ $l_i = y$ ä¸” $l_{i-1} = x$, ä¸ºè¿™äº›ç‰¹å¾èµ‹äºˆæƒé‡$w_{x,y} = \log p(l_i = y | l_{i-1} = x)$ ç±»ä¼¼çš„, å¯¹äºŽHMMçš„æ¯ä¸ªå‘å°„æ¦‚çŽ‡$p(w_i = z | l_{i} = x)$, CRFå®šä¹‰ä¸€ç»„ç‰¹å¾å‡½æ•°ä¸º$g_{x,y}(s, i, l_i, l_{i-1}) = 1$ å¦‚æžœ $w_i = z$ ä¸” $l_i = x$, èµ‹äºˆæƒé‡$w_{x,z} = \log p(w_i = z | l_i = x)$. å¦‚æ­¤, CRFè®¡ç®—çš„åˆ†å€¼$p(l|s)$å°±ç²¾ç¡®åœ°æ­£æ¯”äºŽå¯¹åº”çš„HMM, ä¹Ÿå°±æ˜¯è¯´, ä»»æ„çš„HMMéƒ½å¯ä»¥ç”±CRFè¡¨è¾¾å‡ºæ¥. CRFæ¯”HMMæ›´å¼ºå¤§, æ›´å¹¿æ³› CRFå¯ä»¥å®šä¹‰æ›´å¹¿æ³›çš„ç‰¹å¾å‡½æ•°ï¼šHMMå—é™äºŽç›¸é‚»ä½ç½®çš„çŠ¶æ€è½¬æ¢ï¼ˆäºŒå…ƒè½¬æ¢ï¼‰å’Œå‘å°„æ¦‚çŽ‡å‡½æ•°ï¼Œè¿«ä½¿æ¯ä¸ªå•è¯ä»…ä¾èµ–äºŽå½“å‰æ ‡ç­¾ï¼Œå¹¶ä¸”æ¯ä¸ªæ ‡ç­¾ä»…ä¾èµ–äºŽå‰ä¸€ä¸ªæ ‡ç­¾ã€‚è€ŒCRFå¯ä»¥ä½¿ç”¨æ›´å¤šæ ·çš„å…¨å±€ç‰¹å¾ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœå¥å­çš„ç»“å°¾åŒ…å«é—®å·ï¼Œåˆ™å¯ä»¥ç»™ç»™CRFæ¨¡åž‹å¢žåŠ ä¸€ä¸ªç‰¹å¾å‡½æ•°ï¼Œè®°å½•æ­¤æ—¶å°†å¥å­çš„ç¬¬ä¸€ä¸ªå•è¯æ ‡è®°ä¸ºVERBçš„æ¦‚çŽ‡ã€‚è¿™ä½¿å¾—CRFå¯ä»¥ä½¿ç”¨é•¿è·ç¦»ä¾èµ–çš„ç‰¹å¾ã€‚ CRFå¯ä»¥æœ‰ä»»æ„çš„æƒé‡å€¼ï¼šHMMçš„æ¦‚çŽ‡å€¼å¿…é¡»æ»¡è¶³ç‰¹å®šçš„çº¦æŸï¼Œ $0 &lt;= p(w_i | l_i) &lt;= 1, \sum_w p(w_i = w | l_1) = 1)$, è€ŒCRFçš„æƒé‡å€¼æ˜¯ä¸å—é™åˆ¶çš„ã€‚ CRFæ—¢å…·æœ‰åˆ¤åˆ«å¼æ¨¡åž‹çš„ä¼˜ç‚¹ï¼Œåˆè€ƒè™‘åˆ°é•¿è·ç¦»ä¸Šä¸‹æ–‡æ ‡è®°é—´çš„è½¬ç§»æ¦‚çŽ‡ï¼Œä»¥åºåˆ—åŒ–å½¢å¼è¿›è¡Œå…¨å±€å‚æ•°ä¼˜åŒ–å’Œè§£ç çš„ç‰¹ç‚¹ï¼Œè§£å†³äº†å…¶ä»–åˆ¤åˆ«å¼æ¨¡åž‹(å¦‚MEMM)éš¾ä»¥é¿å…çš„æ ‡è®°åè§é—®é¢˜ã€‚ CRFä¸ŽLogistic RegressionCRFçš„æ¦‚çŽ‡è®¡ç®—ä¸ŽLogistic Regression (LR)çš„å½¢å¼ç±»ä¼¼ï¼Œ$$CRF: p(l | s) = \frac{exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l_i, l_{i-1})]}{\sum_{lâ€™} exp[\sum_{j = 1}^m \sum_{i = 1}^n \lambda_j f_j(s, i, l^\prime_i, l^\prime_{i-1})]} $$$$LR: P(y|x) = \frac{\exp \bigg( \sum\limits_{i=1}^{N} w_{i} \cdot f_{i}(x,y) \bigg)} {\sum\limits_{yâ€™ \in Y} \exp \bigg( \sum\limits_{i=1}^{N} w_{i} \cdot f_{i}(x,yâ€™) \bigg)}$$åœ¨LRä¸­, $f_i(y, x)$æ˜¯ä¸€ä¸ªç‰¹å¾ï¼Œ$w_i$æ˜¯ä¸Žè¯¥ç‰¹å¾ç›¸å…³çš„æƒé‡ã€‚æå–çš„ç‰¹å¾æ˜¯äºŒå…ƒç‰¹å¾ï¼Œå–å€¼0æˆ–1ï¼Œé€šå¸¸ç§°ä¸ºæŒ‡ç¤ºå‡½æ•°ã€‚è¿™äº›ç‰¹å¾ä¸­çš„æ¯ä¸€ä¸ªéƒ½ç”±ä¸Žè¾“å…¥$x$å’Œåˆ†ç±»$y$ç›¸å…³è”çš„å‡½æ•°è®¡ç®—ã€‚ å®žé™…ä¸Šï¼ŒCRFåŸºæœ¬ä¸Šå°±æ˜¯é€»è¾‘å›žå½’çš„åºåˆ—åŒ–ï¼šä¸Žé€»è¾‘å›žå½’æ˜¯ç”¨äºŽåˆ†ç±»çš„å¯¹æ•°çº¿æ€§æ¨¡åž‹ä¸åŒï¼ŒCRFæ˜¯æ ‡ç­¾åºåˆ—çš„å¯¹æ•°çº¿æ€§æ¨¡åž‹ã€‚ CRFæ¨¡åž‹è®­ç»ƒå¦‚ä½•é€šè¿‡æ•°æ®è®­ç»ƒCRFæ¨¡åž‹, ä¼°è®¡ç‰¹å¾å‡½æ•°çš„æƒé‡? åˆ©ç”¨æžå¤§ä¼¼ç„¶ä¼°è®¡ï¼ˆMaximum Likelihood Estimationï¼ŒMLE)å’Œæ¢¯åº¦ä¼˜åŒ–(gradient descent). $\log p(l | s)$ç›¸å¯¹äºŽå‚æ•°$Î»_i$çš„æ¢¯åº¦ä¸º:$$\frac{\partial}{\partial w_j} \log p(l | s) = \sum_{j = 1}^m f_i(s, j, l_j, l_{j-1}) - \sum_{lâ€™} p(lâ€™ | s) \sum_{j = 1}^m f_i(s, j, l^\prime_j, l^\prime_{j-1})$$å¯¼æ•°çš„ç¬¬ä¸€é¡¹æ˜¯çœŸå®žæ ‡ç­¾ä¸‹çš„ç‰¹å¾$f_i$çš„è´¡çŒ®ï¼Œç¬¬äºŒé¡¹æ˜¯å½“å‰æ¨¡åž‹ä¸‹ç‰¹å¾$f_i$çš„æœŸæœ›è´¡çŒ®ã€‚ å¯¹äºŽä¸€å †è®­ç»ƒæ ·ä¾‹ï¼ˆå¥å­å’Œç›¸å…³çš„è¯æ€§æ ‡ç­¾ï¼‰ã€‚éšæœºåˆå§‹åŒ–CRFæ¨¡åž‹çš„æƒé‡ã€‚è¦å°†è¿™äº›éšæœºåˆå§‹åŒ–çš„æƒé‡è½¬ç§»åˆ°æ­£ç¡®çš„æƒé‡ï¼Œå¯¹äºŽæ¯ä¸ªè®­ç»ƒç¤ºä¾‹: éåŽ†æ¯ä¸ªç‰¹å¾å‡½æ•°$f_i$ï¼Œè®¡ç®—è®­ç»ƒç¤ºä¾‹ç›¸å¯¹äºŽ$Î»_i$çš„å¯¹æ•°æ¦‚çŽ‡çš„æ¢¯åº¦ ä»¥learning rate $\alpha$çš„é€ŸçŽ‡æ²¿æ¢¯åº¦æ–¹å‘ä¸æ–­ä¿®æ­£$Î»_i$: $\lambda_i = \lambda_i + \alpha [\sum_{j = 1}^m f_i(s, j, l_j, l_{j-1}) - \sum_{lâ€™} p(lâ€™ | s) \sum_{j = 1}^m f_i(s, j, l^\prime_j, l^\prime_{j-1})]$ é‡å¤è¿™äº›è®­ç»ƒæ­¥éª¤ï¼Œç›´åˆ°æ»¡è¶³åœæ­¢æ¡ä»¶ï¼ˆä¾‹å¦‚ï¼Œæ›´æ–°ä½ŽäºŽæŸä¸ªé˜ˆå€¼ï¼‰ã€‚ CRFçš„ç¼ºç‚¹æ˜¯æ¨¡åž‹è®­ç»ƒæ—¶æ”¶æ•›é€Ÿåº¦æ¯”è¾ƒæ…¢. è®­ç»ƒåŽçš„CRFæ¨¡åž‹, å¯ä»¥ç”¨äºŽé¢„æµ‹ä¸€ä¸ªæœªæ ‡è®°åºåˆ—çš„æœ€å¤§å¯èƒ½æ ‡è®°. æˆ‘ä»¬éœ€è¦æ¯ä¸ªæ ‡è®°çš„æ¦‚çŽ‡$p(l | s)$, å¯¹äºŽå¤§å°ä¸ºkçš„æ ‡ç­¾é›†å’Œé•¿åº¦ä¸ºmçš„å¥å­, éœ€è¦æ¯”è¾ƒçš„$p(l | s)$ç»„åˆæœ‰$k^m$ç§. ä½†æ˜¯è®¡ç®—æ—¶, å¯ä»¥åˆ©ç”¨åŠ¨æ€è§„åˆ’çš„æ–¹æ³•, åŽŸç†ç±»ä¼¼äºŽViterbiç®—æ³•. CRFä¸­æ–‡å‘½åå®žä½“è¯†åˆ«æ¯”å¦‚ä¸­æ–‡å‘½åå®žä½“è¯†åˆ«ä»»åŠ¡, å‡å¦‚éœ€è¦åˆ¤æ–­äººåã€åœ°åã€ç»„ç»‡åä¸‰ç±»å‘½åå®žä½“. å¯¹äºŽäººå, é€šè¿‡ä¸€äº›æ¨¡æ¿æ¥ç­›é€‰ç‰¹å¾ã€‚æ¨¡æ¿æ˜¯å¯¹ä¸Šä¸‹æ–‡çš„ç‰¹å®šä½ç½®å’Œç‰¹å®šä¿¡æ¯çš„è€ƒè™‘, é€‚ç”¨äºŽäººåçš„ç‰¹å¾æ¨¡æ¿: äººåçš„æŒ‡ç•Œè¯ï¼šä¸»è¦åŒ…æ‹¬ç§°è°“è¯ã€åŠ¨è¯å’Œå‰¯è¯ç­‰ï¼Œå¥é¦–ä½ç½®å’Œæ ‡ç‚¹ç¬¦å·ä¹Ÿå¯ã€‚æ ¹æ®æŒ‡ç•Œè¯ä¸Žäººåå…±çŽ°çš„æ¦‚çŽ‡çš„å¤§å°ï¼Œå°†äººåçš„å·¦å³æŒ‡ç•Œè¯å„åˆ†ä¸ºä¸¤çº§ï¼Œç”Ÿæˆ4ä¸ªäººåæŒ‡ç•Œè¯åˆ—è¡¨ï¼š äººåè¯†åˆ«ç‰¹å¾çš„åŽŸå­æ¨¡æ¿ï¼Œæ¯ä¸ªæ¨¡æ¿éƒ½åªè€ƒè™‘äº†ä¸€ç§å› ç´ ï¼š å½“ç‰¹å¾å‡½æ•°å–ç‰¹å®šå€¼æ—¶ï¼Œç‰¹å¾æ¨¡æ¿è¢«å®žä¾‹åŒ–, å°±å¯ä»¥å¾—åˆ°å…·ä½“çš„ç‰¹å¾ã€‚æ¯”å¦‚å½“å‰è¯çš„å‰ä¸€ä¸ªè¯ $w_{i-1}$ åœ¨äººå1çº§å·¦æŒ‡ç•Œè¯åˆ—è¡¨ä¸­å‡ºçŽ°, $f_i(x, y) = 1, if: PBW1(w_{i-1}) = true, y = PERSON$ ç±»ä¼¼çš„ï¼Œåšåœ°åã€ç»„ç»‡åçš„ç‰¹å¾æå–å’Œé€‰æ‹©ï¼Œå¹¶å°†å…¶å®žä¾‹åŒ–ï¼Œå¾—åˆ°æ‰€æœ‰çš„ç‰¹å¾å‡½æ•°ã€‚ è¯„æµ‹æŒ‡æ ‡:å¬å›ž recall = $ \frac{æ­£ç¡®è¯†åˆ«çš„å‘½åå®žä½“é¦–éƒ¨ï¼ˆå°¾éƒ¨ï¼‰çš„ä¸ªæ•°}{æ ‡å‡†ç»“æžœä¸­å‘½åå®žä½“é¦–éƒ¨ï¼ˆå°¾éƒ¨ï¼‰çš„çš„æ€»æ•°} \times 100\%$ ç²¾ç¡®çŽ‡ precision = $ \frac{æ­£ç¡®è¯†åˆ«çš„å‘½åå®žä½“é¦–éƒ¨ï¼ˆå°¾éƒ¨ï¼‰çš„ä¸ªæ•°}{è¯†åˆ«å‡ºçš„å‘½åå®žä½“é¦–éƒ¨ï¼ˆå°¾éƒ¨ï¼‰çš„æ€»æ•°} \times 100\%$ F1 = $ \frac{2 \times precision \times recall}{precision + recall}$ ç”Ÿæˆå¼æ¨¡åž‹å’Œåˆ¤åˆ«å¼æ¨¡åž‹ä»Žæœ´ç´ è´å¶æ–¯, åˆ°HMM; ä»ŽLogistic Regressionåˆ°CRF, è¿™äº›æ¦‚çŽ‡å›¾æ¨¡åž‹æœ‰å¦‚ä¸‹è½¬æ¢å…³ç³»: è€Œåœ¨æœ´ç´ è´å¶æ–¯ä¸ŽLogistic Regression, ä»¥åŠHMMå’ŒCRFä¹‹é—´, åˆæœ‰ç”Ÿæˆå¼å’Œåˆ¤åˆ«å¼çš„åŒºåˆ«. ç”Ÿæˆå¼æ¨¡åž‹æè¿°æ ‡ç­¾å‘é‡yå¦‚ä½•æœ‰æ¦‚çŽ‡åœ°ç”Ÿæˆç‰¹å¾å‘é‡x, å³å°è¯•æž„å»ºxå’Œyçš„è”åˆåˆ†å¸ƒ$p(y, x)$, å…¸åž‹çš„æ¨¡åž‹æœ‰HMMï¼Œè´å¶æ–¯æ¨¡åž‹ï¼ŒMRFã€‚ç”Ÿæˆå¼æ¨¡åž‹ è€Œåˆ¤åˆ«æ¨¡åž‹ç›´æŽ¥æè¿°å¦‚ä½•æ ¹æ®ç‰¹å¾å‘é‡xåˆ¤æ–­å…¶æ ‡ç­¾y, å³å°è¯•æž„å»º$p(y | x)$çš„æ¡ä»¶æ¦‚çŽ‡åˆ†å¸ƒ, å…¸åž‹æ¨¡åž‹å¦‚å¦‚LR, SVMï¼ŒCRFï¼ŒMEMMç­‰. åŽŸåˆ™ä¸Šï¼Œä»»ä½•ç±»åž‹çš„æ¨¡åž‹éƒ½å¯ä»¥ä½¿ç”¨è´å¶æ–¯è§„åˆ™è½¬æ¢ä¸ºå¦ä¸€ç§ç±»åž‹ï¼Œä½†å®žé™…ä¸Šè¿™äº›æ–¹æ³•æ˜¯ä¸åŒçš„. ç”Ÿæˆæ¨¡åž‹å’Œåˆ¤åˆ«æ¨¡åž‹éƒ½æè¿°äº†$p(y, x)$çš„æ¦‚çŽ‡åˆ†å¸ƒï¼Œä½†åŠªåŠ›çš„æ–¹å‘ä¸åŒã€‚ç”Ÿæˆæ¨¡åž‹ï¼Œä¾‹å¦‚æœ´ç´ è´å¶æ–¯åˆ†ç±»å™¨å’ŒHMMï¼Œæ˜¯ä¸€ç±»å¯ä»¥å› å¼åˆ†è§£ä¸º$p(y, x) = p(y)p(x|y)$çš„è”åˆåˆ†å¸ƒ, ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬æè¿°äº†å¦‚ä½•ä¸ºç»™å®šæ ‡ç­¾çš„ç‰¹å¾é‡‡æ ·æˆ–â€œç”Ÿæˆâ€å€¼ã€‚ç”Ÿæˆå¼æ¨¡åž‹ä»Žç»Ÿè®¡çš„è§’åº¦è¡¨ç¤ºæ•°æ®çš„åˆ†å¸ƒæƒ…å†µï¼Œèƒ½å¤Ÿåæ˜ åŒç±»æ•°æ®æœ¬èº«çš„ç›¸ä¼¼åº¦ï¼Œä¸å…³å¿ƒåˆ¤åˆ«è¾¹ç•Œã€‚ç”Ÿæˆå¼æ¨¡åž‹çš„ä¼˜ç‚¹æ˜¯:â€¢ å®žé™…ä¸Šå¸¦çš„ä¿¡æ¯è¦æ¯”åˆ¤åˆ«æ¨¡åž‹ä¸°å¯Œï¼Œ ç ”ç©¶å•ç±»é—®é¢˜æ¯”åˆ¤åˆ«æ¨¡åž‹çµæ´»æ€§å¼ºâ€¢ èƒ½æ›´å……åˆ†çš„åˆ©ç”¨å…ˆéªŒçŸ¥è¯†â€¢ æ¨¡åž‹å¯ä»¥é€šè¿‡å¢žé‡å­¦ä¹ å¾—åˆ°ç¼ºç‚¹ä¹Ÿå¾ˆæ˜Žæ˜¾: â€¢ å­¦ä¹ è¿‡ç¨‹æ¯”è¾ƒå¤æ‚; â€¢ åœ¨ç›®æ ‡åˆ†ç±»é—®é¢˜ä¸­å‡†ç¡®åº¦ä¸é«˜ è€Œåˆ¤åˆ«å¼æ¨¡åž‹, æ¯”å¦‚ LR, æ˜¯ä¸€ç³»åˆ—æ¡ä»¶åˆ†å¸ƒ$p(y | x)$. ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ†ç±»è§„åˆ™æ˜¯ç›´æŽ¥å»ºæ¨¡çš„ã€‚åŽŸåˆ™ä¸Šï¼Œåˆ¤åˆ«æ¨¡åž‹ä¹Ÿå¯é€šè¿‡ä¸ºè¾“å…¥æä¾›è¾¹é™…åˆ†å¸ƒ$p(x)$æ¥èŽ·å¾—è”åˆåˆ†å¸ƒ$p(y, x)$ï¼Œä½†å¾ˆå°‘éœ€è¦è¿™æ ·ã€‚æ¡ä»¶åˆ†å¸ƒ$p(y | x)$ä¸åŒ…æ‹¬$p(x)$çš„ä¿¡æ¯ï¼Œåœ¨åˆ†ç±»ä»»åŠ¡ä¸­å…¶å®žæ— è®ºå¦‚ä½•ä¹Ÿç”¨ä¸åˆ°ã€‚å…¶æ¬¡ï¼Œå¯¹$p(x)$å»ºæ¨¡çš„å›°éš¾ä¹‹å¤„åœ¨äºŽå®ƒé€šå¸¸åŒ…å«å¾ˆå¤šå»ºæ¨¡éš¾åº¦è¾ƒé«˜çš„æœ‰é«˜åº¦ä¾èµ–æ€§çš„ç‰¹å¾ã€‚åˆ¤åˆ«å¼æ¨¡åž‹å¯»æ‰¾ä¸åŒç±»åˆ«ä¹‹é—´çš„æœ€ä¼˜åˆ†ç±»é¢ï¼Œåæ˜ çš„æ˜¯å¼‚ç±»æ•°æ®ä¹‹é—´çš„å·®å¼‚ã€‚ä¼˜ç‚¹æ˜¯:â€¢ åˆ†ç±»è¾¹ç•Œæ›´çµæ´»ï¼Œæ¯”ä½¿ç”¨çº¯æ¦‚çŽ‡æ–¹æ³•æˆ–ç”Ÿäº§æ¨¡åž‹å¾—åˆ°çš„æ›´é«˜çº§ã€‚â€¢ èƒ½æ¸…æ™°çš„åˆ†è¾¨å‡ºå¤šç±»æˆ–æŸä¸€ç±»ä¸Žå…¶ä»–ç±»ä¹‹é—´çš„å·®å¼‚ç‰¹å¾â€¢ åœ¨èšç±»ã€viewpoint changes, partial occlusion and scale variationsä¸­çš„æ•ˆæžœè¾ƒå¥½â€¢é€‚ç”¨äºŽè¾ƒå¤šç±»åˆ«çš„è¯†åˆ«ç¼ºç‚¹æ˜¯ï¼šâ€¢ ä¸èƒ½åæ˜ è®­ç»ƒæ•°æ®æœ¬èº«çš„ç‰¹æ€§ã€‚â€¢ èƒ½åŠ›æœ‰é™ï¼Œå¯ä»¥åˆ†ç±», ä½†æ— æ³•æŠŠæ•´ä¸ªåœºæ™¯æè¿°å‡ºæ¥ã€‚ å‚è€ƒèµ„æ–™http://blog.echen.me/2012/01/03/introduction-to-conditional-random-fields/Classical probabilistic models and conditional random fieldsAn Introduction to Conditional Random Fields, by Charles Sutton and Andrew McCallum]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¾ªçŽ¯ç¥žç»ç½‘ç»œ]]></title>
    <url>%2FNLP-recurrent-neural-networks%2F</url>
    <content type="text"><![CDATA[å¾ªçŽ¯ç¥žç»ç½‘ç»œå½“äººç±»é˜…è¯»æ—¶ï¼Œä¼šæ ¹æ®å¯¹ä¹‹å‰å•è¯çš„ç†è§£å’Œè®°å¿†æ¥è¾…åŠ©ç†è§£å½“å‰çœ‹åˆ°çš„æ¯ä¸ªå•è¯ã€‚ä¹Ÿå°±æ˜¯äººèƒ½å¤Ÿå¾ˆå¥½åœ°å¤„ç†è¯­è¨€çš„é•¿è·ç¦»ä¾èµ–ç‰¹æ€§ï¼ˆlong-term dependencyï¼‰ã€‚åœ¨è‡ªç„¶è¯­è¨€å¤„ç†ä»»åŠ¡ä¸­ï¼Œå¾ˆå¤šä¼ ç»Ÿçš„æ¨¡åž‹æ— æ³•åšåˆ°è¿™ä¸€ç‚¹ï¼Œæ¯”å¦‚å‰é¦ˆç¥žç»ç½‘ç»œï¼›è€Œä¼ ç»Ÿçš„n-gramæ¨¡åž‹å›ºç„¶å¯ä»¥é€šè¿‡æŠŠæŠŠnç³»æ•°å¢žå¤§æ¥æ•æ‰é•¿è·ç¦»ä¾èµ–ï¼Œä½†å¸¦æ¥çš„éžå¸¸å·¨å¤§çš„å†…å­˜æ¶ˆè€—ã€‚ å¾ªçŽ¯ç¥žç»ç½‘ç»œï¼ˆRecurrent Neural Networks, RNNs)å¯ä»¥çœ‹åšæ˜¯å¤šä¸ªå…±äº«å‚æ•°çš„å‰é¦ˆç¥žç»ç½‘ç»œä¸æ–­å åŠ çš„ç»“æžœ è¿™é‡Œçš„æ ¸å¿ƒæ˜¯æƒ³åŠžæ³•è§£ç åŽ†å²ä¿¡æ¯, å³é€šè¿‡é€’å½’æ–¹ç¨‹$s_i = R(x_i, s_{iâˆ’1})$è®©$s_i$è§£ç åºåˆ—$x_{1:n}$. æ¯”å¦‚æŠŠæ‰€æœ‰åŽ†å²ä¿¡æ¯ç´¯åŠ å°±æ˜¯ä¸€ç§éžå¸¸ç®€å•ç²—æš´çš„æ–¹å¼, è¿™æ ·å¾—åˆ°çš„æ˜¯è¿žç»­è¯è¢‹æ¨¡åž‹(continuous-bag-of-words model)$s_i = R_{CBOW}(x_i, s_{i-1}) = x_i + s_{iâˆ’1}$, è™½ç„¶ç®€å•ï¼Œä½†è¿™ç§RNNå…¶å®žå¿½ç•¥äº†æ•°æ®çš„æ—¶åºæ€§è´¨ã€‚ ä¸€èˆ¬æ„ä¹‰ä¸Šçš„RNNæ˜¯æŒ‡Elman Network or Simple-RNN (S-RNN)(Elman [1990]), $s_i = R_{SRNN}(x_i, s_{i-1}) = g(x_iW^x + s_{iâˆ’1}W^s + b)$, ä¹Ÿå°±æ˜¯æŠŠåŽ†å²ä¿¡æ¯å…ˆè¿›è¡Œçº¿æ€§å˜æ¢(ä¹˜ä»¥çŸ©é˜µ), å†å’ŒbiasåŠ èµ·æ¥, å†é€šè¿‡ä¸€ä¸ªéžçº¿æ€§æ¿€æ´»å‡½æ•°(tanhæˆ–ReLU). æ·»åŠ äº†çº¿æ€§å˜æ¢å†è¿›è¡Œéžçº¿æ€§æ¿€æ´», ä½¿ç½‘ç»œå¯¹è¾“å…¥çš„é¡ºåºå˜å¾—æ•æ„Ÿã€‚ åœ¨ä½¿ç”¨æ—¶, ç»™å®šè¾“å…¥åºåˆ—ï¼ˆå•è¯åºåˆ—æˆ–è¯­éŸ³ï¼‰å¾—å‡ºè¾“å‡ºåºåˆ—çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š æŠŠæ¯ä¸ªè¯$x_{t}$(ä»¥å‘é‡è¡¨ç¤º)é€ä¸ªè¾“å…¥RNN æ¯ä¸€æ—¶é—´æ­¥$t$éƒ½æœ‰å¯¹åº”çš„éšå«çŠ¶æ€$s_t$ï¼Œç”¨äºŽè§£ç åŽ†å²ä¿¡æ¯: $s_t = g(Ux_t + Ws_{t-1} + b)$. æ¯ä¸€æ—¶é—´æ­¥éƒ½å¯ä»¥æœ‰ä¸€ä¸ªè¾“å‡ºï¼ˆè™½ç„¶å¤§éƒ¨åˆ†åº”ç”¨åªç”¨åˆ°æœ€åŽä¸€æ—¶é—´æ­¥ï¼‰$o(t)$ï¼š ä¾‹å¦‚ï¼Œè¯­è¨€æ¨¡åž‹æƒ³è¦é¢„æµ‹ä¸‹ä¸€ä¸ªå•è¯ï¼Œé‚£ä¹ˆè¾“å‡ºå°±æ˜¯åœ¨è¯æ±‡è¡¨ä¸Šçš„æ¦‚çŽ‡åˆ†å¸ƒå‘é‡ï¼Œ$o_t = softmax(Vs_t)$. å…¶ä¸­ï¼Œå„ä¸ªæ—¶é—´æ­¥å…±äº«å‡ ä¸ªå‚æ•°çŸ©é˜µï¼ˆ$U, V, W$ï¼‰ In addition to the above normal many to many structure RNNs, there are other non-sequence input or output: Many to one, e.g. when predicting the sentiment of a sentence we may only care about the final output, not the sentiment after each word. One to many: Music generation. é™¤äº†åº”ç”¨äºŽè¯­è¨€æ¨¡åž‹, RNNs è¿˜å¯ä»¥åº”ç”¨äºŽÂ· tagging, e.g. part-of-speech tagging, named entity recognition (many to many RNNs)Â· sentence classification, e.g. sentiment classification (many to one RNNs)Â· generate text, e.g. speech recognition, machine translation, summarization RNNs BackpropagationBackpropagation Through Time (BPTT): Because the parameters are shared by all time steps in the network, the gradient at each output depends not only on the calculations of the current time step, but also the previous time steps. RNNs trained with BPTT have difficulties learning long-term dependencies (e.g. dependencies between steps that are far apart) due to what is called the vanishing/exploding gradient problem. æ¢¯åº¦æ¶ˆå¤±ä¸Žçˆ†ç‚¸The Vanishing/Exploding Gradient problemã€‚ RNNs shares the same matrix (w, u, etc.) at each time step during forward prop and backprop. æ±‚å¯¼æ•°æ—¶, æ ¹æ®é“¾å¼æ³•åˆ™, losså¯¹å„å‚æ•°çš„å¯¼æ•°ä¼šè½¬æ¢ä¸ºlosså¯¹è¾“å‡ºyçš„å¯¼æ•°, ä¹˜ä»¥yå¯¹éšå«å±‚çš„å¯¼æ•°, ä¹˜ä»¥éšå«å±‚ç›¸å¯¹éšå«å±‚ä¹‹é—´çš„å¯¼æ•°, å†ä¹˜ä»¥éšå«å±‚å¯¹å‚æ•°çš„å¯¼æ•°. ä¸åŒéšå«å±‚ï¼ˆä¸¾ä¾‹å¦‚$h_t$å’Œ$h_k$ï¼‰ä¹‹é—´å¦‚æžœç›¸éš”å¤ªè¿œ, $h_t$å¯¹$h_k$çš„å¯¼æ•°å°±å˜æˆå¤šä¸ªjacobiançŸ©é˜µçš„ç›¸ä¹˜ï¼Œ å¯¹å„ä¸ªjacobianèŒƒæ•°ï¼ˆnormsï¼‰è¿›è¡Œåˆ†æžåŽï¼Œå‘çŽ°$h_t$å¯¹$h_k$çš„å¯¼æ•°å€¼åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ä¼šå¾ˆå¿«å˜å¾—å¾ˆæžç«¯ï¼ˆéžå¸¸å°æˆ–è€…éžå¸¸å¤§ï¼‰ã€‚ Gradientä½œä¸ºä¼ å¯¼è¯¯å·®ä»¥å¸®åŠ©ç³»ç»Ÿçº æ­£å‚æ•°çš„å…³é”®è§’è‰²ï¼Œå¦‚æžœæœ¬èº«å˜å¾—æŽ¥è¿‘äºŽ0æˆ–è€…nanï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ— æ³•åˆ¤æ–­tå’Œt+nçš„æ•°æ®çš„ä¾èµ–æ€§ï¼ˆæ˜¯æ²¡æœ‰ä¾èµ–ï¼Ÿè¿˜æ˜¯å› ä¸ºvanish of gradientï¼Ÿè¿˜æ˜¯å› ä¸ºå‚æ•°è®¾ç½®é”™è¯¯ï¼Ÿï¼‰ã€‚æ¢¯åº¦è¡°å‡ä¼šç›´æŽ¥é™ä½Žæ¨¡åž‹å­¦ä¹ é•¿è·ç¦»ä¾èµ–å…³ç³»çš„èƒ½åŠ›ï¼Œç»™å®šä¸€ä¸ªæ—¶é—´åºåˆ—ï¼Œä¾‹å¦‚æ–‡æœ¬åºåˆ—ï¼Œå¾ªçŽ¯ç¥žç»ç½‘ç»œè¾ƒéš¾æ•æ‰ä¸¤ä¸ªæ—¶åˆ»è·ç¦»è¾ƒå¤§çš„æ–‡æœ¬å…ƒç´ ï¼ˆå­—æˆ–è¯ï¼‰ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚ åœ¨ä½¿ç”¨RNNå­¦ä¹ language modelçš„æ—¶å€™ï¼Œéžå¸¸å®¹æ˜“å‡ºçŽ°æ¢¯åº¦çˆ†ç‚¸ï¼Œè§£å†³åŠžæ³•æ˜¯ä½¿ç”¨ gradient clipping æ¢¯åº¦è£å‰ªï¼Œå°±æ˜¯é€šè¿‡æŠŠæ¢¯åº¦æ˜ å°„åˆ°å¦ä¸€ä¸ªå¤§å°çš„ç©ºé—´ï¼Œä»¥é™åˆ¶æ¢¯åº¦èŒƒæ•°çš„æœ€å¤§å€¼On the difficulty of training Recurrent Neural Networksã€‚ è™½ç„¶æ¢¯åº¦è£å‰ªå¯ä»¥åº”å¯¹æ¢¯åº¦çˆ†ç‚¸ï¼Œä½†æ— æ³•è§£å†³æ¢¯åº¦è¡°å‡çš„é—®é¢˜ã€‚ä¸€ä¸ªç¼“è§£æ¢¯åº¦è¡°å‡çš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨æ›´å¥½çš„å‚æ•°åˆå§‹åŒ–æ–¹æ¡ˆå’Œæ¿€æ´»å‡½æ•°ï¼ˆReLUsï¼‰A Simple Way to Initialize Recurrent Networks of Rectified Linear Units. ä¸è¿‡æ›´ä¸»æµçš„è§£å†³æ¢¯åº¦è¡°å‡çš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨æ›´å¤æ‚çš„rnnéšå«å•å…ƒ: Gated Recurrent Units (GRU) introduced by Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation and LSTMs. é—¨æŽ§å¾ªçŽ¯ç½‘ç»œå› ä¸ºæ¢¯åº¦æ¶ˆå¤±çš„é—®é¢˜ï¼ŒRNNçš„è§£ç èƒ½åŠ›æ˜¯å¾ˆæœ‰é™çš„ã€‚S-RNNæž¶æž„çš„ä¸€ä¸ªæ˜Žæ˜¾ç¼ºé™·æ˜¯å¯¹åŽ†å²ä¿¡æ¯çš„è®°å¿†æ˜¯ä¸å—æŽ§åˆ¶ï¼Œåœ¨æ¯ä¸€æ—¶é—´æ­¥çš„è®¡ç®—ï¼Œè¯»å†™æ•´ä¸ªè®°å¿†çŠ¶æ€$s_t$ã€‚è€Œé—¨æŽ§å¾ªçŽ¯ç½‘ç»œï¼Œæ¯”å¦‚Long Short-Term Memoryï¼ˆLSTMsï¼‰ï¼ŒGated Recurring Unitï¼ˆGRUsï¼‰ï¼Œä½¿ç”¨é—¨çš„æ¦‚å¿µï¼Œè®©ç½‘ç»œæ‹¥æœ‰æŽ§åˆ¶å“ªäº›ä¿¡æ¯éœ€è¦è®°å½•, å“ªäº›éœ€è¦ä¸¢å¼ƒçš„èƒ½åŠ›ã€‚å¦‚ä½•å®žçŽ°è¿™ç§é—¨å‘¢? è€ƒè™‘ä¸€ç§ä»‹äºŽ[0, 1]ä¸­é—´çš„å› å­, è®©è¿™ç§å› å­ä¸Žå„ç§çŠ¶æ€ä¿¡æ¯ç›¸ä¹˜, å¯ä»¥ä¸ºæ¯ä¸ªçŠ¶æ€ä¿¡æ¯ç‹¬è‡ªè®­ç»ƒä¸€ä¸ªå› å­, ä¹Ÿå°±æ˜¯ç”±ç®€å•çš„ç¥žç»ç½‘ç»œ(éžçº¿æ€§æ¿€æ´»å‡½æ•°Sigmoid)æ¥æŽ§åˆ¶. æ˜¯å¦å…è®¸ä¿¡æ¯é€šè¿‡ï¼ˆæ‰“å¼€ï¼‰æˆ–ä¸é€šè¿‡ï¼ˆå…³é—­ï¼‰å–å†³äºŽå…¶é—¨æŽ§å•å…ƒå†…éƒ¨Sigmoidæ¿€æ´»å±‚çš„ç‚¹ä¹˜è¿ç®—ã€‚Sigmoidå‡½æ•°å€¼ä»‹äºŽ0å’Œ1ä¹‹é—´ï¼Œå¯ç”¨äºŽæè¿°å…è®¸é€šè¿‡å•å…ƒæ ¼çš„ä¿¡æ¯é‡ã€‚ LSTMæž¶æž„å°†çŠ¶æ€å‘é‡$s_i$åˆ†æˆä¸¤åŠï¼Œå…¶ä¸­ä¸€åŠè¢«è§†ä¸ºâ€œè®°å¿†å•å…ƒâ€$C$, è€Œå¦ä¸€åŠè¢«è§†ä¸ºä¸€èˆ¬çš„å·¥ä½œå­˜å‚¨å•å…ƒ-éšå«çŠ¶æ€$h$ã€‚ 1, LSTMç”¨é—å¿˜é—¨æ¥å†³å®šä»Žå‰ä¸€æ—¶é—´æ­¥çš„è®°å¿†å•å…ƒä¸­ä¸¢å¼ƒå“ªäº›ä¿¡æ¯ï¼ŒæŽ§åˆ¶å½“å‰è®°å¿†å•å…ƒåº”è¯¥å¿˜è®°å¤šå°‘æ¥è‡ªå‰ä¸€æ­¥çŠ¶æ€$h_{t-1}$çš„ä¿¡æ¯é‡ï¼Œæ ‡è®°ä¸ºé—å¿˜ä¿¡æ¯ã€‚é—å¿˜é—¨ç”±ä¸€ä¸ªsigmoidå±‚å­¦ä¹ è€Œæ¥ 2, ç”¨è¾“å…¥é—¨ Input gate (a sigmoid hidden layer) æ¥å†³å®šæœ‰å¤šå°‘æ–°ä¿¡æ¯æ˜¯å€¼å¾—å‚¨å­˜çš„ï¼ˆå½“å‰æ—¶é—´æ­¥$t$ï¼‰ã€‚è¾“å…¥é—¨æŽ§åˆ¶å“ªäº›ä¿¡æ¯éœ€è¦æ›´æ–°. å†é€šè¿‡ä¸€ä¸ªéšå«å±‚(tanh/relu)ç”Ÿæˆæ–°çš„å€™é€‰ä¿¡æ¯å‘é‡$\widetilde{C}_t$. è¾“å…¥é—¨å’Œé—å¿˜é—¨ä¸€èµ·ï¼ŒæŽ§åˆ¶æ¯ä¸€æ­¥çš„ä¿¡æ¯å­˜å‚¨å’Œæ”¹å†™, å°†é—å¿˜ä¿¡æ¯å’Œå€™é€‰ä¿¡æ¯ç»„åˆåœ¨ä¸€èµ·ä½œä¸ºæ›´æ–°ä¿¡æ¯ï¼Œä½œä¸ºå½“å‰æ—¶é—´æ­¥çš„æ–°è®°å¿†å•å…ƒï¼Œ$C_{t}$. 3, æœ€åŽï¼Œç”¨ä¸€ä¸ªè¾“å‡ºé—¨ Output gate (a sigmoid layer) æ¥æŽ§åˆ¶å¤šå°‘è®°å¿†å•å…ƒä½œä¸ºå½“å‰æ­¥çš„å·¥ä½œéšå«çŠ¶æ€$h_t$ã€‚å…ˆé€šè¿‡ä¸€ä¸ªtanhæ¿€æ´»å±‚æŠŠå½“å‰è®°å¿†å•å…ƒ$C_t$æŽ¨é€ä¸º[-1, 1]ä¹‹é—´çš„å€¼, å†ä¹˜ä»¥è¾“å‡ºé—¨. æ€»çš„æ¥è¯´, LSTMæœ‰é—å¿˜é—¨, è¾“å…¥é—¨å’Œè¾“å‡ºé—¨è¿™ä¸‰ä¸ªé—¨. åŠ ä¸Šå…¶ä¸­çš„æ›´æ–°ä¿¡æ¯, å½¢å¼ä¸ŠLSTMæœ‰å››ä¸ªç¥žç»ç½‘ç»œ, è¾“å…¥éƒ½æ˜¯ä¸Šä¸€æ­¥éšå«çŠ¶æ€å’Œå½“å‰æ­¥çš„è¾“å…¥å‘é‡çš„. GRUsLSTMsæœ‰ä¸¤ç§éšå«çŠ¶æ€, ä½†GRUs (Cho, et al. (2014))æŠ›å¼ƒäº†è¿™ç§è®¾è®¡, åªç”¨ä¸€ç§éšå«çŠ¶æ€$h$. è¿™å¯¼è‡´äº†ä¸€ç³»åˆ—çš„å˜åŒ–. GRUsé¦–å…ˆæ ¹æ®å½“å‰çš„è¾“å…¥è¯å‘é‡å’Œéšå«çŠ¶æ€è®¡ç®—æ›´æ–°é—¨$z_t$å’Œä¸€ä¸ªé‡ç½®é—¨$r_t$ã€‚é‡ç½®é—¨ç”¨äºŽååŠ©è®¡ç®—éšå«å±‚çš„æ›´æ–°ä¿¡æ¯$\widetilde{h}_t$. è¾“å‡ºçš„éšå«çŠ¶æ€$h_t$æ˜¯ç”±æ›´æ–°é—¨$z_t$æ¥æŽ§åˆ¶. LSTMsçš„é—å¿˜é—¨å’Œè¾“å…¥é—¨çš„åˆä½œæ ¸å¿ƒæ˜¯æ›´æ–°ä¿¡æ¯. è€ŒGRUså°†LSTMsçš„é—å¿˜é—¨å’Œè¾“å…¥é—¨åˆå¹¶æˆä¸€ä¸ªæ›´æ–°é—¨, æŠ›å¼ƒäº†è¾“å‡ºé—¨çš„æ¦‚å¿µ, è®©æ›´æ–°é—¨è´Ÿè´£è®¡ç®—æ–°çš„éšå«çŠ¶æ€. è¿™æ ·GRUså†…éƒ¨æ€»å…±åªæœ‰ä¸¤ä¸ªé—¨, ä¸‰ä¸ªç¥žç»ç½‘ç»œ, æŸç§ç¨‹åº¦ä¸Šç®€åŒ–äº†LSTMsæ¨¡åž‹ã€‚ GRU intuition é‡ç½®é—¨èµ‹äºˆäº†æ¨¡åž‹ä¸¢å¼ƒä¸Žæœªæ¥æ— å…³çš„ä¿¡æ¯çš„èƒ½åŠ›ã€‚è‹¥é‡ç½®é—¨æŽ¥è¿‘äºŽ0ï¼Œåˆ™å¿½ç•¥ä¹‹å‰çš„è®°å¿†ï¼Œä»…å‚¨å­˜æ–°åŠ å…¥çš„ä¿¡æ¯. æ›´æ–°é—¨æŽ§åˆ¶è¿‡åŽ»çš„çŠ¶æ€å¯¹çŽ°åœ¨çš„å½±å“ç¨‹åº¦ï¼ˆå³å†³å®šæ›´æ–°å¤šå°‘ï¼‰ï¼Œå¦‚æžœæŽ¥è¿‘äºŽ1ï¼Œåˆ™ $h_t=z_t\cdot h_{t-1}$, ç­‰åŒäºŽæŠŠè¿‡åŽ»çš„ä¿¡æ¯å®Œæ•´å¤åˆ¶åˆ°æœªæ¥ï¼Œç›¸åº”åœ°ç¼“è§£æ¢¯åº¦è¡°å‡ã€‚ çŸ­è·ç¦»ä¾èµ–çš„å•å…ƒï¼Œè¿‡åŽ»çš„ä¿¡æ¯ä»…ä¿ç•™å¾ˆçŸ­çš„æ—¶é—´ï¼Œé‡ç½®é—¨ä¸€èˆ¬å¾ˆæ´»è·ƒï¼Œä¹Ÿå°±æ˜¯æ•°å€¼åœ¨0å’Œ1ä¹‹é—´é¢‘ç¹å˜åŠ¨ã€‚ é•¿è·ç¦»ä¾èµ–çš„å•å…ƒï¼Œé‡ç½®é—¨è¾ƒç¨³å®šï¼ˆä¿ç•™è¿‡åŽ»çš„è®°å¿†è¾ƒé•¿æ—¶é—´ï¼‰ï¼Œè€Œæ›´æ–°é—¨è¾ƒæ´»è·ƒã€‚ ä¸åŒRNNså˜ç§çš„æ¯”è¾ƒVanilla RNNs Execution: Read the whole register h Update the whole register GRU Execution: Select a readable subset Read the subset Select a writable subset Update the subset é—¨æŽ§å¾ªçŽ¯ç¥žç»ç½‘ç»œçš„è®­ç»ƒ æŠŠå‚æ•°çŸ©é˜µåˆå§‹åŒ–ä¸ºæ­£äº¤ æŠŠé—å¿˜é—¨çš„biasåˆå§‹åŒ–ä¸º1ï¼Œé»˜è®¤ä¸é—å¿˜ åˆ«å¿˜äº†æ¢¯åº¦è£å‰ª æ³¨æ„dropoutåœ¨RNNsä¸­çš„åº”ç”¨ä¸åŒäºŽDNNå’ŒCNN Bidirectional RNNsBidirectional RNNs are based on the idea that the output at time t may not only depend on the previous elements in the sequence, but also future elements. They are just two RNNs stacked on top of each other. The output is then computed based on the hidden state of both RNNs. å‚è€ƒèµ„æ–™æ–¯å¦ç¦cs224n http://web.stanford.edu/class/cs224n http://colah.github.io Neural Network Methods in Natural Language Processing, by Yoav Goldberg]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è¯­è¨€æ¨¡åž‹]]></title>
    <url>%2FNLP-language-model%2F</url>
    <content type="text"><![CDATA[è¯­è¨€æ¨¡åž‹è¯­è¨€æ¨¡åž‹Language modelingï¼ˆLMï¼‰æœ€åˆæ˜¯é’ˆå¯¹è¯­éŸ³è¯†åˆ«é—®é¢˜è€Œå¼€å‘çš„, çŽ°åœ¨å¹¿æ³›ç”¨äºŽå…¶ä»–NLPåº”ç”¨ä¸­, æ¯”å¦‚æœºå™¨ç¿»è¯‘éœ€è¦åˆ©ç”¨LMæ¥ç»™ç¿»è¯‘å‡ºçš„å¥å­æ‰“åˆ†.å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªè¯­æ–™åº“ - æŸç§è¯­è¨€çš„å¥å­çš„æ— é™é›†åˆ$\mathcal{V^+}$ï¼ˆè¿™äº›å¥å­æ˜¯ç”±æœ‰é™çš„è¯$\mathcal{V}$ç»„æˆçš„ï¼‰ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½ä»Žç½‘ä¸ŠèŽ·å¾—å¤§é‡æ–‡æœ¬ã€‚ç»™å®šäº†æ­¤è¯­æ–™åº“ï¼Œæˆ‘ä»¬æƒ³ä¼°è®¡LMçš„å‚æ•°ã€‚è¿™äº›å‚æ•°åŒ…å«è¯­æ–™åº“ä¸­æ‰€æœ‰å•è¯çš„æœ‰é™é›†åˆ$\mathcal{V}$, ä»¥åŠå¥å­çš„æ¦‚çŽ‡åˆ†å¸ƒå‡½æ•°$p(x_1, x_2, â€¦, x_n)$ï¼Œå¿…é¡»æ»¡è¶³ For any $\langle x_1â€¦x_n \rangle \in \mathcal{V^+}$, $p(x_1, x_2, â€¦, x_n) â‰¥ 0$ $\sum_{\langle x_1â€¦x_n \rangle \in \mathcal{V^+}}p(x_1, x_2, â€¦, x_n) = 1$ æ¯”å¦‚ï¼Œå½“$\mathcal{V}$åªæœ‰cat, eat, fish, é‚£ä¹ˆå®ƒç»„åˆæˆçš„å¥å­æŒ‰ç…§äººç±»çš„è¯„ä»·æ ‡å‡†, é€šé¡ºç¨‹åº¦ä»Žé«˜åˆ°ä½Žæ˜¯: cat eat fish, fish eat cat, cat fish eat, eat cat fish, eat fish cat, fish cat eat. è¿™äº›æ˜¯å¯èƒ½å‡ºçŽ°çš„å¥å­(è¿˜æ²¡å‡ºçŽ°çš„ä¸ä»£è¡¨æœªæ¥ä¸ä¼šå‡ºçŽ°), ä»Žæ¦‚çŽ‡åˆ†å¸ƒçš„è§’åº¦çœ‹å¾…, è¿™äº›å¥å­çš„æ¦‚çŽ‡ä¹‹å’Œæ˜¯1, å› ä¸ºè¿™ä¸‰ä¸ªè¯åªèƒ½ç»„æˆè¿™å‡ ä¸ªå¥å­. è€ŒLMçš„æ„ä¹‰å°±åœ¨äºŽèƒ½å¤Ÿèµ‹äºˆcat eat fishæœ€å¤§çš„æ¦‚çŽ‡, ä»£æ›¿äººæ¥åˆ¤æ–­å¥å­æ˜¯å¦å‡†ç¡®, é€šä¿—çš„è¯´æ˜¯ä¸€ä¸ªå¥å­é€šé¡ºæ‰“åˆ†æœºå™¨. å¹¿ä¹‰çš„è¯­è¨€æ¨¡åž‹, å¯ä»¥è®¡ç®—ä»»ä½•è¿žç»­çš„å•è¯æˆ–è€…ä»»ä½•å…¶ä»–åºåˆ—æ•°æ®ï¼ˆæ¯”å¦‚è¯­éŸ³ï¼‰å‡ºçŽ°çš„æ¦‚çŽ‡, å½“ç„¶æ˜¯ä»¥å‚æ•°çš„è®­ç»ƒæ ·æœ¬çš„è§’åº¦æ¥çœ‹å¾…ã€‚é™¤äº†ä¸ºæ¯ä¸ªè¯åºåˆ—æŒ‡å®šæ¦‚çŽ‡ä¹‹å¤–ï¼Œè¯­è¨€æ¨¡åž‹è¿˜æŒ‡å®šç»™å®šçš„å•è¯ï¼ˆæˆ–å•è¯åºåˆ—ï¼‰è·Ÿéšå‰é¢çš„å•è¯åºåˆ—çš„ä¼¼ç„¶æ¦‚çŽ‡ã€‚ è¯­è¨€æ¨¡åž‹æœ¬èº«å³æ˜¯ä¸€ç§æ¦‚çŽ‡æ¨¡åž‹. æ¦‚çŽ‡æ¨¡åž‹æ˜¯éšæœºçŽ°è±¡çš„æ•°å­¦è¡¨ç¤ºï¼Œç”±æ ·æœ¬ç©ºé—´ï¼Œæ ·æœ¬ç©ºé—´å†…çš„äº‹ä»¶ä»¥åŠä¸Žæ¯ä¸ªäº‹ä»¶ç›¸å…³çš„æ¦‚çŽ‡å®šä¹‰ã€‚ç›®æ ‡æ˜¯æ¨¡æ‹Ÿä¸€ä¸ªäº‹ä»¶å‘ç”Ÿçš„æ¦‚çŽ‡ã€‚ LMçš„ä»»åŠ¡å°±æ˜¯ä¸ºå•è¯åºåˆ—$w_{1:n}$åˆ†é…æ¦‚çŽ‡$P(w_{1:n})$, ç­‰åŒäºŽç»™åºåˆ—çš„æ¯ä¸ªä½ç½®é¢„æµ‹å¯èƒ½å‡ºçŽ°çš„å•è¯ï¼Œç»™å®šå‰é¢çš„å•è¯ï¼ˆä½œä¸ºæ¡ä»¶ï¼‰ï¼Œé¢„æµ‹ä¸‹ä¸€ä¸ªå•è¯å‡ºçŽ°çš„æ¦‚çŽ‡ P(w|w1, w2, w3...)ã€‚å¬èµ·æ¥æœ‰ç‚¹åƒè¯æ€§æ ‡æ³¨(Tagging)â€¦ äº‹å®žä¸Šæœ€åˆä¸ºè¯­è¨€å»ºæ¨¡å¼€å‘çš„å‚æ•°ä¼°è®¡æŠ€æœ¯ä¹Ÿç»™è¯æ€§æ ‡æ³¨åšäº†ä¸å°‘è´¡çŒ®. åˆ©ç”¨é“¾å¼æ³•åˆ™, $$P(w_{1:n}) = P(w_1)P(w_2|w_1)P(w_3|w_{1:2})P(w_4|w_{1:3})â€¦P(w_n|w_{1:n-1}),$$ æœ€åŽä¸€é¡¹åŸºäºŽn-1ä¸ªè¯çš„æ¡ä»¶æ¦‚çŽ‡è®¡ç®—éš¾åº¦éžå¸¸å¤§ã€‚ä¸ºäº†ç®€åŒ–LMå‚æ•°çš„è®­ç»ƒï¼Œåˆ©ç”¨ké˜¶é©¬å°”å¯å¤«å‡è®¾ï¼Œå£°æ˜Žåºåˆ—çš„ä¸‹ä¸€ä¸ªè¯ä»…ä¾èµ–äºŽå‰kä¸ªè¯ã€‚å¦‚åˆ©ç”¨ä¸€é˜¶é©¬å°”å¯å¤«å‡è®¾å¾—åˆ°P(transparent | the water is so ) â‰ˆ P(transparent | so). ä½¿ç”¨é©¬å°”å¯å¤«å‡è®¾ç®€åŒ–å‰é¢çš„ä¹˜é“¾:$$\begin{align}P(w_{1:n}) &amp;= \prod_{i=1}^n P(w_i | w_1, â€¦, w_{i-1}) \\&amp;\propto \prod_{i=1}^n P(w_i | w_{i-k}, â€¦, w_{i-1}) \end{align}$$åœ¨è¯­æ–™å¤„ç†æ—¶ï¼Œå¼€å¤´çš„å¥å­å‰é¢éœ€è¦ç›¸åº”çš„åŠ ä¸Škä¸ªè¡¥ä¸ç¬¦å·&lt;s&gt;ï¼Œæ‰èƒ½è®¡ç®—ç¬¬ä¸€ä¸ªè¯çš„æ¡ä»¶æ¦‚çŽ‡ã€‚LMä¹Ÿæ˜¯ä¸€ç§ç”Ÿæˆæ¨¡åž‹, ä¸€èˆ¬æ˜¯åœ¨å¥å­æœ«å°¾åŠ ä¸Šç‰¹æ®Šç¬¦å·&lt;/s&gt;è¡¨ç¤ºå¥å­ç»“æŸ, ä»¥æ–¹ä¾¿ç”Ÿæˆä»»åŠ¡æ—¶åˆ¤æ–­å¥å­çš„ç”Ÿæˆç»“æŸ. å›ºç„¶Markovå‡è®¾å¯¹äºŽä»»æ„ké˜¶éƒ½æ˜¯æœ‰åå·®çš„ï¼ˆæ¯•ç«Ÿå¥å­å¯ä»¥æœ‰ä»»æ„é•¿çš„ä¾èµ–æ€§ï¼‰ï¼Œä½†ä»å¯ä»¥ä½¿ç”¨è¾ƒå°çš„kå»ºæ¨¡å‡ºè¾ƒå¼ºçš„LMï¼Œå¹¶ä¸”å‡ åå¹´æ¥ä¸€ç›´æ˜¯è¯­è¨€å»ºæ¨¡çš„ä¸»è¦æ–¹æ³•ã€‚ å¯¹äºŽLMå‚æ•°ä¸­æ¯ä¸€é¡¹ä¼¼ç„¶æ¦‚çŽ‡çš„ä¼°ç®—ï¼Œå¯ä»¥ä½¿ç”¨æœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼ˆMLEï¼‰ï¼š$$P(w_{i}=m|w_{i-k:i-1}) = \frac{Count(w_{i-k:i})}{Count(w_{i-k:i-1})}$$ è¿™ä¸ªå°±æ˜¯ç»å…¸çš„N-gramæ¨¡åž‹ã€‚ N-Gramè¯­è¨€æ¨¡åž‹N-Gramè¯­è¨€æ¨¡åž‹æ˜¯åŸºäºŽN-1é˜¶é©¬å°”å¯å¤«å‡è®¾ä¸”ç”±MLEä¼°ç®—å‡ºçš„LMã€‚N-GramLM é¢„æµ‹ä¸‹ä¸€ä¸ªå•è¯å‡ºçŽ°æ¦‚çŽ‡ä»…æ¡ä»¶äºŽå‰é¢çš„(N-1)ä¸ªå•è¯, ä»¥The students opened their booksä¸ºä¾‹: Bi-gram: ç»Ÿè®¡$P(w_{i}=m|w_{i-1})$, P(students | the), P(opened | students), â€¦, å±žäºŽé©¬å°”å¯å¤«ä¸€é˜¶æ¨¡åž‹, å³å½“å‰tæ—¶é—´æ­¥çš„çŠ¶æ€ä»…è·Ÿt-1ç›¸å…³. Tri-gram: P(students | &lt;/s&gt; The), P(opened | The students), é©¬å°”å¯å¤«äºŒé˜¶æ¨¡åž‹ Four-gram: ä¾æ­¤ç±»æŽ¨ ç‰¹æ®Šçš„Uni-gram: ç»Ÿè®¡$P(w_i)$, P(the), P(students), â€¦, æ­¤æ—¶æ•´ä¸ªæ¨¡åž‹é€€åŒ–ä¸ºè¯è¢‹æ¨¡åž‹, ä¸å†å±žäºŽé©¬å°”å¯å¤«æ¨¡åž‹, è€Œæ˜¯åŸºäºŽè´å¶æ–¯å‡è®¾, å³å„ä¸ªå•è¯æ˜¯æ¡ä»¶ç‹¬ç«‹çš„. æ‰€ä»¥ä¸€èˆ¬N-gramæ˜¯æŒ‡N&gt;1çš„. N-Gramæ¨¡åž‹å› ä¸ºä½¿ç”¨MLEä¼°ç®—å‚æ•°ï¼Œç¼ºç‚¹å¾ˆæ˜Žæ˜¾ï¼š æ— æ³•å¾ˆå¥½åœ°è§£å†³NLPä¸­çš„é•¿è·ç¦»ä¾èµ–çŽ°è±¡, æ¯”å¦‚ä¸€èˆ¬è¡¨çŽ°æ¯”è¾ƒå¥½çš„Trigramè¯­è¨€æ¨¡åž‹ï¼Œæ²¡æœ‰è€ƒè™‘åˆ°ä¸¤æ­¥ä¹‹å¤–çš„è¯ æ²¡æœ‰è€ƒè™‘è¯çš„ç›¸ä¼¼æ€§ï¼Œæ³›åŒ–èƒ½åŠ›å·®ã€‚æ¯”å¦‚åœ¨è®­ç»ƒé›†å‡ºçŽ°äº†The cat is walking in the bedroom,ç†è®ºä¸Šåº”è¯¥æ³›åŒ–åˆ°ç»™A dog was running in a room, å› ä¸ºdogå’Œcat(resp. â€œtheâ€ and â€œaâ€, â€œroomâ€ and â€œbedroomâ€, etcâ€¦)æœ‰ç±»ä¼¼çš„è¯­ä¹‰å’Œè¯­æ³•å®šä½. N-gramåªæ˜¯åœ¨æµ‹è¯•è¯­æ–™åº“ä¸Žè®­ç»ƒè¯­æ–™åº“æ¯”è¾ƒç›¸ä¼¼æ—¶è¡¨çŽ°æ‰æ¯”è¾ƒå¥½ã€‚å¦åˆ™åŸºäºŽè®­ç»ƒè¯­æ–™è®­ç»ƒå‡ºæ¥çš„å‚æ•°è‚¯å®šæ— æ³•å¾ˆå¥½åœ°è¯„ä¼°æµ‹è¯•è¯­æ–™ï¼Œå°±åƒäººæ— æ³•å¯¹å…¶ä¸è®¤è¯†çš„è¯­è¨€åšä»»ä½•è¯­æ³•å¥æ³•ä¸Šçš„è¯„ä»·ã€‚ ç¨€ç–é—®é¢˜1ï¼šå¤§å¤šæ•°é«˜é˜¶Gramå‡ ä¹Žä¸ä¼šå‡ºçŽ°ï¼Œè™½ç„¶u v wåœ¨è®­ç»ƒè¯­æ–™ä¸­ä»Žæ¥æ²¡æœ‰å‡ºçŽ°è¿‡, ä½†æˆ‘ä»¬ä¸èƒ½ç®€å•åœ°æŠŠP(w | u, v)å®šä¹‰ä¸º0ï¼Œå› ä¸ºè¯­è¨€æ˜¯åƒå˜ä¸‡åŒ–çš„ï¼Œæœ‰äº›è¯ç»„è™½ç„¶å°‘è§ä½†ä¸ä»£è¡¨ä¸å­˜åœ¨ã€‚å¥å­çš„æ¦‚çŽ‡æ˜¯ç”±å„ä¸ªgramä¼¼ç„¶æ¦‚çŽ‡ç›¸ä¹˜è€Œæ¥ï¼Œå¦‚æžœä»…ä»…å› ä¸ºä¸€ä¸ªè¯ç»„å‡ºçŽ°æ¬¡æ•°ä¸º0å°±å¯¼è‡´æ•´ä¸ªå¥å­æ¦‚çŽ‡å˜ä¸º0, é‚£æ˜¾ç„¶æ˜¯ä¸åˆç†çš„. ç¨€ç–é—®é¢˜2ï¼šéƒ¨åˆ†ä½Žé˜¶gramæ²¡æœ‰å‡ºçŽ°è¿‡ï¼Œä½Žé˜¶gramçš„æ¬¡æ•°ä½œä¸ºMLEå…¬å¼ä¸­åˆ†æ¯å˜ä¸º0ï¼Œé‚£è®¡ç®—å°±æ²¡æ³•è¿›è¡Œä¸‹åŽ»äº†. ä¸€èˆ¬è€Œè¨€ï¼ŒNè¶Šé«˜ï¼Œæ¨¡åž‹è¡¨çŽ°è¶Šå¥½ï¼Œä½†æ˜¯æ›´å¤§çš„Nä½¿ç¨€ç–é—®é¢˜å˜å¾—æ›´ç³Ÿã€‚é€šå¸¸äººä»¬ä¸ä¼šå–å¤§äºŽ5çš„Nã€‚ éœ€è¦å­˜å‚¨æ‰€æœ‰å¯èƒ½çš„N-Gramï¼Œæ‰€ä»¥æ¨¡åž‹çš„å¤§å°æ˜¯ O(exp(n)), éœ€è¦å¤§é‡çš„å†…å­˜ï¼Œè€Œå…¶å®žå¤§éƒ¨åˆ†éƒ½æ˜¯å‡ºçŽ°æ¬¡æ•°ä¸º0. å¹³æ»‘é’ˆå¯¹æ•°æ®ç¨€ç–é—®é¢˜ï¼ˆ0æ¦‚çŽ‡çš„é—®é¢˜ï¼‰, å¯ä»¥ä½¿ç”¨å„ç§å¹³æ»‘å¤„ç†ï¼ˆSmoothingï¼‰. åŠ ä¸€ï¼ˆLaplaceï¼‰å¹³æ»‘ï¼šæœ€ç®€å•çš„å¹³æ»‘æ³•ï¼Œä¸ºæ‰€æœ‰äº‹ä»¶ï¼ˆä¸ç®¡æœ‰æ²¡å‡ºçŽ°è¿‡ï¼‰çš„é¢‘æ¬¡åŠ ä¸€ï¼Œè¿™æ ·ä¿è¯äº†æ²¡æœ‰0æ¦‚çŽ‡äº‹ä»¶å‡ºçŽ°ã€‚è¿™ç§å¹³æ»‘æ•ˆæžœå¾ˆå·®ï¼Œå› ä¸ºé½å¤«å®šå¾‹Zipf&#39;s lawçš„å…³ç³» Zipf&#39;s lawï¼šåœ¨è‡ªç„¶è¯­è¨€çš„è¯­æ–™åº“é‡Œï¼Œä¸€ä¸ªå•è¯å‡ºçŽ°çš„é¢‘çŽ‡ä¸Žå®ƒåœ¨é¢‘çŽ‡è¡¨é‡Œçš„æŽ’åæˆåæ¯”ã€‚ ä¼šæœ‰å¾ˆå¤šé•¿å°¾å•è¯å¾ˆå°‘ç”šè‡³å‡ ä¹Žæ²¡æœ‰å‡ºçŽ°è¿‡, æ‰€ä»¥åœ¨æ€»æ•°ä¸º1çš„æ¦‚çŽ‡æ± å­é‡Œ, ä¸ºäº†ç»™è¿™äº›é•¿å°¾å•è¯åˆ†é…è‡³å°‘é¢‘æ¬¡1çš„æ¦‚çŽ‡, éœ€è¦ä»ŽçœŸæ­£å‡ºçŽ°çš„å•è¯(æ‰€è°“çœŸå®žå‘ç”Ÿçš„äº‹ä»¶)ä¸­åˆ†èµ°å¾ˆå¤šæ¦‚çŽ‡. å› æ­¤å¯ä»¥ç»™Laplaceå¹³æ»‘åŠ å…¥æŽ§åˆ¶å› å­ï¼Œå˜ä¸º Add alpha smoothingã€‚æ›´å¤šå¹³æ»‘æ–¹æ¡ˆå‚è€ƒUoE-anlp è¯­è¨€æ¨¡åž‹è¯„ä¼°æ–¹æ³•æ—¢ç„¶LMæ˜¯ç”¨äºŽè¯„ä¼°å¥å­æ˜¯å¦å‡†ç¡®çš„æ¨¡åž‹ï¼Œé‚£ä¹ˆåœ¨è¯„ä»·LMå¥½åæ—¶ï¼Œå°±è¦çœ‹å®ƒåœ¨æµ‹è¯•é›†ä¸Šçš„è¡¨çŽ°å¦‚ä½•ã€‚ç»™å®šæµ‹è¯•é›†åŒ…å«$m$ä¸ªå¥å­$x^{(1)}, x^{(2)}, â€¦, x^{(m)}$, å„ä¸ªå¥å­çš„é•¿åº¦åˆ†åˆ«ä¸º$n_i$. LMç»™è¿™äº›æµ‹è¯•é›†å¥å­è¯„ä¼°çš„æ¦‚çŽ‡å¤§å°ä¸º$$\prod_{i=1}^m p(x^{(i)})$$ è¿™ä¸ªæ•°å€¼è¶Šé«˜ï¼Œè¯´æ˜ŽLMè¯„ä¼°æµ‹è¯•é›†å¥å­çš„è´¨é‡è¶Šå¥½ã€‚æ³¨æ„, æµ‹è¯•é›†å¿…é¡»æ˜¯å®Œå…¨æ²¡æœ‰å‚ä¸Žæ¨¡åž‹è®­ç»ƒ, ä¸”æ˜¯åœ¨äººç±»æ ‡å‡†ä¸­æ˜¯å¥½çš„å¥å­. ä½†åœ¨å®žé™…ä½¿ç”¨ä¸­, æˆ‘ä»¬å¾€å¾€ä½¿ç”¨ä¸Šé¢è¿™ä¸ªæ¦‚çŽ‡çš„ä¸€ç§å˜æ¢ - å›°æƒ‘åº¦ï¼ˆPerplexityï¼‰æ¥è¯„ä»·LMçš„è´¨é‡. é¦–å…ˆå–æ•´ä¸ªæµ‹è¯•è¯­æ–™åº“çš„å¯¹æ•°æ¦‚çŽ‡é™¤ä»¥æµ‹è¯•è¯­æ–™åº“ä¸­çš„å•è¯æ€»æ•°$M$: $$l = \frac{1}{M} \log_2 \prod_{i=1}^m p(x^{(i)}) = \frac{1}{M} \sum_{i=1}^m \log_2 p(x^{(i)})$$ç„¶åŽå¾—åˆ°$$\begin{align}Perplexity &amp;= 2^{-l} \\&amp;= 2^{-\frac{1}{M} \sum_{i=1}^m \log_2 p(x^{(i)})}\\\\&amp;= t^{-1}\end{align}$$å…¶ä¸­ï¼Œ$t = \sqrt[\leftroot{-2}\uproot{2}M]{\prod_{i=1}^m p(x^{(i)})}$, ä½œä¸ºæµ‹è¯•é›†æ¦‚çŽ‡çš„å‡ ä½•å¹³å‡. ä¾‹å¦‚ï¼Œå¦‚æžœå›°æƒ‘ç­‰äºŽ100ï¼Œåˆ™$t = 0.01$ï¼Œè¡¨æ˜Žå‡ ä½•å¹³å‡å€¼ä¸º0.01. å¯ä»¥çœ‹åˆ°, Perplexityçš„å€¼è¶Šå°ï¼Œè¯­è¨€æ¨¡åž‹å»ºæ¨¡æµ‹è¯•é›†çš„èƒ½åŠ›å°±è¶Šå¥½. æ¦‚çŽ‡å–å¯¹æ•°è½¬æ¢å¯ä»¥é¿å…æ•°å€¼ä¸‹æº¢ï¼Œå¯ä»¥æŠŠä¹˜æ³•è½¬æ¢ä¸ºåŠ æ³•, è®¡ç®—ä¹Ÿæ›´å¿«. å›°æƒ‘åº¦ä¸ºä½•å°±æ˜¯ä¸€ç§å¥½çš„è¡¡é‡æ ‡å‡†å‘¢ï¼Ÿå¯¹äºŽä»»ä½•ä¸€ä¸ªä»»åŠ¡ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰Baselineæ¨¡åž‹ä½œä¸ºåŸºå‡†ï¼Œå¦‚æžœåŽç»­æœ‰ä¸€ä¸ªæ–°çš„æ¨¡åž‹ï¼Œä½†æ— æ³•è¶…è¿‡æ­¤baselineï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¤ä¸ºè¿™ä¸ªæ–°çš„æ¨¡åž‹æ˜¯æ²¡æœ‰è¿›æ­¥çš„ã€‚å¯¹äºŽè¯­è¨€å»ºæ¨¡è¿™ä¸€ä¸ªä»»åŠ¡ï¼Œæœ€æ— è„‘æœ€ç®€å•çš„baselineï¼Œå°±æ˜¯å‡è®¾æ¯ä¸€ä¸ªä½ç½®çš„æ¯ä¸ªå•è¯å‡ºçŽ°æ¦‚çŽ‡ç›¸ç­‰ï¼Œè¿™å°±æ˜¯æœ€å¤§ç†µåˆ†å¸ƒï¼Œå³å‡è®¾æ­¤baselineå¯¹è¿™ä¸ªä»»åŠ¡ä¸€æ— æ‰€çŸ¥ï¼Œæ‰€æœ‰ä½ç½®æ‰€æœ‰å•è¯åœ¨å®ƒçœ¼é‡Œéƒ½æ˜¯æ²¡åŒºåˆ«çš„(å‡åŒ€åˆ†å¸ƒ)ã€‚å¦‚æžœè¯æ±‡é›†(åŒ…å«&lt;/s&gt;)å¤§å°ä¸ºN, é‚£ä¹ˆ$$P_{i \in T}(w_i | w_{1:i-1}) = \frac{1}{N},$$ æ­¤æ—¶çš„å›°æƒ‘åº¦ç­‰äºŽN, å³åœ¨å‡åŒ€æ¦‚çŽ‡åˆ†å¸ƒæ¨¡åž‹ä¸‹ï¼Œå›°æƒ‘åº¦ç­‰äºŽè¯æ±‡é‡çš„å¤§å°ã€‚æ˜¾è€Œæ˜“è§ä»»ä½•ä¸€ä¸ªæœ‰æ•ˆæ¨¡åž‹çš„å›°æƒ‘åº¦å¿…é¡»å°äºŽç±»åˆ«ä¸ªæ•°. æ­¤æ—¶å›°æƒ‘åº¦å¯ä»¥ç†è§£ä¸ºæ¨¡åž‹çš„æœ‰æ•ˆè¯æ±‡é‡ï¼šä¾‹å¦‚ï¼Œè¯æ±‡é‡å¤§å°ä¸º10,000, è€Œæ¨¡åž‹çš„å›°æƒ‘åº¦ä¸º120ï¼Œé‚£ä¹ˆè¿™å¤§è‡´è¯´æ˜Žæœ‰æ•ˆçš„è¯æ±‡é‡åªæœ‰å¤§æ¦‚120ä¸ªã€‚æœ€ä½³æƒ…å†µä¸‹ï¼Œæ¨¡åž‹æ€»æ˜¯æŠŠæµ‹è¯•é›†çš„æ¦‚çŽ‡é¢„æµ‹ä¸º 1, æ­¤æ—¶å›°æƒ‘åº¦ä¸º 1ã€‚æœ€åæƒ…å†µä¸‹ï¼Œæ¦‚çŽ‡é¢„æµ‹ä¸º 0, æ­¤æ—¶å›°æƒ‘åº¦ä¸ºæ­£æ— ç©·ã€‚Baselineæ¨¡åž‹æ€»æ˜¯é¢„æµ‹æ‰€æœ‰ç±»åˆ«çš„æ¦‚çŽ‡éƒ½ç›¸åŒ, æ­¤æ—¶å›°æƒ‘åº¦ä¸ºè¯æ±‡é‡å¤§å°ï¼ˆç±»åˆ«ä¸ªæ•°ï¼‰ã€‚ ç›®å‰å¾ˆå¤šç¥žç»ç½‘ç»œæ¡†æž¶è®¡ç®—è¯­è¨€æ¨¡åž‹çš„æŸå¤±å‡½æ•°éƒ½æ˜¯ç”¨äº¤å‰ç†µæŸå¤±å‡½æ•°å¹¶å–å¯¹æ•°,è¦å¾—åˆ°perplexityï¼Œåªéœ€è¦æŠŠè¿™ä¸ªlosså–æŒ‡æ•°è¿ç®—ã€‚ é‚£ä¹ˆå›°æƒ‘åº¦ä¸€èˆ¬éƒ½æ˜¯å¤šå¤§å‘¢ï¼ŸGoodman (â€œA bit of progress in language modelingâ€, figure 2) è¯„ä¼°äº†åœ¨è‹±è¯­æ•°æ®ä¸Šçš„unigramï¼Œbigramå’Œtrigramè¯­è¨€æ¨¡åž‹ï¼Œè¯æ±‡é‡ä¸º50,000ã€‚Goodmançš„æŠ¥å‘Šç»“æžœæ˜¾ç¤ºï¼Œtrigramæ¨¡åž‹çš„å›°æƒ‘åº¦çº¦ä¸º74ï¼Œbigramæ¨¡åž‹ä¸º137ï¼Œunigramæ¨¡åž‹ä¸º955ã€‚ç›¸æ¯”äºŽBaselineæ¨¡åž‹å›°æƒ‘åº¦50,000ï¼Œtrigramæ¨¡åž‹æ˜¾ç„¶æœ‰äº†å·¨å¤§çš„æ”¹è¿›ï¼Œä¸”æ¯”bigramå’Œunigramæ¨¡åž‹ä¹Ÿæœ‰å¾ˆå¤§çš„æ”¹è¿›ã€‚è€Œæ›´å¼ºå¤§çš„SOTAç¥žç»è¯­è¨€æ¨¡åž‹ï¼Œå¯ä»¥åœ¨wikitext-2æ•°æ®é›†ä¸Šè·‘å‡º40ä»¥ä¸‹çš„å›°æƒ‘åº¦ã€‚ ç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹ç¥žç»ç½‘ç»œæ¨¡åž‹è§£å†³äº†ä¼ ç»Ÿè¯­è¨€æ¨¡åž‹çš„ä¸€äº›ç¼ºç‚¹ï¼šå®ƒä»¬å…è®¸è¶Šæ¥è¶Šé•¿çš„è·ç¦»ä¾èµ–ï¼Œè€Œå‚æ•°æ•°é‡ä»…çº¿æ€§å¢žåŠ ï¼Œå®ƒä»¬å‡å°‘äº†æ‰‹åŠ¨è®¾è®¡backoffé¡ºåºçš„éœ€è¦ï¼Œå¹¶ä¸”å®ƒä»¬æ”¯æŒè·¨ä¸åŒä¸Šä¸‹æ–‡çš„æ³›åŒ–ã€‚ Bengio et al. [2003]æå‡ºçš„ç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹(NNLM, ç¡®åˆ‡çš„è¯´æ˜¯å‰é¦ˆç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹), æŠŠæ–‡æœ¬å¤„ç†æˆnä¸ªk-gramè¯çª—å£$w_{i:i+k-1}$, æ¯ä¸ªè¯è½¬æ¢ä¸ºè¯é•¶åµŒçš„å½¢å¼$\mathcal{v}(w) \in \mathcal{R}^{d_w}$, ä¸€æ•´ä¸ªçª—å£çš„è¯å‘é‡æ‹¼æŽ¥ä¸ºçŸ©é˜µå‘é‡$x = [\mathcal{v}(w_0); â€¦; \mathcal{v}(w_{k-1})]$, ä½œä¸ºè¾“å…¥æ•°æ®è¾“å…¥åˆ°ä¸€ä¸ª1åˆ°2å±‚çš„æ„ŸçŸ¥æœº. è®­ç»ƒæ•°æ®çš„å¤„ç†ä¸€èˆ¬è¿™ä¹ˆæ“ä½œ, æ¯ä¸ªå¥å­çš„å¼€å¤´åŠ ä¸Š&lt;s&gt;, æœ«å°¾åŠ ä¸Š&lt;/s&gt;, ç„¶åŽæŒ‰ç…§kå¤§å°çš„é•¿åº¦ä¸€æ®µæ®µæˆªæ–­æˆk-gramè¯çª—å£$w_{i:i+k-1}$. æ¯ä¸€æ®µk-gramçš„è¯æ‹¼æŽ¥ä¸ºä¸€ä¸ªå‘é‡$x = (C(w_{i}), C(w_{i+1}), Â·Â·Â·, C(w_{i+k-1}))$, ä½œä¸ºä¸€ä¸ªè®­ç»ƒæ ·æœ¬, å…¶æœ«å°¾çš„ä¸‹ä¸€ä¸ªè¯$w_{i+k}$ä½œä¸ºæ ·æœ¬å¯¹åº”çš„é¢„æµ‹æ ‡ç­¾$y_i = \mathcal{v}(w_{i+k})$. è®­ç»ƒæ—¶ï¼Œä»¥è¾“å‡ºçš„è¯å‘é‡æ¦‚çŽ‡åˆ†å¸ƒå‘é‡å’Œå¯¹åº”æ­£ç¡®æ ‡ç­¾çš„ one-hot-vector é—´çš„ cross-entropy loss ä¸ºæŸå¤±å‡½æ•°. ç¥žç»ç½‘ç»œçš„å‚æ•°æ•°é‡æ¯”ä¼ ç»Ÿçš„N-gramå°‘ï¼Œå› ä¸ºå…¶æ¯å¢žåŠ ä¸€ä¸ªè¯ï¼Œå‚æ•°å°±å¤š$d_w$, ä¹Ÿå°±æ˜¯çº¿æ€§å¢žåŠ , è€ŒN-gramæ˜¯å¤šé¡¹å¼å¢žåŠ é€ŸçŽ‡. å¹¶ä¸”NNLMçš„å‚æ•°çŸ©é˜µå¯¹æ‰€æœ‰è¾“å…¥éƒ½æ˜¯å…±äº«çš„, è¿™è¿›ä¸€æ­¥å‡å°‘äº†å‚æ•°é‡. è™½ç„¶å¦‚æ­¤, NNLMçš„è®­ç»ƒæ—¶é—´è¿˜æ˜¯æ¯”N-gram LMé•¿. ç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹çš„æ³›åŒ–èƒ½åŠ›æ›´å¥½ï¼Œå› ä¸ºç›¸ä¼¼çš„è¯å…·æœ‰ç›¸ä¼¼çš„ç‰¹å¾å‘é‡ï¼Œå¹¶ä¸”å› ä¸ºæ¦‚çŽ‡å‡½æ•°ï¼ˆæ¨¡åž‹å‚æ•°ï¼‰æ˜¯è¿™äº›ç‰¹å¾å€¼çš„å¹³æ»‘å‡½æ•°ï¼Œæ‰€ä»¥ç‰¹å¾çš„å¾®å°å˜åŒ–ç›¸åº”åœ°å¼•èµ·æ¦‚çŽ‡çš„å¾®å°å˜åŒ–ã€‚ çœŸæ­£å½±å“NNLMè®¡ç®—æ•ˆçŽ‡çš„æ˜¯è¾“å‡ºå±‚çš„softmaxè®¡ç®—, å› ä¸ºè®­ç»ƒæ ·æœ¬çš„è¯æ±‡é‡$\mathcal{V}$å¾€å¾€å¾ˆå¤§. è¾“å‡ºå±‚çš„softmaxéœ€è¦ä¸Žéšå«å±‚å‚æ•°çŸ©é˜µ$W^2 \in \mathcal{R}^{d_{hid} \times \mathcal{V}}$è¿›è¡Œæ˜‚è´µçš„çŸ©é˜µå‘é‡ä¹˜æ³•, ç„¶åŽè¿›è¡Œ$\mathcal{V}$æ¬¡å¯¹æ•°æ“ä½œ. è¿™éƒ¨åˆ†è®¡ç®—å æ®äº†å¤§éƒ¨åˆ†è¿è¡Œæ—¶é—´ï¼Œä½¿å¾—å¤§è¯æ±‡é‡çš„NNLMå»ºæ¨¡ä»¤äººæœ›è€Œå´æ­¥ã€‚ åŽç»­å‘å±•çš„NNLMæ™®éä½¿ç”¨å¾ªçŽ¯ç¥žç»ç½‘ç»œï¼ˆRNN, LSTMï¼‰æ¥ä»£æ›¿ç®€å•çš„å‰é¦ˆç¥žç»ç½‘ç»œã€‚å¾ªçŽ¯ç¥žç»ç½‘ç»œå¯ä»¥ç†è§£ä¸ºå¤šå±‚å‰é¦ˆç¥žç»ç½‘ç»œå åŠ , ä½†å„ç¥žç»ç½‘ç»œéšå«å±‚çš„å‚æ•°æ˜¯å…±äº«çš„. å¥å­é€è¯è¾“å…¥å¾ªçŽ¯ç¥žç»ç½‘ç»œ, ä¹Ÿå°±æ˜¯å¾ªçŽ¯ç¥žç»ç½‘ç»œä½¿ç”¨åŒæ ·å‚æ•°æ–¹ç¨‹æ¥å¤„ç†æ¯ä¸€ä¸ªè¯, å› æ­¤å¾ªçŽ¯ç¥žç»ç½‘ç»œçš„å‚æ•°é‡æ¯”å‰é¦ˆç¥žç»ç½‘ç»œæ›´å°‘. ä½¿ç”¨å¾ªçŽ¯ç¥žç»ç½‘ç»œä½œä¸ºLMæ¨¡åž‹æ—¶, åŒæ ·æœ€åŽä¸€å±‚è¿˜æ˜¯ä½¿ç”¨softmaxè¾“å‡ºå±‚ã€‚ä¸åŒçš„æ˜¯è¾“å…¥ä¸å†å±€é™äºŽå®šé•¿çš„kgramè¯çª—å£ï¼ŒLSTMç†è®ºä¸Šå¯ä»¥æŽ¥å—æ— é™é•¿åºåˆ—, ä½†äº‹å®žä¸ŠLSTMçš„è®°å¿†èƒ½åŠ›ä¹Ÿæ˜¯æœ‰é™çš„, å¤ªé•¿å°±ä¼šé—å¿˜æŽ‰å‰é¢çš„ä¿¡æ¯. å¯¹å¤§è¯æ±‡é‡è¯­è¨€æ¨¡åž‹çš„å°è¯•Hierarchical softmax [Morin and Bengio, 2005] Self-normalizing aproaches, æ¯”å¦‚ noise-contrastive estimation (NCE) [Mnih and Teh, 2012, Vaswani et al., 2013] æˆ–è€…åœ¨è®­ç»ƒç›®æ ‡å‡½æ•°ä¸­åŠ å…¥æ­£åˆ™åŒ–é¡¹ [Devlin et al., 2014]. æœ‰å…³å¤„ç†å¤§è¾“å‡ºè¯æ±‡è¡¨çš„è¿™äº›å’Œå…¶ä»–æŠ€æœ¯çš„è‰¯å¥½è¯„è®ºå’Œæ¯”è¾ƒï¼Œè¯·å‚é˜… Chen et al. [2016]. å‚è€ƒèµ„æ–™class notes by Michael Collins: http://www.cs.columbia.edu/~mcollins/lm-spring2013.pdfNeural Network Methods in Natural Language Processing, by Yoav Goldberg A Neural Probabilistic Language Model, Yoshua Bengio, 2003]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¿¡æ¯æŠ½å–]]></title>
    <url>%2FNLP-information-extraction%2F</url>
    <content type="text"><![CDATA[ä¿¡æ¯æŠ½å–1997å¹´MUCä¼šè®®ï¼ˆMUC-7ï¼‰ å¬å¼€æ—¶ï¼Œè¯„æµ‹ä»»åŠ¡å·²ç»å¢žåŠ åˆ°5ä¸ªï¼šâ‘  åœºæ™¯æ¨¡æ¿ï¼ˆscenario template, STï¼‰å¡«å……ï¼šå®šä¹‰äº†æè¿°åœºæ™¯çš„æ¨¡æ¿åŠæ§½å¡«å……è§„èŒƒï¼›â‘¡ å‘½åå®žä½“ï¼ˆnamed entity, NEï¼‰è¯†åˆ«ï¼šè¯†åˆ«å‡ºæ–‡æœ¬ä¸­å‡ºçŽ°çš„ä¸“æœ‰åç§°å’Œæœ‰æ„ä¹‰çš„æ•°é‡çŸ­è¯­ï¼Œ å¹¶åŠ ä»¥å½’ç±»ï¼›â‘¢ å…±æŒ‡ï¼ˆcoreference, CRï¼‰å…³ç³»ç¡®å®šï¼šè¯†åˆ«å‡ºç»™å®šæ–‡æœ¬ä¸­çš„å‚ç…§è¡¨è¾¾ï¼ˆ referring expressionsï¼‰ï¼Œå¹¶ç¡®å®šè¿™äº›è¡¨è¾¾ä¹‹é—´çš„å…±æŒ‡å…³ç³»ï¼›â‘£ æ¨¡æ¿å…ƒç´ ï¼ˆtemplate element, TEï¼‰å¡«å……ï¼šç±»ä¼¼äºŽäººåå’Œç»„ç»‡æœºæž„åè¯†åˆ«ï¼Œä½†æ˜¯è¦æ±‚ç³»ç»Ÿå¿…é¡»è¯†åˆ«å‡ºå®žä½“çš„æè¿°å’Œåå­—ï¼Œå¦‚æžœä¸€ä¸ªå®žä½“åœ¨æ–‡æœ¬ä¸­è¢«æåˆ°äº†å¤šæ¬¡ï¼Œä½¿ç”¨äº†å‡ ç§å¯èƒ½çš„æè¿°å’Œä¸åŒçš„åå­—å½¢å¼ï¼Œè¦æ±‚ç³»ç»Ÿéƒ½è¦æŠŠå®ƒä»¬è¯†åˆ«å‡ºæ¥ï¼Œä¸€ä¸ªæ–‡æœ¬ä¸­çš„æ¯ä¸ªå®žä½“åªæœ‰ä¸€ä¸ªæ¨¡æ¿å…ƒç´ ï¼»Grishman and Sundheim, 1996ï¼½ï¼›â‘¤ æ¨¡æ¿å…³ç³»ï¼ˆtemplate relation, TRï¼‰ï¼šç¡®å®šå®žä½“ä¹‹é—´ä¸Žç‰¹å®šé¢†åŸŸæ— å…³çš„å…³ç³»ã€‚ 1999å¹´èµ·ç¾Žå›½NISTç»„ç»‡äº†è‡ªåŠ¨å†…å®¹æŠ½å–ï¼ˆautomatic content extraction, ACEï¼‰è¯„æµ‹ä¼šè®®ï¼Œæ—¨åœ¨ç ”ç©¶å’Œå¼€å‘è‡ªåŠ¨å†…å®¹æŠ€æœ¯ä»¥æ”¯æŒå¯¹ä¸‰ç§ä¸åŒæ¥æºæ–‡æœ¬ï¼ˆæ™®é€šæ–‡æœ¬ã€ç»è¯­éŸ³è¯†åˆ«åŽå¾—åˆ°çš„æ–‡æœ¬ã€ ç”±OCRè¯†åˆ«å¾—åˆ°çš„æ–‡æœ¬ï¼‰çš„è‡ªåŠ¨å¤„ç†ï¼Œä»¥å®žçŽ°æ–°é—»è¯­æ–™ä¸­å‡ºçŽ°çš„å®žä½“ã€å…³ç³»ã€äº‹ä»¶ç­‰å†…å®¹çš„è‡ªåŠ¨æŠ½å–ã€‚è¯„æµ‹ä»»åŠ¡è®¾è®¡:å®žä½“æ£€æµ‹ä¸Žè·Ÿè¸ªï¼ˆentity detection and tracking, EDTï¼‰ã€æ•°å€¼æ£€æµ‹ä¸Žè¯†åˆ«ï¼ˆvalue detection and recognition, VDRï¼‰ã€æ—¶é—´è¯†åˆ«å’Œè§„èŒƒåŒ–ï¼ˆtime expression recognition and normalization, TERNï¼‰ã€å…³ç³»æ£€æµ‹ä¸Žæè¿°ï¼ˆrelation detection and characterization, RDCï¼‰ã€äº‹ä»¶æ£€æµ‹ä¸Žæè¿°ï¼ˆevent detection and characterization, EDCï¼‰å’Œå®žä½“ç¿»è¯‘ï¼ˆentity translation, ETï¼‰ç­‰ã€‚ TF-IDF å…³é”®è¯æŠ½å–12import jieba.analysejieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=()) sentence ä¸ºå¾…æå–çš„æ–‡æœ¬topK ä¸ºè¿”å›žå‡ ä¸ª TF/IDF æƒé‡æœ€å¤§çš„å…³é”®è¯ï¼Œé»˜è®¤å€¼ä¸º 20withWeight ä¸ºæ˜¯å¦ä¸€å¹¶è¿”å›žå…³é”®è¯æƒé‡å€¼ï¼Œé»˜è®¤å€¼ä¸º FalseallowPOS ä»…åŒ…æ‹¬æŒ‡å®šè¯æ€§çš„è¯ï¼Œé»˜è®¤å€¼ä¸ºç©ºï¼Œå³ä¸ç­›é€‰. å¦‚ç”µå•†è¯„è®ºæŒ‡å®šè¦å½¢å®¹è¯ å…³é”®è¯æå–æ‰€ä½¿ç”¨é€†å‘æ–‡ä»¶é¢‘çŽ‡ï¼ˆIDFï¼‰æ–‡æœ¬è¯­æ–™åº“å¯ä»¥åˆ‡æ¢æˆè‡ªå®šä¹‰è¯­æ–™åº“çš„è·¯å¾„, ç”¨æ³•ï¼š jieba.analyse.set_idf_path(file_name) # file_nameä¸ºè‡ªå®šä¹‰è¯­æ–™åº“çš„è·¯å¾„è‡ªå®šä¹‰è¯­æ–™åº“ç¤ºä¾‹è§ https://github.com/fxsjy/jieba/blob/master/extra_dict/idf.txt.bigç”¨æ³•ç¤ºä¾‹è§ https://github.com/fxsjy/jieba/blob/master/test/extract_tags_idfpath.py å…³é”®è¯æå–æ‰€ä½¿ç”¨åœæ­¢è¯ï¼ˆStop Wordsï¼‰æ–‡æœ¬è¯­æ–™åº“å¯ä»¥åˆ‡æ¢æˆè‡ªå®šä¹‰è¯­æ–™åº“çš„è·¯å¾„, ç”¨æ³•ï¼š jieba.analyse.set_stop_words(file_name) # file_nameä¸ºè‡ªå®šä¹‰è¯­æ–™åº“çš„è·¯å¾„è‡ªå®šä¹‰è¯­æ–™åº“ç¤ºä¾‹è§ https://github.com/fxsjy/jieba/blob/master/extra_dict/stop_words.txtç”¨æ³•ç¤ºä¾‹è§ https://github.com/fxsjy/jieba/blob/master/test/extract_tags_stop_words.py å…³é”®è¯ä¸€å¹¶è¿”å›žå…³é”®è¯æƒé‡å€¼ https://github.com/fxsjy/jieba/blob/master/test/extract_tags_with_weight.py TextRankè®ºæ–‡ï¼šTextRank: Bringing Order into Texts. å°†å¾…æŠ½å–å…³é”®è¯çš„æ–‡æœ¬è¿›è¡Œåˆ†è¯ ä»¥å›ºå®šçª—å£å¤§å°(é»˜è®¤ä¸º5ï¼Œé€šè¿‡spanå±žæ€§è°ƒæ•´)ï¼Œè¯ä¹‹é—´çš„å…±çŽ°å…³ç³»ï¼Œæž„å»ºå›¾ è®¡ç®—å›¾ä¸­èŠ‚ç‚¹çš„PageRankï¼Œæ˜¯æ— å‘å¸¦æƒå›¾ æ•°æ®é‡è¶Šå¤§ï¼Œæž„å»ºçš„å›¾è¶Šç²¾å‡† jieba.analyse.textrank(sentence, topK=20, withWeight=False, allowPOS=(&#39;ns&#39;, &#39;n&#39;, &#39;vn&#39;, &#39;v&#39;)) é»˜è®¤è¿‡æ»¤è¯æ€§ã€‚jieba.analyse.TextRank() æ–°å»ºè‡ªå®šä¹‰å®žä¾‹ å¼€æ”¾å¼ä¿¡æ¯æŠ½å–å¤„ç†çš„æ–‡æœ¬é¢†åŸŸä¸å†é™å®šäºŽè§„èŒƒçš„æ–°é—»æ–‡æœ¬æˆ–è€…æŸä¸€é¢†åŸŸæ–‡æœ¬ï¼Œè€Œæ˜¯ä¸é™å®šé¢†åŸŸçš„ç½‘ç»œæ–‡æœ¬, ä¸ä»…éœ€è¦è€ƒè™‘æ–‡æœ¬ç‰¹å¾ï¼ŒåŒæ—¶éœ€è¦ç»¼åˆè€ƒè™‘ç½‘é¡µç»“æž„ç‰¹å¾å’Œç”¨æˆ·è¡Œä¸ºç‰¹å¾ç­‰ã€‚ å¼€æ”¾å¼å®žä½“æŠ½å–å¼€æ”¾å¼å®žä½“æŠ½å–å…³æ³¨çš„æ˜¯ä»Žæµ·é‡ã€å†—ä½™ã€ä¸è§„èŒƒçš„ç½‘ç»œæ•°æ®æºä¸ŠæŠ½å–å‡ºç¬¦åˆæŸä¸ªè¯­ä¹‰ç±»çš„å®žä½“åˆ—è¡¨ï¼Œä¾§é‡äºŽæŠ½å–ã€‚ åŸºäºŽè¿™æ ·çš„å‡è®¾ï¼šåŒç±»å®žä½“åœ¨ç½‘ç»œä¸Šå…·æœ‰ç›¸ä¼¼çš„ç½‘é¡µç»“æž„æˆ–è€…ç›¸ä¼¼çš„ä¸Šä¸‹æ–‡ç‰¹å¾ã€‚å› æ­¤å¯ä»¥æ ¹æ®ç»™å‡ºçš„ç‰¹å®šè¯­ä¹‰ç±»çš„è‹¥å¹²å®žä½“ï¼ˆâ€œç§å­â€ï¼‰ï¼Œæ‰¾å‡ºè¯¥è¯­ä¹‰ç±»åŒ…å«çš„å…¶ä»–å®žä½“ï¼Œå…¶ä¸­ç‰¹å®šè¯­ä¹‰ç±»çš„æ ‡ç­¾å¯èƒ½æ˜¯æ˜¾å¼ï¼Œä¹Ÿå¯èƒ½æ˜¯éšå¼ç»™å‡ºçš„ã€‚å¦‚ç»™å‡ºâ€œä¸­å›½ã€ç¾Žå›½ã€ä¿„ç½—æ–¯â€è¿™ä¸‰ä¸ªå®žä½“ï¼Œè¦æ±‚æ‰¾å‡ºâ€œå›½å®¶â€è¿™ä¸ªè¯­ä¹‰ç±»çš„å…¶ä»–å®žä½“è¯¸å¦‚â€œå¾·å›½ã€æ³•å›½ã€æ—¥æœ¬â€ç­‰ã€‚ è®­ç»ƒæ­¥éª¤åŒ…å«ä¸¤éƒ¨åˆ†ï¼šå€™é€‰å®žä½“èŽ·å–å’Œå€™é€‰å®žä½“ç½®ä¿¡åº¦è®¡ç®—å’ŒæŽ’åºã€‚ å…·ä½“è®­ç»ƒè¿‡ç¨‹ï¼šé€šå¸¸ä»Žç§å­å®žä½“å‡ºå‘ï¼Œé€šè¿‡åˆ†æžç§å­å®žä½“åœ¨è¯­æ–™ä¸­çš„ä¸Šä¸‹æ–‡ç‰¹å¾å¾—åˆ°æ¨¡æ¿ï¼Œæ ¹æ®æ¨¡æ¿å¾—åˆ°æ›´å¤šå€™é€‰å®žä½“ï¼Œé€‰å–ç½®ä¿¡åº¦é«˜çš„å€™é€‰å®žä½“ä½œä¸ºæ–°ç§å­è¿›è¡Œè¿­ä»£ï¼Œæ»¡è¶³ä¸€å®šæ¡ä»¶åŽåœæ­¢è¿­ä»£ï¼Œ è¿”å›žåŽ†æ¬¡ç½®ä¿¡åº¦é«˜çš„å€™é€‰å®žä½“ä½œä¸ºç»“æžœè¾“å‡ºã€‚ æŠ½å–æ¯”è¯†åˆ«åœ¨ä»»åŠ¡ä¸Šæ›´åŠ åº•å±‚ï¼Œå®žä½“æŠ½å–çš„ç»“æžœå¯ä»¥ä½œä¸ºåˆ—è¡¨æ”¯æ’‘å®žä½“çš„è¯†åˆ«ã€‚ å¯¹äºŽä¸­æ–‡è€Œè¨€ï¼Œå½“ä¸å­˜åœ¨ç½‘é¡µç»“æž„ç‰¹å¾æ—¶ï¼Œå®žä½“æŠ½å–ä»»åŠ¡å˜å¾—æ›´åŠ å›°éš¾ï¼Œå…¶ä¸­ä¸€ä¸ªé‡è¦åŽŸå› æ¥è‡ªæ±‰è¯­åˆ†è¯ï¼ŒæœªçŸ¥å®žä½“å¾€å¾€åœ¨åˆ†è¯è¿‡ç¨‹ä¸­è¢«åˆ†å¼€ã€‚ å®žä½“æ¶ˆæ­§Entity disambiguationçš„éš¾ç‚¹åœ¨äºŽæŒ‡ç§°é¡¹å¤šæ ·æ€§ï¼ˆname variationï¼‰å’ŒæŒ‡ç§°é¡¹æ­§ä¹‰ï¼ˆname ambiguityï¼‰ã€‚æŒ‡ç§°é¡¹å¤šæ ·æ€§æŒ‡ä¸€ä¸ªå®žä½“æ¦‚å¿µå¯ä»¥ç”¨å¤šç§å‘½åæ€§æŒ‡ç§°é¡¹æŒ‡ç§°ï¼Œå¦‚å…¨ç§°ã€åˆ«ç§°ã€ç®€ç§°ã€æ‹¼å†™é”™è¯¯ã€å¤šè¯­è¨€åç§°ç­‰ã€‚ å•è¯­è¨€çš„å®žä½“æ¶ˆæ­§é—®é¢˜çš„ä¸»è¦æ–¹æ³•ï¼š å®žä½“èšç±»æ¶ˆæ­§æ³•ï¼šå¯¹æ¯ä¸€ä¸ªå®žä½“æŒ‡ç§°é¡¹æŠ½å–å…¶ä¸Šä¸‹æ–‡ç‰¹å¾ï¼ˆåŒ…æ‹¬è¯ã€å®žä½“ç­‰ï¼‰ï¼Œå¹¶å°†å…¶è¡¨ç¤ºæˆç‰¹å¾å‘é‡ï¼›ç„¶åŽè®¡ç®—å®žä½“æŒ‡ç§°é¡¹ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼›è®¡ç®—åŸºäºŽæŒ‡ç§°é¡¹ä¹‹é—´çš„ç›¸ä¼¼åº¦æ—¶ï¼Œå¯é‡‡ç”¨ä¸€å®šèšç±»ç®—æ³•å°†å…¶èšç±»ï¼Œå°†æ¯ä¸ªç±»çœ‹ä½œä¸€ä¸ªå®žä½“æ¦‚å¿µã€‚è¿™ç§æ–¹æ³•çš„æ ¸å¿ƒä»»åŠ¡æ˜¯è®¡ç®—å®žä½“æŒ‡ç§°é¡¹ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼Œ ä¼ ç»Ÿçš„æ–¹æ³•æ˜¯åˆ©ç”¨ä¸Šä¸‹æ–‡çš„è¯ä¿¡æ¯å»ºç«‹è¯è¢‹æ¨¡åž‹ï¼ˆbag-of-words, BOWï¼‰ã€‚ é’ˆå¯¹äººåæ¶ˆæ­§ï¼Œé‡‡ç”¨åŸºäºŽå›¾çš„ç®—æ³•ï¼Œåˆ©ç”¨ç¤¾ä¼šåŒ–å…³ç³»çš„ä¼ é€’æ€§è€ƒè™‘éšè—çš„å®žä½“å…³ç³»çŸ¥è¯†ã€‚ åˆ©ç”¨çŸ¥è¯†èµ„æºï¼Œå¦‚Wikipediaã€Webä¸Šçš„é“¾æŽ¥ä¿¡æ¯ã€å‘½åå®žä½“çš„åŒçŽ°ä¿¡æ¯ã€é¢†åŸŸç‰¹å®šè¯­æ–™åº“ç­‰ï¼Œæ¥æå‡å®žä½“æ¶ˆæ­§çš„æ•ˆæžœã€‚ å®žä½“é“¾æŽ¥æ¶ˆæ­§æ³•ï¼šå®žä½“é“¾æŽ¥ï¼ˆentity linkingï¼‰ä¹Ÿç§°å®žä½“åˆ†è¾¨æˆ–å®žä½“è§£æžï¼ˆentity resolutionï¼‰ï¼Œæˆ–è®°å½•é“¾æŽ¥ï¼ˆrecord linkageï¼‰ã€‚åŸºäºŽå®žä½“é“¾æŽ¥æ¶ˆæ­§æ³•çš„ç›®çš„æ˜¯è§£å†³åŸºäºŽèšç±»çš„å®žä½“æ¶ˆæ­§æ³•ä¸èƒ½æ˜¾å¼åœ°ç»™å‡ºå®žä½“è¯­ä¹‰ä¿¡æ¯çš„é—®é¢˜ï¼Œå…¶åŸºæœ¬ä»»åŠ¡æ˜¯ï¼šç»™å®šä¸€ä¸ªå®žä½“æŒ‡ç§°é¡¹ï¼Œå°†å…¶é“¾æŽ¥åˆ°çŸ¥è¯†åº“ä¸­çš„å®žä½“æ¦‚å¿µä¸Šã€‚å®žä½“é“¾æŽ¥çš„æ ¸å¿ƒä»»åŠ¡ä»æ˜¯è®¡ç®—å®žä½“æŒ‡ç§°é¡¹å’Œå€™é€‰å®žä½“ä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼Œé€‰æ‹©ç›¸ä¼¼åº¦æœ€å¤§çš„å€™é€‰å®žä½“ä½œä¸ºé“¾æŽ¥çš„ç›®æ ‡å®žä½“ã€‚ å®žä½“æ¶ˆæ­§ä»é¢ä¸´å¾ˆå¤šéš¾é¢˜ï¼ŒåŒ…æ‹¬ç©ºç›®æ ‡å®žä½“é—®é¢˜ï¼ˆNIL entity problemï¼‰ï¼ˆå³å®žä½“çŸ¥è¯†åº“ä¸­ä¸åŒ…å«æŸæŒ‡ç§°é¡¹çš„ç›®æ ‡å®žä½“ï¼‰ã€çŸ¥è¯†åº“è¦†ç›–åº¦æœ‰é™ã€æ¥è‡ªäº’è”ç½‘çš„çŸ¥è¯†æºå¯é æ€§å·®å’ŒçŸ¥è¯†åº“ä½¿ç”¨æ–¹æ³•å•ä¸€ï¼ˆé›†ä¸­äºŽä½¿ç”¨å•æ–‡æ¡£ç‰¹å¾ï¼‰ç­‰ã€‚ å¼€æ”¾å¼å®žä½“å…³ç³»æŠ½å–å®žä½“å…³ç³»é€šå¸¸é‡‡ç”¨é‡‡ç”¨ä¸‰å…ƒç»„è¡¨ç¤ºï¼š(Arg1, Pred, Arg2)ï¼Œ å…¶ä¸­ï¼ŒArg1è¡¨ç¤ºå®žä½“ï¼ŒArg2è¡¨ç¤ºå®žä½“å…³ç³»å€¼ï¼Œé€šå¸¸ä¹Ÿæ˜¯å®žä½“ï¼ŒPredè¡¨ç¤ºå…³ç³»åç§°ï¼Œé€šå¸¸ä¸ºåŠ¨è¯ã€åè¯æˆ–è€…åè¯çŸ­è¯­ã€‚]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Information Retrieval</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java BitMap å’Œ Bloom Filter]]></title>
    <url>%2Fjava-BitMap%2F</url>
    <content type="text"><![CDATA[Bit MapBit-mapç”¨ä¸€ä¸ªbitä½æ¥æ ‡è®°æŸä¸ªå…ƒç´ å¯¹åº”çš„Valueï¼Œ è€ŒKeyå³æ˜¯è¯¥å…ƒç´ ã€‚ç”±äºŽé‡‡ç”¨äº†Bitä¸ºå•ä½æ¥å­˜å‚¨æ•°æ®ï¼Œå› æ­¤åœ¨å­˜å‚¨ç©ºé—´æ–¹é¢ï¼Œå¯ä»¥å¤§å¤§èŠ‚çœã€‚å‡è®¾æˆ‘ä»¬è¦å¯¹0-7å†…çš„5ä¸ªå…ƒç´ 4,7,2,5,3æŽ’åºï¼ˆå‡è®¾è¿™äº›å…ƒç´ æ²¡æœ‰é‡å¤ï¼‰ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é‡‡ç”¨Bit-mapçš„æ–¹æ³•æ¥è¾¾åˆ°æŽ’åºçš„ç›®çš„ã€‚è¦è¡¨ç¤º8ä¸ªæ•°ï¼Œæˆ‘ä»¬å°±åªéœ€è¦8ä¸ªBitï¼ˆ1Bytesï¼‰ï¼Œ é¦–å…ˆæˆ‘ä»¬å¼€è¾Ÿ1Byteçš„ç©ºé—´ï¼Œå°†è¿™äº›ç©ºé—´çš„æ‰€æœ‰Bitä½éƒ½ç½®ä¸º0ï¼Œ0 0 0 0 0 0 0 0. ç„¶åŽéåŽ†è¿™5ä¸ªå…ƒç´ ï¼Œé¦–å…ˆç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯4ï¼Œé‚£ä¹ˆå°±æŠŠ4å¯¹åº”çš„ä½ç½®è®¾ä¸º1, p+(i/8)|(0x01&lt;&lt;(i%8)), è¿™é‡Œé»˜è®¤ä¸ºBig-ending, 0 0 0 0 1 0 0 0. ç„¶åŽå†å¤„ç†ç¬¬äºŒä¸ªå…ƒç´ 7ï¼Œå°†ç¬¬å…«ä½ç½®ä¸º1,ï¼ŒæŽ¥ç€å†å¤„ç†ç¬¬ä¸‰ä¸ªå…ƒç´ ï¼Œä¸€ç›´åˆ°æœ€åŽå¤„ç†å®Œæ‰€æœ‰çš„å…ƒç´ ï¼Œå°†ç›¸åº”çš„ä½ç½®ä¸º1ï¼Œè¿™æ—¶å€™çš„å†…å­˜çš„Bitä½çš„çŠ¶æ€0 0 1 1 1 1 0 1 éåŽ†ä¸€éBitåŒºåŸŸï¼ŒæŠŠ1çš„ç´¢å¼•ä¾æ¬¡è¾“å‡ºï¼ˆ2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ7ï¼‰ï¼Œè¿™æ ·å°±è¾¾åˆ°äº†æŽ’åºçš„ç›®çš„ã€‚ ç®—æ³•çš„å…³é”®æ˜¯å¦‚ä½•ç¡®å®šåè¿›åˆ¶çš„æ•°æ˜ å°„åˆ°äºŒè¿›åˆ¶bitä½çš„mapå›¾ã€‚ç®—æ³•å ç”¨å¾ˆå°‘å†…å­˜ï¼Œæ¯”å¦‚N=10000000ï¼›åªéœ€å ç”¨å†…å­˜ä¸ºN/8=1250000Byte=1.25Mã€‚ç¼ºç‚¹æ˜¯ä¸èƒ½æœ‰é‡å¤æ•°æ®ã€‚ Mapæ˜ å°„è¡¨å‡è®¾éœ€è¦æŽ’åºæˆ–è€…æŸ¥æ‰¾çš„æ€»æ•°N=10000000ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ç”³è¯·å†…å­˜ç©ºé—´çš„å¤§å°ä¸ºint a[1 + N/32]ï¼Œå…¶ä¸­ï¼ša[0]åœ¨å†…å­˜ä¸­å 32ä½, å¯ä»¥å¯¹åº”åè¿›åˆ¶æ•°0-31ï¼Œä¾æ¬¡ç±»æŽ¨ï¼šbitmapè¡¨ä¸ºï¼š12345a[0]---------&gt;0-31a[1]---------&gt;32-63a[2]---------&gt;64-95a[3]---------&gt;96-127.......... åè¿›åˆ¶æ•°éœ€è¦è½¬æ¢ä¸ºå¯¹åº”çš„bitä½ ä½ç§»è½¬æ¢å°†åè¿›åˆ¶æ•°è½¬æ¢ä¸ºå¯¹åº”çš„bitä½, ç”³è¯·ä¸€ä¸ªintä¸€ç»´æ•°ç»„ï¼Œä½œä¸º32åˆ—çš„äºŒç»´æ•°ç»„ï¼Œ1234567int a[0] |0000000000000000000000000000000000000|int a[1] |0000000000000000000000000000000000000|â€¦â€¦â€¦â€¦â€¦â€¦int a[N] |0000000000000000000000000000000000000| ä¾‹å¦‚åè¿›åˆ¶0ï¼Œå¯¹åº”åœ¨a[0]ç¬¬ä¸€ä½ï¼š 00000000000000000000000000000001 æ±‚åè¿›åˆ¶0-Nå¯¹åº”åœ¨æ•°ç»„açš„ç´¢å¼•ï¼šåè¿›åˆ¶0-31ï¼Œå¯¹åº”a[0]ï¼Œå…ˆç”±åè¿›åˆ¶æ•°nè½¬æ¢ä¸ºä¸Ž32çš„ä½™å¯è½¬åŒ–ä¸ºå¯¹åº”åœ¨æ•°ç»„aä¸­çš„ç´¢å¼•0ã€‚æ¯”å¦‚n=24,é‚£ä¹ˆ n/32=0ï¼Œåˆ™24å¯¹åº”a[0]ã€‚åˆæ¯”å¦‚n=60, é‚£ä¹ˆn/32=1ï¼Œåˆ™60å¯¹åº”a[1]ã€‚ æ±‚0-Nå¯¹åº”0-31ä¸­çš„æ•°ï¼šåè¿›åˆ¶0-31å°±å¯¹åº”0-31ï¼Œè€Œ32-63åˆ™å¯¹åº”ä¹Ÿæ˜¯0-31ï¼Œå³ç»™å®šä¸€ä¸ªæ•°nå¯ä»¥é€šè¿‡æ¨¡32æ±‚å¾—å¯¹åº”0-31ä¸­çš„æ•°ã€‚ åˆ©ç”¨ç§»ä½0-31ä½¿å¾—å¯¹åº”32bitä½ä¸º1. æ‰¾åˆ°å¯¹åº”0-31çš„æ•°ä¸ºM, å·¦ç§»Mä½ï¼šå³2 ^ M, ç½®1. Bloom Filterä¸ºäº†é™ä½Žé”®å€¼å†²çªçš„æ¦‚çŽ‡ï¼ŒBloom Filterä½¿ç”¨äº†å¤šä¸ªå“ˆå¸Œå‡½æ•°ï¼šåˆ›å»ºä¸€ä¸ªmä½BitSetï¼Œå…ˆå°†æ‰€æœ‰ä½åˆå§‹åŒ–ä¸º0ï¼Œç„¶åŽé€‰æ‹©kä¸ªä¸åŒçš„å“ˆå¸Œå‡½æ•°ã€‚ç¬¬iä¸ªå“ˆå¸Œå‡½æ•°å¯¹å­—ç¬¦ä¸²strå“ˆå¸Œçš„ç»“æžœè®°ä¸ºh(i, str)ï¼Œä¸”h(i, str)çš„èŒƒå›´æ˜¯0åˆ°m-1 ã€‚ å¯¹äºŽå­—ç¬¦ä¸²strï¼Œåˆ†åˆ«è®¡ç®—h(1, str), h(2, str), ... h(k, str), ä»¥è¿™äº›å“ˆå¸Œå€¼ä½œä¸ºç´¢å¼•, å°†BitSetçš„å¯¹åº”ä½ç½®çš„ä½è®¾ä¸º1, è¿™æ ·å°±æŠŠstræ˜ å°„åˆ°BitSetçš„kä¸ªäºŒè¿›åˆ¶ä½äº†. å¦‚æžœè¦æ£€æŸ¥æŸstringæ˜¯å¦å·²ç»è¢«è®°å½•åœ¨BitSetä¸­, åªéœ€è¦è®¡ç®—å…¶å“ˆå¸Œå€¼æ•°ç»„, å¹¶æ£€æŸ¥BitSetä¸Šå¯¹åº”ä½ç½®çš„å€¼æ˜¯å¦ä¸º1, è‹¥å¯¹åº”ä½ç½®ä¸­æœ‰ä»»ä½•ä¸€ä¸ªä¸æ˜¯1, é‚£ä¹ˆè¯¥å­—ç¬¦ä¸²ä¸€å®šæ²¡æœ‰è¢«è®°å½•è¿‡, è‹¥å…¨éƒ¨å¯¹åº”ä½ç½®éƒ½ä¸º1, é‚£ä¹ˆæŒ‰ç…§false positiveè®¤ä¸ºè¯¥å­—ç¬¦ä¸²å·²ç»è¢«è®°å½•è¿‡äº†(ä½†ä¸æ˜¯100%è‚¯å®š). åˆ é™¤æ“ä½œä¼šå½±å“åˆ°å…¶ä»–å­—ç¬¦ä¸²ã€‚å¦‚æžœéœ€è¦åˆ é™¤å­—ç¬¦ä¸²çš„åŠŸèƒ½ï¼Œä½¿ç”¨Counting bloomfilter(CBF)ï¼Œè¿™æ˜¯ä¸€ç§Bloom Filterçš„å˜ä½“ï¼ŒCBFå°†Bloom Filteræ¯ä¸€ä¸ªBitæ”¹ä¸ºä¸€ä¸ªè®¡æ•°å™¨ï¼Œè¿™æ ·å°±å¯ä»¥å®žçŽ°åˆ é™¤å­—ç¬¦ä¸²çš„åŠŸèƒ½äº†ã€‚ Bloom Filterè·Ÿå•å“ˆå¸Œå‡½æ•°Bit-Mapä¸åŒä¹‹å¤„åœ¨äºŽï¼šBloom Filterä½¿ç”¨äº†kä¸ªå“ˆå¸Œå‡½æ•°ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²è·Ÿkä¸ªbitå¯¹åº”ã€‚ä»Žè€Œé™ä½Žäº†å†²çªçš„æ¦‚çŽ‡ã€‚ æ‰€ä»¥Bloom Filteré€‚ç”¨ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š åªè¦è¿”å›žæ•°æ®ä¸å­˜åœ¨ï¼Œåˆ™è‚¯å®šä¸å­˜åœ¨ã€‚ è¿”å›žæ•°æ®å­˜åœ¨ï¼Œä½†åªèƒ½æ˜¯å¤§æ¦‚çŽ‡å­˜åœ¨ã€‚ ä¸èƒ½æ¸…é™¤å…¶ä¸­çš„æ•°æ®ã€‚ BloomFilterçš„åº”ç”¨å¾ˆå¤šï¼Œæ¯”å¦‚æ•°æ®åº“ã€çˆ¬è™«ï¼ˆç”¨çˆ¬è™«æŠ“å–ç½‘é¡µæ—¶å¯¹ç½‘é¡µurlåŽ»é‡ï¼‰ã€é˜²ç¼“å­˜å‡»ç©¿ç­‰ã€‚ç‰¹åˆ«æ˜¯éœ€è¦ç²¾ç¡®çŸ¥é“æŸä¸ªæ•°æ®ä¸å­˜åœ¨æ—¶åšç‚¹ä»€ä¹ˆäº‹æƒ…å°±éžå¸¸é€‚åˆå¸ƒéš†è¿‡æ»¤ã€‚ Goolgeåœ¨BigTableä¸­å°±ä½¿ç”¨äº†BloomFilterï¼Œä»¥é¿å…åœ¨ç¡¬ç›˜ä¸­å¯»æ‰¾ä¸å­˜åœ¨çš„æ¡ç›®ã€‚ å®žçŽ°Javaå®žçŽ°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118ä½œè€…ï¼šcrossoverJieé“¾æŽ¥ï¼šhttps://zhuanlan.zhihu.com/p/50926087æ¥æºï¼šçŸ¥ä¹Žè‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…èŽ·å¾—æŽˆæƒï¼Œéžå•†ä¸šè½¬è½½è¯·æ³¨æ˜Žå‡ºå¤„ã€‚public class BloomFilters &#123; /** * æ•°ç»„é•¿åº¦ */ private int arraySize; /** * æ•°ç»„ */ private int[] array; public BloomFilters(int arraySize) &#123; this.arraySize = arraySize; array = new int[arraySize]; &#125; /** * å†™å…¥æ•°æ® * @param key */ public void add(String key) &#123; int first = hashcode_1(key); int second = hashcode_2(key); int third = hashcode_3(key); array[first % arraySize] = 1; array[second % arraySize] = 1; array[third % arraySize] = 1; &#125; /** * åˆ¤æ–­æ•°æ®æ˜¯å¦å­˜åœ¨ * @param key * @return */ public boolean check(String key) &#123; int first = hashcode_1(key); int second = hashcode_2(key); int third = hashcode_3(key); int firstIndex = array[first % arraySize]; if (firstIndex == 0) &#123; return false; &#125; int secondIndex = array[second % arraySize]; if (secondIndex == 0) &#123; return false; &#125; int thirdIndex = array[third % arraySize]; if (thirdIndex == 0) &#123; return false; &#125; return true; &#125; /** * hash ç®—æ³•1 * @param key * @return */ private int hashcode_1(String key) &#123; int hash = 0; int i; for (i = 0; i &lt; key.length(); ++i) &#123; hash = 33 * hash + key.charAt(i); &#125; return Math.abs(hash); &#125; /** * hash ç®—æ³•2 * @param data * @return */ private int hashcode_2(String data) &#123; final int p = 16777619; int hash = (int) 2166136261L; for (int i = 0; i &lt; data.length(); i++) &#123; hash = (hash ^ data.charAt(i)) * p; &#125; hash += hash &lt;&lt; 13; hash ^= hash &gt;&gt; 7; hash += hash &lt;&lt; 3; hash ^= hash &gt;&gt; 17; hash += hash &lt;&lt; 5; return Math.abs(hash); &#125; /** * hash ç®—æ³•3 * @param key * @return */ private int hashcode_3(String key) &#123; int hash, i; for (hash = 0, i = 0; i &lt; key.length(); ++i) &#123; hash += key.charAt(i); hash += (hash &lt;&lt; 10); hash ^= (hash &gt;&gt; 6); &#125; hash += (hash &lt;&lt; 3); hash ^= (hash &gt;&gt; 11); hash += (hash &lt;&lt; 15); return Math.abs(hash); &#125;&#125; Guava å®žçŽ°12345678910111213141516171819@Testpublic void guavaTest() &#123; long star = System.currentTimeMillis(); BloomFilter&lt;Integer&gt; filter = BloomFilter.create( Funnels.integerFunnel(), 10000000, 0.01); for (int i = 0; i &lt; 10000000; i++) &#123; filter.put(i); &#125; Assert.assertTrue(filter.mightContain(1)); Assert.assertTrue(filter.mightContain(2)); Assert.assertTrue(filter.mightContain(3)); Assert.assertFalse(filter.mightContain(10000000)); long end = System.currentTimeMillis(); System.out.println("æ‰§è¡Œæ—¶é—´ï¼š" + (end - star));&#125; æž„é€ æ–¹æ³•æœ‰ä¸¤ä¸ªæ¯”è¾ƒé‡è¦çš„å‚æ•°ï¼Œä¸€ä¸ªæ˜¯é¢„è®¡å­˜æ”¾å¤šå°‘æ•°æ®ï¼Œä¸€ä¸ªæ˜¯å¯ä»¥æŽ¥å—çš„è¯¯æŠ¥çŽ‡ã€‚Guava ä¼šé€šè¿‡ä½ é¢„è®¡çš„æ•°é‡ä»¥åŠè¯¯æŠ¥çŽ‡å¸®ä½ è®¡ç®—å‡ºä½ åº”å½“ä¼šä½¿ç”¨çš„æ•°ç»„å¤§å° numBits ä»¥åŠéœ€è¦è®¡ç®—å‡ æ¬¡ Hash å‡½æ•° numHashFunctions ã€‚1234567891011121314151617181920212223242526@VisibleForTestingstatic &lt;T&gt; BloomFilter&lt;T&gt; create( Funnel&lt;? super T&gt; funnel, long expectedInsertions, double fpp, Strategy strategy) &#123; checkNotNull(funnel); checkArgument( expectedInsertions &gt;= 0, "Expected insertions (%s) must be &gt;= 0", expectedInsertions); checkArgument(fpp &gt; 0.0, "False positive probability (%s) must be &gt; 0.0", fpp); checkArgument(fpp &lt; 1.0, "False positive probability (%s) must be &lt; 1.0", fpp); checkNotNull(strategy); if (expectedInsertions == 0) &#123; expectedInsertions = 1; &#125; /* * TODO(user): Put a warning in the javadoc about tiny fpp values, since the resulting size * is proportional to -log(p), but there is not much of a point after all, e.g. * optimalM(1000, 0.0000000000000001) = 76680 which is less than 10kb. Who cares! */ long numBits = optimalNumOfBits(expectedInsertions, fpp); int numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits); try &#123; return new BloomFilter&lt;T&gt;(new LockFreeBitArray(numBits), numHashFunctions, funnel, strategy); &#125; catch (IllegalArgumentException e) &#123; throw new IllegalArgumentException("Could not create BloomFilter of " + numBits + " bits", e); &#125;&#125; putæœ‰ä¸åŒçš„ç­–ç•¥ï¼Œå¦‚MURMUR128_MITZ_64()ç­–ç•¥æ ¹æ® murmur3_128 æ–¹æ³•çš„åˆ°ä¸€ä¸ª 128 ä½é•¿åº¦çš„ byte[]ã€‚åˆ†åˆ«å–é«˜ä½Ž 8 ä½çš„åˆ°ä¸¤ä¸ª hash å€¼(lowerEight, upperEight)ã€‚å†æ ¹æ®åˆå§‹åŒ–æ—¶çš„åˆ°çš„æ‰§è¡Œ hash çš„æ¬¡æ•°è¿›è¡Œ hash è¿ç®—ã€‚12345678910111213141516171819202122232425/** * This strategy uses all 128 bits of &#123;@link Hashing#murmur3_128&#125; when hashing. It looks different * than the implementation in MURMUR128_MITZ_32 because we're avoiding the multiplication in the * loop and doing a (much simpler) += hash2. We're also changing the index to a positive number by * AND'ing with Long.MAX_VALUE instead of flipping the bits. */MURMUR128_MITZ_64() &#123; @Override public &lt;T&gt; boolean put( T object, Funnel&lt;? super T&gt; funnel, int numHashFunctions, LockFreeBitArray bits) &#123; long bitSize = bits.bitSize(); byte[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal(); long hash1 = lowerEight(bytes); long hash2 = upperEight(bytes); boolean bitsChanged = false; long combinedHash = hash1; for (int i = 0; i &lt; numHashFunctions; i++) &#123; // Make the combined hash positive and indexable bitsChanged |= bits.set((combinedHash &amp; Long.MAX_VALUE) % bitSize); combinedHash += hash2; &#125; return bitsChanged; &#125;&#125; LockFreeBitArrayå°±æ˜¯çœŸæ­£å­˜æ”¾æ•°æ®çš„åº•å±‚æ•°æ®ç»“æž„ã€‚åˆ©ç”¨äº†ä¸€ä¸ª AtomicLongArray data æ¥å­˜æ”¾æ•°æ®ã€‚æ‰€ä»¥ set() æ—¶å€™ä¹Ÿæ˜¯å¯¹è¿™ä¸ª data åšå¤„ç†ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Models a lock-free array of bits. * * &lt;p&gt;We use this instead of java.util.BitSet because we need access to the array of longs and we * need compare-and-swap. */static final class LockFreeBitArray &#123; private static final int LONG_ADDRESSABLE_BITS = 6; final AtomicLongArray data; private final LongAddable bitCount; LockFreeBitArray(long bits) &#123; this(new long[Ints.checkedCast(LongMath.divide(bits, 64, RoundingMode.CEILING))]); &#125; // Used by serialization LockFreeBitArray(long[] data) &#123; checkArgument(data.length &gt; 0, "data length is zero!"); this.data = new AtomicLongArray(data); this.bitCount = LongAddables.create(); long bitCount = 0; for (long value : data) &#123; bitCount += Long.bitCount(value); &#125; this.bitCount.add(bitCount); &#125; /** Returns true if the bit changed value. */ boolean set(long bitIndex) &#123; if (get(bitIndex)) &#123; return false; &#125; int longIndex = (int) (bitIndex &gt;&gt;&gt; LONG_ADDRESSABLE_BITS); long mask = 1L &lt;&lt; bitIndex; // only cares about low 6 bits of bitIndex long oldValue; long newValue; do &#123; oldValue = data.get(longIndex); newValue = oldValue | mask; if (oldValue == newValue) &#123; return false; &#125; &#125; while (!data.compareAndSet(longIndex, oldValue, newValue)); // We turned the bit on, so increment bitCount. bitCount.increment(); return true; &#125;&#125; åœ¨ set() ä¹‹å‰å…ˆé€šè¿‡ get() åˆ¤æ–­è¿™ä¸ªæ•°æ®æ˜¯å¦å­˜åœ¨äºŽé›†åˆä¸­ï¼Œå¦‚æžœå·²ç»å­˜åœ¨åˆ™ç›´æŽ¥è¿”å›žå‘ŠçŸ¥å®¢æˆ·ç«¯å†™å…¥å¤±è´¥ã€‚æŽ¥ä¸‹æ¥å°±æ˜¯é€šè¿‡ä½è¿ç®—è¿›è¡Œä½æˆ–èµ‹å€¼ã€‚get() æ–¹æ³•çš„è®¡ç®—é€»è¾‘å’Œ set() ç±»ä¼¼ï¼Œåªè¦åˆ¤æ–­ä¸º 0 å°±ç›´æŽ¥è¿”å›žå­˜åœ¨è¯¥å€¼ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸Žä¿¡æ¯å¤„ç† 08 - æ•°æ®åŽ‹ç¼© - å“ˆå¤«æ›¼ç¼–ç ]]></title>
    <url>%2FNLP-08-data-compression-huffman-compression%2F</url>
    <content type="text"><![CDATA[é¿å…æ­§ä¹‰çš„ç¼–ç åœ¨æž„å»ºåŽ‹ç¼©ç¼–ç çš„å¯¹åº”å…³ç³»æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸åŒçš„æ•°é‡çš„ä½æ¥ç¼–ç ä¸åŒçš„å­—ç¬¦.æ¯”å¦‚æ‘©æ–¯å¯†ç . å¦‚æžœå•çº¯ä½¿ç”¨è¿™ç§å¯¹åº”å…³ç³»ï¼Œä¼šå‡ºçŽ°ä¸€äº›é—®é¢˜ï¼Œ å¦‚â€¢â€¢â€¢âˆ’âˆ’âˆ’â€¢â€¢â€¢ä¼šäº§ç”Ÿæ­§ä¹‰: SOS? V7? IAMIE? EEWNI? æ‰€ä»¥åœ¨å®žé™…ä½¿ç”¨ä¸­, å¯†ç ä½¿ç”¨ä¸€äº›é—´éš”æ¥åˆ†éš”ä»£ç å­—ã€‚ é‚£ä¹ˆå¯¹äºŽä¸åŒçš„åŽ‹ç¼©ç¼–ç , æœ‰ä»€ä¹ˆå¸¸ç”¨æ–¹æ³•æ¥é¿å…æ­§ä¹‰ï¼Ÿæ–¹æ³•æ˜¯ç¡®ä¿æ²¡æœ‰ä¸€ä¸ªç¼–ç æ˜¯å¦ä¸€ä¸ªç¼–ç çš„å‰ç¼€ã€‚æ¯”å¦‚ ä½¿ç”¨å›ºå®šé•¿åº¦ç¼–ç ã€‚ ä¸ºæ¯ä¸ªç¼–ç æ·»åŠ ç‰¹æ®Šçš„stop charã€‚ ä½¿ç”¨ä¸€ç§å…·å¤‡å¹¿æ³›ä½¿ç”¨æ€§çš„prefix-freeç¼–ç ã€‚ ç”¨ä»€ä¹ˆæ•°æ®ç»“æž„æ¥è®¾è®¡prefix-freeç¼–ç ? ç”¨Trieæž„é€ ç¼–ç ä¸€ä¸ªäºŒå‰(0, 1)Trie: å¶èŠ‚ç‚¹æ˜¯å­—ç¬¦, æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„å°±æ˜¯ç¼–ç . åŽ‹ç¼©:æ–¹æ³•1ï¼šä»Žå¶å¼€å§‹; æŒ‰ç…§è·¯å¾„åˆ°è¾¾æ ¹; åå‘æ‰“å°bitsã€‚æ–¹æ³•2ï¼šåˆ›å»ºé”®-å€¼å¯¹çš„ç¬¦å·è¡¨ã€‚ è§£åŽ‹: ä»Žæ ¹èŠ‚ç‚¹å¼€å§‹, æ ¹æ®ä½å€¼æ˜¯0è¿˜æ˜¯1åœ¨Trieå›¾ä¸Šæ¸¸èµ°, ç›´åˆ°èµ°åˆ°å¶èŠ‚ç‚¹ï¼Œåˆ™è§£åŽ‹å‡ºä¸€ä¸ªå­—ç¬¦ è¿”å›žæ ¹èŠ‚ç‚¹, ç»§ç»­ç¬¬ä¸€æ­¥, ç›´åˆ°è·‘å®Œæ‰€æœ‰ç¼–ç . 1234567891011121314151617181920212223242526272829303132333435363738394041private static class Node implements Comparable&lt;Node&gt;&#123; private final char ch; // used only for leaf nodes private final int freq; // used only for compress private final Node left, right; public Node(char ch, int freq, Node left, Node right) &#123; this.ch = ch; this.freq = freq; this.left = left; this.right = right; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; // compare Nodes by frequency public int compareTo(Node that) &#123; return this.freq - that.freq; &#125; // Runtime - Linear in input size N public void expand() &#123; Node root = readTrie(); // read in encoding trie int N = BinaryStdIn.readInt(); // read in number of chars for (int i = 0; i &lt; N; i++) &#123; Node x = root; while (!x.isLeaf()) &#123; if (!BinaryStdIn.readBoolean()) x = x.left; else x = x.right; &#125; BinaryStdOut.write(x.ch, 8); &#125; BinaryStdOut.close(); &#125;&#125; å¦‚ä½•è¯»å–ä¸€ä¸ªTrieï¼šæ ¹æ®Trieçš„å‰åºéåŽ†åºåˆ—é‡æž„.1234567891011private static Node readTrie()&#123; if (BinaryStdIn.readBoolean()) &#123; char c = BinaryStdIn.readChar(8); return new Node(c, 0, null, null); &#125; Node x = readTrie(); Node y = readTrie(); return new Node('\0', 0, x, y);&#125; å¦‚ä½•æŠŠTrieå†™ä¸ºåºåˆ—ï¼šä»¥å‰åºéåŽ†çš„æ–¹å¼å†™Trieï¼›é¢å¤–ç”¨ä¸€ä¸ªä½æ ‡è®°æ˜¯å¦å¶èŠ‚ç‚¹ã€‚123456789101112private static void writeTrie(Node x)&#123; if (x.isLeaf()) &#123; BinaryStdOut.write(true); BinaryStdOut.write(x.ch, 8); return; &#125; BinaryStdOut.write(false); writeTrie(x.left); writeTrie(x.right);&#125; ç”¨å“ˆå¤«æ›¼ç®—æ³•æž„å»ºæœ€ä¼˜ç¼–ç å°±æ˜¯ç”¨Huffmanç®—æ³•. Huffmanç®—æ³•æ˜¯æŠŠæœ€çŸ­çš„ç¼–ç èµ‹ç»™å‡ºçŽ°é¢‘çŽ‡æœ€é«˜çš„å­—ç¬¦, æŠŠæœ€é•¿çš„ç¼–ç ç•™ç»™å‡ºçŽ°é¢‘çŽ‡è¾ƒä½Žçš„å­—ç¬¦. åœ¨Trieä¸Šçš„æ•ˆæžœå°±å˜æˆé¢‘çŽ‡æœ€é«˜çš„å­—ç¬¦è·¯å¾„æœ€çŸ­, é•¿è·¯å¾„éƒ½ç•™ç»™é¢‘çŽ‡ä½Žçš„å­—ç¬¦. è¿™æ ·æ€»çš„æ•ˆæžœå°±æ˜¯ä½¿ç”¨äº†æ›´å°‘çš„æ•°æ®ä½æ¥è¡¨è¾¾åŒæ ·çš„ä¿¡æ¯. ç»Ÿè®¡è¾“å…¥çš„å„ä¸ªå­—ç¬¦çš„é¢‘çŽ‡freq[i]ã€‚ ä¸ºæ¯ä¸ªchar iæž„å»ºä¸€ä¸ªå…·æœ‰æƒé‡freq[i]çš„Trie(å­èŠ‚ç‚¹ä¸ºnull), ä»Žæ­¤èŠ‚ç‚¹å¼€å§‹ é‡å¤ä»¥ä¸‹è¿‡ç¨‹ç›´åˆ°èžåˆä¸ºä¸€ä¸ªtrie(æ ¹èŠ‚ç‚¹)ï¼š é€‰æ‹©å½“å‰æƒé‡æœ€å°çš„ä¸¤Tries, freq[i]å’Œfreq[j], å…¶ä¸­i &lt;= j, freq[i] &lt;= freq[j] ç»™å®ƒä»¬åˆ›å»ºçˆ¶èŠ‚ç‚¹, æƒé‡ä¸ºfreq[i] + freq[j], ä¸¤ä¸ªå­Trieå’Œå…¶çˆ¶èŠ‚ç‚¹åˆå¹¶ä¸ºä¸€ä¸ªTrie, è€Œä¸”è·¯å¾„0(å·¦è¾¹)æ€»æ˜¯æŒ‡å‘è¾ƒå°çš„å­Trie, è·¯å¾„1(å³è¾¹)æŒ‡å‘è¾ƒå¤§çš„. 1234567891011121314151617private static Node buildTrie(int[] freq)&#123; MinPQ&lt;Node&gt; pq = new MinPQ&lt;Node&gt;(); // initialize PQ with singleton tries for (char i = 0; i &lt; R; i++) if (freq[i] &gt; 0) pq.insert(new Node(i, freq[i], null, null)); while (pq.size() &gt; 1) &#123; // merge two smallest tries Node x = pq.delMin(); Node y = pq.delMin(); Node parent = new Node('\0', x.freq + y.freq, x, y); pq.insert(parent); &#125; return pq.delMin();&#125; é€šè¿‡è¿™ä¸ªç®—æ³•, å¯ä»¥ä¿è¯é¢‘çŽ‡æœ€é«˜(æƒé‡æœ€å¤§)çš„å­—ç¬¦çš„å¶èŠ‚ç‚¹å°±æ˜¯æœ€å·¦å¶èŠ‚ç‚¹, ä¸€èˆ¬ç¼–ç ä¸º0, å…¶ä»–ä¾æ¬¡ç±»æŽ¨. å¯ä»¥è¯æ˜ŽHuffmanç®—æ³•ç”Ÿæˆçš„æœ€ä¼˜prefix-freeç¼–ç . å®Œæ•´ä»£ç è§ Implementation.ãƒ»Pass 1: tabulate char frequencies and build trie.ãƒ»Pass 2: encode file by traversing trie or lookup table Running time. Using a binary heap â‡’ N + R log R. N input size, R alphabet size. å¯¹äºŽå…·æœ‰nä¸ªå¶å­èŠ‚ç‚¹çš„å“ˆå¤«æ›¼æ ‘ï¼Œä¸€å…±éœ€è¦2*n-1ä¸ªèŠ‚ç‚¹: äºŒå‰æ ‘æœ‰ä¸‰ç§ç±»åž‹èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹æ•°ä¸º2çš„èŠ‚ç‚¹ï¼Œä¸º1çš„èŠ‚ç‚¹å’Œä¸º0çš„å¶èŠ‚ç‚¹ã€‚è€Œå“ˆå¤«æ›¼æ ‘çš„éžå¶å­èŠ‚ç‚¹æ˜¯ç”±ä¸¤ä¸ªèŠ‚ç‚¹ç”Ÿæˆçš„ï¼Œå› æ­¤ä¸èƒ½å‡ºçŽ°åªæœ‰å•å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼Œå¦‚æžœå¶å­èŠ‚ç‚¹ä¸ªæ•°ä¸ºn, é‚£ä¹ˆéžå¶å­èŠ‚ç‚¹çš„ä¸ªæ•°ä¸ºn-1. å“ˆå¤«æ›¼ç¼–ç å¹¿æ³›åº”ç”¨äºŽjpeg, pdf, MP3, MP4ç­‰æ–‡ä»¶ç¼–ç ä¸­. åœ¨ç¥žç»ç½‘ç»œä¸­, å“ˆå¤«æ›¼æ ‘ä¹Ÿè¢«ç”¨äºŽæž„å»ºå±‚çº§Softmax. ä¸€ä¸ªä½¿ç”¨Huffman Encodingçš„å®žä¾‹ï¼šhttps://github.com/congchan/cs106b-programming-abstraction/tree/master/HW6_Huffman%20Encoding/Huffman/src]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Algorithm</tag>
        <tag>Information Retrieval</tag>
        <tag>Data Compression</tag>
        <tag>Huffman Compression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸Žä¿¡æ¯å¤„ç† 07 - æ•°æ®åŽ‹ç¼©]]></title>
    <url>%2FNLP-07-data-compression-introduction%2F</url>
    <content type="text"><![CDATA[æ•°æ®åŽ‹ç¼©åŽ‹ç¼©æ•°æ®ä»¥èŠ‚çœå‚¨å­˜ç©ºé—´ï¼ŒèŠ‚çœä¼ è¾“æ—¶é—´ã€‚åŒæ—¶å¾ˆå¤šæ–‡ä»¶éƒ½æœ‰å¾ˆå¤šå†—ä½™ä¿¡æ¯ï¼Œè¿™ä¸ºåŽ‹ç¼©æä¾›äº†å¾ˆå¤šå¯èƒ½æ€§ã€‚é€šç”¨æ–‡ä»¶åŽ‹ç¼©Â·æ–‡ä»¶ï¼šGZIPï¼ŒBZIPï¼Œ7zÂ·Archiversï¼šPKZIPÂ·æ–‡ä»¶ç³»ç»Ÿï¼šNTFSï¼ŒHFS +ï¼ŒZFS å¤šåª’ä½“Â·å›¾åƒï¼šGIFï¼ŒJPEGÂ·å£°éŸ³ï¼šMP3Â·è§†é¢‘ï¼šMPEGï¼ŒDivXâ„¢ï¼ŒHDTV é€šè®¯Â·ITU-T T4 Group 3 FaxÂ·V.42bisè°ƒåˆ¶è§£è°ƒå™¨Â·Skype æ•°æ®åº“ åŽ‹ç¼©çŽ‡Compression ratio = Bits in Compressed B / bits in B. è‡ªç„¶è¯­è¨€çš„åŽ‹ç¼©çŽ‡ä¸º50-75ï¼…æˆ–æ›´é«˜. è¯»å†™äºŒè¿›åˆ¶12345678910111213141516public class BinaryStdIn &#123; boolean readBoolean() // read 1 bit of data and return as a boolean value char readChar() // read 8 bits of data and return as a char value char readChar(int r) // read r bits of data and return as a char value // similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits) boolean isEmpty() // is the bitstream empty? void close() // close the bitstream&#125;public class BinaryStdOut &#123; void write(boolean b) // write the specified bit void write(char c) // write the specified 8-bit char void write(char c, int r) // write the r least significant bits of the specified char // similar methods for byte (8 bits); short (16 bits); int (32 bits); long and double (64 bits) void close() // close the bitstream&#125; æ¯”å¦‚ä½¿ç”¨ä¸‰ç§æ–¹æ³•è¡¨è¾¾12/31/19991, A character stream (StdOut),1StdOut.print(month + "/" + day + "/" + year); 00110001 100110010 200101111 /00110111 300110001 100101111 /00110001 100111001 900111001 900111001 1å…± 80bits2, Three ints (BinaryStdOut)123BinaryStdOut.write(month);BinaryStdOut.write(day);BinaryStdOut.write(year); 00000000 00000000 00000000 00001100 1200000000 00000000 00000000 00011111 3100000000 00000000 00000111 11001111 1999å…±96bits3ï¼ŒA 4-bit field, a 5-bit field, and a 12-bit field (BinaryStdOut)123BinaryStdOut.write(month, 4);BinaryStdOut.write(day, 5);BinaryStdOut.write(year, 12); 1100 1211111 130111110 01111 1999å…±21bits é€šç”¨æ•°æ®åŽ‹ç¼©ç®—æ³•ï¼Ÿä¸å­˜åœ¨çš„ï¼Œå› ä¸ºå‡å¦‚çœŸçš„å­˜åœ¨ä¸€ç§å¯ä»¥åŽ‹ç¼©æ‰€æœ‰æ¯”ç‰¹ä¸²çš„ç®—æ³•ï¼Œé‚£ä¹ˆè¯¥ç®—æ³•å°±å¯ä»¥ç»§ç»­åŽ‹ç¼©å·²ç»è¢«å®ƒåŽ‹ç¼©è¿‡çš„æ•°æ®ï¼Œé‚£æ„å‘³ç€æ‰€æœ‰æ¯”ç‰¹ä¸²å¯ä»¥è¢«åŽ‹ç¼©ä¸º0æ¯”ç‰¹. Run-length encodingSimple type of redundancy in a bitstream. Long runs of repeated bitsï¼š0000000000000001111111000000011111111111Compression, 4-bit counts to represent alternating runs of 0s and 1s: 15 0s, then 7 1s, then 7 0s, then 11 1s.1111 0111 0111 1011123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class RunLength&#123; // maximum run-length count private final static int R = 256; // number of bits per count private final static int LG_R = 8; /** * Reads a sequence of bits from standard input; compresses * them using run-length coding with 8-bit run lengths; and writes the * results to standard output. */ public static void compress() &#123; char run = 0; boolean old = false; while (!BinaryStdIn.isEmpty()) &#123; boolean b = BinaryStdIn.readBoolean(); if (b != old) &#123; BinaryStdOut.write(run, LG_R); run = 1; old = !old; &#125; else &#123; // å¦‚æžœé•¿åº¦è¶…è¿‡æœ€å¤§å€¼, å†™å…¥0 if (run == R-1) &#123; BinaryStdOut.write(run, LG_R); run = 0; BinaryStdOut.write(run, LG_R); &#125; run++; &#125; &#125; BinaryStdOut.write(run, LG_R); BinaryStdOut.close(); &#125; /** * Reads a sequence of bits from standard input (that are encoded * using run-length encoding with 8-bit run lengths); decodes them; * and writes the results to standard output. */ public static void expand() &#123; boolean bit = false; while (!BinaryStdIn.isEmpty()) &#123; int run = BinaryStdIn.readInt(lgR); for (int i = 0; i &lt; run; i++) BinaryStdOut.write(bit); bit = !bit; &#125; BinaryStdOut.close(); &#125;&#125;]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Algorithm</tag>
        <tag>Information Retrieval</tag>
        <tag>Data Compression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¼—æ•°é—®é¢˜ - Boyerâ€“Moore majority vote algorithm]]></title>
    <url>%2Falgorithms-majority-element%2F</url>
    <content type="text"><![CDATA[æ•°ç»„ä¸­æœ‰ä¸€ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œä¾‹å¦‚è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º9çš„æ•°ç»„1,2,3,2,2,2,5,4,2ã€‚ç”±äºŽæ•°å­—2åœ¨æ•°ç»„ä¸­å‡ºçŽ°äº†5æ¬¡ï¼Œè¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œå› æ­¤è¾“å‡º2ã€‚å¦‚æžœä¸å­˜åœ¨åˆ™è¾“å‡º0ã€‚å› ä¸ºè¿™ä¸ªæ•°å‡ºçŽ°æ¬¡æ•°è¶…è¿‡äº†æ•°ç»„é•¿åº¦ä¸€åŠä»¥ä¸Š, é‚£ä¹ˆå®ƒå°±æ˜¯æ•°ç»„ä¸­å‡ºçŽ°æ¬¡æ•°æœ€å¤šçš„æ•°, æ•…è°“ä¹‹ä¼—æ•°.1234567891011121314class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here most = numbers[0] count = 1 for item in numbers: if item == most: count += 1 else: count -= 1 if count &lt; 0: most = item count = 1 return 0 if numbers.count(most) &lt;= len(numbers) / 2 else most ä¼—æ•°é—®é¢˜ä¼—æ•°é—®é¢˜å¯ä»¥æŽ¨å¹¿æ³›åŒ–ï¼šç»™å®šå¤§å°ä¸ºnçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°æ‰€æœ‰å‡ºçŽ°è¶…è¿‡n / mæ¬¡çš„å…ƒç´ ã€‚è¿™ç§é—®é¢˜å¯ä»¥ä½¿ç”¨ Boyer-Moore ç®—æ³•è§£å†³. The Boyerâ€“Moore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. It is named after Robert S. Boyer and J Strother Moore, who published it in 1981, and is a prototypical example of a streaming algorithm. å¦‚æžœå­˜åœ¨ä¼—æ•°å…ƒç´ ï¼Œè¯¥ç®—æ³•ä¼šæ‰¾åˆ°ä¼—æ•°å…ƒç´ ï¼šå¯¹äºŽå‡ºçŽ°æ¬¡æ•°ä¸€åŠä»¥ä¸Šçš„å…ƒç´ ã€‚ä½†æ˜¯ï¼Œå¦‚æžœæ²¡æœ‰ä¼—æ•°ï¼Œç®—æ³•å°†ä¸ä¼šæ£€æµ‹åˆ°è¯¥äº‹å®žï¼Œå¹¶ä¸”ä»å°†è¾“å‡ºå…¶ä¸­ä¸€ä¸ªå…ƒç´ ã€‚ è¿™ä¸ªæ—¶å€™éœ€è¦ç¬¬äºŒæ¬¡éåŽ†æ•°æ®, éªŒè¯åœ¨ç¬¬ä¸€æ¬¡é€šè¿‡ä¸­æ‰¾åˆ°çš„å…ƒç´ æ˜¯å¦çœŸæ­£å ä¼—æ•°ã€‚ æ¯”å¦‚æ‰¾åˆ°æ‰€æœ‰å‡ºçŽ°è¶…è¿‡n / 3æ¬¡çš„å…ƒç´ , æœ€å¤šåªå¯èƒ½æœ‰2ä¸ª, å¯ä»¥ç”¨é•¿åº¦ä¸º2çš„æ•°æ®ç»“æž„(è¿™é‡Œé€‰æ‹©map)æ¥è®°å½•ä¼—æ•°.123456789101112131415161718192021class Solution: def majorityElement(self, nums): """ :type nums: List[int] :rtype: List[int] """ m = 2 cand = [0] * m freq = &#123;&#125; for item in nums: if len(freq) &lt; m: freq[item] = 1 + freq.get(item, 0) elif item in freq: freq[item] += 1 else: for k in list(freq): freq[k] -= 1 if freq[k] &lt;= 0: freq.pop(k) return [k for k in freq if nums.count(k) &gt; len(nums) // (m + 1)]]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸Žä¿¡æ¯å¤„ç† 06 - ä¸åŒæ ‘ç»“æž„çš„å­—ç¬¦ä¸²ç¬¦å·è¡¨]]></title>
    <url>%2FNLP-06-string-symbol-table-other-Trie%2F</url>
    <content type="text"><![CDATA[å„ç§æ ‘çš„å˜ç§ä¸ºäº†é€‚åº”ä¸åŒçš„åº”ç”¨åœºæ™¯, äººä»¬ä½¿ç”¨ä¸åŒçš„æ ‘ç»“æž„æ¥å®žçŽ°ç¬¦å·è¡¨. ä¹å®«æ ¼è¾“å…¥æ³•å¯¹äºŽæ‰‹æœºçš„ä¹å®«æ ¼è¾“å…¥æ³•, ç®€å•çš„å®žçŽ°æ–¹å¼æ˜¯å¤šæ¬¡æ•²å‡»: é€šè¿‡åå¤æŒ‰é”®è¾“å…¥ä¸€ä¸ªå­—æ¯ï¼Œç›´åˆ°å‡ºçŽ°æ‰€éœ€çš„å­—æ¯ã€‚ä½† http://www.t9.com/ çš„ T9 texting æ”¯æŒæ›´é«˜æ•ˆçš„è¾“å…¥æ–¹æ³•:ãƒ»Find all words that correspond to given sequence of numbers.ãƒ»Press 0 to see all completion options.Ex. helloãƒ»å¤šæ¬¡æ•²å‡»: 4 4 3 3 5 5 5 5 5 5 6 6 6ãƒ»T9: 4 3 5 5 6 å¯ä»¥ä½¿ç”¨ 8-way trie æ¥å®žçŽ°. ä¸‰å…ƒæœç´¢TrieRè¾ƒå¤§çš„R-way trieçš„ç©ºé—´æ•ˆçŽ‡ä¸é«˜ï¼Œè¯»å–æ¯”è¾ƒå¤§çš„æ–‡ä»¶å¾€å¾€å¯¼è‡´å†…å­˜ä¸è¶³ã€‚ä½†å¼Šç«¯æ˜¯å¼€è¾Ÿå‡ºçš„æ•°ç»„å†…å­˜åˆ©ç”¨çŽ‡å…¶å®žä¸é«˜ã€‚çŽ°åœ¨å¾ˆå¤šç³»ç»Ÿéƒ½ä½¿ç”¨Unicodeï¼Œåˆ†æ”¯å¯é«˜è¾¾65,536. æ‰€ä»¥éœ€è¦æ›´é«˜æ•ˆçš„æ–¹æ³•ã€‚ Ternary search tries:ãƒ»Store characters and values in nodes (not keys).ãƒ»Each node has 3 children: smaller (left), equal (middle), larger (right).Search in a TST: Follow links corresponding to each character in the key.ãƒ»If less, take left link; if greater, take right link.ãƒ»If equal, take the middle link and move to the next key character.1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TST&lt;Value&gt;&#123; private Node root; private class Node &#123; private Value val; private char c; private Node left, mid, right; &#125; public void put(String key, Value val) &#123; root = put(root, key, val, 0); &#125; private Node put(Node x, String key, Value val, int d) &#123; char c = key.charAt(d); if (x == null) &#123; x = new Node(); x.c = c; &#125; if (c &lt; x.c) x.left = put(x.left, key, val, d); else if (c &gt; x.c) x.right = put(x.right, key, val, d); else if (d &lt; key.length() - 1) x.mid = put(x.mid, key, val, d+1); else x.val = val; return x; &#125; public boolean contains(String key) &#123; return get(key) != null; &#125; public Value get(String key) &#123; Node x = get(root, key, 0); if (x == null) return null; return x.val; &#125; private Node get(Node x, String key, int d) &#123; if (x == null) return null; char c = key.charAt(d); if (c &lt; x.c) return get(x.left, key, d); else if (c &gt; x.c) return get(x.right, key, d); else if (d &lt; key.length() - 1) return get(x.mid, key, d+1); else return x; &#125;&#125; TSTsæ¯”hashingæ›´å¿«ï¼ˆç‰¹åˆ«æ˜¯å¯¹äºŽæœç´¢ç¼ºå¤±é”®çš„æƒ…å†µï¼‰ã€‚ åŸºæ•°æ ‘Radix Tree, ä¹Ÿå« Patricia trie (Practical Algorithm to Retrieve Information Coded in Alphanumeric), crit-bit tree, åŽ‹ç¼©å‰ç¼€æ ‘:ãƒ»Remove one-way branching.ãƒ»Each node represents a sequence of characters.ãƒ»Implementation: one step beyond this course.å¯¹äºŽåŸºæ•°æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æžœè¯¥èŠ‚ç‚¹æ˜¯å”¯ä¸€çš„å­æ ‘çš„è¯ï¼Œå°±å’Œçˆ¶èŠ‚ç‚¹åˆå¹¶ã€‚ Applications.ãƒ»Database search.ãƒ»P2P network search.ãƒ»IP routing tables: find longest prefix match.ãƒ»Compressed quad-tree for N-body simulation.ãƒ»Efficiently storing and querying XML documents. åŽç¼€æ ‘åŽç¼€æ ‘ï¼ˆSuffix treeï¼‰æŒ‡å­—ç¬¦ä¸²åŽç¼€çš„åŸºæ•°æ ‘: ä¸€ä¸ªString Sçš„åŽç¼€æ ‘æ˜¯ä¸€ä¸ªè¾¹ï¼ˆedgeï¼‰è¢«æ ‡è®°ä¸ºå­—ç¬¦ä¸²çš„æ ‘ã€‚å› æ­¤æ¯ä¸€ä¸ªSçš„åŽç¼€éƒ½å”¯ä¸€å¯¹åº”ä¸€æ¡ä»Žæ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹çš„è·¯å¾„ã€‚è¿™æ ·å°±å½¢æˆäº†ä¸€ä¸ªSçš„åŽç¼€çš„åŸºæ•°æ ‘ã€‚ Applications.ãƒ»Linear-time: longest repeated substring, longest common substring, longest palindromic substring, substring search, tandem repeats, â€¦.ãƒ»Computational biology databases (BLAST, FASTA). å­—ç¬¦ç¬¦å·è¡¨æ€»ç»“Red-black BST.ãƒ»Performance guarantee: log N key compares.ãƒ»Supports ordered symbol table API. Hash tables.ãƒ»Performance guarantee: constant number of probes.ãƒ»Requires good hash function for key type. Tries. R-way, TST.ãƒ»Performance guarantee: log N characters accessed.ãƒ»Supports character-based operations. You can get at anything by examining 50-100 bits]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Algorithm</tag>
        <tag>Trie</tag>
        <tag>Information Retrieval</tag>
        <tag>Symbol table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸Žä¿¡æ¯å¤„ç† 05 - å­—ç¬¦ä¸²ç¬¦å·è¡¨å’Œä¸‰å…ƒæœç´¢Trie]]></title>
    <url>%2FNLP-05-string-symbol-table-Trie%2F</url>
    <content type="text"><![CDATA[ç¬¦å·è¡¨ åœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œç¬¦å·è¡¨æ˜¯ä¸€ç§ç”¨äºŽè¯­è¨€ç¿»è¯‘å™¨ï¼ˆä¾‹å¦‚ç¼–è¯‘å™¨å’Œè§£é‡Šå™¨ï¼‰ä¸­çš„æ•°æ®ç»“æž„ã€‚åœ¨ç¬¦å·è¡¨ä¸­ï¼Œç¨‹åºæºä»£ç ä¸­çš„æ¯ä¸ªæ ‡è¯†ç¬¦éƒ½å’Œå®ƒçš„å£°æ˜Žæˆ–ä½¿ç”¨ä¿¡æ¯ç»‘å®šåœ¨ä¸€èµ·ï¼Œæ¯”å¦‚å…¶æ•°æ®ç±»åž‹ã€ä½œç”¨åŸŸä»¥åŠå†…å­˜åœ°å€ã€‚å¸¸ç”¨å“ˆå¸Œè¡¨æ¥å®žçŽ°. ç¬¦å·è¡¨çš„åº”ç”¨éžå¸¸å¹¿æ³›, å¯ç”¨äºŽå®žçŽ°Set, Dictionary, æ–‡ä»¶ç´¢å¼•, ç¨€ç–å‘é‡/çŸ©é˜µç­‰æ•°æ®ç»“æž„å’Œç›¸å…³çš„è¿ç®—æ“ä½œ, è¿˜æœ‰å…¶ä»–å¦‚è¿‡æ»¤æŸ¥è¯¢(Exception filter), ä¸€è‡´æ€§æŸ¥è¯¢(concordance queries)ç­‰æ“ä½œ. å­—ç¬¦ç¬¦å·è¡¨å°±æ˜¯ä¸“é—¨é’ˆå¯¹å­—ç¬¦æ“ä½œçš„ç¬¦å·è¡¨, API:Prefix match - Keys with prefix sh: she, shells, and shore.Wildcard match - Keys that match .he: she and the.Longest prefix - Key that is the longest prefix of shellsort: shells.12345678910public interface StringST&lt;Value&gt; &#123; StringST(); create a symbol table with string keys void put(String key, Value val); put key-value pair into the symbol table Value get(String key); value paired with key void delete(String key); delete key and corresponding value Iterable&lt;String&gt; keys(); all keys Iterable&lt;String&gt; keysWithPrefix(String s); keys having s as a prefix Iterable&lt;String&gt; keysThatMatch(String s); keys that match s (where . is a wildcard) String longestPrefixOf(String s); longest key that is a prefix of s&#125; ä»¥Trieä¸ºåŸºç¡€çš„å­—ç¬¦ç¬¦å·è¡¨algs4ä¸­æä¾›äº†ç”¨ R-way trie æ¥å®žçŽ°ç¬¦å·è¡¨(symbol table)ä¾‹å­:1234567891011121314151617181920212223242526272829303132333435363738public class TrieST&lt;Value&gt; &#123; private static final int R = 256; // extended ASCII private Node root = new Node(); private static class Node &#123; private Object value; private Node[] next = new Node[R]; &#125; public void put(String key, Value val) &#123; root = put(root, key, val, 0); &#125; private Node put(Node x, String key, Value val, int d) &#123; if (x == null) x = new Node(); if (d == key.length()) &#123; x.value = val; return x; &#125; char c = key.charAt(d); x.next[c] = put(x.next[c], key, val, d+1); return x; &#125; public boolean contains(String key) &#123; return get(key) != null; &#125; public Value get(String key) &#123; Node x = get(root, key, 0); if (x == null) return null; return (Value) x.val; &#125; private Node get(Node x, String key, int d) &#123; if (x == null) return null; if (d == key.length()) return x; char c = key.charAt(d); return get(x.next[c], key, d+1); &#125;&#125; æŒ‰é¡ºåºè¿­ä»£æ‰€æœ‰é”®ï¼šÂ·ä¸­åºéåŽ†trieï¼Œæ‰¾åˆ°çš„é”®æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­Â·ç»´æŠ¤ä»Žæ ¹åˆ°å½“å‰èŠ‚ç‚¹è·¯å¾„çš„å­—ç¬¦åºåˆ—1234567891011121314public Iterable&lt;String&gt; keys()&#123; Queue&lt;String&gt; queue = new Queue&lt;String&gt;(); collect(root, "", queue); return queue;&#125;private void collect(Node x, String prefix, Queue&lt;String&gt; q)&#123; if (x == null) return; if (x.val != null) q.enqueue(prefix); for (char c = 0; c &lt; R; c++) collect(x.next[c], prefix + c, q);&#125; å‰ç¼€åŒ¹é…Find all keys in a symbol table starting with a given prefix.Ex. Autocomplete in a cell phone, search bar, text editor, or shell.ãƒ»User types characters one at a time.ãƒ»System reports all matching strings.1234567public Iterable&lt;String&gt; keysWithPrefix(String prefix)&#123; Queue&lt;String&gt; queue = new Queue&lt;String&gt;(); Node x = get(root, prefix, 0); collect(x, prefix, queue); return queue;&#125; æœ€é•¿å‰ç¼€Find longest key in symbol table that is a prefix of query string.Ex. To send packet toward destination IP address, router chooses IP address in routing table that is longest prefix match. ãƒ»Search for query string.ãƒ»Keep track of longest key encountered.1234567891011121314public String longestPrefixOf(String query)&#123; int length = search(root, query, 0, 0); return query.substring(0, length);&#125;private int search(Node x, String query, int d, int length)&#123; if (x == null) return length; if (x.val != null) length = d; if (d == query.length()) return length; char c = query.charAt(d); return search(x.next[c], query, d+1, length);&#125;]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Algorithm</tag>
        <tag>Trie</tag>
        <tag>Information Retrieval</tag>
        <tag>Symbol table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸Žä¿¡æ¯å¤„ç† 04 - â€œå’Œè°â€ - å¤šæ¨¡å¼åŒ¹é…ç®—æ³• - ACè‡ªåŠ¨æœº]]></title>
    <url>%2FNLP-04-string-match-algorithm-ac-automaton%2F</url>
    <content type="text"><![CDATA[è™½ç„¶KMPå¯ä»¥ç”¨äºŽå•æ¨¡å¼åŒ¹é…é—®é¢˜ï¼Œä½†å¦‚æžœæ˜¯å¤šæ¨¡å¼é—®é¢˜, KMPçš„æ€§èƒ½å°±å¾—ä¸åˆ°ä¿è¯ã€‚æ¯”å¦‚æ ¹æ®å¢™å†…æ³•å¾‹è¦æ±‚, å¢™å†…çš„æœç´¢å¼•æ“Žéœ€è¦è¿‡æ»¤æ•æ„Ÿè¯åŽæ‰èƒ½åˆæ³•è¿è¥ã€‚æ•æ„Ÿè¯çš„æ•°é‡ä¸å°‘, å¦‚æžœè¦æ±‚åŒ…å«æ•æ„Ÿè¯çš„ç½‘é¡µä¸èƒ½è¢«æœç´¢åˆ°, é‚£ä¹ˆæœç´¢å¼•æ“Žåœ¨çˆ¬å–ç½‘é¡µä¿¡æ¯æ—¶, å°±è¦æ ‡è®°ç½‘é¡µçš„æ–‡æœ¬ä¸­æ˜¯å¦åŒ…å«ä»»æ„ä¸ªæ•æ„Ÿè¯. è¿™å°±æ˜¯å…¸åž‹çš„å¤šæ¨¡åŒ¹é…é—®é¢˜. è¿™ç§æƒ…å†µä¸‹å¦‚æžœä½¿ç”¨Trieï¼Œé‚£ä¹ˆéœ€è¦éåŽ†ç½‘é¡µçš„æ¯ä¸€ä¸ªå­—ç¬¦ä½ç½®ï¼Œå¯¹æ¯ä¸€ä¸ªä½ç½®è¿›è¡ŒTrieå‰ç¼€åŒ¹é…ã€‚å¦‚æžœè¯å…¸çš„è¯è¯­æ•°é‡ä¸ºNï¼Œæ¯ä¸ªè¯è¯­é•¿åº¦ä¸ºLï¼Œæ–‡ç« çš„é•¿åº¦ä¸ºMï¼Œé‚£ä¹ˆéœ€è¦è¿›è¡Œçš„è®¡ç®—æ¬¡æ•°æ˜¯åœ¨N*M*Lè¿™ä¸ªçº§åˆ«çš„. å³ä½¿æŠŠè¯è¯­çš„é•¿åº¦Lç®€åŒ–ä¸ºå¸¸æ•°çº§åˆ«çš„, æ•´ä¸ªç®—æ³•çš„å¤æ‚åº¦ä¹Ÿè‡³å°‘æ˜¯$O(n^2)$. ACè‡ªåŠ¨æœºå¯ä»¥çœ‹åˆ°ï¼ŒKMPç®—æ³•å¯ä»¥é¿å…back upï¼ˆåœ¨æ£€æŸ¥å­—ç¬¦çš„è¿‡ç¨‹ä¸­ä¸éœ€è¦å›žå¤´ï¼‰ï¼Œè€ŒTrieå¯ä»¥å­˜å‚¨å¤šä¸ªæ¨¡å¼çš„ä¿¡æ¯ã€‚å¦‚æžœæŠŠäºŒè€…ç»“åˆåœ¨ä¸€èµ·ï¼Œä¹Ÿè®¸èƒ½ä»Žæ€§èƒ½ä¸Šè§£å†³å¤šæ¨¡å¼ï¼ˆä»»æ„ä½ç½®ï¼‰åŒ¹é…é—®é¢˜ã€‚è¿™å°±æ˜¯Ahoâ€“Corasickç®—æ³•ï¼ˆACè‡ªåŠ¨æœºï¼‰ã€‚ Ahoâ€“Corasickç®—æ³•æ˜¯ç”±Alfred V. Ahoå’ŒMargaret J.Corasick å‘æ˜Žçš„å­—ç¬¦ä¸²æœç´¢ç®—æ³•ï¼Œç”¨äºŽåœ¨è¾“å…¥çš„ä¸€ä¸²å­—ç¬¦ä¸²ä¸­åŒ¹é…æœ‰é™ç»„å­—å…¸ä¸­çš„å­ä¸²ã€‚å®ƒä¸Žæ™®é€šå­—ç¬¦ä¸²åŒ¹é…çš„ä¸åŒç‚¹åœ¨äºŽåŒæ—¶ä¸Žæ‰€æœ‰å­—å…¸ä¸²è¿›è¡ŒåŒ¹é…ã€‚ç®—æ³•å‡æ‘Šæƒ…å†µä¸‹å…·æœ‰è¿‘ä¼¼äºŽçº¿æ€§çš„æ—¶é—´å¤æ‚åº¦ï¼Œçº¦ä¸ºå­—ç¬¦ä¸²çš„é•¿åº¦åŠ æ‰€æœ‰åŒ¹é…çš„æ•°é‡ã€‚ æ‰€ä»¥ç®—æ³•çš„å…³é”®å°±æ˜¯é€šè¿‡TrieæŠŠå¤šä¸ªæ¨¡å¼æž„å»ºä¸ºä¸€ä¸ªDFAï¼ˆDeterministic finite state automatonï¼‰ï¼Œç„¶åŽè®©æ¨¡å¼ä¸²æœ«å°¾å¯¹åº”çš„çŠ¶æ€ä½œä¸ºä¸€ä¸ªDFAçš„ç»ˆæ­¢èŠ‚ç‚¹ã€‚è¿™æ ·ï¼Œå¯¹äºŽä¸€ä¸ªè¦æ£€æŸ¥çš„é•¿å­—ç¬¦ä¸²ï¼ˆå¦‚ä¸€æ®µç½‘é¡µå†…å®¹ï¼‰ï¼Œè®©è¿™ä¸ªå­—ç¬¦ä¸²åœ¨DFAä¸Šè·‘ä¸€è¶Ÿï¼Œæ¯ä¸€ä¸ªå­—ç¬¦è¡¨ç¤ºä¸€ç§è·³è½¬æ–¹å¼ï¼Œå¦‚æžœè¿™æ®µå­—ç¬¦èƒ½å¤Ÿè·³åˆ°ä»»ä½•ä¸€ä¸ªç»ˆç»“èŠ‚ç‚¹, é‚£ä¹ˆå°±è¡¨æ˜Žè¿™æ®µå­—ç¬¦ä¸²åŒ¹é…äº†è‡³å°‘ä¸€ä¸ªæ¨¡å¼, å¦‚æžœæ•´æ®µå­—ç¬¦è·‘å®Œéƒ½æ²¡åˆ°è¾¾ç»ˆç»“èŠ‚ç‚¹, é‚£ä¹ˆè¿™ä¸ªç½‘é¡µå°±æ˜¯â€å’Œè°çš„â€. åœ¨å•æ¨¡å¼åŒ¹é…ä¸­, ç”¨KMPæž„å»ºçš„DFAæ˜¯æ¯”è¾ƒç®€å•çš„, ä»Žå·¦åˆ°å³, å¼€å¤´çš„çŠ¶æ€å°±æ˜¯å¼€å§‹çŠ¶æ€, ç»“å°¾çš„çŠ¶æ€å°±æ˜¯ç»“æŸçŠ¶æ€:è€Œå¤šæ¨¡å¼åŒ¹é…ä¸­, åœ¨Trieçš„ç»“æž„åŸºç¡€ä¸Šæž„å»ºå‡ºæ¥çš„DFAæ›´åƒä¸€ä¸ªDFAçš„æ ·å­:Trieä¸­çš„èŠ‚ç‚¹, å°±ç±»ä¼¼äºŽDFAä¸­çš„çŠ¶æ€. å¦‚æžœè®©å­—ç¬¦ä¸²shisåœ¨ä¸Šé¢è·‘, å‡å¦‚ä»…ä»…æ˜¯é Trie(ä¹Ÿå³æ˜¯æ²¡æœ‰è™šçº¿æ ‡è¯†çš„è½¬ç§»), é‚£ä¹ˆç¬¬ä¸€æ¬¡ä»Žå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦så¼€å§‹è½¬ç§», ç»è¿‡è½¬ç§»è·¯å¾„0 - 85 - 90ä¹‹åŽå°±è½¬ä¸åŠ¨äº†, å› ä¸ºTrieè®°å½•çš„æ¨¡å¼ä¸­æ²¡æœ‰shi, è¿™ä¸ªæ—¶å€™å¾—back up, ä»Žç¬¬äºŒä¸ªä½ç½®hå¼€å§‹å†åŒ¹é…ä¸€é. è¿™ä¸ªè¿‡ç¨‹ä¸­å°±äº§ç”Ÿé‡å¤åŒ¹é…, è€Œå‚è€ƒKMPçš„æ€è·¯, åœ¨åŒ¹é…shiçš„è¿‡ç¨‹ä¸­, å…¶å®žå·²ç»æŒ–æŽ˜å‡ºäº†hiè¿™ä¸ªå­ä¸²äº†, è€Œè¿™ä¸ªå­ä¸²æ˜¯è·Ÿæ¨¡å¼hiså¯¹åº”çš„, å¦‚æžœæœ‰åŠžæ³•ä¸å›žå¤´ç»§ç»­åŒ¹é…ä¸‹åŽ»å°±èƒ½æé«˜æ€§èƒ½äº†. è€ŒDFAä¸­è™šçº¿çš„å¤±è´¥è½¬ç§»å°±æ˜¯ç”¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜çš„: å½“èµ°åˆ°çŠ¶æ€90æ—¶, å‰é¢æœ‰äº†å°éƒ¨åˆ†å­ä¸²håˆšå¥½å¯¹åº”çŠ¶æ€74, è¿™ä¸ªæ—¶å€™ç”¨è™šçº¿ä½œä¸ºå¤±è´¥è½¬ç§», è½¬ç§»åˆ°74, åœ¨çŠ¶æ€74ä¸­å¯»æ‰¾ä¸‹ä¸€ä¸ªè½¬ç§»i, è¿™æ ·å°±å®žçŽ°äº†ä¸å›žå¤´ç»§ç»­åŒ¹é…äº†. å› ä¸ºACè‡ªåŠ¨æœºæ˜¯åœ¨Trieçš„åŸºç¡€ä¸Šæ·»åŠ è¾¹, ç”¨äºŽæŒ‡ç¤ºå„ä¸ªèŠ‚ç‚¹ç»è¿‡ä¸åŒå­—ç¬¦åŽè·³è½¬åˆ°å“ªä¸ªèŠ‚ç‚¹, ç»“æžœå°±å˜æˆäº†å›¾, æ‰€ä»¥ä¹Ÿå«åšTrieå›¾. è¦æž„å»ºACè‡ªåŠ¨æœº: é¦–å…ˆè¦æŠŠæ‰€æœ‰æ¨¡å¼éƒ½åƒè¿›ä¸€ä¸ªTrieä¸­(æœ€è¿‘çœ‹å¤šè¿›å‡»çš„å·¨äººäº†), æž„å»ºå‡ºä¸€ä¸ªç”±ä¸åŒå®žçº¿ä¸²è”èµ·æ¥çš„çŠ¶æ€æœº, å…¶ä¸­ä»£è¡¨åˆšå¥½å»åˆä¸€ä¸ªæ¨¡å¼çš„çŠ¶æ€æ ‡è®°ä¸ºç»ˆç»“èŠ‚ç‚¹(å¦‚ä¸Šå›¾ç»¿è‰²èŠ‚ç‚¹) ç„¶åŽè¡¥å…¨å…¶ä»–å­—ç¬¦çš„è½¬ç§»(å¤±è´¥è½¬ç§»), ç”¨è™šçº¿è¡¨ç¤º. è¡¥å…¨äº†æ‰€æœ‰å­—ç¬¦çš„è½¬ç§»æ–¹å¼, æ‰èƒ½è®©å­—ç¬¦ä¸²æ°¸ä¸å›žå¤´åœ°åŒ¹é…ä¸‹åŽ», é¿å…äº†back up, ä¿è¯æ€§èƒ½. é—®é¢˜çš„å…³é”®åœ¨å¦‚ä½•è¡¥å…¨æ‰€æœ‰çš„çŠ¶æ€è½¬ç§». è¡¥å…¨çŠ¶æ€è½¬ç§»è¿™é‡Œè¦åœ¨Trieç»“æž„ä¸­å®šä¹‰ä¸€ä¸ªåŽç¼€èŠ‚ç‚¹çš„æ¦‚å¿µ: Trieä¸­å¯¹åº”è·¯å¾„(å·²æœ‰æ¨¡å¼)åŽ»æŽ‰éƒ¨åˆ†å‰ç¼€å­—ç¬¦åŽå‰©ä½™çš„åŽç¼€å­—ç¬¦åœ¨Trieä¸­å¯¹åº”çš„ç»“ç‚¹. æ¯”å¦‚ä¸Šå›¾ä¸­, hä½œä¸ºshçš„ä¸€ä¸ªåŽç¼€, hå¯¹åº”çš„TrieèŠ‚ç‚¹74å°±æ˜¯shå¯¹åº”èŠ‚ç‚¹90çš„åŽç¼€èŠ‚ç‚¹. ç­‰äºŽè¯´, èŠ‚ç‚¹å’Œå…¶åŽç¼€èŠ‚ç‚¹å¯¹åº”çš„æ¨¡å¼æœ‰ä¸€éƒ¨åˆ†åŽç¼€æ˜¯ç›¸åŒ. å¦‚æžœçŸ¥é“äº†æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„åŽç¼€èŠ‚ç‚¹, é‚£ä¹ˆåœ¨åŒ¹é…çš„è¿‡ç¨‹ä¸­, åœ¨ä»»ä¸€ä½ç½®åŒ¹é…å¤±è´¥, éƒ½å¯ä»¥é€šè¿‡å¤±è´¥è½¬ç§»çš„æ–¹å¼è½¬ç§»åˆ°åŽç¼€èŠ‚ç‚¹, ç»§ç»­è¿›è¡ŒåŽç»­åŒ¹é…, è€Œä¸ä¼šé—æ¼, å› ä¸ºåŽç¼€èŠ‚ç‚¹å¯¹åº”è¿™ä¸ªç›®å‰ä¸ºæ­¢å·²åŒ¹é…å­—ç¬¦çš„æŸä¸€éƒ¨åˆ†åŽç¼€. ç­‰äºŽè¯´, åŽç¼€èŠ‚ç‚¹å‘Šè¯‰æˆ‘ä»¬, åœ¨å­—ç¬¦ä¸²ä¸­å‡ºçŽ°ä¸Žæ¨¡å¼ä¸åŒçš„å­—ç¬¦ä¸²æ—¶(åŒ¹é…å¤±è´¥), å¦‚ä½•è½¬ç§»åˆ°å…¶ä»–çŠ¶æ€. æ‰€ä»¥é—®é¢˜çš„å…³é”®åˆå˜æˆäº†å¦‚ä½•æ±‚åŽç¼€èŠ‚ç‚¹. æ±‚åŽç¼€èŠ‚ç‚¹è§‚å¯ŸTrieç»“æž„å¯ä»¥å‘çŽ°ä¸¤ä¸ªè¦ç‚¹ å­—ç¬¦ä¸²ä»»ä½•ä¸€ä¸ªä½ç½®å¯¹åº”çš„çŠ¶æ€èŠ‚ç‚¹ï¼Œä¸€å®šæ¯”å®ƒçš„åŽç¼€èŠ‚ç‚¹æ›´æ·±ï¼Œæ¯”å¦‚å‰é¢ä¾‹å­ä¸­çŠ¶æ€èŠ‚ç‚¹90åœ¨ç¬¬äºŒå±‚, è€Œå…¶åŽç¼€èŠ‚ç‚¹74åœ¨ç¬¬ä¸€å±‚. è¿™ç‚¹ä¹Ÿæ˜¯ç†æ‰€å½“ç„¶çš„, æ¯•ç«ŸåŽç¼€æ¯”è¾ƒçŸ­. ä»ŽåŠ¨æ€è§„åˆ’çš„è§’åº¦è€ƒè™‘, å­—ç¬¦ä¸²ä»»ä¸€ä½ç½®iå¯¹åº”çš„çŠ¶æ€èŠ‚ç‚¹çš„åŽç¼€èŠ‚ç‚¹ä¸€å®šæ˜¯k&lt;içš„èŠ‚ç‚¹ä¸­çš„æŸä¸€ä¸ª. å› ä¸ºæ¯ä¸€ä¸ªçŠ¶æ€iéƒ½æ˜¯ç”±å…¶çˆ¶èŠ‚ç‚¹jé€šè¿‡æŸä¸€ä¸ªå­—ç¬¦cè½¬ç§»è€Œæ¥, é‚£ä¹ˆiçš„åŽç¼€èŠ‚ç‚¹ä¸€å®šæ˜¯jçš„åŽç¼€èŠ‚ç‚¹é€šè¿‡åŒæ ·çš„å­—ç¬¦cè½¬ç§»è€Œæ¥. æˆ–è€…è¯´, å¦‚æžœjçš„åŽç¼€èŠ‚ç‚¹æ˜¯jj, é‚£ä¹ˆjå’Œjjæœ‰ç€ç›¸åŒçš„åŽç¼€, å®ƒä»¬é€šè¿‡åŒæ ·çš„è½¬ç§»å­—ç¬¦cè½¬ç§»åŽ, äºŒè€…åˆ°è¾¾çš„èŠ‚ç‚¹ä¹Ÿä¸€å®šæœ‰ç€ç›¸åŒçš„åŽç¼€. æ¯”å¦‚ä¸Šé¢Ushersè‡ªåŠ¨æœºä¾‹å­ä¸­, å¦‚æžœç”¨å­—ç¬¦ä¸²sshisæ¥è·‘, é‚£ä¹ˆsshå¯¹åº”çš„çŠ¶æ€90, æ˜¯ç”±å‰ç¼€ssé€šè¿‡å­—ç¬¦hè½¬ç§»è€Œæ¥. å› ä¸ºsshçš„åŽç¼€èŠ‚ç‚¹, åŒæ ·æ˜¯æŸä¸€ä¸ªæœ‰å…±åŒåŽç¼€çš„å­—ç¬¦(hæˆ–è€…sh)å¯¹åº”çš„çŠ¶æ€(åœ¨è¿™é‡Œæ˜¯hå¯¹åº”çš„74). å¯ä»¥å‘çŽ°74æ˜¯ç”±æ ¹èŠ‚ç‚¹0é€šè¿‡åŒæ ·çš„å­—ç¬¦hè½¬ç§»è€Œæ¥çš„. åè¿‡æ¥è¯´, èŠ‚ç‚¹0å°±æ˜¯èŠ‚ç‚¹90çš„çˆ¶èŠ‚ç‚¹85çš„åŽç¼€èŠ‚ç‚¹. åœ¨å¤šä¸ªæ¨¡å¼ä¸­, å¦‚æžœæœ‰æŸæ¨¡å¼çš„å‰ç¼€åˆšå¥½æ˜¯å¦ä¸€æ¨¡å¼çš„å­ä¸²(åŽç¼€). æ¯”å¦‚ä¸Šé¢Ushersè‡ªåŠ¨æœºä¾‹å­ä¸­, æ¨¡å¼her(æˆ–è€…he)çš„å‰ç¼€heå°±æ˜¯æ¨¡å¼sheçš„å­ä¸², åˆ™ä¼šäºŒè€…å­˜åœ¨å¤±è´¥è½¬ç§»çš„å…³è”. å¦‚æžœæ²¡æœ‰, é‚£ä¹ˆå°±è·³å›žåˆå§‹çŠ¶æ€èŠ‚ç‚¹. æ‰€ä»¥è¡¥å…¨æ‰€æœ‰çŠ¶æ€è½¬ç§»çš„å…·ä½“å®žçŽ°æ–¹æ³•å°±æ˜¯è¿ç”¨åŠ¨æ€è§„åˆ’çš„åŽŸç†: ä»ŽTrieæ ¹èŠ‚ç‚¹å¼€å§‹, é€å±‚å¾€ä¸‹è¡¥å…¨æ¯ä¸€å±‚çš„çŠ¶æ€è½¬ç§», ä¹Ÿå°±æ˜¯å®½åº¦ä¼˜å…ˆéåŽ†(BFS), è¿™æ ·ä¸‹å±‚çš„çŠ¶æ€è½¬ç§»å°±å¯ä»¥åˆ©ç”¨ä¸Šå±‚çš„ç»“æžœ. åŠ¨æ€è§„åˆ’çš„è½¬ç§»æ–¹ç¨‹å¯ä»¥æè¿°ä¸º: æ¯ä¸€ä¸ªé€šè¿‡å­—ç¬¦cè½¬ç§»è€Œæ¥çš„çŠ¶æ€èŠ‚ç‚¹içš„åŽç¼€èŠ‚ç‚¹ = içš„çˆ¶èŠ‚ç‚¹çš„åŽç¼€èŠ‚ç‚¹é€šè¿‡cè½¬ç§»åˆ°çš„çŠ¶æ€èŠ‚ç‚¹ åˆå§‹çŠ¶æ€åŒ…å«ä¸¤éƒ¨åˆ†: ä¸€ä¸ªæ˜¯æ ¹èŠ‚ç‚¹(åˆå§‹çŠ¶æ€0), å®ƒçš„åŽç¼€èŠ‚ç‚¹å°±æ˜¯å®ƒè‡ªå·±, å¦ä¸€ä¸ªæ˜¯ç¬¬ä¸€å±‚çš„çŠ¶æ€èŠ‚ç‚¹, å¦‚85, 74, å› ä¸ºå®ƒä»¬å¯¹åº”çš„æ˜¯é•¿åº¦ä¸º1çš„å­—ç¬¦, æ²¡æœ‰åŽç¼€, æ‰€ä»¥å®ƒä»¬çš„åŽç¼€èŠ‚ç‚¹ä¹Ÿæ˜¯æ ¹èŠ‚ç‚¹0. åœ¨å®žçŽ°ä¸­è¿˜è¦æ³¨æ„, åŽç¼€ç»“ç‚¹ä¸ºæ ‡è®°ç»“ç‚¹çš„ç»“ç‚¹ä¹Ÿéœ€è¦è¢«æ ‡è®°. å› ä¸ºåœ¨çŠ¶æ€è½¬ç§»è¿‡ç¨‹ä¸­, å¦‚æžœæŸä¸ªè™šçº¿è½¬ç§»åˆšå¥½è½¬ç§»åˆ°ç»ˆç»“èŠ‚ç‚¹, ä½†åœ¨å­—ç¬¦ä¸²éåŽ†çš„è¿‡ç¨‹ä¸­, å¹¶æ²¡æœ‰é€‰æ‹©èµ°è¿™ä¸€æ¡çº¿, å°±ä¼šå¿½ç•¥äº†è¿™ä¸ªç»ˆç»“èŠ‚ç‚¹, å¯¼è‡´åŒ¹é…å¤±è´¥, æˆ–è€…å¤šèµ°äº†æ›´å¤šçš„è·¯. æ¯”å¦‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­, å¦‚æžœæŠŠæ¨¡å¼sheæ”¹ä¸ºshee, 91ä¸å†æ˜¯ç»ˆç»“èŠ‚ç‚¹, è€Œæ˜¯å»¶ä¼¸åˆ°92ä¸ºç»ˆç»“èŠ‚ç‚¹, 91çš„åŽç¼€èŠ‚ç‚¹æ˜¯76. å¦‚æžœç”¨å­—ç¬¦ä¸²ssheæ¥è·‘è¿™ä¸ªDFA, å°±ä¼šå‡ºçŽ°èµ°åˆ°æœ€åŽå­—ç¬¦eæ—¶, åœ¨èŠ‚ç‚¹91ç»“æŸ, åŒ¹é…å¤±è´¥. æ‰€ä»¥éœ€è¦æŠŠ91ä¹Ÿæ ‡è®°ä¸ºç»ˆç»“èŠ‚ç‚¹. å®žçŽ°ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** æŠŠå­—å…¸é€šè¿‡insertæŠŠæ‰€æœ‰å•è¯æ’å…¥Trieæ ‘ï¼Œ * ç„¶åŽé€šè¿‡setSuffix()æž„å»ºå‡ºå¯¹åº”çš„Trieå›¾ï¼Œ * ç„¶åŽä»ŽTrieå›¾çš„æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œæ²¿ç€æ–‡ç« strçš„æ¯ä¸€ä¸ªå­—ç¬¦ï¼Œèµ°å‡ºå¯¹åº”çš„è¾¹ï¼Œ * ç›´åˆ°é‡åˆ°ä¸€ä¸ªæ ‡è®°ç»“ç‚¹æˆ–è€…æ•´ä¸ªstréƒ½éåŽ†å®Œæˆ */public static class Trie &#123; private TrieNode trie; Queue&lt;TrieNode&gt; queue; public Trie() &#123; trie = new TrieNode(null, ' '); queue = new LinkedList&lt;&gt;(); &#125; public void insert(String word) &#123; TrieNode curNode = trie; for (char x : word.toCharArray()) &#123; curNode = insert(curNode, x); &#125; curNode.setLast(true); &#125; /** insert char x, means create a new node in the x edge. * return created node */ private TrieNode insert(TrieNode node, char x) &#123; if (node.get(x) == null) &#123; node.set(x); &#125; return node.get(x); &#125; /** BFS on the trie */ public void setSuffix() &#123; queue.add(trie); while (!queue.isEmpty()) &#123; /** poll() removes the present head. http://www.tutorialspoint.com/java/util/linkedlist_poll.htm */ TrieNode node = queue.poll(); setSuffix(node); complementDFA(node); &#125; &#125; /** Set node's suffix, complement lacking edge * */ private TrieNode setSuffix(TrieNode node) &#123; if (node.root == null) &#123; // Trie root node.suffix = node; &#125; else if (node.root.root == null) &#123; node.suffix = node.root.suffix; &#125; else &#123; node.suffix = node.root.suffix.get(node.fromIndex); &#125; if (node.suffix.isLast) &#123; node.isLast = true; &#125; return node.suffix; &#125; /** Complement DFA according to suffix */ private void complementDFA(TrieNode node) &#123; if (node.isLast) &#123; return; &#125; for (int i = 0; i &lt; node.edges.length; i++) &#123; if (node.edges[i] == null) &#123; if (node.root == null) &#123; node.edges[i] = node; &#125; else &#123; node.edges[i] = node.suffix.edges[i]; &#125; &#125; else &#123; queue.add(node.edges[i]); &#125; &#125; &#125; public boolean search(String s) &#123; boolean contains = false; TrieNode curNode = trie; for (int i = 0; i &lt; s.length(); i++) &#123; char x = s.charAt(i); curNode = curNode.get(x); if (curNode.isLast) &#123; contains = true; break; &#125; &#125; return contains; &#125; public static class TrieNode &#123; static final int R = 26; static final int ATO0 = 97; boolean isLast; TrieNode[] edges; TrieNode root; char fromIndex; TrieNode suffix; public TrieNode(TrieNode root, char from) &#123; this.root = root; fromIndex = from; edges = new TrieNode[R]; isLast = false; &#125; public TrieNode get(char ch) &#123; return edges[ch - ATO0]; &#125; /** instantiate the ch child in edges */ public void set(char ch) &#123; edges[ch - ATO0] = new TrieNode(this, ch); &#125; public void setLast(boolean isLast) &#123; this.isLast = isLast; &#125; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); Trie t = new Trie(); String[] X = &#123;"sb", "dsb", "cjdsb", "qnmlgb"&#125;; for (String x : X) &#123; t.insert(x); &#125; t.setSuffix(); String s = "aadbaaadaaac"; if (t.search(s)) &#123; System.out.println("YES"); &#125; else &#123; System.out.println("NO"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Algorithm</tag>
        <tag>Trieå›¾</tag>
        <tag>ACè‡ªåŠ¨æœº</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸Žä¿¡æ¯å¤„ç† 03 - å•æ¨¡å¼åŒ¹é…ä¸Žæ‹¼å†™æ£€æŸ¥ - Trie]]></title>
    <url>%2FNLP-03-string-match-algorithm-Trie%2F</url>
    <content type="text"><![CDATA[Trie ä¹Ÿç§°å­—å…¸æ ‘ï¼Œåç§°æ¥æºäºŽRetrievalï¼Œæ”¯æŒ$O(n)$æ’å…¥å’ŒæŸ¥è¯¢æ“ä½œï¼Œä»¥ç©ºé—´æ¢å–æ—¶é—´çš„æ•°æ®ç»“æž„. ç”¨äºŽè¯é¢‘ç»Ÿè®¡å’Œè¾“å…¥ç»Ÿè®¡é¢†åŸŸ, å¯ä»¥é«˜æ•ˆåœ°å­˜å‚¨å¤§è§„æ¨¡çš„å­—å…¸æ•°æ®, ä¹Ÿå¯ä»¥ç”¨äºŽæ¨¡ç³ŠåŒ¹é…, æœç´¢æœ€é•¿å‰ç¼€è¯ç­‰. A trie, also called digital tree, radix tree or prefix tree is a kind of search tree - an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Keys tend to be associated with leaves, though some inner nodes may correspond to keys of interest. Hence, keys are not necessarily associated with every node. TrieTrieæ²¡æœ‰è§„å®šæ¯ä¸€ä¸ªèŠ‚ç‚¹çš„åˆ†æ”¯æ•°é‡, ç”¨R-way Trieæ¥è¡¨ç¤ºåˆ†æ”¯æ•°é‡ä¸ºRçš„Trie. å¯¹äºŽä¸åŒçš„åº”ç”¨, å¯ä»¥è®¾ç½®ä¸åŒçš„R. å­—ç¬¦ï¼ˆæ¨¡ç³Šï¼‰åŒ¹é…ä¸Žæ‹¼å†™æ£€æŸ¥åº”ç”¨ä¾‹å­æ˜¯åœ¨ä¸€æœ¬å­—å…¸ä¸­æŸ¥æ‰¾ç‰¹å®šå‰ç¼€çš„æ‰€æœ‰å•è¯. ç®€åŒ–çš„ä¾‹å­æ˜¯åœ¨è‹±æ–‡å­—å…¸ä¸­, æ ¹æ®æŸ¥è¯¢å‰ç¼€, è¿”å›žç›¸åŒå‰ç¼€çš„æ‰€æœ‰å•è¯æ•°. åŒæ ·çš„ç»“æž„å¯ä»¥ç”¨æ¥æ£€æŸ¥æ‹¼å†™é”™è¯¯. é‚£ä¹ˆåªéœ€è¦åœ¨æ¯ä¸€ä¸ªèŠ‚ç‚¹å­˜å‚¨è¯¥èŠ‚ç‚¹ä»¥ä¸‹æ‰€æœ‰å•è¯æ•°å°±è¡Œäº†. æ¯ä¸€ä¸ªèŠ‚ç‚¹åŒ…å«ä¸€ä¸ªé•¿åº¦26çš„æ•°ç»„ï¼Œä»¥æ–¹ä¾¿å¿«é€Ÿå®šä½å¯¹åº”çš„26ä¸ªå­—æ¯, ç±»ä¼¼B-tree:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * å­—æ¯æœ¬èº«å¯ä»¥ç”¨æ¥ä½œä¸ºç´¢å¼•ï¼ša - 97, z - 122 * Color æ˜¯å¤‡ç”¨å±žæ€§ï¼Œ ç”¨äºŽæ ‡è®°è¯¥èŠ‚ç‚¹æ˜¯å¦ä¸ºå•è¯ç»“å°¾ï¼Œè¿™é‡Œæš‚æ—¶ç”¨ä¸åˆ°ã€‚ */public static class Trie &#123; static final int ALPHABET = 26; static final int ATO0 = 97; int color; int n; Trie[] node; public Trie(int n) &#123; this.n = n; node = new Trie[ALPHABET]; &#125; public void insert(String words) &#123; Trie[] curNode = node; for (char x : words.toCharArray()) &#123; int index = x - ATO0; insert(curNode, index); curNode = curNode[index].node; &#125; &#125; private void insert(Trie[] curNode, int index) &#123; if (curNode[index] == null) &#123; curNode[index] = new Trie(1); &#125; else &#123; curNode[index].n++; &#125; &#125; public int search(String prefix) &#123; int count = 0; Trie[] curNode = node; for (char x : prefix.toCharArray()) &#123; int index = x - ATO0; if (curNode[index] == null) &#123; return 0; &#125; count = curNode[index].n; curNode = curNode[index].node; &#125; return count; &#125;&#125; å¦‚æžœè¦é—®é¢˜æ‰©å±•ä¸ºè¿”å›žæ‰€æœ‰ç›¸åŒå‰ç¼€çš„å•è¯ï¼Œé‚£ä¹ˆå°±è¦åœ¨æ’å…¥å­—å…¸æ—¶ï¼Œåœ¨å¯¹åº”å•è¯ç»“å°¾çš„èŠ‚ç‚¹æ ‡è®°é¢œè‰²ã€‚ æé«˜æ‰©å±•æ€§ç”¨å›ºå®šé•¿åº¦ä¸º26çš„æ•°ç»„æ¥å¤„ç†è‹±æ–‡ï¼Œå¥½å¤„æ˜¯æ•°ç»„å†…å­˜å ç”¨å°ï¼Œç´¢å¼•æ—¶ä¹Ÿä¸éœ€è¦æœç´¢ï¼Œç›´æŽ¥ç”¨å­—ç¬¦ç ä½œä¸ºç´¢å¼•ã€‚ä¹Ÿå¯ä»¥æ ¹æ®ASCIIç è¿›ä¸€æ­¥æ‰©å¤§æ•°ç»„é•¿åº¦ä»¥æ”¯æŒæ›´å¤šå­—ç¬¦ã€‚ ä¸ºäº†æé«˜å¯æ‰©å±•æ€§ï¼Œå¯ä»¥è€ƒè™‘ç”¨å…¶ä»–æ›´çµæ´»çš„æ•°æ®ç»“æž„æ¥æ›¿ä»£æ•°ç»„ï¼Œæ¯”å¦‚HashMapï¼ŒåŒæ—¶æŠŠHashMapæ”¾è¿›ä¸€ä¸ªTrieNodeç±»ã€‚è¿™æ ·ä»¥åŽè¦ä¿®æ”¹æ ¸å¿ƒçš„å­˜å‚¨ç»“æž„ï¼Œåªéœ€è¦æ”¹åŠ¨TrieNodeå³å¯ï¼Œå…¶ä½™çš„æŽ¥å£ä¸ç”¨æ”¹ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static class Trie &#123; private TrieNode node; public Trie() &#123; this.node = new TrieNode(); &#125; public void insert(String word) &#123; TrieNode curNode = node; for (char x : word.toCharArray()) &#123; curNode = curNode.set(x); &#125; &#125; public int search(String prefix) &#123; TrieNode curNode = node; for (char x : prefix.toCharArray()) &#123; if (curNode.get(x) == null) &#123; return 0; &#125; curNode = curNode.get(x); &#125; return curNode.count; &#125; public static class TrieNode &#123; HashMap&lt;Character, TrieNode&gt; map; private int count; private char value; public TrieNode() &#123; count = 0; map = new HashMap&lt;&gt;(); &#125; public TrieNode(Character val) &#123; count = 1; this.value = val; map = new HashMap&lt;&gt;(); &#125; public TrieNode get(char ch) &#123; return map.get(ch); &#125; public TrieNode set(char ch) &#123; TrieNode t = map.get(ch); if (t == null) &#123; t = new TrieNode(ch); this.map.put(ch, t); &#125; else &#123; t.count++; &#125; return t; &#125; public int getCount() &#123; return this.count; &#125; public char getValue() &#123; return this.value; &#125; &#125;&#125; HashMapçš„å¯»å€è™½ç„¶ä¼šé å­—ç¬¦ç ä½œä¸ºåœ°å€çš„æ•°ç»„æ…¢ä¸€ç‚¹ç‚¹ï¼Œä½†ä¹Ÿæ˜¯éžå¸¸å¿«çš„:$O(\log N)$ã€‚ä½†HashMapæœ¬èº«æ˜¯æ¯”è¾ƒè€—å†…å­˜çš„æ•°æ®ç»“æž„, æ‰€ä»¥å¦‚æžœçŸ¥é“è¦å¤„ç†çš„æ•°æ®æ˜¯åœ¨ç‰¹å®šèŒƒå›´å†…çš„, æ¯”å¦‚èŠ‚ç‚¹å°±æ˜¯åœ¨256ä¸ªå­—ç¬¦ä¸­, é‚£ä¹ˆè¿˜æ˜¯ä¸è¦ä¸ç”¨HashMap.]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Algorithm</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸Žä¿¡æ¯å¤„ç† 02 - å­—ç¬¦æœç´¢åŒ¹é…ç®—æ³• 02 - Boyer-Moore(BM) å’Œ Rabin-Karp(RK)]]></title>
    <url>%2FNLP-02-string-searching-algorithm-02-bm-rk%2F</url>
    <content type="text"><![CDATA[å­—ç¬¦ä¸²æœç´¢/åŒ¹é…ç®—æ³•ä¸­, Boyer-Moore(BM)æ¯”å‰é¢çš„Knuthâ€“Morrisâ€“Pratt(KMP)æ›´é«˜æ•ˆ. BMç®—æ³•ä»Žå³åˆ°å·¦æ‰«ææ¨¡å¼ä¸­çš„å­—ç¬¦ã€‚å½“åŒ¹é…çš„å­—ç¬¦åœ¨æ¨¡å¼ä¸­ä¸å­˜åœ¨æ—¶ï¼Œå¯ä»¥è·³è¿‡æœ€å¤šè¾¾Mä¸ªå­—ç¬¦. BMåœ¨å†³å®šè¦è·³è¿‡å¤šå°‘å­—ç¬¦æ—¶, åˆ†å‡ ç§æƒ…å†µè€ƒè™‘:1, mismatch character T not in pattern: increment i one character beyond T2.1, Mismatch character in pattern: mismatch character N in pattern, align text N with rightmost pattern N2.2, Mismatch character in pattern (but heuristic no help): mismatch character E in pattern, align text E with rightmost pattern E? è¿˜æ˜¯ increment i by 1? æ— æ³•ç¡®å®š, éœ€è¦è¾…åŠ©ä¿¡æ¯. éœ€è¦é¢„å…ˆè®¡ç®—æ¨¡å¼å„ä¸ªå­—ç¬¦åœ¨æ¨¡å¼æœ€å³è¾¹å‡ºçŽ°çš„ç´¢å¼•(è‹¥æ— åˆ™-1):12345right = new int[R];for (int c = 0; c &lt; R; c++) right[c] = -1;for (int j = 0; j &lt; M; j++) right[pat.charAt(j)] = j; 1234567891011121314151617181920public int search(String txt)&#123; int N = txt.length(); int M = pat.length(); int skip; for (int i = 0; i &lt;= N-M; i += skip) &#123; skip = 0; for (int j = M-1; j &gt;= 0; j--) &#123; if (pat.charAt(j) != txt.charAt(i+j)) &#123; skip = Math.max(1, j - right[txt.charAt(i+j)]); break; &#125; &#125; if (skip == 0) return i; // match &#125; return N;&#125; Substring search with the Boyer-Moore mismatched character heuristic takes about ~ N / M character compares to search for a pattern of length M in a text of length N.Worst-case. Can be as bad as ~ M N. Boyer-Mooreå˜ç§: é€šè¿‡æ·»åŠ ç±»ä¼¼KMPçš„è§„åˆ™æ¥é˜²æ­¢é‡å¤æ¨¡å¼ï¼Œå¯ä»¥å°†æœ€åæƒ…å†µæ”¹å–„ä¸º~3 Nå­—ç¬¦æ¯”è¾ƒã€‚ RKRabin-Karp åŸºäºŽ modular hashingï¼šãƒ»Compute a hash of pattern characters 0 to M - 1.ãƒ»For each i, compute a hash of text characters i to M + i - 1.ãƒ»If pattern hash = text substring hash, check for a match. æ‰€ä»¥ç®—æ³•çš„å…³é”®åœ¨äºŽå¦‚ä½•é«˜æ•ˆåœ°è®¡ç®—å“ˆå¸Œå€¼ï¼šHornerâ€™s method - ç”¨äºŽè¯„ä¼°Mé˜¶å¤šé¡¹å¼çš„çº¿æ€§æ—¶é—´æ–¹æ³•12345678// Compute hash for M-digit keyprivate long hash(String key, int M)&#123; long h = 0; for (int j = 0; j &lt; M; j++) h = (R * h + key.charAt(j)) % Q; return h;&#125; ç»™å®š$x_i$ï¼Œå¦‚ä½•è®¡ç®—$x_{i+1}$ï¼š$$x_i = t_i R^{M-1} + T_{i+1}R^{M-2} + â€¦ + t_{i+M-1}R^0$$$$x_{i+1} = t_{i+1}R^{M-1} + T_{i+2}R^{M-2} + â€¦ + t_{i+M}R^0$$$$x_{i+1} = (x_i - t_i R^{M-1}) R + t_{i+M}$$M-digit, base-R integer, modulo Qï¼Œ$R^{M-1}$æ˜¯å¯ä»¥é¢„å…ˆè®¡ç®—çš„.12345678910111213141516171819202122232425262728293031323334353637public class RabinKarp&#123; private long patHash; // pattern hash value private int M; // pattern length private long Q; // modulus private int R; // radix private long RM; // R^(M-1) % Q public RabinKarp(String pat) &#123; M = pat.length(); R = 256; Q = longRandomPrime(); // a large prime (but avoid overflow) RM = 1; // precompute R^&#123;M â€“ 1&#125; (mod Q) for (int i = 1; i &lt;= M-1; i++) RM = (R * RM) % Q; patHash = hash(pat, M); &#125; private long hash(String key, int M) &#123; /* as before */ &#125; /** check for hash collision using rolling hash function */ public int search(String txt) &#123; int N = txt.length(); int txtHash = hash(txt, M); if (patHash == txtHash) return 0; for (int i = M; i &lt; N; i++) &#123; txtHash = (txtHash + Q - RM*txt.charAt(i-M) % Q) % Q; txtHash = (txtHash*R + txt.charAt(i)) % Q; if (patHash == txtHash) return i - M + 1; &#125; return N; &#125;&#125; æœ‰ä¸¤ç§æ–¹å¼åˆ¤æ–­æ˜¯å¦åŒ¹é…ï¼š Monte Carlo version. Return match if hash match. Always runs in linear time. Extremely likely to return correct answer (but not always!). Las Vegas version. Check for substring match if hash match; continue search if false collision. Always returns correct answer. Extremely likely to run in linear time (but worst case is M N). In theory, if Q is a sufficiently large random prime (about $M N^2$), then the probability of a false collision is about 1 / N.In practice, choose Q to be a large prime (but not so large to cause overflow). Under reasonable assumptions, probability of a collision is about 1 / Q. æ€»ç»“ç®—æ³•å¯ä»¥æ‹“å±•åˆ°äºŒç»´æ¨¡å¼åŒ¹é…, å¤šæ¨¡å¼åŒ¹é…ç­‰é—®é¢˜.]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Algorithm</tag>
        <tag>Boyer-Moore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½æ“ä½œ - å¿«é€Ÿå¹‚]]></title>
    <url>%2Fbits-operations-07%2F</url>
    <content type="text"><![CDATA[å¦‚ä½•å®žçŽ°å¿«é€Ÿçš„å¹‚è¿ç®—ï¼Ÿ è¦æ±‚$c = a^b$, æŒ‰ç…§æœ´ç´ ç®—æ³•æŠŠaè¿žä¹˜bæ¬¡çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$. è€Œå¿«é€Ÿå¹‚èƒ½åšåˆ°$O(\log n)$ã€‚æŠŠbè½¬æ¢ä¸ºäºŒè¿›åˆ¶, äºŒè¿›åˆ¶æ•°ç¬¬iä½çš„æƒä¸º$2^{i-1}$ï¼Œå°±å¯ä»¥æŠŠäºŒè¿›åˆ¶æ‹†åˆ†ä¸ºè‹¥å¹²ä¸ªä»¥2ä¸ºåº•çš„çœŸæ•°, ç„¶åŽåˆ©ç”¨å¹‚æ•°çš„æ€§è´¨ï¼Œä¾‹å¦‚ç”¨æœ´ç´ ç®—æ³•æ±‚$a^{11}$è¦æ±‚ä¹˜11æ¬¡. è€ƒè™‘åˆ°11çš„äºŒè¿›åˆ¶ä¸º1011, å¦‚æžœæŠŠ$a^{11}$æ‹†åˆ†ä¸º:$$a^{11} = a^{a_0 2^0 + a_1 2^1 + a_2 0 + a_3 2^3} = a^1 a^2 a^8$$å¯ä»¥çœ‹åˆ°æ¯ä¸€ä¸ªå› å­éƒ½æ˜¯ä¸Šä¸€ä¸ªå› å­çš„å¹³æ–¹ï¼Œåˆ©ç”¨$a^2 a^2$æ±‚å‡º$a^4$, åŒæ ·åˆ©ç”¨$a^4$çš„å¹³æ–¹æ±‚å‡º$a^8$, æ¯æ¬¡è®¡ç®—åªéœ€è¦ç”¨åˆ°ä¸Šä¸€æ¬¡è®¡ç®—å‡ºæ¥çš„ç»“æžœ, æ‰€ä»¥æ€»çš„è¿ç®—æ¬¡æ•°æ˜¯4æ¬¡. ä»»ä½•ä¸€ä¸ªæ•°bæœ€å¤šèƒ½å†™æˆé•¿åº¦ä¸º$O(\log b)$çš„äºŒè¿›åˆ¶, å› æ­¤è¿™ä¸ªç®—æ³•å°±æ˜¯$O(\log n)$. åœ¨ç¨‹åºè®¾è®¡ä¸­æ˜¯æ ¹æ®bçš„äºŒè¿›åˆ¶ä¸­æ˜¯å¦ä¸º1æ¥æŽ§åˆ¶æ˜¯å¦ä¹˜ä»¥ä¸Šä¸€æ¬¡ç¿»å€çš„ç§¯ ä¸æ–­å³ç§»b, ç›´åˆ°bä¸å†æœ‰1ï¼š æ ¹æ®å½“å‰ä½çš„æƒé‡ï¼ˆå½“å‰bæœ€åŽä¸€ä½ï¼‰æ˜¯å¦ä¸º1æ¥å†³å®šcæ˜¯å¦ä¹˜ä»¥æœ€æ–°çš„a æŠŠaå¹³æ–¹ï¼Œç”¨äºŽä¸‹ä¸€ä½è®¡ç®— åœ¨Javaä¸­è¦è€ƒè™‘æžç«¯å€¼INT_MIN123456789101112// é€’å½’public double myPow(double x, int n) &#123; if(n==0) return 1; double temp = myPow(x, n/2); if (n % 2 ==0) return temp * temp; else &#123; if(n &gt; 0) return x*temp*temp; else return (temp*temp) / x; &#125;&#125; 123456789101112131415161718// å¾ªçŽ¯public double myPow(double x, int n) &#123; double ans = 1; if(n &lt; 0)&#123; n = -(n+1); // å¤„ç†æžç«¯å€¼ x = 1/x; ans *= x; &#125; System.out.println(n); while (n &gt; 0) &#123; if ((n &amp; 1) == 1) ans *= x; x *= x; n &gt;&gt;= 1; &#125; return ans;&#125; å¿«é€Ÿå¹‚å–ä½™æ±‚a^b mod c.å¦‚æžœbæ˜¯å¶æ•°, a^b mod c = $(a^2)^{b/2} \% c$å¦‚æžœbæ˜¯å¥‡æ•°, a^b mod c = $((a^2)^{b/2} \times a) \% c$ åˆå› ä¸ºå–ä½™æœ‰æ€§è´¨:a^b mod c = (a mod c)^b å¼•ç†ï¼š(a * b) mod c = [( a mod c ) * (b mod c) ] mod c è¯æ˜Žï¼š12345è®¾ a mod c =dï¼Œb mod c= e; åˆ™ï¼ša=t*c + d ; b=k*c + e ; (a*b)mod c = (t*c+d)(t*c+e) = (tk c^2 + ( te+dk ) *c + d*e) mod c = de mod c å³ç§¯çš„å–ä½™ç­‰äºŽå–ä½™çš„ç§¯çš„å–ä½™. åˆ©ç”¨å¿«é€Ÿå¹‚çš„æ€æƒ³, ä»¤k = (a * a) mod cï¼Œæ‰€è¦æ±‚çš„æœ€ç»ˆç»“æžœå³ä¸º k^(b/2) mod c, è¿™ä¸ªè¿‡ç¨‹å¯ä»¥è¿­ä»£ä¸‹åŽ», å¦‚æžœbæ˜¯å¥‡æ•°, æˆ–å¤šå‡ºä¸€é¡¹a mod c. å½“b = 0æ—¶, æ‰€æœ‰å› å­å·²ç»ç›¸ä¹˜, è¿­ä»£ç»“æŸ, å¤æ‚åº¦ä¸ºO(log b)123456789101112long long PowerMod(int a, int b, int c)&#123; int ans = 1; a = a % c; while(b&gt;0) &#123; if(b % 2 = = 1) ans = (ans * a) % c; b = b/2; // b&gt;&gt;=1; a = (a * a) % c; &#125; return ans;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLPä¸Žä¿¡æ¯å¤„ç† 01 - å­—ç¬¦æœç´¢åŒ¹é…ç®—æ³• 01 - KMP]]></title>
    <url>%2FNLP-01-string-searching-algorithm-01-kmp%2F</url>
    <content type="text"><![CDATA[In computer science, string-searching algorithms, sometimes called string-matching algorithms, are an important class of string algorithms that try to find a place where one or several strings (also called patterns) are found within a larger string or text. å­—ç¬¦ä¸²æœç´¢/åŒ¹é…ç®—æ³•åœ¨å¤§è§„æ¨¡æ–‡æœ¬åº”ç”¨ä¸­æœ‰éžå¸¸é‡è¦çš„ä½œç”¨ï¼Œæ¯”å¦‚æ–‡ç« æ•æ„Ÿè¯æœç´¢ï¼Œå¤šå…³é”®è¯è¿‡æ»¤æœç´¢ç­‰ã€‚å¦‚æžœä½¿ç”¨æš´åŠ›æœç´¢ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦å¾ˆé«˜ï¼ˆè‹¥ m ä¸ºå…³é”®å­—çš„é•¿åº¦ï¼Œ n ä¸ºè¦å¾…æœç´¢çš„å­—ç¬¦ä¸²é•¿åº¦ï¼Œ kä¸ºå…³é”®å­—æ•°é‡ï¼Œåˆ™å¤æ‚åº¦ä¸º$O(n \times m \times k)$ã€‚è€Œå¥½çš„ç®—æ³•å¯ä»¥è®©è¿™äº›é—®é¢˜çš„æ—¶é—´å¤æ‚åº¦å¤§å¤§é™ä½Žã€‚ å¸¸ç”¨çš„ç®—æ³•æœ‰Knuthâ€“Morrisâ€“Pratt(KMP), Boyer-Moore(BM), Rabin-Karp(RK), Trie, Trieå›¾, ACè‡ªåŠ¨æœºç­‰. KMPKnuthâ€“Morrisâ€“Pratt ç®—æ³•åœ¨æ¯æ¬¡æœç´¢åŒ¹é…å‰ï¼Œé¢„å¤„ç†æ¨¡å¼å­—ç¬¦ä¸²ï¼Œè®°å½•æ¨¡å¼å­—ç¬¦ä¸²è‡ªèº«é‡å¤çš„æƒ…å†µï¼Œå³åŒ…å«å·¦ä¸´ç•Œçš„å­å­—ç¬¦ä¸²å’ŒåŒ…å«å³ä¸´ç•Œçš„å­å­—ç¬¦ä¸²çš„é‡å¤é•¿åº¦ï¼Œä»¥æ­¤æ¥ä½œä¸ºåŽç»­åŒ¹é…çš„å‚è€ƒã€‚å½“å®žé™…åŽ»åŒ¹é…å¸¦æœç´¢å­—ç¬¦ä¸²æ—¶ï¼Œæƒ³è±¡æ˜¯æˆ‘ä»¬æ‹¿ç€æ¨¡å¼å­—ç¬¦ä¸²ä»Žå·¦åˆ°å³åŒ¹é…è¿‡åŽ»ã€‚ä»»ä½•æ—¶å€™ï¼Œå¦‚æžœå‘çŽ°åŒ¹é…ä¸ä¸Šçš„æ—¶ï¼Œä¸æ˜¯ç®€å•åœ°å³ç§»ä¸€ä½ç»§ç»­é‡æ–°åŒ¹é…ï¼Œè€Œæ˜¯åœ¨å·²åŒ¹é…éƒ¨åˆ†çš„èŒƒå›´å†…ï¼Œç›´æŽ¥è·³è¿‡kä¸ªå­—ç¬¦ï¼Œå³ç§»åˆ°ä¸Žæ¨¡å¼å¼€å¤´éƒ¨åˆ†é‡å¤çš„ä½ç½®ï¼Œå¹¶æŽ¥ç€é‡å¤éƒ¨åˆ†åŽé¢ç»§ç»­å¼€å§‹åŒ¹é…ï¼ˆé‡å¤çš„éƒ¨åˆ†è¯æ˜Žå·²ç»åŒ¹é…è¿‡ï¼‰ã€‚ ä¸€ä¸ªå¾ˆå¥½è§£é‡Šå‚è€ƒKMPç®—æ³•çš„ç†è®ºåŸºç¡€åŸºäºŽç¡®å®šæ€§æœ‰é™çŠ¶æ€è‡ªåŠ¨æœº DFAï¼ˆDeterministic finite state automatonï¼‰ã€‚DFAå¯ä»¥ç†è§£ä¸ºæŠ½è±¡çš„å­—ç¬¦æœç´¢æœºï¼š æœ‰é™æ•°é‡çš„çŠ¶æ€ï¼ˆåŒ…æ‹¬å¼€å§‹å’Œåœæ­¢ï¼‰ã€‚ å­—æ¯è¡¨æ¯ä¸ªå­—ç¬¦å¯¹åº”ä¸€ä¸ªçŠ¶æ€è½¬æ¢ã€‚ åªæŽ¥å—èƒ½é€šå¾€åœæ­¢çŠ¶æ€çš„è½¬æ¢åºåˆ—ã€‚ å¦‚ABCAABABABABå¯¹åº”0â†’1â†’2â†’0â†’1â†’1â†’2â†’3â†’4â†’5â†’4â†’5â†’4 å¯ä»¥çœ‹å‡ºKMPç®—æ³•çš„å‡ ä¸ªè¦ç‚¹: çŠ¶æ€State: è¡¨ç¤ºæ¨¡å¼ä¸­å·²åŒ¹é…çš„å­—ç¬¦æ•°ã€‚pattern[]æœ€é•¿å‰ç¼€(åŒæ—¶æ˜¯txt[0..i]çš„åŽç¼€)çš„é•¿åº¦. éœ€è¦é¢„å…ˆä»Žpatternä¸­è®¡ç®—dfa[][] å­—ç¬¦ä¸²éåŽ†æŒ‡é’ˆåªä¼šå‰è¿›ä¸ä¼šåŽé€€ 12345678public int search(String txt)&#123; int i, j, N = txt.length(); for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) j = dfa[txt.charAt(i)][j]; if (j == M) return i - M; else return N;&#125; Running time: at most N character accesses to Simulate DFA on text. ä½¿ç”¨DFAç”¨çŠ¶æ€state jè¡¨ç¤ºæ¨¡å¼patçš„å‰jä¸ªå­—ç¬¦å·²ç»åŒ¹é…. ç”¨dfa[c][j]è¡¨ç¤ºåœ¨çŠ¶æ€state jæ—¶, é‡åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦c, åº”è¯¥è½¬ç§»åˆ°ä»€ä¹ˆçŠ¶æ€. åœ¨çŠ¶æ€state jï¼šÂ· å¦‚æžœåŒ¹é…æˆåŠŸï¼Œchar c == pat.charAt(j)ï¼Œåˆ™è½¬ç§»åˆ°state j+1: dfa[pat.charAt(j)][j] = j+1.Â· å¦‚æžœå¤±è´¥ï¼Œåˆ™ä»Žpat[1..j-1]å¯¹åº”çš„DFAçŠ¶æ€Xï¼Œå‘ç€cæ–¹å‘è½¬ç§»ï¼šcopy dfa[][X] to dfa[][j].ãƒ»Update X.1234567891011121314public KMP(String pat)&#123; this.pat = pat; M = pat.length(); dfa = new int[R][M]; dfa[pat.charAt(0)][0] = 1; for (int X = 0, j = 1; j &lt; M; j++) &#123; for (int c = 0; c &lt; R; c++) dfa[c][j] = dfa[c][X]; // copy mismatch cases dfa[pat.charAt(j)][j] = j+1; X = dfa[pat.charAt(j)][X]; &#125;&#125; Running time. M character accesses (but space/time proportional to R M). NEXTæ•°ç»„å‡è®¾çŽ°åœ¨æ–‡æœ¬ä¸²SåŒ¹é…åˆ°iä½ç½®ï¼Œæ¨¡å¼ä¸²PåŒ¹é…åˆ°jä½ç½®:é¦–å…ˆç¬¬ä¸€ä½NEXTå€¼next[0]ä¸€å®šæ˜¯-1, åŽé¢çš„ç¬¬j+1ä¸ªå€¼next[j]ä»£è¡¨[0, j-1]éƒ¨åˆ†æœ‰å¤šå°‘é‡å¤å‰åŽç¼€. å¯ä»¥æ ¹æ®å‰ä¸€ä½çš„next[j-1]å€¼kæŽ¨æ–­: å¦‚æžœP[j] == P[k], åˆ™æ„å‘³ç€é‡å¤å‰åŽç¼€é•¿åº¦+1, é‚£ä¹ˆnext[j] = next[j-1] + 1 = k + 1. å¦‚æžœP[j] != P[k], åˆ™æ„å‘³ç€å‰é¢é‡å¤å‰åŽç¼€æ— æ³•ç»§ç»­ä¸‹åŽ». æ­¤æ—¶ä¸èƒ½ç®€å•åœ°åˆ¤å®šnext[j] = 0, éœ€è¦ç»§ç»­å¾€å‰çœ‹æ˜¯å¦æœ‰æ›´çŸ­å°çš„é‡å¤å‰åŽç¼€. åˆå› ä¸ºé‡å¤å‰åŽç¼€æ„å‘³ç€å‰åŽç«¯ç›¸åŒ, å› æ­¤å¯ä»¥ç›´æŽ¥åŒ¹é…P[j] ?= P[k&#39;], k&#39; = next[k], ä»¥æ­¤å¾ªçŽ¯ä¸‹åŽ»ç›´åˆ°k&#39; = -1ä¸ºæ­¢. ä»¥ä¸Šç®—æ³•è¿˜å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–: å½“P[j] != S[i]æ—¶ï¼Œä¸‹æ¬¡å¿…ç„¶åŒ¹é…P[next [j]] ?= S[i]ï¼Œæ­¤æ—¶å¦‚æžœP[j] == P[next[j]]ï¼Œåˆ™æ„å‘³ç€åŒ¹é…å¿…ç„¶å¤±è´¥. è¿™æ ·å°±å‡ºçŽ°äº†å†—ä½™åŒ¹é…ã€‚æ‰€ä»¥å¦‚æžœå‡ºçŽ°P[j] == P[next[j]]ï¼Œåˆ™ä»¤next[j] = next[next[j]] = next[next[j-1] + 1] = next[k + 1].12345678910111213141516public void GetNext(char[] p, int[] next) &#123; next[0] = -1; int k = -1; int j = -1; while (j &lt; p.length - 1) &#123; //p[k]è¡¨ç¤ºå‰ç¼€ï¼Œp[j]è¡¨ç¤ºåŽç¼€ if (k == -1 || p[j] == p[k]) &#123; if (p[++j] != p[++k]) next[j] = k; else next[j] = next[k]; &#125; else k = next[k]; &#125;&#125; å¯¹äºŽä¼˜åŒ–åŽçš„nextæ•°ç»„å¯ä»¥å‘çŽ°ä¸€ç‚¹ï¼šå¦‚æžœæ¨¡å¼ä¸²çš„åŽç¼€è·Ÿå‰ç¼€ç›¸åŒï¼Œé‚£ä¹ˆå®ƒä»¬çš„nextå€¼ä¹Ÿæ˜¯ç›¸åŒçš„ï¼Œä¾‹å¦‚æ¨¡å¼ä¸²abcabcï¼Œå®ƒçš„å‰ç¼€åŽç¼€éƒ½æ˜¯abcï¼Œå…¶ä¼˜åŒ–åŽçš„nextæ•°ç»„ä¸ºï¼š-1 0 0 -1 0 0ï¼Œå‰ç¼€åŽç¼€abcçš„nextå€¼éƒ½ä¸º-1 0 0. åŸºäºŽNEXTæ•°ç»„çš„KMPç®—æ³•åŸºäºŽå‰é¢æ±‚å‡ºçš„NEXTæ•°ç»„, å¯ä»¥æ ¹æ®ä»¥ä¸‹æ­¥éª¤å®žçŽ°KMPç®—æ³•: å‡è®¾çŽ°åœ¨æ–‡æœ¬ä¸²SåŒ¹é…åˆ°iä½ç½®ï¼Œæ¨¡å¼ä¸²PåŒ¹é…åˆ°jä½ç½® if j = -1, or S[i] == P[j](å½“å‰å­—ç¬¦åŒ¹é…æˆåŠŸ), then i++, j++ else, j = next[j]ã€‚å½“å¤±é…æ—¶ï¼Œæ¨¡å¼ä¸²Pç›¸å¯¹äºŽæ–‡æœ¬ä¸²Så‘å³ç§»åŠ¨j - next[j]ä½(å¤§äºŽç­‰äºŽ1)ã€‚ 123456789101112131415161718/** è¿”å›žæ¨¡å¼ä¸²ç¬¬ä¸€æ¬¡åœ¨æ–‡æœ¬ä¸²ä¸­å‡ºçŽ°çš„ä½ç½® */public int KmpSearch(char[] s, char[] p) &#123; int i = 0; int j = 0; while (i &lt; s.length &amp;&amp; j &lt; p.length) &#123; if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if (j == p.length) &#123; return i - j; &#125; else &#123; return -1; &#125;&#125; KMPåº”ç”¨åˆ¤æ–­ä¸€æ®µæ–‡å­—ï¼ˆåŽŸä¸²ï¼‰é‡Œé¢æ˜¯å¦å­˜åœ¨æ•æ„Ÿè¯ï¼ˆæ¨¡å¼ä¸²ï¼‰ã€‚åŽŸé¢˜åœ°å€ http://hihocoder.com/problemset/problem/1015?sid=1368409ï¼š è¾“å…¥ï¼šç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°Nï¼Œè¡¨ç¤ºæµ‹è¯•æ•°æ®ç»„æ•°ã€‚æŽ¥ä¸‹æ¥çš„N*2è¡Œï¼Œæ¯ä¸¤è¡Œè¡¨ç¤ºä¸€ä¸ªæµ‹è¯•æ•°æ®ã€‚åœ¨æ¯ä¸€ä¸ªæµ‹è¯•æ•°æ®ä¸­ï¼Œç¬¬ä¸€è¡Œä¸ºæ¨¡å¼ä¸²ï¼Œç”±ä¸è¶…è¿‡10^4ä¸ªå¤§å†™å­—æ¯ç»„æˆï¼Œç¬¬äºŒè¡Œä¸ºåŽŸä¸²ï¼Œç”±ä¸è¶…è¿‡10^6ä¸ªå¤§å†™å­—æ¯ç»„æˆã€‚å…¶ä¸­N&lt;=20.12345678910115HAHAHAHAWQNWQNADAADADADABABABBBABABABABABABABABBDADADDAADAADDAAADAAD è¾“å‡º: å¯¹äºŽæ¯ä¸€ä¸ªæµ‹è¯•æ•°æ®ï¼ŒæŒ‰ç…§å®ƒä»¬åœ¨è¾“å…¥ä¸­å‡ºçŽ°çš„é¡ºåºè¾“å‡ºä¸€è¡ŒAnsï¼Œè¡¨ç¤ºæ¨¡å¼ä¸²åœ¨åŽŸä¸²ä¸­å‡ºçŽ°çš„æ¬¡æ•°ã€‚1234531310 è¿™é‡Œæ˜¯éœ€è¦æ‰¾å‡ºå‡ºçŽ°çš„æ¬¡æ•°ï¼Œå› æ­¤ä¸ä»…ä»…æ˜¯æ‰¾åˆ°ç¬¬ä¸€ä¸ªï¼Œè¿˜è¦ç»§ç»­éåŽ†åŽŸä¸²ç»Ÿè®¡å‰©ä½™å‡ºçŽ°çš„æ¬¡æ•°ï¼ŒåŒæ—¶è¦è€ƒè™‘é‡å çš„éƒ¨åˆ†ã€‚å…³é”®çš„åŠŸèƒ½ä»£ç å¯ä»¥å¤åˆ¶ä¸Šé¢çš„ï¼Œä½†æ˜¯éœ€è¦ä½œå‡ºä¸€äº›æ”¹åŠ¨ã€‚ é¦–å…ˆï¼Œå› ä¸ºéƒ¨åˆ†é‡å æƒ…å†µä¹Ÿæ˜¯è¦ç»Ÿè®¡çš„ï¼Œæ¯”å¦‚ADADADAè¿™ä¸ªåŽŸä¸², åŒ…å«3ä¸ªADA. æ‰€ä»¥è¦è€ƒè™‘å³ä½¿åŒ¹é…æˆåŠŸåŽ, æ¨¡å¼ä¸²çš„ç´¢å¼•jèƒ½å¤Ÿè·³å›žå‰é¢çš„é‡å¤å‰ç¼€ä½ç½®. è€ƒè™‘ä½¿ç”¨æœªä¼˜åŒ–è¿‡çš„NEXTè®¡ç®—æ–¹æ³•. é™¤æ­¤ä¹‹å¤–, é€šè¿‡é¢å¤–è®¡ç®—å¤šä¸€ä½NEXTå€¼, è®°å½•å®Œæ•´çš„æ¨¡å¼ä¸²çš„é‡å¤å‰åŽç¼€é•¿åº¦, ä»¥ååŠ©ç´¢å¼•.123456789101112public static void GetNext(char[] p, int[] next) &#123; next[0] = -1; int k = -1; int j = 0; while (j &lt; p.length) &#123; if (k == -1 || p[j] == p[k]) &#123; next[++j] = ++k; &#125; else &#123; k = next[k]; &#125; &#125;&#125; å¯¹äºŽADA, åŽŸæ¥æœªä¼˜åŒ–è¿‡çš„NEXTæ˜¯-1,0,0, çŽ°åœ¨æ˜¯-1,0,0,1, æœ€åŽä¸€ä½1è¡¨ç¤ºADAè¿™ä¸ªæ¨¡å¼ä¸²çš„é‡å¤å‰åŽç¼€æ˜¯é•¿åº¦ä¸º1çš„A. å€ŸåŠ©é¢å¤–é•¿åº¦çš„NEXT, åªéœ€è¦å°å°åœ°æ”¹åŠ¨KMPè®¡ç®—é€»è¾‘, æœ€é‡è¦çš„æ˜¯å½“jåˆ°è¾¾NEXTçš„é¢å¤–ä½ç½®æ—¶, é€šè¿‡j = next[j];æŠŠjåŽæ‹¨åˆ°é‡å¤å‰ç¼€çš„ä½ç½®, ä»¥æ–¹ä¾¿è¿›è¡ŒåŽé¢çš„æœç´¢.123456789101112131415161718192021/** è¿”å›žæ¨¡å¼ä¸²åœ¨åŽŸä¸²ä¸­å‡ºçŽ°çš„æ¬¡æ•° */public static int KmpSearch(char[] s, char[] p) &#123; int[] next = new int[p.length + 1]; // é¢å¤–å¤šè®¡ç®—ä¸€ä½ GetNext(p, next); int c = 0, i = 0, j = 0; int len = s.length; while (i &lt; len) &#123; if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; if (j == p.length) &#123; c++; j = next[j]; &#125; &#125; return c;&#125;]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Algorithm</tag>
        <tag>Trie</tag>
        <tag>KMP</tag>
        <tag>Ahoâ€“Corasick algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½æ“ä½œ - æ±‰æ˜Žè·ç¦»]]></title>
    <url>%2Fbits-operations-06%2F</url>
    <content type="text"><![CDATA[æ±‚ä¸¤ä¸ªæ•´æ•°çš„æ±‰æ˜Žè·ç¦» hamming distanceLeetcode 461ä¸¤ä¸ªæ•´æ•°ä¹‹é—´çš„æ±‰æ˜Žè·ç¦»æ˜¯è¯¥ä¸¤ä¸ªæ•°ä¹‹é—´ä¸åŒçš„ä½æ•°ã€‚ ç»™å®šä¸¤ä¸ªæ•´æ•°xå’Œyï¼Œè®¡ç®—æ±‰æ˜Žè·ç¦»ã€‚é—®é¢˜ä¹Ÿå¯ä»¥ç†è§£ä¸ºå¯¹äºŽä¸¤ä¸ªæ•´æ•°må’Œn, éœ€è¦æ”¹å˜mçš„äºŒè¿›åˆ¶å¤šå°‘ä½æ‰èƒ½å¾—åˆ°n:12345678910/** Use Brian Kernighan's way to count bits */public int hammingDistance(int x, int y) &#123; x = x ^ y; y = 0; while(x != 0)&#123; y++; x &amp;= x - 1; &#125; return y;&#125; 12345public class Solution &#123; public int hammingDistance(int x, int y) &#123; return Integer.bitCount(x ^ y); &#125;&#125; åŒæ ·ç”¨åˆ°Brian Kernighanç®—æ³•ï¼š Lets say that the bit at index n is 1 and that the bits in indexes 0 up to n-1 are all 0 (weâ€™ll use little endianess - so index 0 is 1, index 1 is 2, index 2 is 4, index 3 is 8 and so on). v-1 subtracts from index 0 - but itâ€™s 0, so it converts it to 1 and subtracts from index 1 - but itâ€™s also 0, so it converts it to 1 and subtracts from index 2 - and so on until we reach index n. Since index n is 1 it can subtract from it and turn it to 0 - and there it stops: 1101000 - 1 = 1100111 So, v-1 is like v except there are n 0 that became 1 and one 1 that became 0. In v &amp; v - 1 all the other bits remain as is, the n zeros that where turned to ones remain 0 (because 0 &amp; 1 == 0), and the one 1 that was turned to 0 turns to 0(because 1 &amp; 0 == 0). So overall - only a single bit was changed in the iteration, and this change was from 1 to 0: 1101000 &amp; 1100111 = 1100000]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½æ“ä½œ - æ‰¾å‡ºåªå‡ºçŽ°ä¸€æ¬¡çš„æ•° - åŠç±»ä¼¼é—®é¢˜]]></title>
    <url>%2Fbits-operations-04%2F</url>
    <content type="text"><![CDATA[â€œæ‰¾å‡ºåªå‡ºçŽ°ä¸€æ¬¡çš„æ•°â€ï¼Œ â€œæ‰¾å‡ºå”¯äºŒçš„åªå‡ºçŽ°Mæ¬¡çš„æ•°â€ï¼Œ â€œæ‰¾å‡ºç¼ºå¤±çš„æ•°â€ç­‰ç­‰ï¼Œéƒ½å¯ä»¥åˆ©ç”¨å¼‚æˆ–æ“ä½œçš„ç‰¹æ€§ï¼Œ å³ä¸€ä¸ªæ•´æ•°å’Œè‡ªå·±è¿›è¡Œå¼‚æˆ–è¿ç®—ä¼šå½’0çš„æ€§è´¨ã€‚ æ‰¾å‡ºå”¯ä¸€ä¸€ä¸ªä»…å‡ºçŽ°Mæ¬¡çš„æ•°åœ¨ä¸€ä¸ªéžç©ºæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºé‚£ä¸ªåªå‡ºçŽ°äº†ä¸€æ¬¡çš„å…ƒç´ ï¼Œå·²çŸ¥å…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºçŽ°ä¸¤æ¬¡ã€‚è¦è¾¾åˆ°O(n)å¤æ‚åº¦éœ€è¦åˆ©ç”¨ä½å¼‚æˆ–. ä½å¼‚æˆ–è¿ç®—èƒ½å¤ŸæŠŠäºŒè¿›åˆ¶ç›¸åŒçš„æ•°åŒ–ä¸º0. æŠŠæ•°ç»„æ‰€æœ‰çš„æ•°éƒ½å¼‚æˆ–, å‡ºçŽ°ä¸¤æ¬¡çš„æ•°å°±ä¼šäº’ç›¸æŠµæ¶ˆä¸º0, å‰©ä½™çš„å°±æ˜¯é‚£ä¸ªåªå‡ºçŽ°äº†ä¸€æ¬¡çš„æ•°:123456public int singleNumber(int[] nums) &#123; int output = 0; for (int i : nums) output ^= i; return output;&#125; ä½†å¦‚æžœæŠŠé—®é¢˜æ‰©å±•ä¸ºâ€œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºçŽ°ä¸‰æ¬¡â€ï¼Œ è¿™æ ·å°±æ— æ³•ç›´æŽ¥åˆ©ç”¨å¼‚æˆ–æŠµæ¶ˆçš„æ€§è´¨äº†ã€‚å‰‘æŒ‡Offerçš„è§£æ³•æ˜¯ç”¨ä¸€ä¸ªé•¿åº¦32çš„æ•°ç»„bitSum, æŠŠåŽŸæ•°ç»„æ‰€æœ‰æ•´æ•°çš„äºŒè¿›åˆ¶æ¯ä¸€ä½åˆ†åˆ«ç´¯åŠ åˆ°bitSumé‡Œé¢, è¿™æ ·å°±å¯ä»¥é€šè¿‡åˆ¤æ–­bitSumå“ªäº›ä½ä¸å¯ä»¥è¢«3æ•´é™¤æ¥æ‰¾å‡ºé‚£ä¸ªæ•°:123456789101112131415161718192021public int singleNumber(int[] nums) &#123; int[] bitSum = new int[32]; for (int i = 0; i &lt; nums.length; i++) &#123; int bitMask = 1; for (int j = 31; j &gt;= 0; j--) &#123; int b = nums[i] &amp; bitMask; if (b != 0) bitSum[j] += 1; bitMask &lt;&lt;= 1; &#125; &#125; int res = 0; for (int i = 0; i &lt; 32; i++) &#123; res &lt;&lt;= 1; res += bitSum[i] % 3; &#125; return res;&#125; å› ä¸ºbitSumçš„é•¿åº¦æ˜¯å¸¸æ•°, æ‰€ä»¥è¯¥æ–¹æ³•å¤æ‚åº¦è¿˜æ˜¯O(N). è¯¥æ–¹æ³•å¯ä»¥è¿›ä¸€æ­¥æ‰©å±•é—®é¢˜ä¸ºæ±‚å”¯ä¸€ä¸€ä¸ªå…ƒç´ å‡ºçŽ°Mæ¬¡ï¼Œå…¶ä»–æ‰€æœ‰å…ƒç´ å‡ºçŽ°Kæ¬¡çš„é—®é¢˜ã€‚ é™¤æ­¤ä¹‹å¤–, è¿˜æœ‰å…¶ä»–æ›´ç²¾ç®€çš„é€šç”¨çš„æ–¹æ³•æ¥è§£å†³æ­¤ç±»é—®é¢˜. æž„é€ çŠ¶æ€è½¬ç§»è¡¨æ–¹æ³•æ¥è‡ªAn General Way to Handle All this sort of questions, è¿™ä¸ªæ–¹æ³•æ ¸å¿ƒæ€æƒ³æ˜¯å»ºç«‹ä¸€ä¸ªè®°å½•çŠ¶æ€çš„å˜é‡, è¯¥å˜é‡ä»£è¡¨æŸä¸ªæ•°å­—å‡ºçŽ°ä¸€æ¬¡åŽçš„çŠ¶æ€. ç›®æ ‡å°±æ˜¯ä½¿å¾—ä¸€ä¸ªæ•°å­—é‡å¤å‡ºçŽ°Kæ¬¡åŽçŠ¶æ€åˆšå¥½å½’0. å¯¹äºŽK=2, å°±è¦ä½¿ä¸¤æ¬¡å åŠ åŽå½’0, éœ€è¦ä¸¤ç§çŠ¶æ€, ä»Žä¿¡æ¯è®ºçš„è§’åº¦çœ‹å¾…, åªéœ€è¦ä¸€ä¸ªä½(0,1)æ¥è¡¨è¾¾ï¼ŒçŠ¶æ€0å¯¹åº”ç€ä¸¤ç§ç­‰ä»·çš„æƒ…å†µ: ä¸€ä¸ªæ•°å­—å®Œå…¨æ²¡å‡ºçŽ°è¿‡, æˆ–è€…å‡ºçŽ°äº†2æ¬¡åŽä¸€èµ·æŠµæ¶ˆé‡ç½®. çŠ¶æ€1å¯¹åº”ç€ä»…ä»…å‡ºçŽ°ä¸€æ¬¡çš„æƒ…å†µ. åœ¨è¿™é‡Œæ•°å­—å’ŒçŠ¶æ€æ¦‚å¿µç­‰ä»·ï¼Œæž„å»ºä¸€ä¸ªçŠ¶æ€è½¬ç§»è¡¨ï¼ˆçœŸå€¼è¡¨ï¼‰ï¼š123456çŠ¶æ€ è¾“å…¥ è¾“å‡ºa c a0 0 01 0 10 1 11 1 0 å¯ä»¥çœ‹åˆ°ï¼Œä¸ç®¡æ˜¯çŠ¶æ€1è¿˜æ˜¯0ï¼Œå¦‚æžœè¾“å…¥ç›¸åŒæ•°å­—ï¼Œå°±ä¼šå˜ä¸º0ï¼›å¦‚æžœè¾“å…¥ä¸åŒçš„æ•°å­—ï¼Œå°±ä¼šå˜ä¸º1. æ ¹æ®è¡¨å†™å‡ºé€»è¾‘è¡¨è¾¾å¼ä¸ºå¼‚æˆ–è¿ç®—. æ ¹æ®çœŸå€¼è¡¨å†™å‡ºé€»è¾‘å¼çš„åŸºæœ¬å¥—è·¯æ˜¯: åªçœ‹è¾“å‡ºç»“æžœä¸º1çš„è½¬ç§», å‡¡å–å€¼ä¸º1çš„å˜é‡å†™æˆåŽŸå˜é‡ï¼Œå–å€¼ä¸º0çš„å˜é‡å†™æˆåå˜é‡, å¾—å‡ºå¯¹åº”çš„è¡¨è¾¾å¼, å†æŠŠæ‰€æœ‰è½¬ç§»æ–¹ç¨‹çš„è¡¨è¾¾å¼åŠ èµ·æ¥. å¦‚è¾“å‡ºä¸º1çš„æ˜¯0 &amp; 1 = 1, 1 &amp; 0 = 1, è¡¨è¾¾å¼å°±æ˜¯(~a &amp; c) | (a &amp; ~c), è¿™ä¸ªæœ¬è´¨ä¸Šå°±æ˜¯a ^ c å¯¹äºŽK = 3, M = 1(or 2), éœ€è¦ä¸‰ç§çŠ¶æ€, é‚£ä¹ˆè‡³å°‘éœ€è¦ä¸¤ä¸ªä½(00, 01, 10)æ¥è¡¨è¾¾. è®©çŠ¶æ€00å¯¹åº”â€å‡â€è¾“å‡º, å¯¹åº”ä¸¤ç§ç­‰ä»·çš„æƒ…å†µ: ä¸€ä¸ªæ•°å­—å®Œå…¨æ²¡å‡ºçŽ°è¿‡, æˆ–è€…å‡ºçŽ°äº†3æ¬¡åŽä¸€èµ·æŠµæ¶ˆé‡ç½®. å†å®šä¹‰01ä¸ºå‡ºçŽ°äº†ä¸€æ¬¡çš„çŠ¶æ€, 10ä¸ºå‡ºçŽ°äº†2æ¬¡, è¿™ä¸¤ç§çŠ¶æ€éƒ½å¯¹åº”ç€â€çœŸâ€è¾“å‡º, ä¹Ÿå°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„ç­”æ¡ˆ, å¾—å‡ºçŠ¶æ€è½¬ç§»ä¸º:12345678çŠ¶æ€ è¾“å…¥ è¾“å‡º(a, b) (c) (a,b)0, 0 0 0, 00, 1 0 0, 11, 0 0 1, 00, 0 1 0, 10, 1 1 1, 01, 0 1 0, 0 å¾—å‡ºa = (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c), b = (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c).åªè¦æŠŠæ•°ç»„æ‰€æœ‰æ•°æŒ‰ç…§è¿™ä¸ªé€»è¾‘åˆ†åˆ«å åŠ åˆ°aå’Œbä¸Šé¢, æœ€åŽç­”æ¡ˆå°±æ˜¯a | b.12345678910public int singleNumber(int[] nums) &#123; int a = 0, b = 0; for (int c : nums) &#123; int temp = (a &amp; ~b &amp; ~c) | (~a &amp; b &amp; c); b = (~a &amp; b &amp; ~c) | (~a &amp; ~b &amp; c); a = temp; &#125; return (a | b);&#125; ä»¥ä¸Šåªæ˜¯ä¸€ç§é€šç”¨çš„å¥—è·¯ï¼Œå¯¹äºŽæ¯ä¸€ç§ç‰¹å®šçš„K, Mç»„åˆ, å¯èƒ½ä¼šæœ‰ä¸åŒçš„ç‰¹æ®Šæœ€ä¼˜æ–¹æ¡ˆ. é€šè¿‡ä¸åŒé›†åˆæ”¶å½•ä¸åŒæ•°å­—åŒä¸Šé¢çš„é—®é¢˜ï¼ŒLeetCodeæŸå¤§ç¥žç»™å‡ºä¸€ä¸ªç›®å‰ä¸ºæ­¢æœ€ä¼˜çš„æ–¹æ¡ˆ, å¹¶æ”¾è¨€â€Challenge meâ€, è‰é¸¡ä»¬çœ‹äº†ç‘Ÿç‘Ÿå‘æŠ–ï¼š123456789public int singleNumber(int[] nums) &#123; int ones = 0, twos = 0; for (int c : nums) &#123; ones = (ones ^ c) &amp; ~twos; twos = (twos ^ c) &amp; ~ones; &#125; return ones;&#125; åŽŸç†æ˜¯åˆ©ç”¨ä¸¤ä¸ªæ•°oneså’Œtwosä½œä¸ºä¸€ç§æ¦‚å¿µä¸Šçš„é›†åˆsetï¼Œé€šè¿‡å¼‚æˆ–æ“ä½œæ¥æ”¶å½•åˆ†åˆ«å‡ºçŽ°äº†1æ¬¡å’Œ2æ¬¡çš„æ•°, set ^ valæœ‰ä¸¤ç§ç»“æžœ: å¦‚æžœseté‡Œé¢æ²¡æœ‰val, æŠŠvalå¼‚æˆ–è¿›åŽ», å¦‚a ^ 0 = a å¦‚æžœsetä¹‹å‰å·²ç»æ”¶å½•äº†val, é‚£ä¹ˆäº¦æˆ–æ“ä½œå°±ä¼šåœ¨setä¸­ç§»é™¤è¿™ä¸ªval, å¦‚ a ^ a = 0 æŒ‰ç…§ä¸Šé¢çš„å®šä¹‰æ¥ç†è§£: (ones ^ c) &amp; ~twos: å½“ä¸”ä»…å½“cæ²¡æœ‰æ”¶å½•åœ¨twosä¸­, æŠŠonesæ”¶å½•cï¼Œå¦åˆ™ç§»é™¤cã€‚è¿™æ ·çš„è¯ï¼Œä»»ä½•ç¬¬ä¸€æ¬¡å‡ºçŽ°çš„æ•°éƒ½ä¼šè¢«æ”¶å…¥onesä¸­, è€Œä»»ä½•ç¬¬äºŒæ¬¡å‡ºçŽ°çš„æ•°ä¼šä»Žonesä¸­ç§»å‡º.So, effectively anything that appears for the first time will be in the set. Anything that appears a second time will be removed. Weâ€™ll see what happens when an element appears a third time (thats handled by the set â€œtwosâ€). ç´§æŽ¥ç€, (twos ^ c) &amp; ~onesç”¨åŒæ ·çš„é€»è¾‘æ›´æ–°twos. è¿™æ ·æ„å‘³ç€ twosä¸ä¼šæ”¶å½•ç¬¬ä¸€æ¬¡å‡ºçŽ°çš„æ•°; ä½†å¯¹äºŽç¬¬äºŒæ¬¡å‡ºçŽ°çš„æ•°, å› ä¸ºä¸Šä¸€æ­¥å·²ç»æŠŠè¿™ä¸ªæ•°ä»Žonesä¸­ç§»é™¤, é‚£ä¹ˆè¿™ä¸ªæ•°å°±ä¼šè¢«æ”¶å½•è¿›twosä¸­, å¯¹äºŽç¬¬ä¸‰æ¬¡å‡ºçŽ°çš„æ•°, å› ä¸ºtwosä¸­å·²ç»æ”¶å½•äº†, æ‰€ä»¥onesä¸ä¼šå†æ”¶å½•, è€Œå¼‚æˆ–æ“ä½œä¼šæŠŠtwosä¸­çš„è¿™ä¸ªæ•°ç§»é™¤. æœ€åŽçš„ç»“æžœå°±æ˜¯, onesä»…ä¿ç•™å‡ºçŽ°äº†1æ¬¡çš„æ•°, twosä»…ä¿ç•™å‡ºçŽ°äº†2æ¬¡çš„æ•°, è€Œé‚£äº›å‡ºçŽ°äº†3æ¬¡çš„æ•°éƒ½è¢«ç§»é™¤äº†. è¿™ç§æ–¹æ³•å¯ä»¥æ‰©å±•ä¸ºé€šç”¨æ–¹æ³•, é€‚ç”¨äºŽä»»ä½•ä»…å­˜åœ¨ä¸€ä¸ªåªå‡ºçŽ°äº†Mæ¬¡çš„æ•°, å…¶ä»–æ•°éƒ½å‡ºçŽ°äº†Kæ¬¡çš„æ•°ç»„, å¦‚K = 4, M = 3123456789101112131415public int singleNumber(int[] nums) &#123; int ones = 0, twos = 0, threes = 0; for (int c : nums) &#123; ones = (ones ^ c) &amp; ~twos &amp; ~threes; twos = (twos ^ c) &amp; ~ones &amp; ~threes; threes = (threes ^ c) &amp; ~twos &amp; ~ones; &#125; return threes;&#125;public static void main(String[] args) &#123; int[] nums = &#123;1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4&#125;; System.out.println(singleNumber(nums)); // 2&#125; æ‰¾å‡ºå”¯äºŒçš„ä»…å‡ºçŽ°Mæ¬¡çš„æ•°LeetCodeåŽŸé¢˜:ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„numsï¼Œå…¶ä¸­æ°å¥½æœ‰ä¸¤ä¸ªå…ƒç´ åªå‡ºçŽ°ä¸€æ¬¡ï¼Œå…¶ä½™æ‰€æœ‰å…ƒç´ å‡å‡ºçŽ°ä¸¤æ¬¡ã€‚ æ‰¾å‡ºåªå‡ºçŽ°ä¸€æ¬¡çš„é‚£ä¸¤ä¸ªå…ƒç´ ã€‚è·Ÿå‰é¢çš„é—®é¢˜ç±»ä¼¼, æˆ‘ä»¬éœ€è¦å†æ¬¡ä½¿ç”¨XORæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚é€šè¿‡åˆ†å‰²æ•°ç»„, æŠŠå‡ºçŽ°ä¸€æ¬¡çš„ä¸¤ä¸ªæ•°, åˆ’åˆ†åˆ°ä¸åŒçš„æ•°ç»„ä¸­, é—®é¢˜å°±è½¬åŒ–ä¸ºå¯»æ‰¾å”¯ä¸€çš„å‡ºçŽ°ä¸€æ¬¡çš„æ•°é—®é¢˜. æ‰€ä»¥å…³é”®å°±æ˜¯å¦‚ä½•æ‹†åˆ†æ•°ç»„. å…·ä½“éœ€è¦ä¸¤æ¬¡éåŽ†ï¼š ç¬¬ä¸€æ¬¡éåŽ†ï¼Œå¯¹æ•°ç»„æ‰€æœ‰å…ƒç´ è¿›è¡Œå¼‚æˆ–ï¼ŒèŽ·å¾—è¦æ‰¾çš„ä¸¤ä¸ªæ•°å­—çš„XORã€‚ç”±äºŽä¸¤ä¸ªæ•°å­—æ˜¯ä¸åŒçš„ï¼Œå› æ­¤åœ¨XORç»“æžœä¸­å¿…å®šæœ‰ä¸€ä¸ªset bit, å³ä½å€¼ä¸ºâ€™1â€™çš„ä½ã€‚ æ‰¾å‡ºä»»æ„set bitï¼ˆå¦‚æœ€å³è¾¹çš„ï¼‰ã€‚ ç¬¬äºŒæ¬¡éåŽ†ï¼Œå°†æ‰€æœ‰æ•°å­—åˆ†æˆä¸¤ç»„: ä¸€ç»„ä¸ºå…·æœ‰ä¸Šè¿°set bitçš„æ•°, å¦ä¸€ç»„æ²¡æœ‰ã€‚æŒ‰ç…§è¿™ç§æ–¹æ³•åˆ†ç»„, ç›¸åŒçš„æ•°å­—ä¸€å®šä¼šè¢«åˆ†é…åˆ°åŒä¸€ç»„ä¸­, è€Œä¸¤ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„æ•°ä¼šåˆ†é…åˆ°ä¸åŒæ•°ç»„ä¸­ã€‚ 1234567891011121314151617181920212223242526272829/**ä»£ç æ¥è‡ª: https://leetcode.com/problems/single-number-iii/discuss/68900/Accepted-C%2B%2BJava-O(n)-time-O(1)-space-Easy-Solution-with-Detail-Explanations*/public class Solution &#123; public int[] singleNumber(int[] nums) &#123; // Pass 1 : // Get the XOR of the two numbers we need to find int diff = 0; for (int num : nums) &#123; diff ^= num; &#125; // Get its last set bit diff &amp;= -diff; // Pass 2 : int[] rets = &#123;0, 0&#125;; // this array stores the two numbers we will return for (int num : nums) &#123; if ((num &amp; diff) == 0) // the bit is not set &#123; rets[0] ^= num; &#125; else // the bit is set &#123; rets[1] ^= num; &#125; &#125; return rets; &#125;&#125; æ‰¾å‡ºç¼ºå¤±çš„æ•°ç»™å®šä¸€ä¸ªåŒ…å«nä¸ªä¸åŒæ•°å­—çš„æ•°ç»„ï¼Œå–è‡ª0,1,2,...,nï¼Œæ‰¾åˆ°æ•°ç»„ä¸­ç¼ºå°‘çš„æ•°å­—ã€‚æŠŠæ‰€æœ‰æ•°å­—å’Œç´¢å¼•0 ~ nå–å¼‚æˆ–, ç´¢å¼•æ˜¯å®Œæ•´çš„, ä½†æ•°å­—ç¼ºå¤±äº†ä¸€ä¸ª, æœ€åŽå¾—åˆ°çš„å°±ä¸€å®šæ˜¯é‚£ä¸ªç¼ºå¤±çš„æ•°.123456public int missingNumber(int[] nums) &#123; int miss = nums.length; for (int i = 0; i &lt; nums.length; i++) miss ^= (nums[i] ^ i); return miss;&#125; é™¤æ­¤ä¹‹å¤–ä¹Ÿå¯ä»¥é€šè¿‡æ±‚ç­‰å·®æ•°åˆ—å’Œï¼Œ ç„¶åŽå‡åŽ»å®žé™…çš„æ•°ç»„å’Œï¼Œå¾—å‡ºç¼ºå¤±çš„æ•°ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½æ“ä½œ - ä¸ä½¿ç”¨åŠ å‡ç¬¦å·æ±‚å’Œæ•´æ•°]]></title>
    <url>%2Fbits-operations-05%2F</url>
    <content type="text"><![CDATA[ä¸ä½¿ç”¨åŠ å‡ç¬¦å·æ±‚å’Œæ•´æ•°ä¸èƒ½ä½¿ç”¨+å’Œ-, ä»…é€šè¿‡^å’Œ&amp;æ“ä½œæ¥æ±‚å’Œä¸¤ä¸ªæ•´æ•°a.å‚è€ƒæ¯ä½ç›¸åŠ å¯èƒ½ä¼šäº§ç”Ÿè¿›ä½(carry), æ‰€ä»¥å¯ä»¥æŠŠç›¸åŠ æ‹†åˆ†ä¸ºä¸¤éƒ¨åˆ†, å¦‚759 + 674å¯ä»¥æ‹†åˆ†ä¸ºä¸è€ƒè™‘è¿›ä½çš„éƒ¨åˆ†323å’Œä»…è€ƒè™‘è¿›ä½çš„éƒ¨åˆ†1110, æ•…759 + 674 = 323 + 1110 = 1433. äºŒè¿›åˆ¶çš„åŠ æ³•ä¹Ÿæ˜¯ä»Žä½Žä½å¼€å§‹é€æ­¥å¾€é«˜ä½è®¡ç®—: è¿›è¡Œä¸€ä½äºŒè¿›åˆ¶çš„åŠ æ³•, ä¹Ÿå°±æ˜¯æš‚ä¸è€ƒè™‘è¿›ä½çš„ä½ç›¸åŠ : 0+0=0ï¼Œ 0+1=1, 1+0=1ï¼Œ 1+1=0, é‚£ä¹ˆå°±æ˜¯^æ“ä½œ. æ‰€å¾—çš„å’Œä½œä¸ºæ–°çš„a. æ±‚è¿›ä½: é€šè¿‡a &amp; båˆ¤æ–­æ˜¯å¦è¿›ä½, å› ä¸ºåªæœ‰ä¸¤ä¸ªä½å‡ä¸º1æ‰ä¼šè¿›ä½. æ‰€å¾—çš„è¿›ä½å·¦ç§»ä¸€ä½ä½œä¸ºæ–°çš„b. ä¸æ–­é‡å¤è¿™ä¸ªè¿‡ç¨‹, æŠŠä½Žä½çš„è¿›ä½ä¼ é€’åˆ°é«˜ä½, ç´¯åŠ åˆ°aä¸­, ç›´åˆ°è¿›ä½ä¸º0, æœ€åŽå¾—åˆ°çš„aå°±æ˜¯ç­”æ¡ˆ. 12345678910public class Solution &#123; public int getSum(int a, int b) &#123; while (b != 0) &#123; // å…³é”®åœ¨äºŽåˆ¤æ–­ç»ˆæ­¢çš„æ—¶æœº int c = a &amp; b; //carry a ^= b; //add b = c &lt;&lt; 1; &#125; return a; &#125;&#125; æ¶‰åŠçš„è¿ç®—å°±æ˜¯ä¸€ä¸ªå¤šä½äºŒè¿›åˆ¶åŠ æ³•çœŸå€¼è¡¨ï¼š(å¯¹åº”äºŽç¡¬ä»¶ä¸­çš„å…¨åŠ å™¨) å…¨åŠ å™¨ï¼ˆfull adderï¼‰å°†ä¸¤ä¸ªä¸€ä½äºŒè¿›åˆ¶æ•°ç›¸åŠ ï¼Œå¹¶æ ¹æ®æŽ¥æ”¶åˆ°çš„ä½Žä½è¿›ä½ä¿¡å·ï¼Œè¾“å‡ºå’Œã€è¿›ä½è¾“å‡ºã€‚å…¨åŠ å™¨çš„ä¸‰ä¸ªè¾“å…¥ä¿¡å·ä¸ºä¸¤ä¸ªåŠ æ•°Aã€Bå’Œä½Žä½è¿›ä½Cinã€‚å…¨åŠ å™¨é€šå¸¸å¯ä»¥é€šè¿‡çº§è”ï¼ˆcascadeï¼‰çš„æ–¹å¼ï¼Œæž„æˆå¤šä½ï¼ˆå¦‚8ä½ã€16ä½ã€32ä½ï¼‰äºŒè¿›åˆ¶æ•°åŠ æ³•å™¨çš„åŸºæœ¬éƒ¨åˆ†ã€‚å…¨åŠ å™¨çš„è¾“å‡ºå’ŒåŠåŠ å™¨ç±»ä¼¼ï¼ŒåŒ…æ‹¬å‘é«˜ä½çš„è¿›ä½ä¿¡å·Coutå’Œæœ¬ä½çš„å’Œä¿¡å·Sï¼Œç›¸åŠ ç»“æžœçš„æ€»å’Œè¡¨è¾¾ä¸º ${\displaystyle \mathrm {sum} =2\times C_{out}+S}$ã€‚ è§„åˆ™æ˜¯s = (x ^ y) ^ CinCout = (x &amp; y) | (y &amp; Cin) | (x &amp; Cin) æ›´ç®€å•çš„ç‰ˆæœ¬:123int getSum(int a, int b) &#123; return b == 0 ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; 1);&#125; ä¸ä½¿ç”¨ç¼“å­˜äº¤æ¢æ•´æ•°åˆ©ç”¨ä¸€ä¸ªæ•´æ•°å’Œè‡ªå·±è¿›è¡Œå¼‚æˆ–è¿ç®—ä¼šå½’0çš„æ€§è´¨123456public int[] exchangeAB(int[] AB) &#123; AB[0] = AB[0] ^ AB[1]; AB[1] = AB[0] ^ AB[1]; // åªå‰©ä¸‹AB[0] AB[0] = AB[0] ^ AB[1]; // åªå‰©ä¸‹AB[1] return AB;&#125; ä¹Ÿå¯ä»¥ä½¿ç”¨åŠ å‡æ³•æ¥æ“ä½œ123456public int[] exchangeAB(int[] AB) &#123; AB[0] = AB[0] + AB[1]; AB[1] = AB[0] - AB[1]; // åªå‰©ä¸‹AB[0] AB[0] = AB[0] - AB[1]; // åªå‰©ä¸‹AB[1] return AB;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½æ“ä½œ - é£Žéªšçš„èµ°ä½æ“ä½œ]]></title>
    <url>%2Fbits-operations-03%2F</url>
    <content type="text"><![CDATA[é€šè¿‡ä½ç§»å®žçŽ°å¾ˆå¤šé£Žéªšçš„æ“ä½œï¼Œ å‚è€ƒè¿™ä¸ªè§†é¢‘ã€‚æ£€æŸ¥ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯å¶æ•°, æœ¬è´¨ä¸Šå°±æ˜¯å–æœ€åŽä¸€ä½æ¥åˆ¤æ–­, å¦‚æžœæ˜¯1é‚£ä¹ˆå°±ä¸€å®šæ˜¯å¥‡æ•°, åä¹‹åˆ™ä¸ºå¶æ•°:1(x &amp; 1) == 0 Check if power of two:1(x &amp; x - 1) == 0 å› ä¸ºå¦‚æžœæ•°xæ˜¯ä»¥2åº•çš„çœŸæ•°, é‚£ä¹ˆå…¶äºŒè¿›åˆ¶ä¸€å®šåªæœ‰ä¸€ä¸ªä½ç½®æ˜¯1, å¦‚0b1000, é‚£ä¹ˆx-1å°±ä¼šå˜æˆåªæœ‰è¯¥ä½ç½®æ˜¯0å…¶å³è¾¹æ‰€æœ‰ä½å˜ä¸º1, å³0b0111, ä¹Ÿå°±æ˜¯è¯´è¿™ç§æƒ…å†µä¸‹xå’Œx-1æ‰€æœ‰ä½ç½®éƒ½äº’å¼‚. é‚£ä¹ˆå®ƒä»¬çš„ä½ä¸Žè¿ç®—å°±æ˜¯x &amp; x - 1 = 0b0000. x &amp; x - 1çš„å¹¿ä¹‰ç”¨é€”æ˜¯æ±‚xäºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°, Counting bits set:123456unsigned int v; // count the number of bits set in vunsigned int c; // c accumulates the total bits set in vfor (c = 0; v; c++)&#123; v &amp;= v - 1; // clear the least significant bit set&#125; Brian Kernighanâ€™s algorithm takes O(log N) to count set bits (1s) in an integer: each iteration sets the least significance bit that isnâ€™t zero to zero - and only it. Since each iteration converts exactly bit from 1 to 0, itâ€™ll take as many iterations as there are non-0 bits to convert all the bits to 0(and thus v == 0 and the loop finishes). An integer n has log(n) bits, hence the worst case is O(log(n)) å¦‚æžœä¸€ä¸ªæ•´æ•°ä¸ä¸º0, é‚£ä¹ˆå…¶äºŒè¿›åˆ¶å°±è‡³å°‘æœ‰ä¸€ä¸ª1. å‡è®¾æœ€å³è¾¹ä¸€ä½æ˜¯1, é‚£ä¹ˆå‡1å°±ä¼šæŠŠæœ€åŽä¸€ä½å˜ä¸º0, å‰é¢æ‰€æœ‰ä½ä¿æŒä¸å˜. å‡å¦‚æœ€åŽä¸€ä½æ˜¯0, é‚£ä¹ˆæœ€é å³çš„1å‡è®¾åœ¨mä½ç½®, é‚£ä¹ˆå‡åŽ»1, è¯¥ä½ç½®ä¼šå˜ä¸º0, è€Œå…¶å³è¾¹çš„æ‰€æœ‰0éƒ½ä¼šå˜ä¸º1, å…¶å·¦è¾¹çš„æ‰€æœ‰ä½ä¸å˜. v &amp;= v - 1æŠŠæœ€å³çš„1å˜ä¸º0. èŽ·å–äºŒè¿›åˆ¶çš„æœ€åŽä¸€ä¸ª1:123def last_set_bit(x): y = ~(x - 1) # = - (x - 1) - 1 = -x return x &amp; y å‡è®¾æœ€å³è¾¹çš„1ä½äºŽn, -1æ“ä½œä¼šæŠŠnå³è¾¹æ‰€æœ‰0å˜ä¸º1, è€Œnä½å˜ä¸º0. æŽ¥ç€~æ“ä½œä¼šæŠŠnå·¦è¾¹æ‰€æœ‰ä½ç¿»è½¬, è€ŒnåŠå…¶å³è¾¹çš„æ•°ä¼šå˜ä¸ºåŽŸæ¥çš„æ ·å­, ä¹Ÿå°±æ˜¯nä¸º1, å³è¾¹å…¨ä¸º0(æˆ–è€…æ²¡æœ‰å³è¾¹). æœ€åŽ&amp;æ“ä½œå°±åªå‰©ä¸‹nä½çš„1å’Œå³è¾¹çš„0(å¦‚æžœæœ‰çš„è¯).]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming 06 - KnapsackèƒŒåŒ…é—®é¢˜]]></title>
    <url>%2Falgorithms-dynamic-programming-06%2F</url>
    <content type="text"><![CDATA[KnapsackèƒŒåŒ…é—®é¢˜ èƒŒåŒ…é—®é¢˜ï¼ˆKnapsack problemï¼‰æ˜¯ä¸€ç§ç»„åˆä¼˜åŒ–çš„NPå®Œå…¨é—®é¢˜ã€‚é—®é¢˜å¯ä»¥æè¿°ä¸ºï¼šç»™å®šä¸€ç»„ç‰©å“ï¼Œæ¯ç§ç‰©å“éƒ½æœ‰è‡ªå·±çš„é‡é‡å’Œä»·æ ¼ï¼Œåœ¨é™å®šçš„æ€»é‡é‡å†…ï¼Œæˆ‘ä»¬å¦‚ä½•é€‰æ‹©ï¼Œæ‰èƒ½ä½¿å¾—ç‰©å“çš„æ€»ä»·æ ¼æœ€é«˜ã€‚é—®é¢˜çš„åç§°æ¥æºäºŽå¦‚ä½•é€‰æ‹©æœ€åˆé€‚çš„ç‰©å“æ”¾ç½®äºŽç»™å®šèƒŒåŒ…ä¸­ã€‚ä¹Ÿå¯ä»¥å°†èƒŒåŒ…é—®é¢˜æè¿°ä¸ºå†³å®šæ€§é—®é¢˜ï¼Œå³åœ¨æ€»é‡é‡ä¸è¶…è¿‡Wçš„å‰æä¸‹ï¼Œæ€»ä»·å€¼æ˜¯å¦èƒ½è¾¾åˆ°Vã€‚ 0-1èƒŒåŒ…æœ€åŸºç¡€çš„èƒŒåŒ…é—®é¢˜ï¼šæœ‰Nä»¶ç‰©å“å’Œä¸€ä¸ªä½“ç§¯ä¸ºVçš„èƒŒåŒ…, æ¯ç§ç‰©å“å‡åªæœ‰ä¸€ä»¶, ç¬¬iä»¶ç‰©å“çš„å¤§å°/é‡é‡æ˜¯s[i]ï¼Œä»·å€¼æ˜¯v[i]. æ±‚å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„ä½“ç§¯æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…ä½“ç§¯ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§. å¯¹äºŽæ¯ä¸€ä¸ªç‰©å“ï¼Œåªæœ‰ä¸¤ç§ç»“æžœï¼Œæ”¾å…¥æˆ–è€…ä¸æ”¾å…¥èƒŒåŒ…ï¼Œé‚£ä¹ˆkn(i, j)åˆ™è¡¨ç¤ºèƒŒåŒ…å®¹é‡å‰©ä½™jæ—¶, å‰iä¸ªç‰©å“èƒ½å¤Ÿè¾¾åˆ°çš„æœ€å¤§å€¼: kn1 = kn(i-1, j-s(i)) + v(i)è¡¨ç¤ºç‰©å“iæ”¾å…¥èƒŒåŒ…åŽçš„æ€»ä»·å€¼, ä¸ºå‰i-1ç‰©å“åœ¨ç¬¬iä¸ªç‰©å“å ç”¨äº†èƒŒåŒ…å®¹é‡s(i)åŽçš„çš„æœ€ä¼˜è§£åŠ ä¸Šç¬¬iä¸ªç‰©å“çš„ä»·å€¼v(i). kn2 = kn(i-1, j)è¡¨ç¤ºç‰©å“iå¹¶æ²¡æœ‰æ”¾å…¥èƒŒåŒ…, ç­‰äºŽå‰i-1ä¸ªç‰©å“åœ¨ç›¸åŒèƒŒåŒ…å®¹é‡çš„æœ€ä¼˜ä»·å€¼. å½’çº³å‡ºæ¥çš„å¤§å°å­é—®é¢˜é—´çš„å…³ç³»(è½¬ç§»æ–¹ç¨‹)ä¸º: kn(i, j) = max(kn1, kn2) = max(kn(i-1, j-s(i)) + v(i), kn(i-1, j)). åˆå§‹çŠ¶æ€æ˜¯å¯¹äºŽä¸åŒèƒŒåŒ…å‰©ä½™å®¹é‡, å½“æ²¡æœ‰ç‰©å“å¯æ”¾æ—¶, è¿”å›žçš„æœ€å¤§ä»·å€¼ä¸€å®šæ˜¯0. æ‰€ä»¥èƒŒåŒ…é—®é¢˜, å°±æ˜¯äºŒç»´çš„åŠ¨æ€è§„åˆ’é—®é¢˜. éœ€è¦ç¡®å®šåˆå§‹çŠ¶æ€, å’Œå“ªäº›ä¿¡æ¯éœ€è¦è®°å¿†. å¯ä»¥ç®€å•åœ°ç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„è®°å¿†æ‰€æœ‰kn(i, j), ä½†è¦è€ƒè™‘åˆ°å½“å®¹é‡éžå¸¸å¤§, ç‰©å“éžå¸¸å¤šæ—¶, è¿™ä¸ªäºŒç»´æ•°ç»„æ˜¯å¾ˆå¤§çš„, æ¯”å¦‚å½“(i, j) = (2000, 2000000), ä¼šæŠ›å‡ºjava.lang.OutOfMemoryError: Java heap space. ç‰¹åˆ«æ˜¯, å½“æ¯ä¸ªç‰©å“çš„ä»·å€¼ä¹Ÿæ¯”è¾ƒå¤§æ—¶, äºŒç»´æ•°ç»„çš„jç»´åº¦å…¶å®žåˆ©ç”¨çŽ‡å¾ˆä½Ž. æ‰€ä»¥å­˜åœ¨å¾ˆå¤šä¼˜åŒ–çš„ç©ºé—´. ä¼˜åŒ–çš„å…³é”®ç‚¹åœ¨äºŽå‡å°‘è®°å¿†ç‚¹. æ³¨æ„åˆ°è½¬ç§»æ–¹ç¨‹ä¸­: kn(i, *)åªéœ€è¦ç”¨åˆ°kn(i-1, *)çš„å€¼, ä½†æˆ‘ä»¬åˆæ¸…æ¥šåœ°çŸ¥é“ï¼Œç‰©å“åœ¨è¿™é‡Œæ˜¯æ²¡æœ‰é¡ºåºçš„æ„ä¹‰çš„ï¼Œæ‰€ä»¥è¿™é‡Œçš„iä»…ä»…æ˜¯è¡¨ç¤ºè¿­ä»£çš„æ­¥éª¤, åªæ˜¯ä¸ºäº†éåŽ†æ‰€æœ‰ç‰©å“, è‡³äºŽå…·ä½“çš„é¡ºåºæ˜¯ä¸é‡è¦çš„, æ‰€ä»¥ä¸éœ€è¦è®°å½•æ‰€æœ‰iå¯¹åº”çš„kn(i, *), ä»…ä»…è®°å½•æœ€è¿‘ä¸€æ¬¡è®¡ç®—å€¼å³å¯. æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦è‡³å¤šä¸¤ä¸ªæ•°ç»„ç”¨æ¥è®°å½•i-1å’Œiå¯¹åº”çš„knå€¼. kn(i, j)è¦ç”¨åˆ°kn(i-1, k), k&lt;=jçš„å€¼, å…·ä½“è¦ç”¨åˆ°å“ªäº›kæ˜¯å–å†³äºŽi. æ‰€ä»¥jç»´åº¦çš„å€¼å¿…é¡»éƒ½è¦è®°å½•ä¸‹æ¥, ä»¥é˜²åŽç»­éœ€è¦ç”¨åˆ°. ç»“åˆèµ·æ¥å‘çŽ°åªéœ€è¦ä¸€ä¸ªä¸€ç»´æ•°ç»„kn = new int[size + 1]å³å¯, iå¯¹åº”çš„å€¼å¯ä»¥ç›´æŽ¥åœ¨æ•°ç»„ä¸Šæ›´æ–°, ä¸éœ€è¦é¢å¤–çš„æ•°ç»„è®°å½•ä¸Šä¸€æ¬¡è¿­ä»£çš„å€¼. åœ¨å®žçŽ°ä¸­, å› ä¸ºkn(i, j)è¦ç”¨åˆ°kn(i-1, &lt;=j)çš„å€¼, ä¹Ÿå°±æ˜¯kn[&lt;j]çš„å€¼ä¸èƒ½å…ˆäºŽkn[j]æ›´æ–°, æ‰€ä»¥knçš„è®¡ç®—è¦ä»Žå³å¾€å·¦(j = size; j--). æ¯æ¬¡å†³å®šæ˜¯å¦åŠ å…¥iç‰©å“ä¹‹å‰, å¦‚æžœå‰©ä½™å®¹é‡jå°äºŽs[i], é‚£ä¹ˆè‚¯å®šæ— æ³•æ”¾å…¥, è¿™ä¸ªåˆ¤æ–­å¯ä»¥èžåˆè¿›jçš„éåŽ†ä¸­, å› ä¸ºjæœ¬èº«ä»£è¡¨äº†å‰©ä½™å®¹é‡. 123456789101112static int[] values;static int[] sizes;public static int knapsack(int size) &#123; int n = values.length; int[] vs = new int[size + 1]; for (int i = 0; i &lt; n; i++) &#123; // items for (int j = size; j &gt;= sizes[i]; j--) &#123; vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]); &#125; &#125; return vs[size];&#125; ä¼˜åŒ–ä»¥åŽç©ºé—´å¤æ‚åº¦ç”±$\theta(NS)$é™åˆ°$\theta(S)$ã€‚ä½†æ—¶é—´å¤æ‚åº¦ä¸å˜. å¯¹äºŽ0-1èƒŒåŒ…é—®é¢˜ï¼Œå¦‚æžœé—®é¢˜å˜ä¸ºæ±‚æ°å¥½è£…æ»¡æ—¶çš„æœ€å¤§å€¼, å‚è€ƒè¿™ç¯‡åšæ–‡: æ­¤æ—¶åªæœ‰å®¹é‡ä¸º0çš„èƒŒåŒ…å¯èƒ½è¢«ä»·å€¼ä¸º0çš„ç‰©å“(æ— ç‰©å“)æ°å¥½è£…æ»¡ï¼Œåˆå§‹åŒ–åˆæ³•çŠ¶æ€kn[0] = 0, kn[j &gt; 0]ä¸ºè´Ÿæ•°. åä¹‹, å¦‚æžœè¦æ±‚çš„æ˜¯æ°å¥½è£…æ»¡æ—¶çš„æœ€å°å€¼ï¼Œåˆå§‹åŒ–ä¸ºæ­£æ— ç©·ã€‚è¦æ³¨æ„çš„æ˜¯æ”¹å˜åˆå§‹åŒ–ä»¥åŽæœ€åŽä¸€ä¸ªå€¼æ˜¯æ°å¥½è£…æ»¡çš„æœ€å¤§å€¼ï¼Œå¦‚æžœä¸èƒ½æ°å¥½è£…æ»¡ï¼Œé‚£è‚¯å®šæ˜¯ä¸€ä¸ªè´Ÿæ•°ï¼Œè€Œä¸”å¯¹äºŽæ°å¥½è£…æ»¡çš„çš„åˆå§‹åŒ–æƒ…å†µçš„ä¸è¦æ±‚æ»¡çš„æœ€å¤§å€¼æ˜¯0-vèƒŒåŒ…å®¹é‡çš„æœ€å¤§å€¼ã€‚å³æ˜¯æœ€åŽä¸€è¡Œçš„MAXã€‚ å®Œå…¨èƒŒåŒ…Unbounded Knapsack: æœ‰Nç§ç‰©å“å’Œä¸€ä¸ªä½“ç§¯ä¸ºSçš„èƒŒåŒ…ï¼Œæ¯ç§ç‰©å“éƒ½æœ‰æ— é™ä»¶å¯ç”¨ã€‚ç¬¬iä»¶ç‰©å“çš„ä½“ç§¯æ˜¯s[i]ï¼Œä»·å€¼æ˜¯value[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„ä½“ç§¯æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…ä½“ç§¯ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ 0-1èƒŒåŒ…çš„é—®é¢˜ä¸­æ¯ä¸€ç§ç‰©å“åœ¨èƒŒåŒ…ä¸­çš„æ•°é‡åªæœ‰0å’Œ1ä¸¤ç§, è€Œå®Œå…¨èƒŒåŒ…é—®é¢˜æ¯ä¸€ç§ç‰©å“åœ¨èƒŒåŒ…ä¸­çš„æ•°é‡æ˜¯0ä¸ªåˆ°k = S/s[i]ä¸ª. ä½¿ç”¨ä¸Ž0-1èƒŒåŒ…ç±»ä¼¼çš„å®šä¹‰, kn(i, j)è¡¨ç¤ºèƒŒåŒ…å®¹é‡å‰©ä½™jæ—¶, æ”¾å…¥ä»»æ„ä¸ªå‰iä¸ªç‰©å“èƒ½å¤Ÿè¾¾åˆ°çš„æœ€å¤§å€¼, è¿™æ ·è½¬ç§»æ–¹ç¨‹å˜ä¸º: kn(i, j) = max{kn(i-1, j-k*s(i)) + k*v(i)}, 0 &lt;= k &lt;= S/s[i]ã€‚å¯ä»¥ç›´æŽ¥åœ¨0-1èƒŒåŒ…çš„ä»£ç ä¸­å¢žåŠ ä¸€ä¸ªå¾ªçŽ¯ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦å°±å¢žåŠ äº†ã€‚å¯¹äºŽå–å¤šå°‘ä¹Ÿå¯ä»¥åˆ©ç”¨äºŒè¿›åˆ¶æ‹†åˆ†ï¼Œå–çš„æ—¶å€™å–1, 2, 4, ...ã€‚ å®Œå…¨èƒŒåŒ…çš„ç®—æ³•ä¼˜åŒ–æ³¨æ„åˆ°å®Œå…¨èƒŒåŒ…æœ¬èº«ä¹ŸåŒ…å«0-1èƒŒåŒ…çš„æƒ…å†µ, 0-1èƒŒåŒ…æ˜¯å®Œå…¨èƒŒåŒ…çš„ç‰¹ä¾‹. å®Œå…¨èƒŒåŒ…çš„kn(i, j)åŒ…å«äº†ç¬¬iç§ç‰©å“çš„æ•°é‡åœ¨0 - S/s[i]æ‰€æœ‰å¯èƒ½é€‰æ‹©, å¹¶å–å…¶æœ€å¤§å€¼: è‹¥è‡³å°‘æ”¾ä¸€ä¸ªç‰©å“iè¿›èƒŒåŒ…, é‚£ä¹ˆåœ¨å¯¹ç‰©å“içš„æ•°é‡è¿›è¡Œ0 - S/s[i]çš„éåŽ†æ—¶, è¿­ä»£æ–¹ç¨‹å˜ä¸ºkn1 = kn(i, j-s(i)) + v(i) è‹¥ç¬¬iä¸ªç‰©å“ä¸æ”¾å…¥èƒŒåŒ…æ—¶, æƒ…å†µå’Œ0-1èƒŒåŒ…çš„kn2ä¸€æ ·, kn2 = kn(i-1, j) æ‰€ä»¥0-1èƒŒåŒ…çš„è¿­ä»£æ–¹ç¨‹vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]);å¯ä»¥ç›´æŽ¥å¥—ç”¨åœ¨å®Œå…¨èƒŒåŒ…ä¸Š. åªæ˜¯knçš„è®¡ç®—è¦æ”¹ä¸ºä»Žå·¦å¾€å³(j = 0; j &lt;= size; j++). å› ä¸ºæ­¤æ—¶kn1ç”¨çš„ä¸å†æ˜¯ä¸Šä¸€æ¬¡è¿­ä»£çš„kn(i-1, j-s(i)), è€Œæ˜¯æœ¬æ¬¡è¿­ä»£çš„kn(i, j-s(i)). å³kn(i, j)è¦ç”¨åˆ°kn(i, &lt;=j)çš„å€¼, æ‰€ä»¥kn[&lt;j]çš„å€¼è¦å…ˆäºŽkn[j]æ›´æ–°. åŒæ ·, æ¯æ¬¡å†³å®šæ˜¯å¦åŠ å…¥iç‰©å“ä¹‹å‰, å¦‚æžœå‰©ä½™å®¹é‡jå°äºŽs[i], é‚£ä¹ˆè‚¯å®šæ— æ³•æ”¾å…¥, è¿™ä¸ªåˆ¤æ–­å¯ä»¥èžåˆè¿›jçš„éåŽ†ä¸­.123456789101112static int[] values;static int[] sizes;public static int unboundedKnapsack(int size) &#123; int n = values.length; int[] vs = new int[size + 1]; for (int i = 0; i &lt; n; i++) &#123; // items for (int j = sizes[i]; j &lt;= size; j++) &#123; vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]); &#125; &#125; return vs[size];&#125; ä¼˜åŒ–åŽçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(NV). åœ¨æ•°æ®ä¸Šä¹Ÿå¯ä»¥ä¼˜åŒ–ï¼šå¦‚æžœç‰©å“aæ¯”bä»·å€¼æ›´é«˜, ä½†ä½“ç§¯æ›´å°, é‚£ä¹ˆå®Œå…¨å¯ä»¥ä¸è€ƒè™‘ç‰©å“bã€‚å¯¹äºŽéšæœºç”Ÿæˆçš„æ•°æ®ï¼Œè¿™ä¸ªæ–¹æ³•å¾€å¾€ä¼šå¤§å¤§å‡å°‘æœç´¢ç©ºé—´ã€‚ å¤šé‡èƒŒåŒ…æœ‰Nç§ç‰©å“å’Œä¸€ä¸ªä½“ç§¯ä¸ºVçš„èƒŒåŒ…ã€‚ç¬¬iç§ç‰©å“æœ€å¤šæœ‰num[i]ä»¶å¯ç”¨ï¼Œæ¯ä»¶ä½“ç§¯æ˜¯sizes[i]ï¼Œä»·å€¼æ˜¯value[i]ã€‚æ±‚è§£å°†å“ªäº›ç‰©å“è£…å…¥èƒŒåŒ…å¯ä½¿è¿™äº›ç‰©å“çš„ä½“ç§¯æ€»å’Œä¸è¶…è¿‡èƒŒåŒ…ä½“ç§¯ï¼Œä¸”ä»·å€¼æ€»å’Œæœ€å¤§ã€‚ å¤šé‡èƒŒåŒ…é—®é¢˜å¯ä»¥é‡‡å–åŸºäºŽ0-1èƒŒåŒ…çš„ç®—æ³•åŸºç¡€ä¸Šå¢žåŠ ä¸€å±‚å¾ªçŽ¯æœç´¢num[i]. ä½†è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(NVC).1234567for (int i = 0; i &lt; n; i++) &#123; // items for (int k = 1; k &lt;= num[i]; k++) &#123; for (int j = size; j &gt;= sizes[i]; j--) &#123; vs[j] = Math.max(vs[j - sizes[i]] + values[i], vs[j]); &#125; &#125;&#125; å¤šé‡èƒŒåŒ…é—®é¢˜å…¶å®žåŒ…å«0-1èƒŒåŒ…å’Œå®Œå…¨èƒŒåŒ…ï¼Œå¯ä»¥åˆ†ç±»å¤„ç†ã€‚ å¦‚æžœæ»¡è¶³value[i]*num[i]&gt;=sizeï¼Œè¿™ä¸ªæ—¶å€™å°±æ˜¯å®Œå…¨èƒŒåŒ…é—®é¢˜, è€Œå®Œå…¨èƒŒåŒ…è¦æ¯”å¤šé‡èƒŒåŒ…çš„å¤æ‚åº¦ä½Žï¼Œæ˜¯O(NV)ã€‚ å¦‚æžœæ»¡è¶³num[i]=1å°±æ˜¯0-1èƒŒåŒ…ã€‚ å…¶ä»–èƒŒåŒ…æ··åˆèƒŒåŒ…: å¦‚æžœå°†0-1ã€å®Œå…¨ã€å¤šé‡æ··åˆèµ·æ¥ï¼Œæœ‰çš„ç‰©å“åªå¯ä»¥å–ä¸€æ¬¡ï¼ˆ01èƒŒåŒ…ï¼‰ï¼Œæœ‰çš„ç‰©å“å¯ä»¥å–æ— é™æ¬¡ï¼ˆå®Œå…¨èƒŒåŒ…ï¼‰ï¼Œæœ‰çš„ç‰©å“å¯ä»¥å–çš„æ¬¡æ•°æœ‰ä¸€ä¸ªä¸Šé™ï¼ˆå¤šé‡èƒŒåŒ…ï¼‰ã€‚éœ€è¦åˆ†ç±»æ±‚è§£ï¼Œåˆ¤æ–­æ˜¯å“ªä¸€ç§ï¼Œç„¶åŽåˆ†åˆ«ç»™å‡ºå¾ªçŽ¯å’Œå¾ªçŽ¯é¡ºåºï¼Œåˆ†åˆ«è°ƒç”¨çŠ¶æ€è½¬æ¢æ–¹ç¨‹ã€‚ å…¶ä»–è¿˜æœ‰äºŒç»´è´¹ç”¨èƒŒåŒ…ï¼Œä¾èµ–èƒŒåŒ…ï¼Œåˆ†ç»„èƒŒåŒ…â€¦]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming 05 - è·³å°é˜¶]]></title>
    <url>%2Falgorithms-dynamic-programming-05%2F</url>
    <content type="text"><![CDATA[è·³å°é˜¶è·³ä¸Šä¸€ä¸ªnçº§çš„å°é˜¶æ€»å…±æœ‰å¤šå°‘ç§è·³æ³•ï¼Œå…ˆåŽæ¬¡åºä¸åŒç®—ä¸åŒçš„ç»“æžœï¼Œé™åˆ¶æ¡ä»¶æ˜¯æ¯æ¬¡åªèƒ½è·³1çº§æˆ–è€…2çº§ã€‚æŠ½è±¡å‡ºæ¥çš„æ¨¡åž‹æ˜¯ï¼šç»™å®šæ­£æ•´æ•°Nï¼Œæœ‰å¤šå°‘ç§ç´¯åŠ æ–¹æ¡ˆï¼Œä¸åŒé¡ºåºå½“åšä¸åŒæ–¹æ¡ˆï¼Œé™åˆ¶æ¡ä»¶å¯ä»¥æ˜¯ç»™å®šçš„æ•´æ•°$n_0, n_1, â€¦, n_k$ä½œä¸ºå¯é€‰ç´¯åŠ å…ƒç´ . å¯¹äºŽé™åˆ¶æ¡ä»¶ä¸ºåªæœ‰ä¸¤ç§è·³æ³•, å³1é˜¶æˆ–è€…2é˜¶çš„, é—®é¢˜å¯ä»¥åˆ†è§£ä¸º: å‡å®šç¬¬ä¸€æ¬¡è·³çš„æ˜¯1é˜¶ï¼Œé‚£ä¹ˆå°±å‰©ä¸‹n-1ä¸ªå°é˜¶ï¼Œå‰©ä½™è·³æ³•æ˜¯f(n-1); å‡å®šç¬¬ä¸€æ¬¡è·³çš„æ˜¯2é˜¶ï¼Œåˆ™å‰©ä¸‹n-2ä¸ªå°é˜¶ï¼Œå‰©ä½™è·³æ³•æ˜¯f(n-2) å¯ä»¥å½’çº³å‡ºé€šç”¨çš„å…¬å¼: f(n) = f(n-1) + f(n-2), åªæœ‰ä¸€é˜¶çš„æ—¶å€™f(1) = 1, åªæœ‰ä¸¤é˜¶çš„æ—¶å€™å¯ä»¥æœ‰f(2) = 2, åˆšå¥½å°±æ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—. æ‰€ä»¥è¿™ä¸ªç®€å•çš„è·³å°é˜¶é—®é¢˜å°±æ˜¯è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„é—®é¢˜ã€‚ åè¿‡æ¥æ€è€ƒ, æ¯”å¦‚å¯¹äºŽ8ä¸ªå°é˜¶, æœ‰å¤šå°‘ç§å›žæ»šæ–¹æ¡ˆ? åªæœ‰ä¸¤ç§: å›žæ»š1ä¸ªå°é˜¶, å°±åˆ°äº†7; å›žæ»š2ä¸ªå°é˜¶, å°±åˆ°äº†6. ç­‰äºŽè¯´: å‡å¦‚æœ‰f(7)ç§æ–¹æ¡ˆè·³åˆ°7, æœ‰f(6)ç§æ–¹æ¡ˆè·³åˆ°6ï¼Œé‚£ä¹ˆå°±æœ‰f(7) + f(6)ç§æ–¹æ¡ˆåˆ°è¾¾8 ä»Žæ ‘ç»“æž„æ¥ç†è§£: å¦‚æžœèŠ‚ç‚¹ä»£è¡¨å°é˜¶æ•°nå¯¹åº”çš„è·³æ³•f(n), èŠ‚ç‚¹ä¸ŽèŠ‚ç‚¹é—´çš„æžä»£è¡¨å•æ¬¡å¯ä»¥è·³çš„é˜¶æ•°, çˆ¶èŠ‚ç‚¹çš„å€¼å°±æ˜¯å…¶æ‰€æœ‰å­èŠ‚ç‚¹çš„å€¼å’Œ. å¯¹äºŽåªæœ‰ä¸¤ç§è·³æ³•é™åˆ¶é—®é¢˜, çˆ¶èŠ‚ç‚¹f(n)å°±åªæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹, åˆ†åˆ«ä¸ºf(n-1)å’Œf(n-2). æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸¾ä¾‹ï¼šFibonacci sequence: ${\displaystyle 0,\;1,\;1,\;2,\;3,\;5,\;8,\;13,\;21,\;34,\;55,\;89,\;144,\;\ldots }$$$F_0 = 0, F_1 = 1, F_2 = 1, F_n = F_{n-1} + F_{n-2} (n&gt;2) $$ Fibonacci numbers grow almost as fast as the powers of 2. Recursive solution is exponential algorithm1234fib1(n): if n = 0: return 0 if n = 1: return 1 return fib1(n - 1) + fib1(n - 2) å› ä¸ºæ¯ä¸€ä¸ªfib1()éƒ½ä¼šç”ŸæˆæŒ‡æ•°çº§æ•°é‡çš„å­åˆ†æ”¯è®¡ç®—, æ‰€ä»¥è¿™ä¸ªç®—æ³•å¤æ‚åº¦æ˜¯$O(2^n)$. ä½†æ˜¯æ³¨æ„åˆ°æ–æ³¢é‚£å¥‘æ•°åˆ—å…¬å¼æ˜¯$F_n = F_{n-1} + F_{n-2}$, ä¹Ÿå°±æ˜¯åªè¦çŸ¥é“nå‰é¢ä¸¤ä¸ªå€¼, å°±èƒ½è®¡ç®—å‡º$f_n$. åˆå› ä¸ºæ–æ³¢é‚£å¥‘æ•°åˆ—å¤©ç„¶çš„æ˜¯ä»Žä½Žå¾€é«˜ç®—, é‚£ä¹ˆæ¯æ¬¡è¿­ä»£åªéœ€è¦ç”¨åˆ°å‰ä¸¤æ¬¡çš„å€¼$F_{n-1}, F_{n-2}$, è®¡ç®—åŽæ›´æ–°å®ƒä»¬å³å¯. ç”¨è¿™ä¸ªæ€è·¯æ¥è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—, å¤æ‚åº¦å°±æ˜¯$O(n)$.1234567891011121314public int JumpFloor(int target) &#123; if (target &lt;= 1) &#123; return target; &#125; int n = 2; int n0 = 1; int n1 = 1; int ways = 0; while (n &lt;= target) &#123; ways = n0 + n1; n0 = n1; n1 = ways; n++; &#125; return ways;&#125; å˜æ€è·³å°é˜¶å˜æ€è·³å°é˜¶å°±æ˜¯æ˜¯ç”¨æ¥æ›´å¤æ‚çš„é™åˆ¶æ¡ä»¶, æ¯”å¦‚å¯é€‰å•æ¬¡è·³é˜¶æ•°ä¸º[1, ... n], ä¹Ÿå°±æ˜¯æ— é™åˆ¶çš„æƒ…å†µ, ä¹Ÿå¯ä»¥æŒ‰ç…§ä¸Šé¢çš„æ€è·¯æŽ¨å¯¼. æ¯”å¦‚ä»Žæ ‘ç»“æž„çš„è€ƒè™‘, å°±å˜æˆæ¯ä¸ªçˆ¶èŠ‚ç‚¹f(n)å¯ä»¥æœ‰nä¸ªå­èŠ‚ç‚¹, å°±æ˜¯f(n-1), f(n-2), ..., f(n-n), æ‰€ä»¥f(n)å°±æ˜¯æ‰€æœ‰è¿™äº›å­èŠ‚ç‚¹çš„å’Œ. f(n-n)ä¹Ÿå°±æ˜¯f(0)æ„å‘³ç€ä¸€æ¬¡è·³å®Œæ‰€æœ‰é˜¶æ•°n, æ‰€ä»¥f(0) = 1. è¿›ä¸€æ­¥å½’çº³, f(n-2) + ... + f(n-n) = f(n-1), æ‰€ä»¥f(n) = f(n-1) + f(n-1), å¯ä»¥ç”¨é€’å½’æˆ–è€…åŠ¨æ€è§„åˆ’æ¥è®¡ç®—. å½“ç„¶è¿›ä¸€æ­¥å½’çº³ä¼šå‘çŽ°$f(n) = 2^{n-1}$, å¯ä»¥ç”¨ä½ç§»æ¥æ“ä½œ:1234public int JumpFloorII(int target) &#123; int a=1; return a &lt;&lt; (target - 1);&#125; åªæ˜¯è¦æ³¨æ„intæ˜¯æœ‰èŒƒå›´çš„. å¤§å˜æ€è·³å°é˜¶å†ä¸¾ä¸€ä¸ªæ›´å¤æ‚çš„é™åˆ¶æ¡ä»¶, å¯é€‰å•æ¬¡è·³é˜¶æ•°ä¸º$2^0, 2^1, â€¦, 2^k$, $2^k$è¦å°äºŽn. é‚£ä¹ˆç›¸åº”çš„,$$f(n) = f(n - 2^0) + f(n - 2^1)â€¦ + f(n - 2^k), \quad s.t. \quad 2^k &lt;= n,$$è¿™æ ·å°±æ„å‘³ç€å¯¹äºŽæ¯ä¸ªf(n), éœ€è¦ç”¨åˆ°çš„f(k)å€¼æ•°é‡æ˜¯ä¸åŒçš„, å°±ä¸èƒ½ç®€å•åœ°ç”¨å›ºå®šæ•°é‡çš„å˜é‡æ¥ä¿ç•™è¾ƒå°å€¼äº†. å¯¹äºŽä¸åŒçš„f(n), å®ƒä»¬çš„å¾ˆå¤šå­åˆ†æ”¯è®¡ç®—æ˜¯å…±äº«çš„, æ¯”å¦‚f(6)å’Œf(5)éƒ½ç”¨åˆ°äº†f(4). é‚£ä¹ˆåœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ï¼Œåªè¦æŠŠæ¯æ¬¡è®¡ç®—å‡ºæ¥çš„è¾ƒå°çš„f(k)å‚¨å­˜åˆ°æ•°ç»„ä¸­, åŽç»­å…¶ä»–f(n)è¦ç”¨åˆ°f(n - 2^k)æ—¶, ç›´æŽ¥ä»Žå†…å­˜ä¸­å–å€¼å³å¯. åˆå§‹å€¼å–f(0) = f(1) = 1:12345678910111213141516public int JumpFloorIII(int target) &#123; int[] f = new int[target]; f[0] = f[1] = 1; return jump(f, target);&#125;private static int jump(int[] f, int target) &#123; if (f[target] == 0) &#123; int ways = 0; for (int i = 0; (1 &lt;&lt; i) &lt;= target; i++) &#123; ways += jump(f, target - (1 &lt;&lt; i)); &#125; f[target] = ways; &#125; return f[target];&#125; è¿™ä¸ªä»£ç é€‚ç”¨äºŽn &lt;= 1024çš„æƒ…å†µ. å¦åˆ™è¦æ”¹ä¸ºå¾ªçŽ¯ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming 04 - ä¸‘æ•°]]></title>
    <url>%2Falgorithms-dynamic-programming-04%2F</url>
    <content type="text"><![CDATA[ä¸‘æ•°æŠŠåªåŒ…å«è´¨å› å­2ã€3å’Œ5çš„æ•°ç§°ä½œä¸‘æ•°ï¼ˆUgly Numberï¼‰ã€‚ä¾‹å¦‚6ã€8éƒ½æ˜¯ä¸‘æ•°ï¼Œä½†14ä¸æ˜¯ï¼Œå› ä¸ºå®ƒåŒ…å«è´¨å› å­7ã€‚ ä¹ æƒ¯ä¸Šæˆ‘ä»¬æŠŠ1å½“åšæ˜¯ç¬¬ä¸€ä¸ªä¸‘æ•°ã€‚ è¦åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯ä¸‘æ•°, ä¸æ–­åœ°åˆ†åˆ«é™¤ä»¥2, 3, 5ï¼Œç„¶åŽæ£€æŸ¥numæ˜¯å¦åˆ°è¾¾1:1234567public boolean isUgly(int num) &#123; //(é™¤æ•°åŒ…æ‹¬`4`å¯ä»¥è®©ä»£ç æ›´ç®€æ´) for (int i=2; i&lt;6 &amp;&amp; num&gt;0; i++) while (num % i == 0) num /= i; return num == 1;&#125; å¦‚æžœè¦è¿”å›žç¬¬nä¸ªä¸‘æ•°(leetcodeåŽŸé¢˜), æƒ…å†µå°±ç¨å¾®å¤æ‚ç‚¹. ä»ŽåŠ¨æ€è§„åˆ’çš„è§’åº¦è€ƒè™‘, å¯¹äºŽä¸€ä¸ªè¾ƒå¤§çš„ä¸‘æ•°N, å¿…å®šæ˜¯ç”±æŸä¸ªæ›´å°çš„ä¸‘æ•°Mä¹˜ä»¥2, 3, 5å…¶ä¸­ä¸€ä¸ªå¾—æ¥çš„. æ‰€ä»¥å¯ä»¥ä»Žå°åˆ°å¤§ä¸æ–­ç”Ÿæˆä¸‘æ•°. ä¸ºäº†é¿å…åœ¨å¾ªçŽ¯ä¸­æ¯ä¸€æ¬¡è®¡ç®—éƒ½ä»Žå¤´å¼€å§‹æ£€æŸ¥æ¯ä¸€ä¸ªæ•°kå¯¹åº”çš„2*k, 3*k, 5*k, éœ€è¦ç”¨ä¸‰ä¸ªå˜é‡last2, last3, last5æ¥åˆ†åˆ«è®°å½•æœ€è¿‘ä¸€æ¬¡ç”¨åˆ°çš„ä¸‘æ•°çš„ç´¢å¼•, ä¸‹ä¸€æ¬¡è®¡ç®—æ—¶å°±ç›´æŽ¥ä»Žä¸Šä¸€æ¬¡åœæ­¢çš„åœ°æ–¹å¼€å§‹è¿è¡Œ.12345678910111213141516171819202122232425262728293031323334353637/** return the nth ugly number */public static int unglyNumber(int n) &#123; final int INIT = 5; int[] uglys = new int[n + INIT]; for (int i = 0; i &lt; 5;) &#123; uglys[i] = ++i; &#125; int last2, last3, last5, m2, m3, m5; last2 = last3 = last5 = 0; m2 = m3 = m5 = 1; for (int i = INIT; i &lt; n; i++) &#123; for (int j = last2 + 1; j &lt; i; j++) &#123; if (m2 &lt;= uglys[i - 1] &amp;&amp; uglys[j] * 2 &gt; uglys[i - 1]) &#123; m2 = uglys[j] * 2; last2 = j; &#125; &#125; for (int j = last3 + 1; j &lt; i; j++) &#123; if (m3 &lt;= uglys[i - 1] &amp;&amp; uglys[j] * 3 &gt; uglys[i - 1]) &#123; m3 = uglys[j] * 3; last3 = j; &#125; &#125; for (int j = last5 + 1; j &lt; i; j++) &#123; if (m5 &lt;= uglys[i - 1] &amp;&amp; uglys[j] * 5 &gt; uglys[i - 1]) &#123; m5 = uglys[j] * 5; last5 = j; &#125; &#125; uglys[i] = Math.min(Math.min(m2, m3), m5); &#125; return uglys[n - 1];&#125; è¿™é‡Œæä¾›äº†å¦ä¸€ä¸ªç†è§£è¿™ä¸ªé—®é¢˜çš„æ€è·¯ï¼Œå¹¶ç”±æ­¤å¾—å‡ºäº†ä¸€ä¸ªæ›´å¿«çš„çš„ç®—æ³•(O(n))ï¼šæ ¹æ®å‰é¢ç®—æ³•çš„åŽŸç†ï¼Œå¯ä»¥çŸ¥é“ä¸‹ä¸€ä¸ªä¸‘æ•°ä¸€å®šæ˜¯å‰é¢æŸä¸€ä¸ªä¸‘æ•°ä¹˜ä»¥2,3,5ä¸­çš„ä¸€ä¸ªï¼Œæ‰€ä»¥å¯ä»¥æŠŠé—®é¢˜è½¬æ¢ä¸ºä»Žä»¥ä¸‹ä¸‰ç»„æ•°æ®ä¸­ä¸æ–­å–æœ€å°å€¼çš„é—®é¢˜ï¼š123(1) 1Ã—2, 2Ã—2, 3Ã—2, 4Ã—2, 5Ã—2, â€¦(2) 1Ã—3, 2Ã—3, 3Ã—3, 4Ã—3, 5Ã—3, â€¦(3) 1Ã—5, 2Ã—5, 3Ã—5, 4Ã—5, 5Ã—5, â€¦ å¯ä»¥å‘çŽ°æ¯ä¸ªå­åºåˆ—æ˜¯ä¸‘æ•°åºåˆ—æœ¬èº«1, 2, 3, 4, 5......åˆ†åˆ«ä¹˜ä»¥2, 3, 5ã€‚ä½¿ç”¨ç±»ä¼¼merge sortçš„åˆå¹¶æ–¹æ³•ï¼Œæ¯æ¬¡ä»Žä¸‰ä¸ªæ•°ç»„ä¸­å¼¹å‡ºæœ€å°çš„æ•°:12345678910111213141516171819/** return the nth ugly number */public static int getUglyNumber(int n) &#123; if (n == 0) return 0; int[] ugly = new int[n]; ugly[0] = 1; int i2 = 0, i3 = 0, i5 = 0; int next2 = 2, next3 = 3, next5 = 5; for (int i = 1; i &lt; n; i++) &#123; ugly[i] = Math.min(next2, Math.min(next3, next5)); if (next2 == ugly[i]) next2 = ugly[++i2] * 2; if (next3 == ugly[i]) next3 = ugly[++i3] * 3; if (next5 == ugly[i]) next5 = ugly[++i5] * 5; &#125; return ugly[n - 1];&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming 03 - æœ€é•¿å…¬å…±å­åºåˆ—]]></title>
    <url>%2Falgorithms-dynamic-programming-03%2F</url>
    <content type="text"><![CDATA[æœ€é•¿å…¬å…±å­åºåˆ—å¯¹äºŽä¸€ä¸ªå­—ç¬¦ä¸², å®ƒçš„å­åºåˆ—ï¼Œå°±æ˜¯å°†ç»™å­—ç¬¦ä¸²ä¸­ä»»æ„ä¸ªå…ƒç´ åŽ»æŽ‰ä¹‹åŽå‰©ä½™çš„å­—ç¬¦ä¸², æ‰€ä»¥å­åºåˆ—ä¸è¦æ±‚æ˜¯è¿žç»­çš„, ä½†æ˜¯ç»´æŒåŽŸæ¥çš„é¡ºåº. åœ¨æ–‡æœ¬ç›¸ä¼¼åº¦æ¯”è¾ƒä¸­ï¼Œå¸¸ç”¨åˆ°æœ€é•¿å…¬å…±å­åºåˆ—ï¼ˆlongest common sequenceï¼‰ã€‚ åŒæ—¶éåŽ†ä¸¤ä¸ªå­—ç¬¦ä¸², å¦‚æžœx[i] == y[j], åˆ™x[i]å’Œy[j]å‚ä¸Žäº†æœ€é•¿å…¬å…±å­åºåˆ—z[k]çš„æž„å»º. å¦‚æžœç”¨lcs[i, j]è¡¨ç¤ºéåŽ†åˆ°x[0-i]å’Œy[0-j]æ—¶çš„LCSé•¿åº¦, é‚£ä¹ˆçŽ°åœ¨å°±éœ€è¦åˆ¤æ–­x[i]å’Œy[j]çš„å…³ç³», åˆ†ä¸¤ç§æƒ…å†µ: å¦‚æžœäºŒè€…ç›¸ç­‰, é‚£ä¹ˆlcs1 = lcs[i - 1, j - 1] + 1 è‹¥ä¸ç›¸ç­‰, é‚£ä¹ˆåªèƒ½åœ¨xå’Œyä¸­é€‰æ‹©ä¸€ä¸ªè¿›è¡ŒæŽ¨è¿›, é€‰æ‹©ä¾æ®å°±æ˜¯å–è¾ƒå¤§å€¼, lcs2 = max(lcs[i - 1, j], lcs[i, j - 1]) åˆå§‹çŠ¶æ€è‡ªç„¶æ˜¯lcs[0, 0] = 0.12345678910111213141516static int[][] lcs;public static int longestCS(String x, String y) &#123; char[] xList = x.toCharArray(); char[] yList = y.toCharArray(); for (int i = 1; i &lt;= xList.length; i++) &#123; for (int j = 1; j &lt;= yList.length; j++) &#123; if (xList[i - 1] == yList[j - 1]) &#123; lcs[i][j] = lcs[i - 1][j - 1] + 1; &#125; else &#123; lcs[i][j] = Math.max(lcs[i - 1][j], lcs[i][j - 1]); &#125; &#125; &#125; return lcs[x.length()][y.length()];&#125; æœ€é•¿å…¬å…±å­ä¸²æœ€é•¿å…¬å…±å­ä¸²ï¼ˆlongest common substringï¼‰, è¦æ±‚çš„æ˜¯ä»»æ„è¿žç»­çš„å­å­—ç¬¦ä¸²ã€‚è®¾å®šLCS(i, j)ä¸ºåŒ…å«å½“å‰å­—ç¬¦a[i]å’Œb[j]çš„æœ€é•¿lcs. å‡å¦‚å½“å‰æ»¡è¶³a[i] == b[j], é‚£ä¹ˆLCS(i, j) = LCS(i - 1, j - 1) + 1, å¦åˆ™ä¸º0. æ¯”å¦‚å­—ç¬¦ä¸²21232523311324å’Œå­—ç¬¦ä¸²312123223445çš„åŒ¹é…çŸ©é˜µï¼Œå‰è€…ä¸ºXæ–¹å‘çš„ï¼ŒåŽè€…ä¸ºYæ–¹å‘çš„ã€‚ä¾‹å­æ¥æºäºŽè¿™ç¯‡æ–‡ç« 123456789101112130 0 0 1 0 0 0 1 1 0 0 1 0 0 00 1 0 0 0 0 0 0 0 2 1 0 0 0 01 0 2 0 1 0 1 0 0 0 0 0 1 0 00 2 0 0 0 0 0 0 0 1 1 0 0 0 01 0 3 0 1 0 1 0 0 0 0 0 1 0 00 0 0 4 0 0 0 2 1 0 0 1 0 0 01 0 1 0 5 0 1 0 0 0 0 0 2 0 01 0 1 0 1 0 1 0 0 0 0 0 1 0 00 0 0 2 0 0 0 2 1 0 0 1 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 1 00 0 0 0 0 0 0 0 0 0 0 0 0 1 00 0 0 0 0 1 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 123456789101112131415public int findLongest(String A, int n, String B, int m) &#123; char[] cha = A.toCharArray(); char[] chb = B.toCharArray(); int[][] matrix = new int[n][m]; int max = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (cha[i] == chb[j]) &#123; int cur = (i &gt; 0 &amp;&amp; j &gt; 0) ? matrix[i - 1][j - 1] + 1 : 1; max = Math.max(max, cur); matrix[i][j] = cur; &#125; return max;&#125; ä»Žå¦ä¸€ä¸ªè§’åº¦ç†è§£, è¿™ä¸ªè§£æ³•å°±æ˜¯ç”¨ä¸€ä¸ªçŸ©é˜µæ¥è®°å½•ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­æ‰€æœ‰ä½ç½®çš„ä¸¤ä¸ªå­—ç¬¦ä¹‹é—´çš„åŒ¹é…æƒ…å†µï¼Œè‹¥æ˜¯åŒ¹é…åˆ™èµ‹ä¸Šå…¶å·¦ä¸Šè§’å…ƒç´ çš„å€¼åŠ 1ï¼Œå¦åˆ™ä¸º0ã€‚çŸ©é˜µä¸­å€¼æœ€å¤§çš„å€¼ï¼Œå°±å¯¹åº”ç€å¯¹è§’çº¿æœ€é•¿çš„éž0è¿žç»­åºåˆ—ï¼Œå…¶å¯¹åº”çš„ä½ç½®å°±æ˜¯æœ€é•¿åŒ¹é…å­ä¸²çš„ä½ç½®ï¼Œæœ€é•¿åŒ¹é…å­ä¸²çš„ä½ç½®å’Œé•¿åº¦å°±å·²ç»å‡ºæ¥äº†ã€‚è®¡ç®—è¿™ä¸ªçŸ©é˜µçš„å¤æ‚åº¦æ˜¯O(N*M).]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming 02 - æœ€å¤§å­åºåˆ—]]></title>
    <url>%2Falgorithms-dynamic-programming-02%2F</url>
    <content type="text"><![CDATA[æœ€å¤§å­åºåˆ— Maximum subarray problem: In computer science, the maximum subarray problem is the task of finding the contiguous subarray within a one-dimensional array of numbers which has the largest sum. For example, for the sequence of values âˆ’2, 1, âˆ’3, 4, âˆ’1, 2, 1, âˆ’5, 4; the contiguous subarray with the largest sum is 4, âˆ’1, 2, 1, with sum 6.The problem was first posed by Ulf Grenander of Brown University in 1977, as a simplified model for maximum likelihood estimation of patterns in digitized images. A linear time algorithm was found soon afterwards by Jay Kadane of Carnegie Mellon University (Bentley 1984). å¦‚æžœæˆ‘ä»¬çŸ¥é“åœ¨ä½ç½®iç»“æŸçš„æœ€å¤§MSP[i]ï¼Œé‚£ä¹ˆåœ¨ä½ç½®i + 1å¤„ç»“æŸçš„MSP[i+1]å°±æ˜¯æœ‰ä¸¤ç§æƒ…å†µï¼Œä¸€æ˜¯åŒ…å«MSP[i]ï¼Œå³MSP[i+1] = MSP[i] + nums[i]ï¼ŒäºŒæ˜¯ä¸åŒ…å«, å³MSP[i+1] = nums[i], äºŒè€…å–è¾ƒå¤§å€¼ã€‚123456789public int maxSubArray(int[] nums) &#123; int maxCur = nums[0]; // maximum value contains current int maxSoFar = maxCur; // maximum value found so far for(int i = 1; i &lt; nums.length; i++) &#123; maxCur = Math.max(nums[i], nums[i] + maxCur); maxSoFar = Math.max(maxCur, maxSoFar); &#125; return maxSoFar;&#125; è‚¡ç¥¨æœ€ä¼˜ä¹°å–æ—¶é—´ç‚¹ç»™å‡ºä¸€æ®µè‚¡ç¥¨ä»·æ ¼å˜åŒ–åºåˆ—ï¼Œä¸€æ¬¡äº¤æ˜“å¯ä»¥èŽ·å¾—çš„æœ€å¤§æ”¶ç›Šã€‚å¦‚[7,1,5,3,6,4]è¾“å‡º5, åœ¨ç¬¬2å¤©ä¹°å…¥ï¼ˆä»·æ ¼= 1ï¼‰å¹¶åœ¨ç¬¬5å¤©å–å‡ºï¼ˆä»·æ ¼= 6ï¼‰ï¼Œåˆ©æ¶¦ 6-1 = 5ã€‚ è§£å†³é€»è¾‘è·Ÿæœ€å¤§å­åºåˆ—é—®é¢˜ä¸€æ ·, ä½¿ç”¨Kadaneâ€™s Algorithm. è®¡ç®—åŽŸå§‹æ•°ç»„çš„å·®åˆ†, å¹¶å¯»æ‰¾ç»™å‡ºæœ€å¤§åˆ©æ¶¦çš„è¿žç»­å­åºåˆ—, å¦‚æžœå·®åˆ†å°äºŽ0, é‡ç½®ä¸º0:123456789public int maxProfit(int[] prices) &#123; int maxCur = 0; // current maximum value int maxSoFar = 0; // maximum value found so far for(int i = 1; i &lt; prices.length; i++) &#123; maxCur = Math.max(0, maxCur + prices[i] - prices[i-1]); maxSoFar = Math.max(maxCur, maxSoFar); &#125; return maxSoFar;&#125; è‚¡ç¥¨æœ€ä¼˜ä¹°å–æ—¶é—´ç‚¹IIä»¥ä¸Šé—®é¢˜å¦‚æžœæ˜¯æ— é™æ¬¡äº¤æ˜“(ä½†ä¸å…è®¸åœ¨åŒä¸€å¤©å†…ä¹°å–è‚¡ç¥¨):123456789101112131415public int maxProfit(int[] prices) &#123; int profit = 0, i = 0; while (i &lt; prices.length) &#123; // find next local minimum while (i &lt; prices.length-1 &amp;&amp; prices[i+1] &lt;= prices[i]) i++; int min = prices[i++]; // need increment to avoid infinite loop for "[1]" // find next local maximum while (i &lt; prices.length-1 &amp;&amp; prices[i+1] &gt;= prices[i]) i++; profit += i &lt; prices.length ? prices[i++] - min : 0; &#125; return profit;&#125; å¦‚æžœå…è®¸T+0äº¤æ˜“, é‚£ä¹ˆç›´æŽ¥è´ªå¿ƒæ±‚å’Œæ‰€æœ‰æ­£çš„å·®åˆ†é¡¹å°±å¥½äº†. è‚¡ç¥¨æœ€ä¼˜ä¹°å–æ—¶é—´ç‚¹IIIå‚è€ƒè¿™ä¸ªç­”æ¡ˆä»¥ä¸Šé—®é¢˜å¦‚æžœæ˜¯äº¤æ˜“æ¬¡æ•°æœ€å¤šä¸¤æ¬¡, éœ€è¦å¯»æ‰¾åŠ¨æ€è§„åˆ’è½¬ç§»æ–¹ç¨‹. profit[k, i]è¡¨ç¤ºç¬¬kæ¬¡äº¤æ˜“, åœ¨iå¤©çš„åˆ©æ¶¦. å¦‚æžœå½“å¤©ä¸äº¤æ˜“, é‚£ä¹ˆåˆ©æ¶¦ä¸å˜profit[k, i] = profit[k, i - 1]. å¦‚æžœå½“å¤©å–å‡º, å–å‡ºçš„æ˜¯ç¬¬jå¤©ä¹°å…¥çš„è‚¡ç¥¨(j &lt; i), é‚£ä¹ˆåˆ©æ¶¦å°±æ˜¯prices[i] - prices[j] + profit[k-1, j-1], ä¹Ÿå°±æ˜¯è¦prices[j] - profit[k-1, j-1]æœ€å°.1234567891011121314public int maxProfit(int[] prices) &#123; if (prices.length == 0) return 0; int[][] profit = new int[3][prices.length]; for (int k = 1; k &lt;= 2; k++) &#123; for (int i = 1; i &lt; prices.length; i++) &#123; int min = prices[0]; for (int j = 1; j &lt;= i; j++) min = Math.min(min, prices[j] - profit[k-1][j-1]); profit[k][i] = Math.max(profit[k][i-1], prices[i] - min); &#125; &#125; return profit[2][prices.length - 1];&#125; å› ä¸ºiä»Žå·¦å¾€å³, j &lt; i, æ‰€æœ‰minä¸éœ€è¦æ¯æ¬¡éƒ½ä»Žå¤´å¼€å§‹æ‰¾:12345678910111213public int maxProfit(int[] prices) &#123; if (prices.length == 0) return 0; int[][] profit = new int[3][prices.length]; for (int k = 1; k &lt;= 2; k++) &#123; int min = prices[0]; for (int i = 1; i &lt; prices.length; i++) &#123; min = Math.min(min, prices[i] - profit[k-1][i-1]); profit[k][i] = Math.max(profit[k][i-1], prices[i] - min); &#125; &#125; return profit[2][prices.length - 1];&#125; å¤æ‚åº¦ä¸ºO(NK).ä»Žå¾ªçŽ¯ä¸Šå¯ä»¥çœ‹åˆ°, iåªä¾èµ–äºŽi-1, kåªä¾èµ–äºŽk-1, å› æ­¤å¯ä»¥åŽ‹ç¼©ä¸ºä¸€ç»´çš„æ•°ç»„æ¥å­˜å‚¨, ä½†éœ€è¦æ”¹å˜äº¤æ¢iå’Œkçš„å¾ªçŽ¯12345678910111213public int maxProfit(int[] prices) &#123; if (prices.length == 0) return 0; int[] profit = new int[3]; int[] min = new int[3]; for (int i = 1; i &lt; prices.length; i++) &#123; for (int k = 1; k &lt;= 2; k++) &#123; min[k] = Math.Min(min[k], prices[i] - profit[k-1]); profit[k] = Math.Max(profit[k], prices[i] - min[k]); &#125; &#125; return profit[2];&#125; å› ä¸ºåœ¨è¿™é‡Œk=2, æ‰€ä»¥å¯ä»¥ä½¿ç”¨æœ‰é™ä¸ªå˜é‡æ¥å‚¨å­˜çŠ¶æ€:12345678910111213public int maxProfit(int[] prices) &#123; int buyOne = Integer.MAX_VALUE; int SellOne = 0; int buyTwo = Integer.MAX_VALUE; int SellTwo = 0; for(int p : prices) &#123; buyOne = Math.min(buyOne, p); SellOne = Math.max(SellOne, p - buyOne); buyTwo = Math.min(buyTwo, p - SellOne); SellTwo = Math.max(SellTwo, p - buyTwo); &#125; return SellTwo;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dynamic Programming 01 - ç†è§£åŠ¨æ€è§„åˆ’]]></title>
    <url>%2Falgorithms-dynamic-programming-01%2F</url>
    <content type="text"><![CDATA[åœ¨è§£å†³é—®é¢˜ä¸­ï¼Œæœ‰å¾ˆå¤šç»å…¸çš„æ–¹æ³•ï¼Œå¦‚ divide-and-conquer, graph exploration, and greedyã€‚è¿™äº›æ–¹æ³•è™½ç„¶å¾ˆæœ‰æ•ˆï¼Œä½†å°¤å…¶è‡ªèº«çš„å±€é™æ€§ã€‚æŸäº›é—®é¢˜ï¼ˆAdvanced problem: the knapsack problem, sequence alignment, and optimal binary search treesï¼‰éœ€è¦å…¶ä»–æ€è·¯è§£å†³ï¼Œå¦‚ Dynamic programing å’Œ linear programmingã€‚ å‚è€ƒï¼šhttps://people.eecs.berkeley.edu/~vazirani/algorithms/chap6.pdf åŠ¨æ€è§„åˆ’åŠ¨æ€è§„åˆ’ä½œä¸ºä¸€ç§ç¼–ç¨‹èŒƒä¾‹ï¼Œå¯ä»¥ä»Žä¸€ä¸ªä¾‹å­ç€æ‰‹ç†è§£ï¼šæ±‚æ•°åˆ—çš„ weighted independent sets (WIS, æœ€å¤§éžè¿žç»­éžç›¸é‚»å­é›†)å’Œ, å¯¹äºŽa = [1, 4, 5, 4], å…¶WISä¸º{a[1], a[3]} = 8. å¦‚æžœä½¿ç”¨è´ªå¿ƒæ³•, æ¯æ¬¡éƒ½åœ¨å¯é€‰èŒƒå›´å†…å–æœ€å¤§å€¼, é‚£ä¹ˆå°±ä¼šå¾—åˆ°{a[2], a[0]} = 6. å¦‚æžœä½¿ç”¨åˆ†è€Œæ²»ä¹‹æ³•, æŠŠæ•°ç»„åˆ†ä¸ºä¸¤åŠa1 = [1, 4], a2 = [5, 4], åˆ™åˆ†åˆ«å¾—åˆ°WIS{a1[1]}, {a2[0]}, åˆå¹¶åŽå‘çŽ°æ˜¯ç›¸é‚»çš„, ä¸Žè¦æ±‚ç›¸æ‚–. è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå…³é”®çš„æ­¥éª¤æ˜¯æ‰¾åˆ°åŸºäºŽå­é—®é¢˜æœ€ä¼˜è§£çš„æœ€ä¼˜è§£ï¼šæƒ³åŠžæ³•æŠŠç¼©å°æœ€ä¼˜è§£å¤‡é€‰æ–¹æ¡ˆçš„æ•°é‡ï¼Œåœ¨è¿™ä¸ªè¾ƒå°çš„ç©ºé—´ä¸­å¯ä»¥ç›´æŽ¥é‡‡å–æš´åŠ›æœç´¢å¯»æ‰¾æœ€ä¼˜è§£ã€‚ å¯¹äºŽa = [1, 4, 5, 4], å‡è®¾å…¶MSIä¸ºS, å‡å¦‚ä»Žæœ€å³è¾¹çš„å…ƒç´ å¼€å§‹è€ƒè™‘, a[3] = 4åªæœ‰å±žäºŽSå’Œä¸å±žäºŽSä¸¤ç§æƒ…å†µ è‹¥a[3] = 4å±žäºŽS: é‚£ä¹ˆa[2] = 5å°±è‚¯å®šä¸å±žäºŽS, åˆ™S1 = MSI([1, 4]) + MSI([4]) è‹¥a[3]ä¸å±žäºŽS: é‚£ä¹ˆSåªèƒ½å­˜åœ¨äºŽ[1, 4, 5]ä¸­, é—®é¢˜å°±å˜æˆS2 = MSI([1, 4, 5]) æ‰€ä»¥å½’çº³å‡ºS = max(S1, S2) = max(MSI([1, 4]) + MSI([4]), MSI([1, 4, 5])) = ...ã€‚ å¯¹äºŽåªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ çš„åŽ»æƒ…å†µ, MSI([4]) = max(4) = 4, å³MSI([i]) = i è¿™å°±æ˜¯ä¸€ä¸ªé€’å½’çš„è°ƒç”¨: ä¹Ÿå°±æ˜¯ä»Žå³å¾€å·¦, æ¯ä¸€ä¸ªå…ƒç´ éƒ½è¦è€ƒè™‘ä¸€éæ˜¯å¦å±žäºŽS, æ¯æ¬¡ä¼šåˆ†è£‚å‡ºä¸¤ç§æƒ…å†µ, æ‰€ä»¥é€’å½’çš„å¤æ‚åº¦æ˜¯$Î˜(2^n)$. è¿™ä¸ªç®—æ³•æ•ˆçŽ‡ä¸é«˜, éœ€è¦ä¼˜åŒ–. æˆ‘ä»¬è€ƒè™‘è¿™ä¸ªé—®é¢˜åˆ°åº•æœ‰å¤šå°‘ä¸åŒçš„å­é—®é¢˜? å› ä¸ºæˆ‘ä»¬æ˜¯ä»Žå³å¾€å·¦æ‰«ææ¯ä¸€ä¸ªå…ƒç´ , å¯¹äºŽæ¯ä¸€ä¸ªå…ƒç´ i, ä¸ç®¡å…¶å±žäºŽæˆ–ä¸å±žäºŽS, å¾…è§£å†³çš„é€’å½’å­é—®é¢˜åªæœ‰ä¸€ä¸ª, å°±æ˜¯æ±‚å…¶å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ (å‰ç¼€)çš„MSI, æ‰€ä»¥ç†è®ºä¸Šæœ‰$Î˜(n)$ä¸ªä¸åŒçš„å­é—®é¢˜. æ‰€ä»¥è™½ç„¶é€’å½’çš„è°ƒç”¨æ˜¯$Î˜(2^n)$, ä½†éœ€è¦è§£å†³çš„å­é—®é¢˜åªæœ‰$Î˜(n)$, é‚£ä¹ˆå°±å­˜åœ¨ä¼˜åŒ–çš„ç©ºé—´. åŠžæ³•å°±æ˜¯é€šè¿‡è®°å¿†å·²ç»è§£å†³äº†çš„å­é—®é¢˜çš„ç­”æ¡ˆ, æ¥é¿å…é‡å¤çš„è®¡ç®—. å› ä¸ºå³è¾¹çš„å…ƒç´ çš„å­é—®é¢˜ç­”æ¡ˆéœ€è¦ç”¨åˆ°å…¶å·¦è¾¹çš„å­é—®é¢˜çš„ç­”æ¡ˆ, æ‰€ä»¥è®¡ç®—æ—¶, è¦ä»Žå·¦å¾€å³è®¡ç®—ï¼Œ æ‰€ä»¥è¿™ä¸ªç®—æ³•æˆä¸ºforwardç®—æ³•. åœ¨å®šä¹‰åˆå§‹å€¼æ—¶, MSI(i)è¡¨ç¤ºa[i]çš„å‰ç¼€a[0 : i]çš„MSI, MSI(0) = 0, å› ä¸ºa[0]å·¦è¾¹æ²¡æœ‰ä»»ä½•å…ƒç´ . MSI(1) = max(a[0:1]) = a[0] å¯¹äºŽi &gt; 1, MSI(i) = max(MSI(i - 1), MSI(i - 2) + a[i - 1]) 123456789public static int[] forwardMSI(int[] a) &#123; int[] msi = new int[a.length + 1]; msi[0] = 0; msi[1] = a[0]; for (int i = 2; i &lt; msi.length; i++) &#123; msi[i] = Math.max(msi[i - 1], msi[i - 2] + a[i - 1]); &#125; return msi;&#125; ä½†ä»¥ä¸Šç®—æ³•å¹¶æ²¡æœ‰è®°å½•MSIå…·ä½“åŒ…å«å“ªäº›å­é›†ï¼Œè™½ç„¶å¯ä»¥é€šè¿‡ä¿®æ”¹msiæ•°æ®ç»“æž„æ¥é¢å¤–å­˜å‚¨æ¯ä¸ªå€¼å¯¹åº”çš„MSIç‚¹é›†, ä½†è¿™æ ·ä¼šå½±å“æ•ˆçŽ‡è€Œä¸”æµªè´¹å†…å­˜ç©ºé—´. å›žå¿†å‰é¢ä»Žå³å¾€å·¦çš„åˆ†æž, æ¯ä¸ªå…ƒç´ éƒ½ä¼šè€ƒé‡æ˜¯å¦å±žäºŽMSIS, æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠforwardMSIä¸­ç®—å¥½çš„msiæ•°ç»„ä»Žå³å¾€å·¦ä¾æ¬¡åˆ¤æ–­ä¸€é, å·²å†³å®šæ˜¯å¦æŠŠaå¯¹åº”ä½ç½®çš„å…ƒç´ åŠ å…¥åˆ°Sä¸­.12345678910111213public static ArrayList&lt;Integer&gt; backwardMSI(int[] a) &#123; ArrayList&lt;Integer&gt; s = new ArrayList&lt;&gt;(); int i = msi.length - 1; while (i &gt;= 2) &#123; if (msi[i - 1] &gt;= msi[i - 2] + a[i - 1]) &#123; i--; &#125; else &#123; s.add(a[i - 1]); i -= 2; &#125; &#125; return s;&#125; è¿›ä¸€æ­¥ä¼˜åŒ–ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ç±»ä¼¼backwardçš„ç®—æ³•ä¸€æ¬¡è¿‡(O(n))è®¡ç®—å‡ºMSIçš„é›†åˆå’ŒMSIçš„å€¼, å¯¹backwardç®—æ³•ç¨ä½œæ”¹åŠ¨, åœ¨aè¡¨å¼€å¤´æ’å…¥0ï¼ˆæˆ–è€…è®©a[-1] = 0ï¼‰, ç„¶åŽä»Žå³å¾€å·¦ä¾æ¬¡åˆ¤æ–­ä¸€é, ç›´æŽ¥ç”¨aè¡¨è‡ªèº«çš„å€¼æ¥åˆ¤æ–­, å¾—åˆ°ä¸€ä¸ªBackwardç®—æ³•:123456789101112131415161718192021222324static int sum = 0;public static ArrayList&lt;Integer&gt; backwardMSII(int[] a) &#123; ArrayList&lt;Integer&gt; s = new ArrayList&lt;&gt;(); int i = a.length - 1; while (i &gt;= 2) &#123; int x = get(a, i); if (get(a, i - 1) &gt;= get(a, i - 2) + x) &#123; i--; &#125; else &#123; s.add(x); sum += x; i -= 2; &#125; &#125; return s;&#125;private static int get(int[] a, int index) &#123; if (index &lt; 0) &#123; return 0; &#125; else &#123; return a[index]; &#125;&#125; æ€»ç»“åŠ¨æ€è§„åˆ’çš„è§£æ³•ï¼š å®šä¹‰åˆé€‚çš„å­é—®é¢˜é›†åˆ: è¿™äº›å­é—®é¢˜åº”è¯¥å°½å¯èƒ½å°ï¼Œæ•°é‡å°½å¯èƒ½å°‘ã€‚å› ä¸ºå³ä½¿åœ¨æœ€å¥½çš„æƒ…å†µä¸‹ï¼Œä¹Ÿè¦èŠ±è´¹ constant time æ¥è§£å†³æ¯ä¸ªå­é—®é¢˜ï¼Œå› æ­¤å­é—®é¢˜çš„æ•°é‡å’Œå¤§å°å°±æ˜¯æ•´ä¸ªç®—æ³•è¿è¡Œæ—¶é—´çš„ä¸‹é™ã€‚ å½’çº³è½¬ç§»æ–¹ç¨‹ï¼šç³»ç»Ÿåœ°è§£å†³ä»Žæœ€å°çš„å­é—®é¢˜å¼€å§‹çš„æ‰€æœ‰å­é—®é¢˜åŽï¼Œå¦‚ä½•è½¬å‘è¶Šæ¥è¶Šå¤§çš„å­é—®é¢˜ã€‚ é€šè¿‡è®°å¿†å‡å°‘é‡å¤çš„é€’å½’è°ƒç”¨è®¡ç®—: è¦æ±‚å‰é¢å­é—®é¢˜çš„è§£å†³æ–¹æ¡ˆèƒ½å¤Ÿç”¨æ¥å¿«é€Ÿè®¡ç®—å½“å‰å­é—®é¢˜ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Algorithms</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½æ“ä½œ - åŸºç¡€çš„ä½è¿ç®—]]></title>
    <url>%2Fbits-operations-02%2F</url>
    <content type="text"><![CDATA[ä¸€äº›å¸¸è§„çš„æ“ä½œï¼Œ å‚è€ƒè¿™ä¸ªè§†é¢‘ã€‚ åŸºæœ¬ä½æ“ä½œæŠŠæŸä¸€ä½å˜ä¸º1ï¼š12345def set_bit(x, position): mask = 1 &lt;&lt; position return x | maskbin(set_bit(0b110, 0b101)) è¾“å‡º0b100110. å› ä¸ºx = 0b110 = 6, ç¿»è½¬ç¬¬äº”ä½ï¼Œå°±ç”¨position = 0b101 = 5ï¼Œ å¾—åˆ°mask = 0b00100000, ç”¨|æŠŠç¬¬äº”ä½å˜ä¸º1. æ¸…é™¤æŸä¸€ä½ï¼ˆ1å˜0)ï¼š123def clear_bit(x, position): mask = 1 &lt;&lt; position return x &amp; ~mask é€šè¿‡XOR^å’Œ1æ¥ç¿»è½¬æŸä¸€ä½ï¼š123def flip_bit(x, position): mask = 1 &lt;&lt; position return x ^ mask é€šè¿‡&amp;1å¯ä»¥ä½œä¸ºå–ä½æ“ä½œ, æ¥åˆ¤æ–­æŸä¸€ä½æ˜¯å¦æ˜¯1:123def is_bit_set(x, position): shifted = x &gt;&gt; position return shifted &amp; 1 0b1100110 &gt;&gt; 0b101 = 0b11, 0b11 &amp; 0b01 = 1 æ ¹æ®å‚æ•°stateæ¥æŽ§åˆ¶ä¿®æ”¹æŸä¸€ä½, å¦‚æžœå‚æ•°æ˜¯1é‚£ä¹ˆå°±æ˜¯set, å¦‚æžœæ˜¯0é‚£ä¹ˆå°±æ˜¯clear:123def modify_bit(x, position, state): mask = 1 &lt;&lt; position return (x &amp; ~mask) | (-state &amp; mask) å¦‚æžœstate = 0b1, -state = 0b11111111å¦‚æžœstate = 0b0, -state = 0b0]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½æ“ä½œ - äºŒè¿›åˆ¶æ“ä½œç¬¦]]></title>
    <url>%2Fbits-operations-01%2F</url>
    <content type="text"><![CDATA[åœ¨å¾ˆå¤šè¯­è¨€ä¸­ï¼Œå­—ç¬¦charç±»åž‹æ˜¯å…«ä½, é‚£ä¹ˆå¯èƒ½å–å€¼æœ‰256ç§(-128 ~ -1, 0 ~ 127). ä½†æ˜¯ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸º0000 0000 ~ 1111 1111, æ— ç¬¦å·æ•´æ•°çš„å…¨éƒ¨ä½éƒ½è¡¨ç¤ºæ•°å€¼ï¼Œè€Œæœ‰ç¬¦å·æ•°çš„æœ€é«˜ä½æ˜¯ç¬¦å·ä½ï¼ˆ0è¡¨ç¤ºæ­£æ•°ï¼Œ1è¡¨ç¤ºè´Ÿæ•°ï¼‰ï¼Œæ‰€ä»¥å®žé™…è¡¨è¾¾æ•°å€¼çš„åªå‰©ä¸‹n-1ä½ã€‚è¿™æ ·ç†è®ºä¸Šcharçš„å–å€¼åº”è¯¥æ˜¯1111 1111 = -127åˆ°0111 1111 = 127. è€Œ-128 = 1 1000 0000éœ€è¦9ä½æ¥è¡¨è¾¾, æ‰€ä»¥charæ˜¯å¦‚ä½•ä»…ä»…é€šè¿‡å…«ä½è¡¨è¾¾-128? é¦–å…ˆ, å› ä¸ºè®¡ç®—æœºåªèƒ½åšåŠ æ³•, æ‰€ä»¥å‡æ³•æ“ä½œè¦è½¬åŒ–ä¸ºåŠ æ³•, å°è¯•å°†ç¬¦å·ä½å‚ä¸Žè¿ç®—, 1-1å°±è½¬åŒ–ä¸º1 + (-1), ç”¨äºŒè¿›åˆ¶è¡¨è¾¾ä¸º0000 0001 + 1000 0001 = -2, å¾ˆæ˜Žæ˜¾æ˜¯é”™çš„. å¦‚æžœç”¨åŽŸç è¡¨ç¤º, è®©ç¬¦å·ä½ä¹Ÿå‚ä¸Žè®¡ç®—, æ˜¾ç„¶å¯¹äºŽå‡æ³•æ¥è¯´, ç»“æžœæ˜¯ä¸æ­£ç¡®çš„. è¿™ä¹Ÿå°±æ˜¯ä¸ºä½•è®¡ç®—æœºå†…éƒ¨ä¸ä½¿ç”¨åŽŸç è¡¨ç¤ºä¸€ä¸ªæ•°. ä¸ºäº†é¿å…è¿™ç§é”™è¯¯, å¼•å…¥åç (æ­£æ•°çš„åç æ˜¯å…¶æœ¬èº«, è´Ÿæ•°çš„åç æ˜¯ç¬¦å·ä½ä¸å˜, å…¶ä½™ä½å–å), ç”¨-1çš„åŽŸç 1000 0001çš„åç 1111 1110æ¥è¡¨è¾¾-1, è¿™æ ·1 + (-1) = [0000 0001]å + [1111 1110]å = [1111 1111]å, è½¬ä¸ºåŽŸç 1000 0000 = -0. å‘çŽ°ç”¨åç è®¡ç®—å‡æ³•, ç»“æžœçš„çœŸå€¼éƒ¨åˆ†æ˜¯æ­£ç¡®çš„. äºŒè¿›åˆ¶è¡¥ç ä¸ºäº†å½»åº•è§£å†³è´Ÿæ•°è¡¨è¾¾ä¸­çš„-0 = 0, 1000 0000 = 0000 0000é—®é¢˜, å¼•å…¥è¡¥ç (æ­£æ•°çš„è¡¥ç æ˜¯å…¶æœ¬èº«ï¼Œè´Ÿæ•°çš„è¡¥ç ä¸ºå…¶åç åŠ 1). è¡¥ç æ˜¯è®¡ç®—æœºä¸­æœ€å¸¸ç”¨çš„æœ‰ç¬¦å·æ•°çš„è¡¨è¾¾å½¢å¼ã€‚è¡¥ç å®šä¹‰ä¸ºæœ€é«˜ä½æƒé‡ä¸ºè´Ÿçš„äºŒè¿›åˆ¶ç ã€‚$$ B2T_4(0001) = -0 + 0 + 0 + 1 = 1 $$$$ B2T_4(1111) = -8 + 4 + 2 + 1 = -1 $$$$ B2T_4(0101) = -0 + 4 + 0 + 1 = 5 $$$$ B2T_4(1011) = -8 + 0 + 2 + 1 = -5 $$ 0 1 1 1 1 1 1 1 = 1270 0 0 0 0 0 1 0 = 20 0 0 0 0 0 0 1 = 10 0 0 0 0 0 0 0 = 01 1 1 1 1 1 1 1 = âˆ’128 + 127 = -11 1 1 1 1 1 1 0 = âˆ’21 0 0 0 0 0 0 1 = âˆ’128 + 1 = -1271 0 0 0 0 0 0 0 = âˆ’128 è¿™æ ·å‡æ³•æ“ä½œè½¬åŒ–ä¸ºåŠ è¡¥ç 1+(-1) = [0000 0001]è¡¥ + [1111 1111]è¡¥ = [1 0000 0000]è¡¥, charå®šä¹‰ä¸º8ä½, æ•…ç¬¬ä¹ä½èˆå¼ƒ, å¾—åˆ°[0000 0000]è¡¥, è½¬æ¢ä¸ºåŽŸç ä¸º[1000 0000]åŽŸ = -0. æ‰€ä»¥, -0 = [1000 0000]åŽŸçš„è¡¥ç ä¸º1 0000 0000 = 0000 0000 = 0, 0 = 0000 0000çš„è¡¥ç ä¸º1000 0000 = -0. é‰´äºŽ0çš„éžè´Ÿéžæ­£ç‰¹æ€§, ä»…ä»…ä½¿ç”¨0000 0000æ¥è¡¨è¾¾0å’Œå…¶è¡¥ç å°±è¶³å¤Ÿäº†. è¿™æ ·1000 0000å°±å¯ä»¥æŒªä½œä»–ç”¨,ç”¨æ¥è¡¨è¾¾-128. ä¹‹æ‰€ä»¥ç”¨æ¥è¡¨è¾¾-128æ˜¯æœ‰å…¶åˆç†æ€§çš„. å› ä¸º-1 + (-127) = [1000 0001]åŽŸ + [1111 1111]åŽŸ = [1111 1111]è¡¥ + [1000 0001]è¡¥ = [1000 0000]è¡¥, -128 = 1 1000 0000çš„è¡¥ç ä¹Ÿåˆšå¥½æ˜¯1 1000 0000, æ”¾è¿›charçš„å…«ä½ç©ºé—´ä¸­, éœ€è¦æŠŠç¬¬ä¹ä½æˆªæ–­, å¾—åˆ°çš„åˆšå¥½æ˜¯1000 0000. å¯ä»¥æŽ¨ç†å‡ºè¡¥ç çš„å–å€¼èŒƒå›´ï¼Œæœ€å°å€¼ä¸º[10...0], $TMin_w = -2^{w-1}$, æœ€å¤§å€¼ä¸º[01...1], $TMax_w = 2^{w-1} - 1$. ä½¿ç”¨è¡¥ç , ä¸ä»…ä»…ä¿®å¤äº†0çš„ç¬¦å·ä»¥åŠå­˜åœ¨ä¸¤ä¸ªç¼–ç çš„é—®é¢˜, è€Œä¸”è¿˜èƒ½å¤Ÿå¤šè¡¨ç¤ºä¸€ä¸ªæœ€ä½Žæ•°. è¿™å°±æ˜¯ä¸ºä»€ä¹ˆ8ä½äºŒè¿›åˆ¶, ä½¿ç”¨åŽŸç æˆ–åç è¡¨ç¤ºçš„èŒƒå›´ä¸º[-127, +127], è€Œä½¿ç”¨è¡¥ç è¡¨ç¤ºçš„èŒƒå›´ä¸º[-128, 127]. åŒç†16ä½shortä¸­-32768~32767ï¼Œ-32768åŽŸç ä¸º17ä½ï¼Œä¸¢å¼ƒæœ€é«˜ä½å‰©ä¸‹çš„16å’Œ-0çš„åŽŸç ç›¸åŒã€‚ å¯ä»¥è§‚å¯Ÿåˆ°, abs(TMin) = TMax + 1 = TMin, ä¹Ÿå°±æ˜¯æœ€å°å€¼çš„ç»å¯¹å€¼è¿˜æ˜¯æœ€å°å€¼: -(INT_MIN) = - 0[1000 0000]è¡¥ = 1[1000 0000]è¡¥ = [1000 0000]è¡¥ = -128 = [0111 1111]è¡¥ + 1. äºŒè¿›åˆ¶è¡¥ç è¿ç®—æ˜¯åŠ æ³•é€†è¿ç®—ã€‚è¡¥ç ç³»ç»Ÿçš„æœ€å¤§ä¼˜ç‚¹æ˜¯å¯ä»¥åœ¨åŠ æ³•æˆ–å‡æ³•å¤„ç†ä¸­ï¼Œä¸éœ€å› ä¸ºæ•°å­—çš„æ­£è´Ÿè€Œä½¿ç”¨ä¸åŒçš„è®¡ç®—æ–¹å¼ã€‚åªè¦ä¸€ç§åŠ æ³•ç”µè·¯å°±å¯ä»¥å¤„ç†å„ç§æœ‰å·æ•°åŠ æ³•ï¼Œè€Œä¸”å‡æ³•å¯ä»¥ç”¨ä¸€ä¸ªæ•°åŠ ä¸Šå¦ä¸€ä¸ªæ•°çš„è¡¥ç æ¥è¡¨ç¤ºï¼Œå› æ­¤åªè¦æœ‰åŠ æ³•ç”µè·¯åŠè¡¥ç ç”µè·¯å³å¯å®Œæˆå„ç§æœ‰å·æ•°åŠ æ³•åŠå‡æ³•ã€‚ Bitwise operatorsBitwise NOT - ~, or complement: 0 become 1, 1 become 0. The bitwise complement is equal to the twoâ€™s complement of the value minus one. ~x = -x âˆ’ 1 å› ä¸º~x + x = b[1...1] = -1, é€šè¿‡~x + 1å¾—åˆ°ä¸€ä¸ªæ•°çš„è´Ÿæ•°, å¾—åˆ°çš„è´Ÿæ•°ä¹Ÿå°±æ˜¯è¯¥äºŒè¿›åˆ¶æ•°å­—çš„è¡¥ç . æ¯”å¦‚0 = b[0000], ~0 = b[1111],b[1111] + b[0001] = b[0000] = 0, åˆæ¯”å¦‚TMin = b[1000], ~TMin = b[0111], ~TMin + 1 = b[0111] + b[0001] = b[1000] = TMin, ä¹Ÿå°±æ˜¯-TMin = TMin. Bitwise AND - &amp;: 1 &amp; 1 = 1, 1 &amp; 0 = 0, 0 &amp; 0 = 0. performs the logical AND operation on each pair of the corresponding bits, which is equivalent to multiplying them. Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1 (1 Ã— 1 = 1); otherwise, the result is 0 (1 Ã— 0 = 0 and 0 Ã— 0 = 0). Bitwise OR - |: 1 | 1 = 1, 1 | 0 = 1, 0 | 0 = 0 takes two bit patterns of equal length and performs the logical inclusive OR operation on each pair of corresponding bits. The result in each position is 0 if both bits are 0, while otherwise the result is 1. Bitwise XOR - ^: 1 ^ 1 = 0, 1 ^ 0 = 1, 0 ^ 0 = 0 takes two bit patterns of equal length and performs the logical exclusive OR operation on each pair of corresponding bits. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1. In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same. Bit shiftsJavaä¸­æœ‰ä¸‰ç§ç§»ä½è¿ç®—ç¬¦. &lt;&lt;: å·¦ç§»è¿ç®—ç¬¦ï¼Œnum &lt;&lt; n, æŠŠnumçš„äºŒè¿›åˆ¶å·¦ç§»nä½, å³è¾¹çš„ç©ºä½ç”¨0è¡¥ä¸Š, æ¯ä¸€æ¬¡ç§»ä½ç›¸å½“äºŽnum * 2(é™¤éžoverflow) &gt;&gt;: å³ç§»è¿ç®—ç¬¦ï¼Œnum &gt;&gt; n, å³ç§»n, æ¯æ¬¡ç§»ä½ç›¸å½“äºŽnum / 2 å¦‚æžœæ˜¯æ— ç¬¦å·æ•°å€¼ï¼Œä¹Ÿå°±æ˜¯&gt;&gt;&gt;ï¼Œå·¦è¾¹ç©ºç¼ºç”¨0è¡¥ä¸Š, å¦‚æžœæ˜¯æœ‰ç¬¦å·æ•°å€¼ï¼Œåˆ™ç”¨æ•°å­—çš„ç¬¦å·ä½å¡«è¡¥æœ€å·¦è¾¹çš„nä½ å¦‚æžœæ˜¯æ­£æ•°, åˆ™å³ç§»åŽåœ¨æœ€å·¦è¾¹è¡¥nä¸ª0 å¦‚æžœåŽŸå…ˆæ˜¯è´Ÿæ•°, åˆ™å³ç§»åŽåœ¨æœ€å·¦è¾¹è¡¥nä¸ª1]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find All Collinear Points - A Pattern Recognition Problem]]></title>
    <url>%2Falgorithms-applications-03-pattern-recognition%2F</url>
    <content type="text"><![CDATA[The Line Patterns RecognitionA basic but important application of pattern recognition is to recognize line patterns in a given set of points. http://coursera.cs.princeton.edu/algs4/assignments/collinear.html. This blog will give a breif introduction to this problem and provide an enfficient solution. Codes available in algs4/collinear/src/ The problem could be described as: Given a set of n distinct points in the plane, find every (maximal) line segment that connects a subset of 4 or more of the points.. Point data type. an immutable data type Point that represents a point in the plane by implementing the following API:1234567891011public class Point implements Comparable&lt;Point&gt; &#123; public Point(int x, int y) // constructs the point (x, y) public void draw() // draws this point public void drawTo(Point that) // draws the line segment from this point to that point public String toString() // string representation public int compareTo(Point that) // compare two points by y-coordinates, breaking ties by x-coordinates public double slopeTo(Point that) // the slope between this point and that point public Comparator&lt;Point&gt; slopeOrder() // compare two points by slopes they make with this point&#125; Line segment data type. To represent line segments in the plane, use the data type LineSegment.java, which has the following API:12345public class LineSegment &#123; public LineSegment(Point p, Point q) // constructs the line segment between points p and q public void draw() // draws this line segment public String toString() // string representation&#125; Apparently if using brute force, the order of growth of the running time of the program will be $n^4$ in the worst case. A faster, sorting-based solution: Given a point p, the following method determines whether p participates in a set of 4 or more collinear points. Think of p as the origin. For each other point q, determine the slope it makes with p. Sort the points according to the slopes they makes with p. Check if any 3 (or more) adjacent points in the sorted order have equal slopes with respect to p. If so, these points, together with p, are collinear. SolutionThere are two key points to get the order of growth of the running time to be $n^2\log n$ in the worst case, with space proportional to n plus the number of line segments returned, and work properly even if the input has 5 or more collinear points. Stable sort: Arrays.sort() is guaranteed to be stable, so equal elements will not be reordered as a result of the sort. So the input points array is already sorted by points natural order once we sort the element at the first valid check step. To avoid duplicate line segments, we need to check if new found collinear points pairs already exist in the LineSegment. If we loop over the LineSegment everytime we have a new line segments to check, this will results in large run time that will not satisfy the requirement. Instead, we need to make use of the inner features of the line patterns: Since the every possible segment is created by points it contains, and we iterate through the sorted Points array to find segment so every non-duplicate new segment is guaranteed to be created from its smallest point member any duplicate segment is created later by its other member other than the smallest]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Sorting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Randomized Queue with Reservoir Sampling]]></title>
    <url>%2Falgorithms-applications-02-randomized-queue%2F</url>
    <content type="text"><![CDATA[This blog explains an apllication of randomized queue algorithms. Permutation client memory challengeA client program Permutation.java that takes an integer k as a command-line argument; reads in a sequence of strings from standard input using StdIn.readString(); and prints exactly k of them, uniformly at random. Print each item from the sequence at most once. More detail could be found at programming assignment specification and checklist, codes available in algs4/queues/src/. Randomized queueFor a randomized queue, the item removed is chosen uniformly at random from items in the data structure. Each iterator must return the items in uniformly random order. The order of two or more iterators to the same randomized queue must be mutually independent; each iterator must maintain its own random order. API:12345678910public class RandomizedQueue&lt;Item&gt; implements Iterable&lt;Item&gt; &#123; public RandomizedQueue() &#123;&#125; // construct an empty randomized queue public boolean isEmpty() &#123;&#125; // is the randomized queue empty? public int size() &#123;&#125; // return the number of items on the randomized queue public void enqueue(Item item) &#123;&#125; // add the item public Item dequeue() &#123;&#125; // remove and return a random item public Item sample() &#123;&#125; // return a random item (but do not remove it) public Iterator&lt;Item&gt; iterator() &#123;&#125; // return an independent iterator over items in random order public static void main(String[] args) &#123;&#125; // unit testing (optional)&#125; SolutionThe bonu point is to use only one RandomizedQueue object of maximum size at most k. More specifically, as the program sees a sequence of input, one at a time, the programe could only keep k items in memory, and they should be selected at random from the sequence. If we know the total number of items (n), then the solution is easy: select ten distinct indices i between 1 and n with equal probability, and keep the i-th elements. The challenge is that we do not know the input sequence length in advance. The idea is when reading in input strings one by one, we maintain the RandomizedQueue with size at most k on the fly. If the RandomizedQueue is full, then we need to decide whether a new input string should be accepted or not. If it should be accepted, then one of the old elements must be kicked out of the queues. The key point here is how to make the decision. The algorithms explain the mechanism: For a loop over n, swap item [n] with a random item in the range [0] through [n]. We store only the first k elements ([0 : k-1]) as that are all we need. Afterwards, when we get a new string (index [n]), weâ€™ll swap it with one of the first k strings for a given probability P, otherwise just discard it. The Reservoir sampling algorithms could solve the problem: Reservoir sampling is a family of randomized algorithms for randomly choosing a sample of k items from a list S containing n items, where n is either a very large or unknown number. Typically n is large enough that the list doesnâ€™t fit into main memory. Keep the first k items in memory. When the i-th item arrives (for $i&gt;k$): with probability $k/i$, keep the new item (discard an old one, selecting which to replace at random, each with chance $1/k$) with probability $1-k/i$, keep the old items (ignore the new one) code available: https://github.com/congchan/algs4/tree/master/queues/src In our case of implementation, for a loop over n, swap item [n] with a random item in the range [0] through [n]. We store only the first k elements ([0 : k-1]) as that are all we need. Afterwards, when we get a new string (index [n]), weâ€™ll swap it with one of the first k strings for a given probability P, otherwise just discard it. There is another shuffle method called Fisherâ€“Yates shuffle and its $O(n)$ version called Knuth shuffle which could shuffle a given sequence. Test report:1234567891011121314151617Correctness: 43/43 tests passedMemory: 106/105 tests passedTiming: 136/136 tests passedAggregate score: 100.10%[Compilation: 5%, API: 5%, Findbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]Test 3 (bonus): check that maximum size of any or Deque or RandomizedQueue object created is equal to k * filename = tale.txt, n = 138653, k = 5 * filename = tale.txt, n = 138653, k = 50 * filename = tale.txt, n = 138653, k = 500 * filename = tale.txt, n = 138653, k = 5000 * filename = tale.txt, n = 138653, k = 50000==&gt; passedTotal: 3/2 tests passed!]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Reservoir Sampling</tag>
        <tag>Fisherâ€“Yates shuffle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Percolations problem]]></title>
    <url>%2Falgorithms-applications-01-percolation%2F</url>
    <content type="text"><![CDATA[Union-find applications: PercolationProblem discriptions Percolation data type. To model a percolation system, create a data type Percolation with the following API:12345678public class Percolation &#123; public Percolation(int n); // create n-by-n grid, with all sites blocked public void open(int row, int col); // open site (row, col) if it is not open already public boolean isOpen(int row, int col); // is site (row, col) open? public boolean isFull(int row, int col); // is site (row, col) full? public int numberOfOpenSites(); // number of open sites public boolean percolates(); // does the system percolate?&#125; Monte Carlo simulation. To estimate the percolation threshold, consider the following computational experiment: Initialize all sites to be blocked. Repeat the following until the system percolates: Choose a site uniformly at random among all blocked sites. Open the site. The fraction of sites that are opened when the system percolates provides an estimate of the percolation threshold. Codes available at algs4/Percolation/src/ The back wash issueMy solution inspired from this post https://www.sigmainfy.com/blog/avoid-backwash-in-percolation.html, with some improvements: Using one WeightedQuickUnionUF(n * n) objects to track each siteâ€™s parent. Use a byte[n * n] to store the each siteâ€™s state. There are four possible states, represented as BLOCKED: 0b000 OPEN: 0b001 CONNECT_TO_BOTTOM: 0b010 CONNECT_TO_TOP: 0b100 With byte operation |, we enable sites to have mixture of states. open(row, col): to open the current site cur, we need to find out its four possible neibourghs (up, down, left, right, if exist); use find() to return the neibourghsâ€™ parents (upParent, etc..), use union() to connect cur and its neibourghs; Fianally, update curâ€˜s new parent newParentâ€˜s state with the combination of curâ€˜s parent state and the neibourghsâ€™ parents states. in totalm, there involves 4 union() and 5 find() API calls at most but the time complexity is still $\Theta(\lg N)$ isOpen(): $\in \Theta(1)$ by checking the byte[n * n]. isFull(): $\in \Theta(1)$, use one call find() API and thus is $\in \Theta (\lg N)$ percolates(): use a boolean isPercolates as mark, for any new open site that becomes both CONNECT_TO_BOTTOM and CONNECT_TO_TOP, we could mark the model as percolates. 12345Estimated student memory = 9.00 n^2 + 0.00 n + 160.00 (R^2 = 1.000)Test 2 (bonus): check that total memory &lt;= 11 n^2 + 128 n + 1024 bytes==&gt; passed]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
        <tag>Bitwise Operation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœºå™¨é˜…è¯»ç†è§£ - LSTMä¸Žæ³¨æ„åŠ›æœºåˆ¶ - æ–¯å¦ç¦é—®ç­”æ•°æ®é›† (SQuAD)]]></title>
    <url>%2FNLP-attention-02-lstm-reading-comprehension%2F</url>
    <content type="text"><![CDATA[The Standford question and answer dataset (SQuAD) æ˜¯ç”± Rajpurkar ç­‰äººæå‡ºçš„ä¸€ä¸ªè¾ƒæœ‰æŒ‘æˆ˜æ€§çš„é˜…è¯»ç†è§£æ•°æ®é›†ã€‚è¯¥æ•°æ®é›†åŒ…å« 10 ä¸‡ä¸ªï¼ˆé—®é¢˜ï¼ŒåŽŸæ–‡ï¼Œç­”æ¡ˆï¼‰ä¸‰å…ƒç»„ï¼ŒåŽŸæ–‡æ¥è‡ªäºŽ 536 ç¯‡ç»´åŸºç™¾ç§‘æ–‡ç« ï¼Œè€Œé—®é¢˜å’Œç­”æ¡ˆçš„æž„å»ºä¸»è¦æ˜¯é€šè¿‡ä¼—åŒ…çš„æ–¹å¼ï¼Œè®©æ ‡æ³¨äººå‘˜æå‡ºæœ€å¤š 5 ä¸ªåŸºäºŽæ–‡ç« å†…å®¹çš„é—®é¢˜å¹¶æä¾›æ­£ç¡®ç­”æ¡ˆï¼Œä¸”ç­”æ¡ˆå‡ºçŽ°åœ¨åŽŸæ–‡ä¸­ã€‚SQuAD å’Œä¹‹å‰çš„å®Œå½¢å¡«ç©ºç±»é˜…è¯»ç†è§£æ•°æ®é›†å¦‚ CNN/DMï¼ŒCBT ç­‰æœ€å¤§çš„åŒºåˆ«åœ¨äºŽï¼šSQuAD ä¸­çš„ç­”æ¡ˆä¸åœ¨æ˜¯å•ä¸ªå®žä½“æˆ–å•è¯ï¼Œè€Œå¯èƒ½æ˜¯ä¸€æ®µçŸ­è¯­ï¼Œè¿™ä½¿å¾—å…¶ç­”æ¡ˆæ›´éš¾é¢„æµ‹ã€‚SQuAD åŒ…å«å…¬å¼€çš„è®­ç»ƒé›†å’Œå¼€å‘é›†ï¼Œä»¥åŠä¸€ä¸ªéšè—çš„æµ‹è¯•é›†ï¼Œå…¶é‡‡ç”¨äº†ä¸Ž ImageNet ç±»ä¼¼çš„å°é—­è¯„æµ‹çš„æ–¹å¼ï¼Œç ”ç©¶äººå‘˜éœ€æäº¤ç®—æ³•åˆ°ä¸€ä¸ªå¼€æ”¾å¹³å°ï¼Œå¹¶ç”± SQuAD å®˜æ–¹äººå‘˜è¿›è¡Œæµ‹è¯•å¹¶å…¬å¸ƒç»“æžœã€‚ç”±äºŽ SQuAD çš„ç­”æ¡ˆé™å®šäºŽæ¥è‡ªåŽŸæ–‡ï¼Œæ¨¡åž‹åªéœ€è¦åˆ¤æ–­åŽŸæ–‡ä¸­å“ªäº›è¯æ˜¯ç­”æ¡ˆå³å¯ï¼Œå› æ­¤æ˜¯ä¸€ç§æŠ½å–å¼çš„ QA ä»»åŠ¡è€Œä¸æ˜¯ç”Ÿæˆå¼ä»»åŠ¡ã€‚ç®€å•çš„ SQuAD çš„æ¨¡åž‹æ¡†æž¶å¯ä»¥å‚è€ƒseq2seqï¼šEmbed å±‚ï¼ŒEncode å±‚ å’Œ Decode å±‚ã€‚Embed å±‚è´Ÿè´£å°†åŽŸæ–‡å’Œé—®é¢˜ä¸­çš„ tokens æ˜ å°„ä¸ºå‘é‡è¡¨ç¤ºï¼›Encode å±‚ä¸»è¦ä½¿ç”¨ RNN æ¥å¯¹åŽŸæ–‡å’Œé—®é¢˜è¿›è¡Œç¼–ç ï¼Œè¿™æ ·ç¼–ç åŽæ¯ä¸ª token çš„å‘é‡è¡¨ç¤ºå°±è•´å«äº†ä¸Šä¸‹æ–‡çš„è¯­ä¹‰ä¿¡æ¯ï¼›Decode å±‚åˆ™åŸºäºŽ query-aware çš„åŽŸæ–‡è¡¨ç¤ºæ¥é¢„æµ‹ç­”æ¡ˆèµ·å§‹ä½ç½®ã€‚ ä½†è¿™ä¸ªæ–‡æœ¬æ•°æ®é›†æ¶‰åŠé—®é¢˜ï¼ŒåŽŸæ–‡ï¼Œç­”æ¡ˆä¸‰ä¸ªéƒ¨åˆ†, ç‰¹åˆ«æ˜¯éœ€è¦æ ¹æ®é—®é¢˜åœ¨åŽŸæ–‡ä¸­æœå¯»ç­”æ¡ˆçš„èŒƒå›´, è¿™å°±æ¶‰åŠå¦‚æžœæŠŠé—®é¢˜çš„ä¿¡æ¯æå–å‡ºæ¥å¹¶ä½œç”¨äºŽåŽŸæ–‡. ç›®å‰å„ç§å‰æ²¿æ¨¡åž‹çš„å…³æ³¨ç‚¹å‡ ä¹Žéƒ½æ˜¯åœ¨å¦‚ä½•æ•æ‰é—®é¢˜å’ŒåŽŸæ–‡ä¹‹é—´çš„äº¤äº’å…³ç³»ï¼Œä¹Ÿå°±æ˜¯åœ¨ Encode å±‚å’Œ Decode å±‚ä¹‹é—´, ä½¿ç”¨ä¸€ä¸ª Interaction å±‚å¤„ç†ç¼–ç äº†é—®é¢˜è¯­ä¹‰ä¿¡æ¯çš„åŽŸæ–‡è¡¨ç¤ºï¼Œå³ query-aware çš„åŽŸæ–‡è¡¨ç¤ºï¼Œå†è¾“å…¥ç»™ Decode å±‚ã€‚è€Œæœ¬æ¥åº”ç”¨æœºå™¨ç¿»è¯‘Attentionæœºåˆ¶å°±èƒ½å¾ˆå¥½çš„å¤„ç†è¿™ç§äº¤äº’ã€‚ Attentionæœºåˆ¶å‚è€ƒå¦ä¸€ç¯‡æ–‡ç« æ³¨æ„åŠ›æœºåˆ¶. æ³¨æ„åŠ›æœºåˆ¶åº”ç”¨äºŽé˜…è¯»ç†è§£è™½ç„¶æ³¨æ„åŠ›æœºåˆ¶å¤§åŒå°å¼‚ï¼Œä½†æ˜¯ä¸åŒçš„æ³¨æ„åŠ›æƒé‡ï¼ˆæ‰“åˆ†å‡½æ•°ï¼‰å¸¦æ¥çš„æ•ˆæžœæ˜¯ä¸ä¸€æ ·çš„ã€‚æ¯”è¾ƒå¸¸ç”¨çš„æ˜¯å°±æ˜¯ä½¿ç”¨å…¨å±€æ³¨æ„åŠ›æœºåˆ¶ä¸­æåˆ°çš„$$\begin{aligned} score_{general}(tâ€™ t) &amp;= s^\top_{tâ€™} W_\alpha h_t, \\\end{aligned}$$å°±æ˜¯ç”¨ä¸€ä¸ªäº¤äº’çŸ©é˜µ$W_\alpha$æ¥æ•æ‰é—®é¢˜å’ŒåŽŸæ–‡ä¹‹é—´çš„äº¤äº’å…³ç³». åŽŸæ–‡ä½œè€…ç§°ä¹‹ä¸º Bilinear.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class Attention(object): def forwards_bilinear(self, hc, hq, hc_mask, hq_mask, max_context_length_placeholder, max_question_length_placeholder, is_train, keep_prob): '''combine context hidden state(hc) and question hidden state(hq) with global attention bilinear score = hc.T *W *hq ''' d_en = hc.get_shape().as_list()[-1] # (BS, MPL, MQL) interaction_weights = tf.get_variable("W_interaction", shape=[d_en, d_en]) hc_W = tf.reshape(tf.reshape(hc, shape=[-1, d_en]) @ interaction_weights, shape=[-1, max_context_length_placeholder, d_en]) # (BS, MPL, HS * 2) @ (BS, HS * 2, MCL) -&gt; (BS ,MCL, MQL) score = hc_W @ tf.transpose(hq, [0, 2, 1]) # Create mask (BS, MPL) -&gt; (BS, MPL, 1) -&gt; (BS, MPL, MQL) hc_mask_aug = tf.tile(tf.expand_dims(hc_mask, -1), [1, 1, max_question_length_placeholder]) hq_mask_aug = tf.tile(tf.expand_dims(hq_mask, -2), [1, max_context_length_placeholder, 1]) hq_mask_aug = hc_mask_aug &amp; hq_mask_aug score = softmax_mask_prepro(score, hq_mask_aug) # (BS, MPL, MQL) alignment_weights = tf.nn.softmax(score) # (BS, MPL, MQL) @ (BS, MQL, HS * 2) -&gt; (BS, MPL, HS * 2) context_aware = tf.matmul(alignment_weights, hq) concat_hidden = tf.concat([context_aware, hc], axis=2) concat_hidden = tf.cond(is_train, lambda: tf.nn.dropout(concat_hidden, keep_prob), lambda: concat_hidden) # (HS * 4, HS * 2) Ws = tf.get_variable("Ws", shape=[d_en * 2, d_en]) attention = tf.nn.tanh(tf.reshape(tf.reshape(concat_hidden, [-1, d_en * 2]) @ Ws, [-1, max_context_length_placeholder, d_en])) return (attention) def _similarity_matrix(self, hq, hc, max_question_length, max_context_length, question_mask, context_mask, is_train, keep_prob): def _flatten(tensor, keep): fixed_shape = tensor.get_shape().as_list() start = len(fixed_shape) - keep # Calculate (BS * MCL * MQL) left = reduce(mul, [fixed_shape[i] or tf.shape(tensor)[i] for i in range(start)]) # out_shape is simply HS * 2 out_shape = [left] + [fixed_shape[i] or tf.shape(tensor)[i] for i in range(start, len(fixed_shape))] # (BS * MCL * MQL, HS * 2) flat = tf.reshape(tensor, out_shape) return (flat) def _reconstruct(tensor, ref, keep): ref_shape = ref.get_shape().as_list() tensor_shape = tensor.get_shape().as_list() ref_stop = len(ref_shape) - keep tensor_start = len(tensor_shape) - keep # [BS, MCL, MQL] pre_shape = [ref_shape[i] or tf.shape(ref)[i] for i in range(ref_stop)] # [1] keep_shape = [tensor_shape[i] or tf.shape(tensor)[i] for i in range(tensor_start, len(tensor_shape))] # pre_shape = [tf.shape(ref)[i] for i in range(len(ref.get_shape().as_list()[:-keep]))] # keep_shape = tensor.get_shape().as_list()[-keep:] # [BS, MCL, MQL, 1] target_shape = pre_shape + keep_shape out = tf.reshape(tensor, target_shape) out = tf.squeeze(out, [len(args[0].get_shape().as_list()) - 1]) return (out) # (BS, MCL, MQL, HS * 2) d = hq.get_shape().as_list()[-1] logging.debug("d is: &#123;&#125;".format(d)) hc_aug = tf.tile(tf.reshape(hc, shape=[-1, max_context_length, 1, d]), [1, 1, max_question_length, 1]) # (BS, MCL, MQL, HS * 2) hq_aug = tf.tile(tf.reshape(hq, shape=[-1, 1, max_question_length, d]), [1, max_context_length, 1, 1]) # [(BS, MCL, MQL, HS * 2), (BS, MCL, MQL, HS * 2), (BS, MCL, MQL, HS * 2)] args = [hc_aug, hq_aug, hc_aug * hq_aug] # [(BS * MCL * MQL, HS * 2), (BS * MCL * MQL, HS * 2), (BS * MCL * MQL, HS * 2)] args_flat = [_flatten(arg, 1) for arg in args] args_flat = [tf.cond(is_train, lambda: tf.nn.dropout(arg, keep_prob), lambda: arg) for arg in args_flat] d_concat = d * 3 W = tf.get_variable("W", shape=[d_concat, 1]) b = tf.get_variable("b", shape=[1]) # Calculating a(h, u) = w_s^(t)[h; u; h * u] # (BS * MCL * MQL, HS * 6) @ (HS * 6, 1) + (1) -&gt; (BS * MCL * MQL, 1) res = tf.concat(args_flat, 1) @ W + b # (BS * MCL * MQL, 1) -&gt; (BS, MCL, MQL) similarity_matrix = _reconstruct(res, args[0], 1) logging.debug("similiarity_matrix after reconstruct: &#123;&#125;".format(similarity_matrix.get_shape())) context_mask_aug = tf.tile(tf.expand_dims(context_mask, 2), [1, 1, max_question_length]) question_mask_aug = tf.tile(tf.expand_dims(question_mask, 1), [1, max_context_length, 1]) mask_aug = context_mask_aug &amp; question_mask_aug similarity_matrix = softmax_mask_prepro(similarity_matrix, mask_aug) return (similarity_matrix) BiDAFlSeo et al. (2016)é’ˆå¯¹SQuADæå‡ºäº†ä¸€ä¸ªå¦ä¸€ç§æ›´å¤æ‚çš„æ³¨æ„åŠ›æœºåˆ¶, Bi-Directional Attention Flow (BiDAF)ã€‚BiDAFé¡¾åæ€ä¹‰é‚£ä¸ªå°±æ˜¯é—®é¢˜ä¸Žæ®µè½çš„åŒå‘çš„æ³¨æ„åŠ›æœºåˆ¶, åˆ†åˆ«æ˜¯ Context-to-query (C2Q) attention å’Œ Query-to-context (Q2C) attention. ä¸¤è€…éƒ½æ˜¯åŸºäºŽä¼ ç»Ÿçš„æ®µè½çš„èƒŒæ™¯å‘é‡ $H$ ä¸Žé—®é¢˜çš„èƒŒæ™¯å‘é‡ $U$ é—´ç›¸ä¼¼çŸ©é˜µ(similarity matrix) $S \in \mathbb{R^{TÃ—J}}$è¡ç”Ÿå‡ºæ¥çš„.$$S_{tj} = \alpha(H_{:t}, U_{:j}) \in R \\\alpha(h, u) = w^{\top}_{(S)}[h; u; h \odot u]$$ Where $S_{tj}$ indicates the similarity between t-th context word and j-th query word, $\alpha$ is a trainable scalar function that encodes the similarity between its two input vectors, $H_{:t}$ is t-th column vector of H, and $U_{:j}$ is j-th column vector of U, $w_{(S)} \in R^{6d}$ is a trainable weight vector, $[;]$ is vector concatenation across row. ç›¸ä¼¼çŸ©é˜µSè¢«ç”¨äºŽè®¡ç®—ä¸¤ç§æ–¹å‘çš„æ³¨æ„åŠ›å‘é‡. Context-to-query (C2Q) attention signifies which query words are most relevant to each context word $$\tilde{U_{:t}} = \sum_j \alpha_{tj} U_{:j} \\\alpha_t = softmax(S_{t:})$$å…¶ä¸­ $\alpha_t \in R^J è¡¨ç¤º$t$æ®µè½è¯å¯¹å„ä¸ªé—®é¢˜è¯çš„æ³¨æ„åŠ›æƒé‡ Query-to-context (Q2C) attention signifies which context words have the closest similarity to one of the query words and are hence critical for answering the query. å¯¹æ®µè½çš„æ³¨æ„åŠ›æƒé‡ä¸º:$$b = softmax(max_{col}(S)) \in R^T$$å…¶ä¸­$max_{col}$æ˜¯åœ¨æ¯è¡Œé€‰å‡ºæœ€å¤§å€¼.ç„¶åŽå¯¹æ®µè½èƒŒæ™¯å‘é‡è¿›è¡Œæ³¨æ„åŠ›åŠ æƒ:$$\tilde{h} = \sum_t b_t H_{:t} \in R^{2d}$$è¿™ä¸ª$\tilde{h}$å‘é‡æŒ‡çš„æ˜¯åœ¨queryçœ¼é‡Œæœ€é‡è¦çš„æ®µè½æ¬¡çš„åŠ æƒæ±‚å’Œ. å› ä¸º$\tilde{h}$æ˜¯åœ¨æ¯ä¸€ä¸ªå†…åŽ»æœ€å¤§å€¼, æ‰€ä»¥è¿˜éœ€è¦ä»Žæ–°æŠŠ$\tilde{h}$çš„å€¼åœ¨æ¯ä¸€ä¸ªé“ºå¼€$T$æ¬¡å¾—åˆ°ä¸€ä¸ª$\tilde{H} \in R^{2dxT}$å‘é‡ä»¥æ–¹ä¾¿åŽç»­çš„è®¡ç®—. æœ€åŽ, æ®µè½çš„embeddingså‘é‡å’Œæ³¨æ„åŠ›å‘é‡ç»“åˆä¸º$G$, $G$çš„æ¯ä¸€åˆ—å‘é‡å¯ä»¥ç†è§£ä¸ºæ¯ä¸ªæ®µè½è¯çš„ query-aware representation:$$G_{:t} = \beta(H_{:t}, \tilde{U_{:t}}, \tilde{H_{:t}}) \in R^{d_G}$$ where $G_{:t}$ is the t-th column vector (corresponding to t-th context word), Î² is a trainable vector function that fuses its (three) input vectors, and $d_G$ is the output dimension of the Î² function. Î² å‡½æ•°å¯ä»¥æ˜¯ä»»æ„çš„ç¥žç»ç½‘ç»œ, ä½†æ˜¯æ–‡ç« ä¸­æŒ‡å‡ºä½¿ç”¨ç®€å•çš„å‡½æ•°å¦‚ $\beta(h, \tilde{u}, \tilde{h}) = [h; \tilde{u}; h \odot \tilde{u}; h \odot \tilde{h}] \in R^{8dxT}$ (i.e., dG = 8d) è¡¨çŽ°å·²ç»å¾ˆå¥½äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108class Attention(object): def forwards_complex(self, hc, hq, hc_mask, hq_mask, max_context_length_placeholder, max_question_length_placeholder, is_train, keep_prob): '''combine context hidden state(hc) and question hidden state(hq) with attention measured similarity = hc : hq : hc.T * hq ''' s = self._similarity_matrix(hq, hc, max_question_length_placeholder, max_context_length_placeholder, hq_mask, hc_mask, is_train, keep_prob) # C2Q # (BS, MCL, MQL) weights_c2q = tf.nn.softmax(s) # (BS, MCL, MQL) @ (BS, MQL, HS * 2) -&gt; (BS, MCL, HS * 2) query_aware = weights_c2q @ hq # Q2C # (BS, MCL, MQL) -&gt; (BS, MCL) # We are effectively looking through all the question words j's to some context word i and finding the # maximum of those context words score_q2c = tf.reduce_max(s, axis=-1) # (BS, MCL) weights_q2c = tf.expand_dims(tf.nn.softmax(score_q2c), -1) # (BS, HS) context_aware = tf.reduce_sum(tf.multiply(weights_q2c, hc), axis=1) # (BS, MCL, HS * 2) context_aware = tf.tile(tf.expand_dims(context_aware, 1), [1, max_context_length_placeholder, 1]) # [(BS, MCL, HS * 2), (BS, MCL, HS * 2), (BS, MCL, HS * 2), (BS, MCL, HS * 2)] biattention = tf.nn.tanh(tf.concat([hc, query_aware, hc * query_aware, hc * context_aware], 2)) return (biattention) def _similarity_matrix(self, hq, hc, max_question_length, max_context_length, question_mask, context_mask, is_train, keep_prob): def _flatten(tensor, keep): fixed_shape = tensor.get_shape().as_list() start = len(fixed_shape) - keep # Calculate (BS * MCL * MQL) left = reduce(mul, [fixed_shape[i] or tf.shape(tensor)[i] for i in range(start)]) # out_shape is simply HS * 2 out_shape = [left] + [fixed_shape[i] or tf.shape(tensor)[i] for i in range(start, len(fixed_shape))] # (BS * MCL * MQL, HS * 2) flat = tf.reshape(tensor, out_shape) return (flat) def _reconstruct(tensor, ref, keep): ref_shape = ref.get_shape().as_list() tensor_shape = tensor.get_shape().as_list() ref_stop = len(ref_shape) - keep tensor_start = len(tensor_shape) - keep # [BS, MCL, MQL] pre_shape = [ref_shape[i] or tf.shape(ref)[i] for i in range(ref_stop)] # [1] keep_shape = [tensor_shape[i] or tf.shape(tensor)[i] for i in range(tensor_start, len(tensor_shape))] # pre_shape = [tf.shape(ref)[i] for i in range(len(ref.get_shape().as_list()[:-keep]))] # keep_shape = tensor.get_shape().as_list()[-keep:] # [BS, MCL, MQL, 1] target_shape = pre_shape + keep_shape out = tf.reshape(tensor, target_shape) out = tf.squeeze(out, [len(args[0].get_shape().as_list()) - 1]) return (out) # (BS, MCL, MQL, HS * 2) d = hq.get_shape().as_list()[-1] logging.debug("d is: &#123;&#125;".format(d)) hc_aug = tf.tile(tf.reshape(hc, shape=[-1, max_context_length, 1, d]), [1, 1, max_question_length, 1]) # (BS, MCL, MQL, HS * 2) hq_aug = tf.tile(tf.reshape(hq, shape=[-1, 1, max_question_length, d]), [1, max_context_length, 1, 1]) # [(BS, MCL, MQL, HS * 2), (BS, MCL, MQL, HS * 2), (BS, MCL, MQL, HS * 2)] args = [hc_aug, hq_aug, hc_aug * hq_aug] # [(BS * MCL * MQL, HS * 2), (BS * MCL * MQL, HS * 2), (BS * MCL * MQL, HS * 2)] args_flat = [_flatten(arg, 1) for arg in args] args_flat = [tf.cond(is_train, lambda: tf.nn.dropout(arg, keep_prob), lambda: arg) for arg in args_flat] d_concat = d * 3 W = tf.get_variable("W", shape=[d_concat, 1]) b = tf.get_variable("b", shape=[1]) # Calculating a(h, u) = w_s^(t)[h; u; h * u] # (BS * MCL * MQL, HS * 6) @ (HS * 6, 1) + (1) -&gt; (BS * MCL * MQL, 1) res = tf.concat(args_flat, 1) @ W + b # (BS * MCL * MQL, 1) -&gt; (BS, MCL, MQL) similarity_matrix = _reconstruct(res, args[0], 1) logging.debug("similiarity_matrix after reconstruct: &#123;&#125;".format(similarity_matrix.get_shape())) context_mask_aug = tf.tile(tf.expand_dims(context_mask, 2), [1, 1, max_question_length]) question_mask_aug = tf.tile(tf.expand_dims(question_mask, 1), [1, max_context_length, 1]) mask_aug = context_mask_aug &amp; question_mask_aug similarity_matrix = softmax_mask_prepro(similarity_matrix, mask_aug) return (similarity_matrix) æ•°æ®å¤„ç†å†…å®¹æ®µè½æ‘˜è‡ªç»´åŸºç™¾ç§‘æ–‡ç« ä¸­çš„536ç¯‡æ–‡ç« ï¼ŒåŒ…å«107,785å¯¹é—®é¢˜å’Œç­”æ¡ˆï¼Œè¿™ä½¿å¾—SQuADæ˜¾ç€å¤§äºŽä»¥å‰ä»»ä½•äººç±»æ ‡æ³¨çš„æ•°æ®é›†ã€‚åœ¨è¯¥æ•°æ®é›†ä¸­ï¼Œ80ï¼…çš„æ•°æ®ç”¨äºŽè®­ç»ƒï¼Œ10ï¼…ç”¨äºŽéªŒè¯, å‰©ä½™10ï¼…ç”¨äºŽæµ‹è¯•ã€‚åœ¨è®­ç»ƒé›†ä¸­ï¼Œè¿›ä¸€æ­¥åˆ’åˆ†å‡º5ï¼…ç”¨äºŽè®­ç»ƒæ—¶çš„éªŒè¯ã€‚ ä¸Žå…¶ä»–é—®ç­”æ•°æ®é›†ç›¸æ¯”ï¼ŒSQUADå…·æœ‰æ¯”è¾ƒç‹¬ç‰¹çš„ç‰¹å¾ï¼Œæ‰€æœ‰ç­”æ¡ˆéƒ½æ˜¯å‡ºè‡ªç›¸åº”çš„ä¸Šä¸‹æ–‡ä¸­ã€‚å¯¹äºŽæ¯ä¸€ä¸ªæ®µè½, ä¼—åŒ…äººå‘˜ç”Ÿæˆå‡ ä¸ªé—®é¢˜ï¼Œå¹¶é€‰æ‹©åŽŸæ®µè½ä¸­çš„ä¸€å°æ®µä½œä¸ºç­”æ¡ˆ. ç­”æ¡ˆç”±ä¸¤ä¸ªindexç»„æˆ, å¯¹åº”ç­”æ¡ˆåœ¨æ®µè½ä¸­çš„èµ·å§‹ä½ç½®ã€‚å› æ­¤ï¼ŒSQuADæ•°æ®é›†çš„ç­”æ¡ˆå¯èƒ½æ¯”å…¶ä»–ä»¥å•ä¸ªå•è¯å’Œå®žä½“ä¸ºç­”æ¡ˆä¸ºä¸»çš„æ•°æ®é›†é•¿å¾—å¤šã€‚å®žä¾‹: Question:Why was Tesla returned to Gospic? Context paragraph:On 24 March 1879, Tesla was returned to Gospicunder police guard for not having a residence permitâ€¦ Answer:{12, 16} Embeddingè¯å‘é‡ä½¿ç”¨é¢„è®­ç»ƒå¥½çš„ Glove embedding. Glove is a log-bilinear regression model that combines the advantages of global matrix factorization and local context window methods. 12345678def load_glove_embeddings(embed_path): logger.info("Loading glove embedding...") glove = np.load(embed_path)['glove'] logger.info("Dimension: &#123;&#125;".format(glove.shape[1])) logger.info("Vocabulary: &#123;&#125;" .format(glove.shape[0])) return gloveembeddings = load_glove_embeddings(embed_path) 1234567891011121314151617181920212223242526class Model(metaclass=ABCMeta): ... @abstractmethod def setup_embeddings(self): pass def setup_embeddings(self): """ Loads distributed word representations based on placeholder tokens :return: embeddings representaion of question and context. """ with tf.variable_scope("embeddings"): if self.config.RE_TRAIN_EMBED: embeddings = tf.get_variable("embeddings", initializer=self.embeddings) else: embeddings = tf.cast(self.embeddings, dtype=tf.float32) question_embeddings = tf.nn.embedding_lookup(embeddings, self.question_placeholder) question_embeddings = tf.reshape(question_embeddings, shape = [-1, self.max_question_length_placeholder, self.config.embedding_size]) context_embeddings = tf.nn.embedding_lookup(embeddings, self.context_placeholder) context_embeddings = tf.reshape(context_embeddings, shape = [-1, self.max_context_length_placeholder, self.config.embedding_size]) return question_embeddings, context_embeddings æ¨¡åž‹æ•´ä½“çš„æ¨¡åž‹ç”±Embeddingå±‚ï¼ŒEncodrå±‚ï¼ŒAttentionå±‚ï¼ŒDecoderå±‚ç»„æˆ Encoderç¼–ç å™¨å°±æ˜¯ä¸€ä¸ªåŒå‘GRUå±‚:123456789101112131415161718192021class Encoder(object): """ In a generalized encode function, you pass in your inputs, masks, and an initial hidden state input into this function. :param inputs: Symbolic representations of your input :param masks: this is to make sure tf.nn.dynamic_rnn doesn't iterate through masked steps :param encoder_state_input: (Optional) pass this as initial hidden state to tf.nn.dynamic_rnn to build conditional representations :return: outputs: The RNN output Tensor an encoded representation of your input. It can be context-level representation, word-level representation, or both. state: The final state. """ def __init__(self, state_size): self.state_size = state_size def encode(self, inputs, masks, initial_state_fw=None, initial_state_bw=None, reuse=False, keep_prob = 1.0): return BiGRU_layer(inputs, masks, self.state_size, initial_state_fw, initial_state_bw, reuse, keep_prob) 123456789101112131415161718192021222324def BiGRU_layer(inputs, masks, state_size, initial_state_fw=None, initial_state_bw=None, reuse = False, keep_prob=1.0): ''' Wrapped BiGRU_layer for reuse''' # 'outputs' is a tensor of shape [batch_size, max_time, cell_state_size] cell_fw = tf.contrib.rnn.GRUCell(state_size, reuse = reuse) cell_fw = tf.contrib.rnn.DropoutWrapper(cell_fw, input_keep_prob = keep_prob) cell_bw = tf.contrib.rnn.GRUCell(state_size, reuse = reuse) cell_bw = tf.contrib.rnn.DropoutWrapper(cell_bw, input_keep_prob = keep_prob) sequence_length = tf.reduce_sum(tf.cast(masks, 'int32'), axis=1) sequence_length = tf.reshape(sequence_length, [-1,]) # Outputs Tensor shaped: [batch_size, max_time, cell.output_size] (outputs_fw, outputs_bw), (final_state_fw, final_state_bw) = tf.nn.bidirectional_dynamic_rnn( cell_fw = cell_fw,\ cell_bw = cell_bw,\ inputs = inputs,\ sequence_length = sequence_length, initial_state_fw = initial_state_fw,\ initial_state_bw = initial_state_bw, dtype = tf.float32) outputs = tf.concat([outputs_fw, outputs_bw], 2) return outputs, final_state_fw, final_state_bw Decoderè§£ç å™¨ä¹ŸåŒ…å«ä¸€ä¸ªåŒå‘GRUå±‚ï¼Œè¾“å‡ºçš„çŠ¶æ€åˆ†åˆ«ç”±ä¸¤ä¸ªsoftmaxåˆ†ç±»å™¨è®¡ç®—å‡ºé¢„æµ‹çš„ç­”æ¡ˆçš„ start å’Œ end index ä½ç½®:123456789101112131415161718192021222324252627282930313233343536373839404142class Decoder(object): """ takes in a knowledge representation and output a probability estimation over all paragraph tokens on which token should be the start of the answer span, and which should be the end of the answer span. :param knowledge_rep: it is a representation of the paragraph and question, decided by how you choose to implement the encoder :return: (start, end) """ def __init__(self, output_size, state_size=None): self.output_size = output_size self.state_size = state_size def decode(self, knowledge_rep, mask, max_input_length, keep_prob = 1.0): '''Decode with BiGRU''' with tf.variable_scope('Modeling'): outputs, _, _ = BiGRU_layer(knowledge_rep, mask, self.state_size, keep_prob=keep_prob) with tf.variable_scope("start"): start = self.get_logit(outputs, max_input_length) start = softmax_mask_prepro(start, mask) with tf.variable_scope("end"): end = self.get_logit(outputs, max_input_length) end = softmax_mask_prepro(end, mask) return (start, end) def get_logit(self, inputs, max_inputs_length): ''' Get the logit (-inf, inf). ''' d = inputs.get_shape().as_list()[-1] assert inputs.get_shape().ndims == 3, ("Got &#123;&#125;".format(inputs.get_shape().ndims)) inputs = tf.reshape(inputs, shape = [-1, d]) W = tf.get_variable('W', initializer=tf.contrib.layers.xavier_initializer(), shape=(d, 1), dtype=tf.float32) pred = tf.matmul(inputs, W) pred = tf.reshape(pred, shape = [-1, max_inputs_length]) tf.summary.histogram('logit', pred) return pred æ­å»ºæ•´ä¸ªç³»ç»Ÿåœ¨æ•´ä¸ªQASystemç±»ä¸­åˆå§‹åŒ–è¿™äº›åŠŸèƒ½å±‚:12345678910111213141516171819202122232425262728293031323334353637383940414243444546class QASystem(Model): def __init__(self, embeddings, config): """ Initializes System """ self.embeddings = embeddings self.config = config self.encoder = Encoder(config.encoder_state_size) self.decoder = Decoder(output_size=config.output_size, state_size = config.decoder_state_size) self.attention = Attention() # ==== set up placeholder tokens ======== self.context_placeholder = tf.placeholder(tf.int32, shape=(None, None)) self.context_mask_placeholder = tf.placeholder(tf.bool, shape=(None, None)) self.question_placeholder = tf.placeholder(tf.int32, shape=(None, None)) self.question_mask_placeholder = tf.placeholder(tf.bool, shape=(None, None)) self.answer_start_placeholder = tf.placeholder(tf.int32) self.answer_end_placeholder = tf.placeholder(tf.int32) self.max_context_length_placeholder = tf.placeholder(tf.int32) self.max_question_length_placeholder = tf.placeholder(tf.int32) self.dropout_placeholder = tf.placeholder(tf.float32) # ==== assemble pieces ==== with tf.variable_scope(self.config.which_model, initializer=tf.uniform_unit_scaling_initializer(1.0)): self.question_embeddings, self.context_embeddings = self.setup_embeddings() self.preds = self.setup_system() self.loss = self.setup_loss(self.preds) self.f1_train = tf.Variable(0., tf.float64) self.EM_train = tf.Variable(0., tf.float64) self.f1_val = tf.Variable(0., tf.float64) self.EM_val = tf.Variable(0., tf.float64) tf.summary.scalar('f1_train', self.f1_train) tf.summary.scalar('EM_train', self.EM_train) tf.summary.scalar('f1_val', self.f1_val) tf.summary.scalar('EM_val', self.EM_val) # ==== set up training/updating procedure ==== ''' With gradient clipping''' opt_op = get_optimizer(self.config.optimizer, self.loss, config.max_gradient_norm, config.learning_rate) if config.exdma_weight_decay is not None: self.train_op = self.build_exdma(opt_op) else: self.train_op = opt_op self.merged = tf.summary.merge_all() æŠŠå„ä¸ªåŠŸèƒ½å±‚æ­å»ºæˆä¸€ä¸ªå®Œæ•´çš„æ¨¡åž‹:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def setup_system(self): """ Connect all parts of your system here: After your modularized implementation of encoder and decoder you should call various functions inside encoder, decoder here to assemble your reading comprehension system! context: [None, max_context_length, d] question: [None, max_question_length, d] :return: """ d = self.context_embeddings.get_shape().as_list()[-1] '''Step 1: encode context and question, respectively, with independent weights e.g. hq = encode_question(question) # get U (d*J) as representation of q e.g. hc = encode_context(context, q_state) # get H (d*T) as representation of x ''' with tf.variable_scope('question'): hq, question_state_fw, question_state_bw = \ self.encoder.BiGRU_encode(self.question_embeddings, self.question_mask_placeholder, keep_prob = self.dropout_placeholder) if self.config.QA_ENCODER_SHARE: hc, context_state_fw, context_state_bw =\ self.encoder.BiGRU_encode(self.context_embeddings, self.context_mask_placeholder, initial_state_fw = question_state_fw, initial_state_bw = question_state_bw, reuse = True, keep_prob = self.dropout_placeholder) if not self.config.QA_ENCODER_SHARE: with tf.variable_scope('context'): hc, context_state_fw, context_state_bw =\ self.encoder.BiGRU_encode(self.context_embeddings, self.context_mask_placeholder, initial_state_fw = question_state_fw, initial_state_bw = question_state_bw, keep_prob=self.dropout_placeholder) d_Bi = self.config.encoder_state_size*2 assert hc.get_shape().as_list() == [None, None, d_Bi], ( "Expected &#123;&#125;, got &#123;&#125;".format([None, self.max_context_length_placeholder, self.config.encoder_state_size], hc.get_shape().as_list())) assert hq.get_shape().as_list() == [None, None, d_Bi], ( "Expected &#123;&#125;, got &#123;&#125;".format([None, self.max_question_length_placeholder, self.config.encoder_state_size], hq.get_shape().as_list())) '''Step 2: combine context hidden state(hc) and question hidden state(hq) with attention measured similarity = hc.T * hq Context-to-query (C2Q) attention signifies which query words are most relevant to each P context word. attention_c2q = softmax(similarity) hq_hat = sum(attention_c2q*hq) Query-to-context (Q2C) attention signifies which context words have the closest similarity to one of the query words and are hence critical for answering the query. attention_q2c = softmax(similarity.T) hc_hat = sum(attention_q2c*hc) combine with Î² activation: Î² function can be an arbitrary trainable neural network g = Î²(hc, hq, hc_hat, hq_hat) ''' # concat[h, u_a, h*u_a, h*h_a] attention = self.attention.forwards_bilinear(hc, hq, self.context_mask_placeholder, self.question_mask_placeholder, max_context_length_placeholder = self.max_context_length_placeholder, max_question_length_placeholder = self.max_question_length_placeholder, is_train=(self.dropout_placeholder &lt; 1.0), keep_prob=self.dropout_placeholder) d_com = d_Bi*4 '''Step 3: decoding ''' with tf.variable_scope("decoding"): start, end = self.decoder.BiGRU_decode(attention, self.context_mask_placeholder, self.max_context_length_placeholder, self.dropout_placeholder) return start, end]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>NLP</tag>
        <tag>SQuAD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms - Princeton]]></title>
    <url>%2Falgorithms%2F</url>
    <content type="text"><![CDATA[Algorithms, Part I, https://online.princeton.edu/course/algorithms-part-i Algorithms, Part II, https://online.princeton.edu/course/algorithms-part-ii Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne https://algs4.cs.princeton.edu/ Unionâˆ’FindConsidering the dynamic connectivity problem, modeling of multiple objects connected in a space/network. Applications involve manipulating objects of all types.ãƒ»Pixels in a digital photo.ãƒ»Computers in a network.ãƒ»Friends in a social network.ãƒ»Transistors in a computer chip. Given a set of N objects. union(a, b): connect two objects. connected(p, q): is two objects connected? find(p): Find component identifier for p (0 to N â€“ 1) Modeling the objects: array. Modeling the connections:Maximal set of objects that are mutually connected - Connected components. Data structure: Quick findInteger array id[] of length N, two objects are connected iff they have the same id.Defect: union too expensive, $\in \Theta(N^2)$. Quick-unionInteger array id[] of length N, id[i] is parent of i, root of i is id[id[id[...id[i]...]]] (until it doesnâ€™t change).The find is recursive. 123456/** chase parent pointers until reach root * (depth of i array accesses) */private int find(int i) &#123; while (i != id[i]) i = id[i]; return i;&#125; Defect: Trees can get tall, find too expensive, $\in \Theta(N)$. Weighted quick-unionModify quick-union to avoid tall trees. Balance by linking root of smaller tree to root of larger tree. Maintain extra array sz[i] to keep track of size of each tree (number of objects).find: time proportional to depth of p and q, the depth of any node x is at most $\log N$, Weighted quick-union with path compressionMaking all the nodes that examined directly link to its root. Keeps tree almost completely flat. 123456789/** Make every other node in path point to its grandparent* (thereby halving path length). */private int root(int i) &#123; while (i != id[i]) &#123; id[i] = id[id[i]]; i = id[i]; &#125; return i;&#125; Amortized analysis: [Hopcroft-Ulman, Tarjan] Starting from an empty data structure, any sequence of M union-find ops on N objects makes $â‰¤ c ( N + M \lg \ast N )$ array accesses. $\lg \ast N$ is Iterated logarithm, for $N = 2^{65536}$, $\lg \ast N = 5$. In theory, WQUPC is not quite linear. In practice, WQUPC is linear. Amazing fact. [Fredman-Saks] No linear-time algorithm exists. Element SortTwo elementary sorting methods: selection sort and insertion sort. Shellsort is a variation of one of them. The objective is to rearrange the items such that their keys are in ascending order. In Java, the abstract notion of a key is captured by the Comparable interface. The Comparable interface provides an elegant API for callback when Java need to compare keys. Some background knowlege: Cost model, please refer to Asymptotic Analysis Sorting cost model. How many compares and exchanges, or array accesses, for a sorting. Memory. There are sorting algorithms that sort in place (no extra memory except perhaps for a small function-call stack or a constant number of instance variables), and those that need enough extra memory to hold another copy of the array to be sorted. Selection SortRepeatedly selecting the smallest remaining item: Find the smallest item in the array, and exchange it with the first entry. Find the next smallest item and exchange it with the second entry. Continue until the entire array is sorted. Selection sort uses ~$n^2/2$ compares and n exchanges to sort an array of length n. Insertion SortWorks like people sort Pokers: consider the cards one at a time, inserting each into its proper place among those already considered (keeping them sorted).In a computer implementation, we need to make space for the current item by moving larger items one position to the right, before inserting the current item into the vacated position. For randomly ordered arrays of length N with distinct keys, insertion sort uses ~$N^2/4$ compares and ~$N^2/4$ exchanges on the average. The worst case is ~ $N^2/2$ compares and ~ $N^2/2$ exchanges and the best case is $N-1$ compares and 0 exchanges. Insertion sort works well for certain types of nonrandom arrays that often arise in practice, even if they are huge. An inversion is a pair of keys that are out of order in the array. For instance, E X A M P L E has 11 inversions: E-A, X-A, X-M, X-P, X-L, X-E, M-L, M-E, P-L, P-E, and L-E. If the number of inversions in an array is less than a constant multiple of the array size, we say that the array is partially sorted. ShellsortShellsort gains speed by allowing exchanges of entries that are far apart, to produce partially sorted arrays that can be efficiently sorted, eventually by insertion sort. The idea is to rearrange the array to give it the property that taking every $h_{th}$ entry (starting anywhere) yields a sorted sequence. Such an array is said to be h-sorted.By h-sorting for some large values of h, we can move entries in the array long distances and thus make it easier to h-sort for smaller values of h. Using such a procedure for any increment sequence of values of h that ends in 1 will produce a sorted array: The number of compares used by shellsort with the increments 1, 4, 13, 40, 121, 364, â€¦ is O(N^{3/2}). Merge SortMerging means combining two ordered arrays to make one larger ordered array. Merge sort is an utility of divide and conquer paradigm. Mergesort guarantees to sort an array of N items in time proportional to $N \log N$, no matter what the input. But it uses extra space proportional to N. Specifically, mergesort uses between $1/2 N \lg N$ and $N \lg N$ compares and at most $6 N \lg N$ array accesses to sort any array of length N. Abstract in-place merge: The method merge(a, lo, mid, hi) in Merge.java puts the results of merging the subarrays a[lo..mid] with a[mid+1..hi] into a single ordered array, leaving the result in a[lo..hi]. While it would be desirable to implement this method without using a significant amount of extra space, such solutions are remarkably complicated. 123456789101112131415161718192021222324252627282930313233343536373839public class Merge&#123; private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; assert isSorted(a, lo, mid); // precondition: a[lo..mid] sorted assert isSorted(a, mid+1, hi); // precondition: a[mid+1..hi] sorted for (int k = lo; k &lt;= hi; k++) // copy aux[k] = a[k]; int i = lo, j = mid+1; for (int k = lo; k &lt;= hi; k++) // merge &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125; assert isSorted(a, lo, hi); // postcondition: a[lo..hi] sorted &#125; private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid+1, hi); merge(a, aux, lo, mid, hi); &#125; public static void sort(Comparable[] a) &#123; aux = new Comparable[a.length]; sort(a, aux, 0, a.length - 1); &#125;&#125;&#125; Proposition. Mergesort uses at most $N lg N$ compares and $6 N lg N$ array accesses to sort any array of size N. Mergesort uses extra space proportional to N A sorting algorithm is in-place if it uses $â‰¤ c \log N$ extra memory. Ex. Insertion sort, selection sort, shellsort. Mergesort: Practical improvementsUse insertion sort for small subarrays (7).123456789101112private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi)&#123; if (hi &lt;= lo + CUTOFF - 1) &#123; Insertion.sort(a, lo, hi); return; &#125; int mid = lo + (hi - lo) / 2; sort (a, aux, lo, mid); sort (a, aux, mid+1, hi); merge(a, aux, lo, mid, hi);&#125; Stop if already sorted: Is biggest item in first half â‰¤ smallest item in second half?123456789private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi)&#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort (a, aux, lo, mid); sort (a, aux, mid+1, hi); if (!less(a[mid+1], a[mid])) return; merge(a, aux, lo, mid, hi);&#125; Eliminate the copy to the auxiliary array. Save time (but not space) by switching the role of the input and auxiliary array in each recursive call.123456789101112131415161718192021private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi)&#123; int i = lo, j = mid+1; for (int k = lo; k &lt;= hi; k++) // merge from a[] to aux[] &#123; if (i &gt; mid) aux[k] = a[j++]; else if (j &gt; hi) aux[k] = a[i++]; else if (less(a[j], a[i])) aux[k] = a[j++]; else aux[k] = a[i++]; &#125;&#125;private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi)&#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; // switch roles of aux[] and a[] sort (aux, a, lo, mid); sort (aux, a, mid+1, hi); merge(a, aux, lo, mid, hi);&#125; Top-down mergesortA recursive mergesort implementation based on this abstract in-place merge. Bottom-up mergesortDo all the merges of tiny arrays on one pass, then do a second pass to merge those arrays in pairs, and so forth, continuing until we do a merge that encompasses the whole array. We start by doing a pass of 1-by-1 merges then a pass of 2-by-2 merges (merge subarrays of size 2 to make subarrays of size 4), then 4-by-4 merges, and so forth. Proposition: No compare-based sorting algorithm can guarantee to sort N items with fewer than $lg(N!)$ ~ $N \lg N$ compares.Proposition. Mergesort is an asymptotically optimal compare-based sorting algorithm. That is, both the number of compares used by mergesort in the worst case and the minimum number of compares that any compare-based sorting algorithm can guarantee are ~N lg N. 1234567891011121314public class MergeBU&#123; private static void merge(...) &#123; /* as before */ &#125; public static void sort(Comparable[] a) &#123; int N = a.length; Comparable[] aux = new Comparable[N]; for (int sz = 1; sz &lt; N; sz = sz+sz) for (int lo = 0; lo &lt; N-sz; lo += sz+sz) merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1)); &#125;&#125; About 10% slower than recursive, top-down mergesort on typical systems Mergesort ApplicationsJava sort for objects. Perl, C++ stable sort, Python stable sort, Firefox JavaScript, â€¦ Counting inversions: An inversion in an array a[] is a pair of entries a[i] and a[j] such that i &lt; j but a[i] &gt; a[j]. Given an array, design a linearithmic algorithm to count the number of inversion. åœ¨æ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°å­—ï¼Œå¦‚æžœå‰é¢ä¸€ä¸ªæ•°å­—å¤§äºŽåŽé¢çš„æ•°å­—ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªé€†åºå¯¹ã€‚è¾“å…¥ä¸€ä¸ªæ•°ç»„,æ±‚å‡ºè¿™ä¸ªæ•°ç»„ä¸­çš„é€†åºå¯¹çš„æ€»æ•°Pã€‚å¹¶å°†På¯¹1000000007å–æ¨¡çš„ç»“æžœè¾“å‡ºã€‚ å³è¾“å‡ºP%10000000071234567891011121314151617181920212223242526272829303132333435public int InversePairs(int [] array) &#123; int len = array.length; int[] aux = new int[len]; for (int k = 0; k &lt; len; k++) // copy aux[k] = array[k]; return InversePairsSort(array, aux, 0, len - 1);&#125;private int InversePairsSort(int[] a, int[] b, int s, int e)&#123; if (e &lt;= s) return 0; int mid = (e + s) / 2; int n1 = InversePairsSort(b, a, s, mid) % 1000000007; int n2 = InversePairsSort(b, a, mid + 1, e) % 1000000007; return (n1 + n2 + InversePairsMerge(a, b, s, mid, e)) % 1000000007;&#125;private int InversePairsMerge(int[] a, int[] b, int s, int mid, int e)&#123; int i = mid, j = e, n = 0; for (int k = e; k &gt;= s; k--) &#123;// merge from a to b if (i &lt; s) b[k] = a[j--]; else if (j &lt;= mid) b[k] = a[i--]; else if (a[i] &gt; a[j]) &#123; n += j - mid; if(n &gt;= 1000000007)//æ•°å€¼è¿‡å¤§æ±‚ä½™ n %= 1000000007; b[k] = a[i--]; &#125; else b[k] = a[j--]; &#125; return n;&#125; count while mergesorting. Shuffling a linked list: Given a singly-linked list containing n items, rearrange the items uniformly at random. Your algorithm should consume a logarithmic (or constant) amount of extra memory and run in time proportional to $n \log n$ in the worst case: Design a linear-time subroutine that can take two uniformly shuffled linked lists of sizes $n_1$ and $n_2$ and combined them into a uniformly shuffled linked lists of size $n_1 + n_2$. Quick SortBasic plan: Shuffle the array: Random shuffle. Probabilistic guarantee against worst case. Partition so that, for some j entry a[j] is in place no larger entry to the left of j no smaller entry to the right of j Sort each piece recursively Patition: Repeat until i and j pointers cross. Scan i from left to right so long as (a[i] &lt; a[lo]) Scan j from right to left so long as (a[j] &gt; a[lo]) Exchange a[i] with a[j] When pointers cross. Exchange a[lo] with a[j] 123456789101112131415161718192021222324252627282930313233public class Quick&#123; // return index of item now known to be in place private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo, j = hi+1; while (true) &#123; while (less(a[++i], a[lo])) // find item on left to swap if (i == hi) break; while (less(a[lo], a[--j])) // find item on right to swap if (j == lo) break; if (i &gt;= j) break; // check if pointers cross exch(a, i, j); &#125; exch(a, lo, j); // swap with partitioning item return j; &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); &#125; public static void sort(Comparable[] a) &#123; StdRandom.shuffle(a); sort(a, 0, a.length - 1); &#125;&#125; Best case. Number of compares is ~ $N \lg N$Worst case. Number of compares is ~ $Â½N^2$Average case. Number of compares is ~ $1.39 N \lg N$, 39% more compares than mergesort. But faster than mergesort in practice because of less data movement. Quicksort: practical improvementsInsertion sort small subarrays (10 items), could delay insertion sort until one pass at end.123456789101112private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo + CUTOFF - 1) &#123; Insertion.sort(a, lo, hi); return; &#125; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi);&#125; Median of sample:Best choice of pivot item = median. Estimate true median by taking median of sample. Median-of-3 (random) items1234567891011private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; int m = medianOf3(a, lo, lo + (hi - lo)/2, hi); swap(a, lo, m); int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi);&#125; Quicksort with duplicate keysãƒ»Algorithm goes quadratic unless partitioning stops on equal keys!ãƒ»1990s C user found this defect in qsort()Mistake. Put all items equal to the partitioning item on one side.Consequence. ~ $Â½N^2$ compares when all keys equal.Recommended. Stop scans on items equal to the partitioning item.Consequence. ~ $N \lg N$ compares when all keys equal. 3-way partitioning: Dutch national flag problem.Partition array into 3 parts so that:ãƒ»Entries between lt and gt equal to partition item v.ãƒ»No larger entries to left of lt.ãƒ»No smaller entries to right of gt. Let v be partitioning item a[lo] Scan i from left to right. (a[i] &lt; v): exchange a[lt] with a[i]; increment both lt and i (a[i] &gt; v): exchange a[gt] with a[i]; decrement gt (a[i] == v): increment i 12345678910111213141516private static void sort(Comparable[] a, int lo, int hi)&#123; if (hi &lt;= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo; while (i &lt;= gt) &#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; &#125; sort(a, lo, lt - 1); sort(a, gt + 1, hi);&#125; Quicksort ApplicationsJava sort for primitive types. C qsort, Unix, Visual C++, Python, Matlab, Chrome JavaScript, â€¦ Selection: Order statistics, Find the â€œtop k.â€Given an array of N items, find a $k^{th}$ smallest item. Ex. Min(k = 0), max(k = N - 1), median(k = N/2). Quick-select Partition array so that: Entry a[j] is in place No larger entry to the left of j No smaller entry to the right of j Repeat in one subarray, depending on j; finished when j equals k. 12345678910111213public static Comparable select(Comparable[] a, int k)&#123; StdRandom.shuffle(a); int lo = 0, hi = a.length - 1; while (hi &gt; lo) &#123; int j = partition(a, lo, hi); if (j &lt; k) lo = j + 1; else if (j &gt; k) hi = j - 1; else return a[k]; &#125; return a[k];&#125; Quick-select takes linear time on average. Priority Queuesä¼˜å…ˆé˜Ÿåˆ—å¯ç”¨äºŽå¿«é€Ÿåœ°ï¼ˆO(1)ï¼‰è¿”å›žæœ€å¤§æˆ–è€…æœ€å°çš„å€¼ã€‚12345678910public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;&#123; MaxPQ() create an empty priority queue MaxPQ(Key[] a) create a priority queue with given keys void insert(Key v) insert a key into the priority queue Key delMax() return and remove the largest key boolean isEmpty() is the priority queue empty? Key max() return the largest key int size() number of entries in the priority queue&#125; åº”ç”¨:ãƒ»Event-driven simulation. [customers in a line, colliding particles]ãƒ»Numerical computation. [reducing roundoff error]ãƒ»Data compression. [Huffman codes]ãƒ»Graph searching. [Dijkstraâ€™s algorithm, Primâ€™s algorithm]ãƒ»Number theory. [sum of powers]ãƒ»Artificial intelligence. [A* search]ãƒ»Statistics. [maintain largest M values in a sequence]ãƒ»Operating systems. [load balancing, interrupt handling]ãƒ»Discrete optimization. [bin packing, scheduling]ãƒ»Spam filtering. [Bayesian spam filter] æ¯”å¦‚å¯¹äºŽæ•°æ®æµ, éœ€è¦ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¿å­˜æœ€å¤§çš„Mä¸ªå€¼, å› ä¸ºå†…å­˜ä¸è¶³ä»¥å‚¨å­˜æ•°æ®æµå…¨éƒ¨æ•°æ®. Binary HeapHeap-ordered binary tree: çˆ¶èŠ‚ç‚¹æ¯”å…¶æ‰€æœ‰å­èŠ‚ç‚¹éƒ½å¤§ï¼ˆæˆ–éƒ½å°ï¼‰ã€‚æ ¹èŠ‚ç‚¹ä¸ºæœ€å¤§å€¼çš„binary heapç§°ä¹‹ä¸ºæœ€å¤§å †, æ ¹èŠ‚ç‚¹ä¸ºæœ€å°å€¼çš„ç§°ä¹‹ä¸ºæœ€å°å †. ä»¥æœ€å¤§å †ä¸ºä¾‹, ä½¿ç”¨æ•°ç»„æ¥è¡¨è¾¾ï¼š ç´¢å¼•ä»Ž1å¼€å§‹, æŒ‰ç…§å±‚æ¬¡éåŽ†é¡ºåºå­˜å‚¨èŠ‚ç‚¹. æœ€å¤§å€¼å°±æ˜¯æ ¹èŠ‚ç‚¹a[1]\ å¯ä»¥ä½¿ç”¨æ•°ç»„ç´¢å¼•éåŽ†æ ‘ èŠ‚ç‚¹a[k]çš„çˆ¶èŠ‚ç‚¹æ˜¯a[k/2] èŠ‚ç‚¹a[k]çš„å­èŠ‚ç‚¹ä¸ºa[2k], a[2k+1] å½“å­èŠ‚ç‚¹çš„å€¼æ¯”çˆ¶èŠ‚ç‚¹å¤§æ—¶, éœ€è¦ä¸æ–­è°ƒæ¢äºŒè€…çš„å€¼, ç›´åˆ°ä¸å†æœ‰å­èŠ‚ç‚¹æ¯”çˆ¶èŠ‚ç‚¹å¤§çš„æƒ…å†µå­˜åœ¨:12345678private void swim(int k)&#123; while (k &gt; 1 &amp;&amp; less(k/2, k)) &#123; exch(k, k/2); k = k/2; &#125;&#125; åä¹‹å½“çˆ¶èŠ‚ç‚¹æ¯”å­èŠ‚ç‚¹å°æ—¶:ä¸æ–­æŠŠçˆ¶èŠ‚ç‚¹å’Œè¾ƒå¤§çš„å­èŠ‚ç‚¹è°ƒæ¢, ç›´åˆ°æ¢å¤ heap order:1234567891011private void sink(int k)&#123; while (2*k &lt;= N) &#123; int j = 2*k; if (j &lt; N &amp;&amp; less(j, j+1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125;&#125; æ’å…¥æ“ä½œ, éœ€è¦å…ˆæŠŠæ–°èŠ‚ç‚¹æ”¾åœ¨æœ«ç«¯, ç„¶åŽswim. è‡³å¤š1 + lgNæ¯”è¾ƒ:12345public void insert(Key x)&#123; pq[++N] = x; swim(N);&#125; åˆ é™¤æ“ä½œ, éœ€è¦æŠŠæ ¹èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹è°ƒæ¢, ç„¶åŽsink, è‡³å¤š2lgNæ¯”è¾ƒ12345678public Key delMax()&#123; Key max = pq[1]; exch(1, N--); sink(1); pq[N+1] = null; return max;&#125; 12345678910111213141516171819public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;&#123; private Key[] pq; private int N; public MaxPQ(int capacity) &#123; pq = (Key[]) new Comparable[capacity+1]; &#125; public boolean isEmpty() &#123; return N == 0; &#125; public void insert(Key key) public Key delMax() &#123; /* see previous code */ &#125; private void swim(int k) private void sink(int k) &#123; /* see previous code */ &#125; private boolean less(int i, int j) &#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; private void exch(int i, int j) &#123; Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; &#125;&#125; å¦‚æžœè¦å®žçŽ°æœ€å°å †, é‚£ä¹ˆå°±ç”¨greater()æ›¿ä»£less() Heap Sortå¯ä»¥ä½¿ç”¨heapæ•°æ®ç»“æž„æ¥æŽ’åºä¸€ä¸ªæ•°ç»„ï¼Œæ ¸å¿ƒæ­¥éª¤æ˜¯ä¸¤ä¸ª åˆ›å»ºä¸€ä¸ªæœ€å¤§å † ç„¶åŽä¸æ–­æ‹¿å‡ºå½“å‰æœ€å¤§å€¼ï¼Œæ”¾ç½®äºŽåŽé¢. 123456789101112131415161718192021222324public class Heap&#123; public static void sort(Comparable[] a) &#123; // bottom-upæ–¹æ³•åˆ›å»ºå †, // è™½ç„¶æ˜¯ heap order, ä½†ä¸ä¸€å®šæ˜¯sorted order int N = a.length; for (int k = N/2; k &gt;= 1; k--) sink(a, k, N); while (N &gt; 1) &#123; // æŠŠå½“å‰æœ€å¤§å€¼è°ƒæ¢åˆ°Nä½ç½® exch(a, 1, N); // æœ€å¤§å€¼æ”¾åœ¨å°¾éƒ¨ sink(a, 1, --N); // æ¢å¤heap order &#125; &#125; private static void sink(Comparable[] a, int k, int N) &#123; /* as before */ &#125; private static boolean less(Comparable[] a, int i, int j) &#123; /* as before */ &#125; private static void exch(Comparable[] a, int i, int j) &#123; /* as before */ &#125;&#125; In-place sorting algorithm with N log N worst-case, but not stable æŽ’åºç®—æ³•æ±‡æ€»æ¯”è¾ƒ Pigeonhole sorté¸½å·¢æŽ’åº(åŸºæ•°åˆ†ç±») Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements (n) and the length of the range of possible key values (N) are approximately the same. It requires O(n + N) time. ç»™å®šè¦æŽ’åºçš„æ•°ç»„ï¼Œè®¾ç½®ä¸€ä¸ªè¾…åŠ©æ•°ç»„ä½œä¸ºåˆå§‹çš„ç©ºâ€œé¸½ç¬¼â€ï¼Œé€šè¿‡åŽŸå§‹æ•°ç»„çš„èŒƒå›´ä¸ºæ¯ä¸ªé”®å€¼è®¾ç½®ä¸€ä¸ªé¸½ç¬¼ã€‚ éåŽ†åŽŸå§‹æ•°ç»„ï¼Œå°†æ¯ä¸ªå€¼æ”¾å…¥ä¸Žå…¶é”®å¯¹åº”çš„é¸½ç¬¼ä¸­ï¼Œè¿™æ ·æ¯ä¸ªé¸½ç¬¼æœ€ç»ˆéƒ½åŒ…å«è¯¥é”®çš„æ‰€æœ‰å€¼çš„åˆ—è¡¨ã€‚ æŒ‰é¡ºåºè¿­ä»£é¸½ç¬¼æ•°ç»„ï¼Œå¹¶å°†éžç©ºé¸½ç¬¼ä¸­çš„å…ƒç´ ä¾æ¬¡æ”¾å›žåŽŸå§‹æ•°ç»„ä¸­ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Java program to implement Pigeonhole Sort */public class GFG&#123; public static void pigeonhole_sort(int arr[], int n) &#123; int min = arr[0]; int max = arr[0]; int range, i, j, index; for(int a=0; a&lt;n; a++) &#123; if(arr[a] &gt; max) max = arr[a]; if(arr[a] &lt; min) min = arr[a]; &#125; range = max - min + 1; int[] phole = new int[range]; //Arrays.fill(phole, 0); for(i = 0; i &lt; n; i++) phole[arr[i] - min]++; index = 0; for(j = 0; j &lt; range; j++) while(phole[j] &gt; 0) arr[index++] = j + min; &#125; public static void main(String[] args) &#123; GFG sort = new GFG(); int[] arr = &#123;8, 3, 2, 7, 4, 6, 8&#125;; System.out.print("Sorted order is : "); sort.pigeonhole_sort(arr,arr.length); for(int i=0 ; i&lt;arr.length ; i++) System.out.print(arr[i] + " "); &#125;&#125; ç±»ä¼¼äºŽcounting sort Bucket sortæ¡¶æŽ’åº(ç®±æŽ’åº bin sort)ä¸»è¦ç”¨äºŽå‡åŒ€åˆ†å¸ƒåŒºé—´å€¼çš„æŽ’åºï¼Œå¦‚æµ®ç‚¹æ•°æŽ’åºï¼Œ distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a distribution sort, a generalization of pigeonhole sort, and is a cousin of radix sort in the most-to-least significant digit flavor. Bucket sort can be implemented with comparisons and therefore can also be considered a comparison sort algorithm. The computational complexity estimates involve the number of buckets. Worst-case performance ${\displaystyle O(n^{2})}$Best-case performance ${\displaystyle \Omega (n+k)}$Average performance ${\displaystyle \Theta (n+k)}$ è®¾ç½®ä¸€ä¸ªåˆå§‹ä¸ºç©ºçš„â€œæ¡¶â€æ•°ç»„ã€‚ Scatterï¼šéåŽ†åŽŸå§‹æ•°ç»„ï¼Œå°†æ¯ä¸ªå¯¹è±¡åˆ†å‘åˆ°æ¡¶ä¸­ã€‚ å¯¹æ¯ä¸ªéžç©ºæ¡¶è¿›è¡ŒæŽ’åºã€‚ Gatherï¼šæŒ‰é¡ºåºè®¿é—®æ¡¶å¹¶å°†æ‰€æœ‰å…ƒç´ æ”¾å›žåŽŸå§‹æ•°ç»„ä¸­ã€‚ Graphå›¾ï¼šç”±è¾¹è¿žæŽ¥çš„æˆå¯¹çš„é¡¶ç‚¹é›†ã€‚ æ— å‘å›¾ï¼Œæœ‰å‘å›¾]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>algs4</tag>
        <tag>Software Engineer</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ³¨æ„åŠ›æœºåˆ¶]]></title>
    <url>%2FNLP-attention-01%2F</url>
    <content type="text"><![CDATA[æ³¨æ„åŠ›æœºåˆ¶æ³¨æ„åŠ›æœºåˆ¶å°±æ˜¯ä¸ºäº†è§£å†³æœºå™¨ç¿»è¯‘ä¸­ä¸ºä¸åŒçš„å¯¹åº”è¯åˆ†é…æƒé‡çš„æå‡ºçš„ Bahdanau, D., Cho, K., &amp; Bengio, Y. (2014)ã€‚æ¯”å¦‚ç»™å®šä¸€å¯¹è¾“å…¥åºåˆ—çŸ¥è¯†å°±æ˜¯åŠ›é‡&lt;end&gt;å’Œè‹±è¯­è¾“å‡ºåºåˆ—Knowledge is power &lt;end&gt;ã€‚è§£ç å™¨å¯ä»¥åœ¨è¾“å‡ºåºåˆ—çš„æ—¶é—´æ­¥ 1 ä½¿ç”¨æ›´é›†ä¸­ç¼–ç äº†çŸ¥è¯†ä¿¡æ¯çš„èƒŒæ™¯å˜é‡æ¥ç”ŸæˆKnowledgeï¼Œåœ¨æ—¶é—´æ­¥ 2 ä½¿ç”¨æ›´é›†ä¸­ç¼–ç äº†å°±æ˜¯çš„ä¿¡æ¯çš„èƒŒæ™¯å˜é‡æ¥ç”Ÿæˆisï¼Œä¾æ­¤ç±»æŽ¨ã€‚è¿™çœ‹ä¸ŠåŽ»å°±åƒæ˜¯åœ¨è§£ç å™¨çš„æ¯ä¸€æ—¶é—´æ­¥å¯¹è¾“å…¥åºåˆ—ä¸­ä¸åŒæ—¶é—´æ­¥ç¼–ç çš„ä¿¡æ¯åˆ†é…ä¸åŒçš„æ³¨æ„åŠ›ã€‚ æ³¨æ„åŠ›æœºåˆ¶å¯ä»¥ç†è§£ä¸ºå°†queryå’Œä¸€ç»„key-valueå¯¹æ˜ å°„åˆ°è¾“å‡ºã€‚è¾“å‡ºè¢«è®¡ç®—ä¸ºvalueçš„åŠ æƒå’Œï¼Œå…¶ä¸­åˆ†é…ç»™æ¯ä¸ªvalueçš„æƒé‡ç”±queryå’Œç›¸åº”keyçš„ compatibility functionï¼ˆsimilarity function ç›¸ä¼¼å‡½æ•°ï¼‰è®¡ç®—ã€‚ è®¡ç®—æ³¨æ„åŠ›ä¸»è¦åˆ†ä¸ºä¸‰ä¸ªæ­¥éª¤ã€‚ è®¡ç®—queryå’Œæ¯ä¸ªkeyä¹‹é—´çš„ç›¸ä¼¼æ€§$f_c(q,k_i)$ä»¥èŽ·å¾—æ³¨æ„åŠ›åˆ†é…æƒé‡ã€‚å¸¸ç”¨çš„ç›¸ä¼¼æ€§å‡½æ•°åŒ…æ‹¬ç‚¹ç§¯ï¼Œæ‹¼æŽ¥ï¼Œæ£€æµ‹å™¨ç­‰ã€‚ ç„¶åŽé€šå¸¸æ˜¯ä½¿ç”¨softmaxå‡½æ•°æ¥æ­£åˆ™åŒ–è¿™äº›æƒé‡ã€‚ æœ€åŽå°†è¿™äº›æƒé‡ä¸Žç›¸åº”çš„valueä¸€èµ·åŠ æƒå¹¶èŽ·å¾—æœ€ç»ˆçš„å€¼ã€‚ $$\begin{eqnarray} A(q, {(k,v)} ) \xrightarrow[\text{output}]{\text{maps as}} \sum_{i=1}^k{\overbrace{f_c(q,k_i)}^{\theta_i}}v_i, q \in Q, k \in K, v \in V \end{eqnarray}$$ å…·ä½“åœ°è¯´ï¼Œæ³¨æ„æœºåˆ¶å°±æ˜¯åœ¨è¾“å…¥çŠ¶æ€ä¸Šåˆ†é…æƒé‡ã€‚å®ƒæŽ¥å—ä»»æ„æ•°é‡çš„è¾“å…¥${x_1, â€¦, x_k}$å’ŒæŸ¥è¯¢$q$ï¼Œç„¶åŽä¸ºæ¯ä¸ªè¾“å…¥ç”Ÿæˆæƒé‡${\theta_1, â€¦, \theta_k}$ã€‚è¿™å¯ä»¥è¡¡é‡æ¯ä¸ªè¾“å…¥å›žåº”queryæˆ–ä¸Žqueryäº¤äº’çš„ç¨‹åº¦ã€‚å› æ­¤ï¼Œæ³¨æ„æœºåˆ¶çš„è¾“å‡ºç»“æžœ$out$æ˜¯å…¶è¾“å…¥çš„åŠ æƒå¹³å‡å€¼ï¼š$$\begin{eqnarray} out = \sum_{i=1}^k \theta_i x_i \end{eqnarray}$$è¿™ç§çº¿æ€§ç»„åˆçš„æƒé‡æ˜¯ç”±ç¥žç»ç½‘ç»œæŽ§åˆ¶çš„ã€‚ åœ¨ç¼–ç å™¨-è§£ç å™¨æž¶æž„ä¸­ï¼Œqueryé€šå¸¸æ˜¯è§£ç å™¨çš„éšå«çŠ¶æ€ã€‚è€Œkeyï¼Œæ˜¯ç¼–ç å™¨çš„éšå«çŠ¶æ€ï¼Œç›¸åº”çš„valueæ˜¯æ­£åˆ™åŒ–çš„æƒé‡ï¼Œè¡¨ç¤ºkeyèŽ·å¾—å¤šå°‘æ³¨æ„åŠ›ã€‚åŠ æƒæ±‚å’Œä½œä¸ºè¾“å‡º. å¯¹äºŽScaled Dot-Product Attention, valueç”±queryå’Œkeyçš„ç‚¹ç§¯æ±‚å¾—ã€‚ ç›®æ ‡ï¼šå¯¹äºŽè§£ç å™¨çš„æ¯ä¸€ä¸ªæ—¶é—´æ­¥$tâ€™$, ç”Ÿæˆä¸€ä¸ªèƒŒæ™¯å‘é‡$c_{tâ€™}$æ¥æ•æ‰ç›¸å…³çš„è§£ç å™¨ä¿¡æ¯, ä»¥ç”¨äºŽé¢„æµ‹è¾“å‡ºç›®æ ‡å€¼$y_{tâ€™}$. å…·ä½“æ­¥éª¤ï¼šè§£ç å™¨åœ¨æ—¶é—´æ­¥ $tâ€™$ çš„éšè—çŠ¶æ€ $$s_{tâ€™} = g(y_{tâ€™-1}, c_{tâ€™}, s_{tâ€™-1}).$$ ä»¤ç¼–ç å™¨åœ¨æ—¶é—´ $t$ çš„éšè—çŠ¶æ€ä¸º $h_t$ï¼Œä¸”æ€»æ—¶é—´æ­¥æ•°ä¸º $T$ã€‚è§£ç å™¨åœ¨æ—¶é—´æ­¥ $tâ€™$ çš„èƒŒæ™¯å˜é‡ä¸º $$c_{tâ€™} = \sum_{t=1}^T \alpha_{tâ€™ t} h_t,$$ å…¶ä¸­ $\alpha_{tâ€™ t}$ æ˜¯æƒé‡ï¼Œç”¨äºŽç»™å®šè§£ç å™¨çš„å½“å‰éšè—çŠ¶æ€ $s_{tâ€™}$ï¼Œå¯¹ç¼–ç å™¨ä¸­ä¸åŒæ—¶é—´æ­¥çš„éšè—çŠ¶æ€$h_t$æ±‚åŠ æƒå¹³å‡ã€‚è¿™é‡Œçš„æƒå€¼ä¹Ÿç§°æ³¨æ„åŠ›æƒé‡ï¼š $$\alpha_{tâ€™ t} = align(s_{tâ€™}, h_t) = \frac{\exp(score(tâ€™ t))}{ \sum_{t=1}^T \exp(score(tâ€™ t)) },$$ å…¶ä¸­ $score(tâ€™ t) \in \mathbb{R}$ çš„è®¡ç®—ä¸º $$score(tâ€™ t) = a(s_{tâ€™ - 1}, h_t).$$ ä¸Šå¼ä¸­çš„scoreæ‰“åˆ†å‡½æ•° $score(tâ€™ t)$ æœ‰å¤šç§è®¾è®¡æ–¹æ³•ã€‚Bahanau ç­‰ä½¿ç”¨äº†å¤šå±‚æ„ŸçŸ¥æœºï¼š $$e_{tâ€™t} = v^\top \tanh(W_s s_{tâ€™ - 1} + W_h h_t),$$ å…¶ä¸­ $v$ã€$W_s$ã€$W_h$ ä»¥åŠç¼–ç å™¨ä¸Žè§£ç å™¨ä¸­çš„å„ä¸ªæƒé‡å’Œåå·®éƒ½æ˜¯æ¨¡åž‹å‚æ•°ã€‚ Bahanau ç­‰åœ¨ç¼–ç å™¨å’Œè§£ç å™¨ä¸­åˆ†åˆ«ä½¿ç”¨äº†é—¨æŽ§å¾ªçŽ¯å•å…ƒGRUã€‚åœ¨è§£ç å™¨ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å¯¹é—¨æŽ§å¾ªçŽ¯å•å…ƒçš„è®¾è®¡ç¨ä½œä¿®æ”¹ã€‚è§£ç å™¨åœ¨ $tâ€™ $ æ—¶é—´æ­¥çš„éšè—çŠ¶æ€ä¸º $$s_{tâ€™} = z_{tâ€™} \odot s_{tâ€™-1} + (1 - z_{tâ€™}) \odot \tilde{s}_{tâ€™},$$ å…¶ä¸­çš„é‡ç½®é—¨ã€æ›´æ–°é—¨å’Œå€™é€‰éšå«çŠ¶æ€åˆ†åˆ«ä¸º $$\begin{aligned}r_{tâ€™} &amp;= \sigma(W_{yr} y_{tâ€™-1} + W_{sr} s_{tâ€™ - 1} + W_{cr} c_{tâ€™} + b_r), \\z_{tâ€™} &amp;= \sigma(W_{yz} y_{tâ€™-1} + W_{sz} s_{tâ€™ - 1} + W_{cz} c_{tâ€™} + b_z),\\\tilde{s_{tâ€™}} &amp;= \text{tanh}(W_{ys} y_{tâ€™-1} + W_{ss} (s_{tâ€™ - 1} \odot r_{tâ€™}) + W_{cs} c_{tâ€™} + b_s).\end{aligned}$$ ç„¶åŽï¼Œç»™å®šç›®æ ‡(è§£ç å™¨)éšè—çŠ¶æ€$h_{tâ€™}$, ä»¥åŠèƒŒæ™¯å‘é‡$c_{tâ€™}$, é€šè¿‡ä½¿ç”¨ç®€å•çš„å¹¶è”å±‚åˆå¹¶è¿™ä¸¤ä¸ªå‘é‡çš„ä¿¡æ¯, æ¥ç”Ÿæˆæ‰€è°“çš„æ³¨æ„åŠ›éšè—çŠ¶æ€: $$\tilde{h_{tâ€™}} = \tanh(W_c[c_{tâ€™} : h_{tâ€™}]) $$ è¿™ä¸ªæ³¨æ„åŠ›å‘é‡ $\tilde{h_t}$ ä¹‹åŽä¼šé€šè¿‡ä¸€ä¸ªsoftmaxå±‚æ¥ç”Ÿæˆé¢„æµ‹çš„æ¦‚çŽ‡åˆ†å¸ƒ. å…¨å±€æ³¨æ„åŠ›æœºåˆ¶Luong et al. (2015)æå‡ºäº†ä¸¤ç§æ³¨æ„åŠ›æœºåˆ¶çš„å˜ç§ï¼šå…¨å±€ï¼ˆglobalï¼‰å’Œå±€éƒ¨ï¼ˆlocalï¼‰æ³¨æ„åŠ›æœºåˆ¶ã€‚åŒºåˆ«åœ¨äºŽâ€œæ³¨æ„åŠ›â€æ˜¯æ”¾åœ¨æ‰€æœ‰æºä½ç½®æˆ–ä»…æ”¾ç½®åœ¨å°‘æ•°æºä½ç½®ã€‚ The idea of a global attentional model is to consider all the hidden states of the encoder when deriving the context vector $c_t$. ä¸¤ç§æ³¨æ„åŠ›æœºåˆ¶åŒºåˆ«å°±åœ¨äºŽå¦‚ä½•ç”ŸæˆèƒŒæ™¯å‘é‡$c_{tâ€™}$. Luong et al. (2015) ç»™å‡ºäº†å‡ ç§æ‰“åˆ†å‡½æ•°çš„è®¡ç®— $$\begin{aligned} score_{dot}(tâ€™ t) &amp;= s^\top_{tâ€™}h_t \\ score_{general}(tâ€™ t) &amp;= s^\top_{tâ€™} W_\alpha h_t, \\ score_{concat}(tâ€™ t) &amp;= v^\top_\alpha \tanh (W_\alpha[s_{tâ€™} : h_t])\end{aligned}$$ å‚è€ƒèµ„æ–™ç›®å‰ä¸»æµçš„attentionæ–¹æ³•éƒ½æœ‰å“ªäº›ï¼Ÿ - å¼ ä¿Šæž—çš„å›žç­” - çŸ¥ä¹Žhttps://www.zhihu.com/question/68482809/answer/264632289https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms 03 - Memory å†…å­˜]]></title>
    <url>%2Falgorithms-03-memory%2F</url>
    <content type="text"><![CDATA[MemoryBit. 0 or 1.Byte. 8 bits.Megabyte (MB). 1 million or $2^{20}$ bytes.Gigabyte (GB). 1 billion or $2^{30}$ bytes.64-bit machine. We assume a 64-bit machine with 8 byte pointers (References).ãƒ»Can address more memory.ãƒ»Pointers use more space (some JVMs â€œcompressâ€ ordinary object pointers to 4 bytes to avoid this cost). Typical memory usage for primitive types and arraysprimitive types (bytes):boolean 1byte 1char 2int 4float 4long 8double 8 for one-dimensional arrays (bytes):char[] 2N + 24int[] 4N + 24double[] 8N + 24 Typical memory usage for objects in JavaObject overhead. 16 bytes.Reference. 8 bytes.Padding. Each object uses a multiple of 8 bytes.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>algs4</tag>
        <tag>Software Engineer</tag>
        <tag>cs61b</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms 02 - Amortized Analysis å¹³æ‘Šåˆ†æž]]></title>
    <url>%2Falgorithms-02-amortized-analysis%2F</url>
    <content type="text"><![CDATA[å‡å¦‚æœ‰ä¸¤ç§äº¤ç¨Žæ–¹å¼ï¼š æ¯å¤©ä»˜ 3 é‡‘å¸ æ¯æ¬¡ä»˜çš„é‡‘å¸å‘ˆæŒ‡æ•°çº§å¢žé•¿ï¼Œä½†é€šçŸ¥ä»˜æ¬¾é¢‘çŽ‡å‘ˆæŒ‡æ•°çº§ä¸‹é™ ç¬¬1å¤©ï¼šä»˜ 1 ç¬¬2å¤©ï¼šä»˜ 2 (ç´¯è®¡ 3) ç¬¬4å¤©ï¼šä»˜ 4 (ç´¯ç§¯ 7) ç¬¬8å¤©ï¼šä»˜ 8 (ç´¯ç§¯ 15) å“ªç§ä»˜çš„é’±æ¯”è¾ƒå°‘ï¼Ÿç¬¬äºŒç§æ¯”è¾ƒåˆ’ç®—ï¼Œæœ¬è´¨ä¸Šç­‰åŒäºŽæ¯å¤©ä»˜ 2ï¼Œå°±æ˜¯amortized constantã€‚A more rigorous examination of amortized analysis is done here, in three steps: Pick a cost model (like in regular runtime analysis) Compute the average cost of the iâ€™th operation Show that this average (amortized) cost is bounded by a constant. ç±»ä¼¼çš„åº”ç”¨åœ¨Array list æ‰©å®¹ä¸­æåˆ°çš„ geometric resizing æ–¹æ³•(å®žé™…ä¹Ÿæ˜¯Python list ä½¿ç”¨çš„æ–¹æ³•)æœ‰ä½“çŽ°, æ‰€ä»¥ä½¿ç”¨ä¸€ä¸ªå› æ•°æ¥æ‰©å®¹æ•°ç»„, å¯ä»¥è®© ArrayList çš„ addæ“ä½œå˜ä¸º amortized constant time. æ€»ç»“ Amortized analysis provides a way to prove the average cost of operations. If we chose $a_i$ such that $\Phi_i$ is never negative and $a_i$ is constant for all $i$, then the amortized cost is an upper bound on the true cost.â€“ from: https://joshhug.gitbooks.io/]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>algs4</tag>
        <tag>Software Engineer</tag>
        <tag>cs61b</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms 01 - Asymptotic Analysis æ¸è¿›åˆ†æž]]></title>
    <url>%2Falgorithms-01-asymptotic-analysis%2F</url>
    <content type="text"><![CDATA[Resource and Reference: CS61B Berkeley - Josh Hug Algorithms Princeton - ROBERT SEDGEWICK, KEVIN WAYNE æ•ˆçŽ‡æ¥æºä¸¤ä¸ªæ–¹é¢: ç¼–ç¨‹æˆæœ¬: å¼€å‘ç¨‹åºéœ€è¦å¤šé•¿æ—¶é—´ï¼Ÿä»£ç æ˜¯å¦å®¹æ˜“é˜…è¯»ï¼Œä¿®æ”¹å’Œç»´æŠ¤ï¼ˆå¤§éƒ¨åˆ†æˆæœ¬æ¥è‡ªç»´æŠ¤å’Œå¯æ‰©å±•æ€§ï¼‰ï¼Ÿ è¿è¡Œæˆæœ¬: ç¨‹åºéœ€è¦å¤šé•¿æ—¶é—´è¿è¡Œ (Time complexity)ï¼Ÿ éœ€è¦å¤šå°‘å†…å­˜ (Space complexity)ï¼Ÿ Asymptotic AnalysisCare about what happens for very large N (asymptotic behavior). We want to consider what types of algorithms would best handle scalability - Algorithms that scale well have better asymptotic runtime behavior. Simplification Summary Only consider the worst case. Pick a representative operation (aka: cost model) Ignore lower order terms Ignore multiplicative constants. Simplified Analysis Process Choose cost model (representative operation) Figure out the order of growth for the count of representative operation by either: Making an exact count, and discarding unnecessary pieces Only consider the worst case. Ignore lower order terms Ignore constants. Or, using intuition/inspection to determine orders of growth. Big ThetaFormalizing Order of Growth: Suppose a function $R(N)$ with order of growth $f(N)$, this is represented as $R(N) \in \Theta(f(N))$ in notation. Means that there exists positive constants $k_1, k_2$ such that: $$k_1 â‹… f(N) â‰¤ R(N) â‰¤ k_â€‹2 â‹… f(N),$$ for all values of $N$ greater than some $N_0$(a very large N). Procedure: Given a piece of code, express its runtime as a function $R(N)$ $N$ is some property of the input of the function. Oftentimes, $N$ represents the size of the input Rather than finding $R(N)$ exactly, instead care about the order of growth of $R(N)$. One approach (not universal): Choose a representative operation Let $C(N)$ = count of how many times that operation occurs, as a function of $N$. Determine order of growth $C(N) \in \Theta(f(N))$ Often (but not always) consider the worst case count. If operation takes constant time, then $R(N) \in \Theta(f(N))$ åœ¨ Big Theta çš„èŒƒç•´å†…ï¼Œå¯¹äºŽæ¶‰åŠ logarithm çš„æƒ…å†µï¼Œåº•æ•°å¹¶ä¸é‡è¦ï¼Œä»»ä½•åº•æ•°éƒ½æ˜¯ç­‰ä»·çš„ï¼šBinary search: $\Theta(\log N)$ ç›´æŽ¥å¿½ç•¥åº•æ•°ç¬¦å·ã€‚Selection sort: $\Theta(N^2)$Merge two sorted array (Merge Sort): $\Theta(N)$ ç”¨ merge sort åŠ é€Ÿ selection sort - æŠŠ selection sort é€’å½’åœ°å¹³åˆ†, æ€»å…±èƒ½åˆ†è§£å‡º$\log_2N$ä¸ª merge sorts, ä¼ªä»£ç :123456If the list is size 1: returnelse: Mergesort the left half Mergesort the right half Merge the results Total runtime is $â‰ˆNk$, where $k = \log_2(N)$ is the number of levels, overall runtime is $\Theta(N \log N)$.$N^2$ vs. $N \log N$ is an enormous difference. Going from $N\log N$ to $N$ is nice, but not a radical change. Useful math:$1 + 2 + 3 + â€¦ + N = N * (N + 1) / 2 = \Theta(N^2)$$1 + 2 + 4 + â€¦ + N = 2N - 1 = \Theta(N)$ To estimate a discrete sum, replace the sum with an integral, and use calculus:$1 + 2 + 3 + â€¦ + N = \sum_{i=1}^{N} i \sim \int_{x=1}^N x dx \sim \frac{1}{2}(N^2)$ $1^k + 2^k + â€¦ + N^k = \sum_{i=1}^{N} i^k \sim \int_{x=1}^N x^k dx \sim \frac{1}{k+1}(N^{k+1})$ $1 + 1/2 + 1/3 + â€¦ + 1/N = \sum_{i=1}^{N} i^{-1} \sim \int_{x=1}^N x^{-1} dx \sim \ln N$ 3-sum triple loop, $\sum_{i=1}^{N}\sum_{j=1}^{N}\sum_{k=1}^{N} 1 \sim \int_{x=1}^N\int_{y=x}^N\int_{z=y}^N dz dy dx \sim \frac{1}{6}N^3$ Big OBig Theta expresses the exact order of as a function of the input size. However, if the runtime depends on more than just the size of the input, then we must qualify our statements into different cases before using Big Theta. Big O: $R(N) \in O(f(N))$, means that there exists positive constants $k_2$, such that: $R(N) \leq k_2 \cdot f(N)$ for all values of $N$ greater than some $N_0$(a very large $N$). This is a looser condition than Big Theta since Big O does not care about the lower bound, thus it is less informative than Big Theta. To summarize the usefulness of Big O: It allows us to make simple statements without case qualifications, in cases where the runtime is different for different inputs. Sometimes, for particularly tricky problems, we (the computer science community) donâ€™t know the exact runtime, so we may only state an upper bound. Itâ€™s a lot easier to write proofs for Big O than Big Theta, like we saw in finding the runtime of mergesort in the previous chapter. This is beyond the scope of this course. ç±»ä¼¼çš„ä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªä¸‹é™æ¦‚å¿µ - Big Omega ($\Omega$)ï¼Œ ä¸€èˆ¬ç”¨äºŽè¡¨æ˜Žä¸€ä¸ªé—®é¢˜çš„éš¾åº¦æœ‰å¤šå¤§ã€‚ Summary Big O is an upper bound (â€œless than or equalsâ€) Big Omega is a lower bound (â€œgreater than or equalsâ€) Big Theta is both an upper and lower bound (â€œequalsâ€) Big O does NOT mean â€œworst caseâ€. We can still describe worst cases using Big Theta Big Omega does NOT mean â€œbest caseâ€. We can still describe best cases using Big Theta Big O is sometimes colloquially used in cases where Big Theta would provide a more precise statementâ€“ from: https://joshhug.gitbooks.io/]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>algs4</tag>
        <tag>Software Engineer</tag>
        <tag>cs61b</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java LinkedHashMap]]></title>
    <url>%2Fjava-HashMap-LinkedHashMap%2F</url>
    <content type="text"><![CDATA[LinkedHashMapHashMap æ˜¯æ— åºçš„ï¼ŒHashMap åœ¨ put çš„æ—¶å€™æ˜¯æ ¹æ® key çš„ hashcode è¿›è¡Œ hash ç„¶åŽæ”¾å…¥å¯¹åº”çš„åœ°æ–¹ã€‚æ‰€ä»¥åœ¨æŒ‰ç…§ä¸€å®šé¡ºåº put è¿› HashMap ä¸­ï¼Œç„¶åŽéåŽ†å‡º HashMap çš„é¡ºåºè·Ÿ put çš„é¡ºåºä¸åŒ.JAVA åœ¨ JDK1.4 ä»¥åŽæä¾›äº† LinkedHashMap æ¥å®žçŽ°æœ‰åºçš„ HashMapï¼LinkedHashMap æ˜¯ HashMap çš„ä¸€ä¸ªå­ç±»ï¼Œå®ƒä¿ç•™æ’å…¥çš„é¡ºåºï¼Œå¦‚æžœéœ€è¦è¾“å‡ºçš„é¡ºåºå’Œè¾“å…¥æ—¶çš„ç›¸åŒï¼Œé‚£ä¹ˆå°±é€‰ç”¨ LinkedHashMapã€‚LinkedHashMap æ˜¯ Map æŽ¥å£çš„å“ˆå¸Œè¡¨å’Œé“¾è¡¨æ•°ç»„å®žçŽ°ï¼Œå…·æœ‰å¯é¢„çŸ¥çš„è¿­ä»£é¡ºåºã€‚æ­¤å®žçŽ°æä¾›æ‰€æœ‰å¯é€‰çš„æ˜ å°„æ“ä½œï¼Œå¹¶å…è®¸ä½¿ç”¨ null å€¼å’Œ null é”®ã€‚æ­¤ç±»ä¸ä¿è¯æ˜ å°„çš„é¡ºåºï¼Œç‰¹åˆ«æ˜¯å®ƒä¸ä¿è¯è¯¥é¡ºåºæ’ä¹…ä¸å˜ã€‚1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;&#125; LinkedHashMap é‡‡ç”¨çš„ hash ç®—æ³•å’Œ HashMap ç›¸åŒï¼Œä½†æ˜¯å®ƒé‡æ–°å®šä¹‰äº†æ•°ç»„ä¸­ä¿å­˜çš„å…ƒç´  Entryï¼Œè¯¥ Entry é™¤äº†ä¿å­˜å½“å‰å¯¹è±¡çš„å¼•ç”¨å¤–ï¼Œè¿˜ä¿å­˜äº†å…¶ä¸Šä¸€ä¸ªå…ƒç´  before å’Œä¸‹ä¸€ä¸ªå…ƒç´  after çš„å¼•ç”¨ï¼Œä»Žè€Œåœ¨å“ˆå¸Œè¡¨çš„åŸºç¡€ä¸Šåˆæž„æˆäº†åŒå‘é“¾è¡¨ã€‚è¿­ä»£é¡ºåºå¯ä»¥æ˜¯æ’å…¥é¡ºåºæˆ–è€…æ˜¯è®¿é—®é¡ºåºã€‚12345678910111213141516171819/*** The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.* å¦‚æžœä¸ºtrueï¼Œåˆ™æŒ‰ç…§è®¿é—®é¡ºåºï¼›å¦‚æžœä¸ºfalseï¼Œåˆ™æŒ‰ç…§æ’å…¥é¡ºåºã€‚*/private final boolean accessOrder;/*** åŒå‘é“¾è¡¨çš„è¡¨å¤´å…ƒç´ ã€‚ */private transient Entry&lt;K,V&gt; header;/*** LinkedHashMapçš„Entryå…ƒç´ ã€‚* ç»§æ‰¿HashMapçš„Entryå…ƒç´ ï¼Œåˆä¿å­˜äº†å…¶ä¸Šä¸€ä¸ªå…ƒç´ beforeå’Œä¸‹ä¸€ä¸ªå…ƒç´ afterçš„å¼•ç”¨ã€‚ */private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; â€¦â€¦&#125; æ ¹æ®é“¾è¡¨ä¸­å…ƒç´ çš„é¡ºåºå¯ä»¥åˆ†ä¸ºï¼šæŒ‰æ’å…¥é¡ºåºçš„é“¾è¡¨ï¼Œå’ŒæŒ‰è®¿é—®é¡ºåº(è°ƒç”¨ get æ–¹æ³•)çš„é“¾è¡¨ã€‚é»˜è®¤æ˜¯æŒ‰æ’å…¥é¡ºåºæŽ’åºï¼Œå¦‚æžœæŒ‡å®šæŒ‰è®¿é—®é¡ºåºæŽ’åºï¼Œé‚£ä¹ˆè°ƒç”¨getæ–¹æ³•åŽï¼Œä¼šå°†è¿™æ¬¡è®¿é—®çš„å…ƒç´ ç§»è‡³é“¾è¡¨å°¾éƒ¨ï¼Œä¸æ–­è®¿é—®å¯ä»¥å½¢æˆæŒ‰è®¿é—®é¡ºåºæŽ’åºçš„é“¾è¡¨ã€‚ æ³¨æ„ï¼Œæ­¤å®žçŽ°ä¸æ˜¯åŒæ­¥çš„ã€‚å¦‚æžœå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®é“¾æŽ¥çš„å“ˆå¸Œæ˜ å°„ï¼Œè€Œå…¶ä¸­è‡³å°‘ä¸€ä¸ªçº¿ç¨‹ä»Žç»“æž„ä¸Šä¿®æ”¹äº†è¯¥æ˜ å°„ï¼Œåˆ™å®ƒå¿…é¡»ä¿æŒå¤–éƒ¨åŒæ­¥ã€‚ åˆå§‹åŒ–åœ¨ LinkedHashMap çš„æž„é€ æ–¹æ³•ä¸­ï¼Œå®žé™…è°ƒç”¨äº†çˆ¶ç±» HashMap çš„ç›¸å…³æž„é€ æ–¹æ³•æ¥æž„é€ ä¸€ä¸ªåº•å±‚å­˜æ”¾çš„ table æ•°ç»„ï¼Œä½†é¢å¤–å¯ä»¥å¢žåŠ  accessOrder è¿™ä¸ªå‚æ•°ï¼Œå¦‚æžœä¸è®¾ç½®ï¼Œé»˜è®¤ä¸º falseï¼Œä»£è¡¨æŒ‰ç…§æ’å…¥é¡ºåºè¿›è¡Œè¿­ä»£ï¼›æ˜¾å¼è®¾ç½®ä¸º trueï¼Œä»£è¡¨ä»¥è®¿é—®é¡ºåºè¿›è¡Œè¿­ä»£ã€‚1234public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; LinkedHashMap é‡å†™äº† init() æ–¹æ³•ï¼Œåœ¨è°ƒç”¨çˆ¶ç±»çš„æž„é€ æ–¹æ³•å®Œæˆæž„é€ åŽï¼Œè¿›ä¸€æ­¥å®žçŽ°äº†å¯¹å…¶å…ƒç´  Entry çš„åˆå§‹åŒ–æ“ä½œã€‚12345678910/*** Called by superclass constructors and pseudoconstructors (clone,* readObject) before any entries are inserted into the map. Initializes* the chain.*/@Overridevoid init() &#123; header = new Entry&lt;&gt;(-1, null, null, null); header.before = header.after = header;&#125; å­˜å‚¨LinkedHashMap å¹¶æœªé‡å†™çˆ¶ç±» HashMap çš„ put æ–¹æ³•ï¼Œè€Œæ˜¯é‡å†™äº†çˆ¶ç±» HashMap çš„ put æ–¹æ³•è°ƒç”¨çš„å­æ–¹æ³•void recordAccess(HashMap m)ï¼Œvoid addEntry(int hash, K key, V value, int bucketIndex) å’Œvoid createEntry(int hash, K key, V value, int bucketIndex)ï¼Œæä¾›äº†è‡ªå·±ç‰¹æœ‰çš„åŒå‘é“¾æŽ¥åˆ—è¡¨çš„å®žçŽ°ã€‚12345678910111213141516171819public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; é‡å†™æ–¹æ³•1234567891011121314151617181920212223242526272829303132333435363738void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125;&#125;void addEntry(int hash, K key, V value, int bucketIndex) &#123; // è°ƒç”¨createæ–¹æ³•ï¼Œå°†æ–°å…ƒç´ ä»¥åŒå‘é“¾è¡¨çš„çš„å½¢å¼åŠ å…¥åˆ°æ˜ å°„ä¸­ã€‚ createEntry(hash, key, value, bucketIndex); // åˆ é™¤æœ€è¿‘æœ€å°‘ä½¿ç”¨å…ƒç´ çš„ç­–ç•¥å®šä¹‰ Entry&lt;K,V&gt; eldest = header.after; if (removeEldestEntry(eldest)) &#123; removeEntryForKey(eldest.key); &#125; else &#123; if (size &gt;= threshold) resize(2 * table.length); &#125;&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old); table[bucketIndex] = e; // è°ƒç”¨å…ƒç´ çš„addBreforeæ–¹æ³•ï¼Œå°†å…ƒç´ åŠ å…¥åˆ°å“ˆå¸Œã€åŒå‘é“¾æŽ¥åˆ—è¡¨ã€‚ e.addBefore(header); size++;&#125;private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; è¯»å–LinkedHashMap é‡å†™äº†çˆ¶ç±» HashMap çš„ get æ–¹æ³•ï¼Œå®žé™…åœ¨è°ƒç”¨çˆ¶ç±» getEntry() æ–¹æ³•å–å¾—æŸ¥æ‰¾çš„å…ƒç´ åŽï¼Œå†åˆ¤æ–­å½“æŽ’åºæ¨¡å¼ accessOrder ä¸º true æ—¶ï¼Œè®°å½•è®¿é—®é¡ºåºï¼Œå°†æœ€æ–°è®¿é—®çš„å…ƒç´ æ·»åŠ åˆ°åŒå‘é“¾è¡¨çš„è¡¨å¤´ï¼Œå¹¶ä»ŽåŽŸæ¥çš„ä½ç½®åˆ é™¤ã€‚ç”±äºŽçš„é“¾è¡¨çš„å¢žåŠ ã€åˆ é™¤æ“ä½œæ˜¯å¸¸é‡çº§çš„ï¼Œæ•…å¹¶ä¸ä¼šå¸¦æ¥æ€§èƒ½çš„æŸå¤±ã€‚12345678910111213141516171819202122232425262728293031323334public V get(Object key) &#123; // è°ƒç”¨çˆ¶ç±»HashMapçš„getEntry()æ–¹æ³•ï¼Œå–å¾—è¦æŸ¥æ‰¾çš„å…ƒç´ ã€‚ Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); if (e == null) return null; // è®°å½•è®¿é—®é¡ºåºã€‚ e.recordAccess(this); return e.value;&#125;void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; // å¦‚æžœå®šä¹‰äº†LinkedHashMapçš„è¿­ä»£é¡ºåºä¸ºè®¿é—®é¡ºåºï¼Œ // åˆ™åˆ é™¤ä»¥å‰ä½ç½®ä¸Šçš„å…ƒç´ ï¼Œå¹¶å°†æœ€æ–°è®¿é—®çš„å…ƒç´ æ·»åŠ åˆ°é“¾è¡¨è¡¨å¤´ã€‚ if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125;&#125;/*** Removes this entry from the linked list.*/private void remove() &#123; before.after = after; after.before = before;&#125;/**clearé“¾è¡¨ï¼Œè®¾ç½®headerä¸ºåˆå§‹çŠ¶æ€*/public void clear() &#123; super.clear(); header.before = header.after = header;&#125; æŽ’åºæ¨¡å¼LinkedHashMap å®šä¹‰äº†æŽ’åºæ¨¡å¼ accessOrderï¼Œè¯¥å±žæ€§ä¸º boolean åž‹å˜é‡ï¼Œå¯¹äºŽè®¿é—®é¡ºåºï¼Œä¸º trueï¼›å¯¹äºŽæ’å…¥é¡ºåºï¼Œåˆ™ä¸º false(é»˜è®¤å€¼)ã€‚ è¿™äº›æž„é€ æ–¹æ³•éƒ½ä¼šé»˜è®¤æŒ‡å®šæŽ’åºæ¨¡å¼ä¸ºæ’å…¥é¡ºåºã€‚å¦‚æžœä½ æƒ³æž„é€ ä¸€ä¸ª LinkedHashMapï¼Œå¹¶æ‰“ç®—æŒ‰ä»Žè¿‘æœŸè®¿é—®æœ€å°‘åˆ°è¿‘æœŸè®¿é—®æœ€å¤šçš„é¡ºåºï¼ˆå³è®¿é—®é¡ºåºï¼‰æ¥ä¿å­˜å…ƒç´ ï¼Œé‚£ä¹ˆè¯·ä½¿ç”¨ä¸‹é¢çš„æž„é€ æ–¹æ³•æž„é€  LinkedHashMapï¼špublic LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) è¯¥å“ˆå¸Œæ˜ å°„çš„è¿­ä»£é¡ºåºå°±æ˜¯æœ€åŽè®¿é—®å…¶æ¡ç›®çš„é¡ºåºï¼Œè¿™ç§æ˜ å°„å¾ˆé€‚åˆæž„å»º LRU ç¼“å­˜ã€‚LinkedHashMap æä¾›äº† removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) æ–¹æ³•ã€‚è¯¥æ–¹æ³•å¯ä»¥æä¾›åœ¨æ¯æ¬¡æ·»åŠ æ–°æ¡ç›®æ—¶ç§»é™¤æœ€æ—§æ¡ç›®çš„å®žçŽ°ç¨‹åºï¼Œé»˜è®¤è¿”å›ž falseï¼Œè¿™æ ·ï¼Œæ­¤æ˜ å°„çš„è¡Œä¸ºå°†ç±»ä¼¼äºŽæ­£å¸¸æ˜ å°„ï¼Œå³æ°¸è¿œä¸èƒ½ç§»é™¤æœ€æ—§çš„å…ƒç´ ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java LinkedHashMapå’ŒLRUcache]]></title>
    <url>%2Fjava-HashMap-LinkedHashMap-LRU%2F</url>
    <content type="text"><![CDATA[LRUç¼“å­˜ç”¨ç¼“å­˜æ¥å­˜æ”¾ä¹‹å‰è¯»å–è¿‡çš„æ•°æ®ï¼Œè¿™æ ·ï¼Œå†æ¬¡è¯»å–çš„æ—¶å€™ï¼Œå¯ä»¥ç›´æŽ¥åœ¨ç¼“å­˜é‡Œé¢å–ï¼Œè€Œä¸ç”¨å†é‡æ–°æŸ¥æ‰¾ä¸€éï¼Œè¿™æ ·ç³»ç»Ÿçš„ååº”èƒ½åŠ›ä¼šæœ‰å¾ˆå¤§æé«˜ã€‚ä½†æ˜¯ï¼Œå½“æˆ‘ä»¬è¯»å–çš„ä¸ªæ•°ç‰¹åˆ«å¤§çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸å¯èƒ½æŠŠæ‰€æœ‰å·²ç»è¯»å–çš„æ•°æ®éƒ½æ”¾åœ¨ç¼“å­˜é‡Œï¼Œæ¯•ç«Ÿå†…å­˜å¤§å°æ˜¯ä¸€å®šçš„ï¼Œæ‰€ä»¥ä¸€èˆ¬æŠŠæœ€è¿‘å¸¸è¯»å–çš„æ”¾åœ¨ç¼“å­˜é‡Œã€‚ LRU(Least Recently Used)ç¼“å­˜åˆ©ç”¨äº†è¿™æ ·çš„ä¸€ç§æ€æƒ³, æŠŠæœ€æ–°è¯»å–çš„æ•°æ®æ”¾åœ¨æœ€å‰é¢ï¼Œç¼“å­˜ä¸­å­˜å‚¨çš„æ˜¯è¯»å–æœ€é¢‘ç¹çš„æ•°æ®ï¼Œä»¥èƒ½å¤Ÿæé«˜ç³»ç»Ÿçš„æ€§èƒ½ã€‚ LinkedHashMapå®žçŽ°LRULinkedHashMapæ”¯æŒæŒ‰ç…§è®¿é—®é¡ºåºçš„å­˜å‚¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€è¿‘è¯»å–çš„ä¼šæ”¾åœ¨æœ€å‰é¢ï¼Œæœ€ä¸å¸¸è¯»å–çš„ä¼šæ”¾åœ¨æœ€åŽã€‚å…¶æ¬¡ï¼ŒLinkedHashMap æœ‰ä¸€ä¸ªæ–¹æ³•ç”¨äºŽåˆ¤æ–­æ˜¯å¦éœ€è¦ç§»é™¤æœ€ä¸å¸¸è¯»å–çš„æ•°ï¼ŒåŽŸå§‹æ–¹æ³•é»˜è®¤ä¸éœ€è¦ç§»é™¤ï¼Œæ‰€ä»¥ï¼ŒLRU éœ€è¦ override è¿™ä¸ªæ–¹æ³•ï¼Œä½¿å¾—å½“ç¼“å­˜é‡Œå­˜æ”¾çš„æ•°æ®ä¸ªæ•°è¶…è¿‡è§„å®šä¸ªæ•°åŽï¼Œå°±æŠŠæœ€ä¸å¸¸ç”¨çš„ç§»é™¤æŽ‰ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import java.util.LinkedHashMap;import java.util.Collection;import java.util.Map;import java.util.ArrayList;/** * An LRU cache, based on &lt;code&gt;LinkedHashMap&lt;/code&gt;. * * &lt;p&gt; * This cache has a fixed maximum number of elements (&lt;code&gt;cacheSize&lt;/code&gt;). * If the cache is full and another entry is added, the LRU (least recently * used) entry is dropped. * * &lt;p&gt; * This class is thread-safe. All methods of this class are synchronized. * * &lt;p&gt; * Author: Christian d'Heureuse, Inventec Informatik AG, Zurich, Switzerland&lt;br&gt; * Multi-licensed: EPL / LGPL / GPL / AL / BSD. */public class LRUCache&lt;K, V&gt; &#123; private static final float hashTableLoadFactor = 0.75f; private LinkedHashMap&lt;K, V&gt; map; private int cacheSize; /** * Creates a new LRU cache. åœ¨è¯¥æ–¹æ³•ä¸­ï¼Œnew LinkedHashMap&lt;K,V&gt;(hashTableCapacity, * hashTableLoadFactor, true)ä¸­ï¼Œtrueä»£è¡¨ä½¿ç”¨è®¿é—®é¡ºåº * * @param cacheSize * the maximum number of entries that will be kept in this cache. */ public LRUCache(int cacheSize) &#123; this.cacheSize = cacheSize; int hashTableCapacity = (int) Math .ceil(cacheSize / hashTableLoadFactor) + 1; map = new LinkedHashMap&lt;K, V&gt;(hashTableCapacity, hashTableLoadFactor, true) &#123; // (an anonymous inner class) private static final long serialVersionUID = 1; @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; LRUCache.this.cacheSize; &#125; &#125;; &#125; /** * Retrieves an entry from the cache.&lt;br&gt; * The retrieved entry becomes the MRU (most recently used) entry. * * @param key * the key whose associated value is to be returned. * @return the value associated to this key, or null if no value with this * key exists in the cache. */ public synchronized V get(K key) &#123; return map.get(key); &#125; /** * Adds an entry to this cache. The new entry becomes the MRU (most recently * used) entry. If an entry with the specified key already exists in the * cache, it is replaced by the new entry. If the cache is full, the LRU * (least recently used) entry is removed from the cache. * * @param key * the key with which the specified value is to be associated. * @param value * a value to be associated with the specified key. */ public synchronized void put(K key, V value) &#123; map.put(key, value); &#125; /** * Clears the cache. */ public synchronized void clear() &#123; map.clear(); &#125; /** * Returns the number of used entries in the cache. * * @return the number of entries currently in the cache. */ public synchronized int usedEntries() &#123; return map.size(); &#125; /** * Returns a &lt;code&gt;Collection&lt;/code&gt; that contains a copy of all cache * entries. * * @return a &lt;code&gt;Collection&lt;/code&gt; with a copy of the cache content. */ public synchronized Collection&lt;Map.Entry&lt;K, V&gt;&gt; getAll() &#123; return new ArrayList&lt;Map.Entry&lt;K, V&gt;&gt;(map.entrySet()); &#125; // Test routine for the LRUCache class. public static void main(String[] args) &#123; LRUCache&lt;String, String&gt; c = new LRUCache&lt;String, String&gt;(3); c.put("1", "one"); // 1 c.put("2", "two"); // 2 1 c.put("3", "three"); // 3 2 1 c.put("4", "four"); // 4 3 2 if (c.get("2") == null) throw new Error(); // 2 4 3 c.put("5", "five"); // 5 2 4 c.put("4", "second four"); // 4 5 2 // Verify cache content. if (c.usedEntries() != 3) throw new Error(); if (!c.get("4").equals("second four")) throw new Error(); if (!c.get("5").equals("five")) throw new Error(); if (!c.get("2").equals("two")) throw new Error(); // List cache content. for (Map.Entry&lt;String, String&gt; e : c.getAll()) System.out.println(e.getKey() + " : " + e.getValue()); &#125;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java HashMap]]></title>
    <url>%2Fjava-HashMap%2F</url>
    <content type="text"><![CDATA[HashMapHashMap æ˜¯åŸºäºŽå“ˆå¸Œè¡¨çš„ Map æŽ¥å£çš„éžåŒæ­¥å®žçŽ°ã€‚æ­¤å®žçŽ°æä¾›æ‰€æœ‰å¯é€‰çš„æ˜ å°„æ“ä½œï¼Œå¹¶å…è®¸ä½¿ç”¨ null å€¼å’Œ null é”®ã€‚æ­¤ç±»ä¸ä¿è¯æ˜ å°„çš„é¡ºåºï¼Œç‰¹åˆ«æ˜¯å®ƒä¸ä¿è¯è¯¥é¡ºåºä¸æ˜¯stableçš„ã€‚HashMap åº•å±‚å°±æ˜¯ä¸€ä¸ªæ•°ç»„ç»“æž„ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸€é¡¹åˆæ˜¯ä¸€ä¸ªé“¾è¡¨ã€‚å½“æ–°å»ºä¸€ä¸ª HashMap çš„æ—¶å€™ï¼Œå°±ä¼šåˆå§‹åŒ–ä¸€ä¸ªæ•°ç»„table = new Entry[capacity];, æ¯ä¸ª Entry æ˜¯ä¸€ä¸ª key-value å¯¹ï¼Œæœ‰ä¸€ä¸ªæŒ‡å‘ä¸‹ä¸€ä¸ªå…ƒç´ çš„å¼•ç”¨ï¼Œè¿™å°±æž„æˆäº†é“¾è¡¨ã€‚123456789101112131415161718192021222324252627282930public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); init();&#125;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; â€¦â€¦&#125; HashMap åº•å±‚æ•°ç»„çš„é•¿åº¦æ€»æ˜¯ 2 çš„ n æ¬¡æ–¹ï¼Œè¿™æ˜¯ HashMap åœ¨é€Ÿåº¦ä¸Šçš„ä¼˜åŒ–, æ‰€ä»¥æœ‰è¿™æ®µä»£ç ä¿è¯åˆå§‹åŒ–æ—¶ HashMap çš„å®¹é‡æ€»æ˜¯ 2 çš„ n æ¬¡æ–¹ï¼Œå³åº•å±‚æ•°ç»„çš„é•¿åº¦æ€»æ˜¯ä¸º 2 çš„ n æ¬¡æ–¹ã€‚1234// Find a power of 2 &gt;= initialCapacityint capacity = 1;while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; æ’å…¥/æ›´æ–°å¦‚æžœ key å­˜åœ¨äº†ï¼Œé‚£ä¹ˆæ–°çš„ value ä¼šä»£æ›¿æ—§çš„ valueï¼Œå¹¶ä¸”å¦‚æžœ key å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œè¯¥æ–¹æ³•è¿”å›žçš„æ˜¯æ—§çš„ valueï¼Œå¦‚æžœ key ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆè¿”å›ž nullã€‚1234567891011121314151617181920212223242526272829303132333435/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */public V put(K key, V value) &#123; //å…¶å…è®¸å­˜æ”¾nullçš„keyå’Œnullçš„valueï¼Œå½“å…¶keyä¸ºnullæ—¶ï¼Œè°ƒç”¨putForNullKeyæ–¹æ³•ï¼Œæ”¾å…¥åˆ°table[0]çš„è¿™ä¸ªä½ç½® if (key == null) return putForNullKey(value); //é€šè¿‡è°ƒç”¨hashæ–¹æ³•å¯¹keyè¿›è¡Œå“ˆå¸Œï¼Œå¾—åˆ°å“ˆå¸Œä¹‹åŽçš„æ•°å€¼ã€‚è¯¥æ–¹æ³•å®žçŽ°å¯ä»¥é€šè¿‡çœ‹æºç ï¼Œå…¶ç›®çš„æ˜¯ä¸ºäº†å°½å¯èƒ½çš„è®©é”®å€¼å¯¹å¯ä»¥åˆ†ä¸åˆ°ä¸åŒçš„æ¡¶ä¸­ int hash = hash(key); //æ ¹æ®ä¸Šä¸€æ­¥éª¤ä¸­æ±‚å‡ºçš„hashå¾—åˆ°åœ¨æ•°ç»„ä¸­æ˜¯ç´¢å¼•i int i = indexFor(hash, table.length); //å¦‚æžœiå¤„çš„Entryä¸ä¸ºnullï¼Œåˆ™é€šè¿‡å…¶nextæŒ‡é’ˆä¸æ–­éåŽ†eå…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚ for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; å¾€ HashMap ä¸­ put å…ƒç´ çš„æ—¶å€™ï¼Œå…ˆæ ¹æ® key çš„ hashCode é‡æ–°è®¡ç®— hash å€¼ï¼Œæ ¹æ® hash å€¼å¾—åˆ°è¿™ä¸ªå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®ï¼ˆå³ä¸‹æ ‡ï¼‰ï¼Œå¦‚æžœæ•°ç»„è¯¥ä½ç½®ä¸Šå·²ç»å­˜æ”¾æœ‰å…¶ä»–å…ƒç´ äº†ï¼Œé‚£ä¹ˆåœ¨è¿™ä¸ªä½ç½®ä¸Šçš„å…ƒç´ å°†ä»¥é“¾è¡¨çš„å½¢å¼å­˜æ”¾ï¼Œæ–°åŠ å…¥çš„æ”¾åœ¨é“¾å¤´ï¼Œæœ€å…ˆåŠ å…¥çš„æ”¾åœ¨é“¾å°¾ã€‚å¦‚æžœæ•°ç»„è¯¥ä½ç½®ä¸Šæ²¡æœ‰å…ƒç´ ï¼Œå°±ç›´æŽ¥å°†è¯¥å…ƒç´ æ”¾åˆ°æ­¤æ•°ç»„ä¸­çš„è¯¥ä½ç½®ä¸Šã€‚ addEntry(hash, key, value, i)æ–¹æ³•æ ¹æ®è®¡ç®—å‡ºçš„ hash å€¼ï¼Œå°† key-value å¯¹æ”¾åœ¨æ•°ç»„ table çš„ i ç´¢å¼•å¤„ã€‚é¦–å…ˆè¦åˆ¤æ–­å®¹é‡å¦‚æžœè¶…è¿‡é˜ˆå€¼threshold, å¹¶ä¸”ç´¢å¼•ä½ç½®ä¸ä¸ºç©º, å°±è¦å…ˆæ‰©å®¹ï¼š1234567891011121314151617181920212223/** * Adds a new entry with the specified key, value and hash code to * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. */void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; // èŽ·å–æŒ‡å®š bucketIndex ç´¢å¼•å¤„çš„ Entry Entry&lt;K,V&gt; e = table[bucketIndex]; // å°†æ–°åˆ›å»ºçš„ Entry æ”¾å…¥ bucketIndex ç´¢å¼•å¤„ï¼Œå¹¶è®©æ–°çš„ Entry æŒ‡å‘åŽŸæ¥çš„ Entry e table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; hash(int h)æ–¹æ³•æ ¹æ® key çš„ hashCode é‡æ–°è®¡ç®—ä¸€æ¬¡æ•£åˆ—ã€‚æ­¤ç®—æ³•åŠ å…¥äº†é«˜ä½è®¡ç®—ï¼Œé˜²æ­¢ä½Žä½ä¸å˜ï¼Œé«˜ä½å˜åŒ–æ—¶ï¼Œé€ æˆçš„ hash å†²çªã€‚1234567891011121314final int hash(Object k) &#123; int h = 0; if (useAltHashing) &#123; if (k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h = hashSeed; &#125; //å¾—åˆ°kçš„hashcodeå€¼ h ^= k.hashCode(); //è¿›è¡Œè®¡ç®— h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; é«˜æ•ˆè®¡ç®—ç´¢å¼•æˆ‘ä»¬å¸Œæœ› HashMap é‡Œé¢å…ƒç´ ä½ç½®å°½é‡çš„åˆ†å¸ƒå‡åŒ€ï¼Œå°½é‡ä½¿å¾—æ¯ä¸ªä½ç½®ä¸Šçš„å…ƒç´ æ•°é‡åªæœ‰ä¸€ä¸ªï¼Œé‚£ä¹ˆå½“ç”¨ hash ç®—æ³•æ±‚å¾—è¿™ä¸ªä½ç½®çš„æ—¶å€™ï¼Œé©¬ä¸Šå°±å¯ä»¥çŸ¥é“å¯¹åº”ä½ç½®çš„å…ƒç´ ï¼Œè€Œä¸ç”¨å†åŽ»éåŽ†é“¾è¡¨ï¼Œè¿™æ ·å°±å¤§å¤§ä¼˜åŒ–äº†æŸ¥è¯¢çš„æ•ˆçŽ‡ã€‚ å¯¹äºŽä»»æ„ç»™å®šçš„å¯¹è±¡ï¼Œåªè¦å®ƒçš„ hashCode() è¿”å›žå€¼ç›¸åŒï¼Œé‚£ä¹ˆç¨‹åºè°ƒç”¨ hash(int h) æ–¹æ³•æ‰€è®¡ç®—å¾—åˆ°çš„ hash ç å€¼æ€»æ˜¯ç›¸åŒçš„ã€‚æˆ‘ä»¬é¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯æŠŠ hash å€¼å¯¹æ•°ç»„é•¿åº¦å–æ¨¡è¿ç®—ï¼Œè¿™æ ·ä¸€æ¥ï¼Œå…ƒç´ çš„åˆ†å¸ƒç›¸å¯¹æ¥è¯´æ˜¯æ¯”è¾ƒå‡åŒ€çš„ã€‚ä½†æ˜¯ï¼Œâ€œæ¨¡â€è¿ç®—çš„æ¶ˆè€—è¿˜æ˜¯æ¯”è¾ƒå¤§çš„ï¼Œåœ¨ HashMap ä¸­æ˜¯è¿™æ ·åšçš„ï¼šè°ƒç”¨ indexFor(int h, int length) æ–¹æ³•æ¥è®¡ç®—è¯¥å¯¹è±¡åº”è¯¥ä¿å­˜åœ¨ table æ•°ç»„çš„å“ªä¸ªç´¢å¼•å¤„ã€‚123456/** * Returns index for hash code h. */static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; å½“ length æ€»æ˜¯ 2 çš„ n æ¬¡æ–¹æ—¶ï¼Œh &amp; (length-1)è¿ç®—ç­‰ä»·äºŽå¯¹ length å–æ¨¡ï¼Œä¹Ÿå°±æ˜¯ h % lengthï¼Œä½†æ˜¯ä½è¿ç®—æ¯” % æ›´é«˜æ•ˆã€‚12345 hash table.length-18 &amp; (15-1)ï¼š 0100 &amp; 1110 = 01009 &amp; (15-1)ï¼š 0101 &amp; 1110 = 01008 &amp; (16-1)ï¼š 0100 &amp; 1111 = 01009 &amp; (16-1)ï¼š 0101 &amp; 1111 = 0101 15ä¸æ˜¯ä»¥2ä¸ºåº•çš„çœŸæ•°, 15-1 = 0b1110 æœ€åŽä¸€ä½æ°¸è¿œæ˜¯ 0, ä»»ä½•ä¸Žä¹‹&amp;çš„hashå€¼æœ€åŽä¸€ä½ä¹Ÿæ°¸è¿œæ˜¯0, è¿™å°±å¯¼è‡´ 0001ï¼Œ0011ï¼Œ0101ï¼Œ1001ï¼Œ1011ï¼Œ0111ï¼Œ1101 è¿™å‡ ä¸ªä½ç½®æ°¸è¿œéƒ½æ²¡æœºä¼šå­˜æ”¾å…ƒç´ äº†ï¼Œç©ºé—´æµªè´¹ç›¸å½“å¤§ï¼Œæ›´ç³Ÿçš„æ˜¯è¿™ç§æƒ…å†µä¸­ï¼Œæ•°ç»„å¯ä»¥ä½¿ç”¨çš„ä½ç½®æ¯”æ•°ç»„é•¿åº¦å°äº†å¾ˆå¤šï¼Œè¿™æ„å‘³ç€è¿›ä¸€æ­¥å¢žåŠ äº†ç¢°æ’žçš„å‡ çŽ‡ï¼Œå‡æ…¢äº†æŸ¥è¯¢çš„æ•ˆçŽ‡ï¼ è€Œå¦‚æžœlengthæ˜¯ä»¥2åº•çš„çœŸæ•°, å…¶äºŒè¿›åˆ¶é«˜ä½ä¸€å®šæ˜¯1, ä¸”åªæœ‰è¿™ä¸€ä¸ª1, å¦‚0b1000, é‚£ä¹ˆlength-1å°±ä¼šå˜æˆåªæœ‰è¯¥ä½ç½®æ˜¯0å…¶å³è¾¹ä½Žä½æ‰€æœ‰ä½å˜ä¸º1, å³0b0111. è¿™ä½¿å¾—åœ¨ä½Žä½ä¸Šä¸Žæ“ä½œæ—¶ï¼Œå¾—åˆ°çš„å’ŒåŽŸ hash çš„ä½Žä½ç›¸åŒ. åŠ ä¹‹ hash(int h)æ–¹æ³•å¯¹ key çš„ hashCode çš„è¿›ä¸€æ­¥ä¼˜åŒ–ï¼ŒåŠ å…¥äº†é«˜ä½è®¡ç®—ï¼Œå°±ä½¿å¾—åªæœ‰å®Œå…¨ç›¸åŒçš„ hash å€¼çš„ä¸¤ä¸ªkeyæ‰ä¼šè¢«æ”¾åˆ°æ•°ç»„ä¸­çš„åŒä¸€ä¸ªä½ç½®ä¸Šå½¢æˆé“¾è¡¨ã€‚æ‰€ä»¥å¦‚æžœæ•°ç»„é•¿åº¦ä¸º 2 çš„ n æ¬¡å¹‚çš„æ—¶å€™ï¼Œä¸åŒçš„ key ç®—å¾—å¾— index ç›¸åŒçš„å‡ çŽ‡è¾ƒå°ï¼Œé‚£ä¹ˆæ•°æ®åœ¨æ•°ç»„ä¸Šåˆ†å¸ƒå°±æ¯”è¾ƒå‡åŒ€ï¼Œä¹Ÿå°±æ˜¯è¯´ç¢°æ’žçš„å‡ çŽ‡å°ï¼Œç›¸å¯¹çš„ï¼ŒæŸ¥è¯¢çš„æ—¶å€™å°±ä¸ç”¨éåŽ†æŸä¸ªä½ç½®ä¸Šçš„é“¾è¡¨ï¼Œè¿™æ ·æŸ¥è¯¢æ•ˆçŽ‡ä¹Ÿå°±è¾ƒé«˜äº†ã€‚ å¦ä¸€ç§è®¡ç®—Hashçš„æ–¹æ³•: é€šè¿‡hashCode()çš„é«˜16ä½å¼‚æˆ–ä½Ž16ä½å®žçŽ°çš„ï¼š(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)ï¼Œä¸»è¦æ˜¯ä»Žé€Ÿåº¦ã€åŠŸæ•ˆã€è´¨é‡æ¥è€ƒè™‘çš„ï¼Œè¿™ä¹ˆåšå¯ä»¥åœ¨æ•°ç»„tableçš„lengthæ¯”è¾ƒå°çš„æ—¶å€™ï¼Œä¹Ÿèƒ½ä¿è¯è€ƒè™‘åˆ°é«˜ä½ŽBitéƒ½å‚ä¸Žåˆ°Hashçš„è®¡ç®—ä¸­ï¼ŒåŒæ—¶ä¸ä¼šæœ‰å¤ªå¤§çš„å¼€é”€ã€‚1234567//jdk1.8 &amp; jdk1.7static final int hash(Object key) &#123; int h; // h = key.hashCode() ä¸ºç¬¬ä¸€æ­¥ å–hashCodeå€¼ // h ^ (h &gt;&gt;&gt; 16) ä¸ºç¬¬äºŒæ­¥ é«˜ä½å‚ä¸Žè¿ç®— return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; ä¸€æ—¦å‡ºçŽ°é“¾è¡¨è¿‡é•¿ï¼Œä¸¥é‡å½±å“HashMapçš„æ€§èƒ½ï¼Œæ‰€ä»¥JDK1.8ç‰ˆæœ¬å¯¹æ•°æ®ç»“æž„åšäº†è¿›ä¸€æ­¥çš„ä¼˜åŒ–ï¼Œå¼•å…¥äº†çº¢é»‘æ ‘ã€‚å½“é“¾è¡¨é•¿åº¦å¤ªé•¿ï¼ˆé»˜è®¤è¶…è¿‡8ï¼‰æ—¶ï¼Œé“¾è¡¨å°±è½¬æ¢ä¸ºçº¢é»‘æ ‘ï¼Œåˆ©ç”¨çº¢é»‘æ ‘å¿«é€Ÿå¢žåˆ æ”¹æŸ¥çš„ç‰¹ç‚¹æé«˜HashMapçš„æ€§èƒ½ï¼Œå…¶ä¸­ä¼šç”¨åˆ°çº¢é»‘æ ‘çš„æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ç­‰ç®—æ³• è¯»å–ä»Ž HashMap ä¸­ get å…ƒç´ æ—¶ï¼Œé¦–å…ˆè®¡ç®— key çš„ hashCodeï¼Œæ‰¾åˆ°æ•°ç»„ä¸­å¯¹åº”ä½ç½®çš„æŸä¸€å…ƒç´ ï¼Œç„¶åŽé€šè¿‡ key çš„ equals æ–¹æ³•åœ¨å¯¹åº”ä½ç½®çš„é“¾è¡¨ä¸­æ‰¾åˆ°éœ€è¦çš„å…ƒç´ ã€‚1234567891011121314151617181920212223242526272829303132333435363738/** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null : * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise * it returns &#123;@code null&#125;. (There can be at most one such mapping.) * * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to &#123;@code null&#125;. * The &#123;@link #containsKey containsKey&#125; operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; resizerehashå½“ HashMap ä¸­çš„å…ƒç´ è¶Šæ¥è¶Šå¤šçš„æ—¶å€™ï¼Œhash å†²çªçš„å‡ çŽ‡ä¹Ÿå°±è¶Šæ¥è¶Šé«˜ï¼Œå› ä¸ºæ•°ç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„ã€‚æ‰€ä»¥ä¸ºäº†æé«˜æŸ¥è¯¢çš„æ•ˆçŽ‡ï¼Œå°±è¦å¯¹ HashMap çš„æ•°ç»„è¿›è¡Œæ‰©å®¹ã€‚ HashMap æ•°ç»„æ‰©å®¹ä¹‹åŽï¼Œæœ€æ¶ˆè€—æ€§èƒ½çš„ç‚¹å°±å‡ºçŽ°äº†ï¼šåŽŸæ•°ç»„ä¸­çš„æ•°æ®å¿…é¡»é‡æ–°è®¡ç®—å…¶åœ¨æ–°æ•°ç»„ä¸­çš„ä½ç½®ï¼Œå¹¶æ”¾è¿›åŽ»ï¼Œè¿™å°±æ˜¯ resizeã€‚ å½“ HashMap ä¸­çš„å…ƒç´ ä¸ªæ•°è¶…è¿‡æ•°ç»„å¤§å° * loadFactoræ—¶ï¼Œå°±ä¼šè¿›è¡Œæ•°ç»„æ‰©å®¹ï¼ŒloadFactorçš„é»˜è®¤å€¼ä¸º 0.75ï¼Œè¿™æ˜¯ä¸€ä¸ªæŠ˜ä¸­çš„å–å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œæ•°ç»„å¤§å°ä¸º 16ï¼Œé‚£ä¹ˆå½“ HashMap ä¸­å…ƒç´ ä¸ªæ•°è¶…è¿‡ 16*0.75=12 çš„æ—¶å€™ï¼Œå°±æŠŠæ•°ç»„çš„å¤§å°æ‰©å¤§ä¸€å€, æ‰©å±•ä¸º 2*16=32ï¼Œç„¶åŽé‡æ–°è®¡ç®—æ¯ä¸ªå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½®. æ‰€ä»¥å¦‚æžœæˆ‘ä»¬å·²ç»é¢„çŸ¥ HashMap ä¸­å…ƒç´ çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆé¢„è®¾å…ƒç´ çš„ä¸ªæ•°èƒ½å¤Ÿæœ‰æ•ˆçš„æé«˜ HashMap çš„æ€§èƒ½ã€‚ JDK1.7çš„HashMapåœ¨å®žçŽ°resize()æ—¶ï¼Œæ–°table[]çš„åˆ—è¡¨é‡‡ç”¨LIFOæ–¹å¼ï¼Œå³é˜Ÿå¤´æ’å…¥ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯é¿å…å°¾éƒ¨éåŽ†ã€‚1234567891011121314151617181920212223242526272829303132void resize(int newCapacity) &#123; //ä¼ å…¥æ–°çš„å®¹é‡ Entry[] oldTable = table; //å¼•ç”¨æ‰©å®¹å‰çš„Entryæ•°ç»„ int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //æ‰©å®¹å‰çš„æ•°ç»„å¤§å°å¦‚æžœå·²ç»è¾¾åˆ°æœ€å¤§(2^30)äº† threshold = Integer.MAX_VALUE; //ä¿®æ”¹é˜ˆå€¼ä¸ºintçš„æœ€å¤§å€¼(2^31-1)ï¼Œè¿™æ ·ä»¥åŽå°±ä¸ä¼šæ‰©å®¹äº† return; &#125; Entry[] newTable = new Entry[newCapacity]; //åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„Entryæ•°ç»„ transfer(newTable); //ï¼ï¼å°†æ•°æ®è½¬ç§»åˆ°æ–°çš„Entryæ•°ç»„é‡Œ table = newTable; //HashMapçš„tableå±žæ€§å¼•ç”¨æ–°çš„Entryæ•°ç»„ threshold = (int)(newCapacity * loadFactor);//ä¿®æ”¹é˜ˆå€¼&#125;// åŽŸEntryæ•°ç»„çš„å…ƒç´ æ‹·è´åˆ°æ–°çš„Entryæ•°ç»„é‡Œvoid transfer(Entry[] newTable) &#123; Entry[] src = table; //srcå¼•ç”¨äº†æ—§çš„Entryæ•°ç»„ int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //éåŽ†æ—§çš„Entryæ•°ç»„ Entry&lt;K,V&gt; e = src[j]; //å–å¾—æ—§Entryæ•°ç»„çš„æ¯ä¸ªå…ƒç´  if (e != null) &#123; src[j] = null;//é‡Šæ”¾æ—§Entryæ•°ç»„çš„å¯¹è±¡å¼•ç”¨ï¼ˆforå¾ªçŽ¯åŽï¼Œæ—§çš„Entryæ•°ç»„ä¸å†å¼•ç”¨ä»»ä½•å¯¹è±¡ï¼‰ do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //ï¼ï¼é‡æ–°è®¡ç®—æ¯ä¸ªå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½® e.next = newTable[i]; //æ ‡è®°[1], å˜ä¸ºå¤´èŠ‚ç‚¹ newTable[i] = e; //å°†å…ƒç´ æ”¾åœ¨æ•°ç»„ä¸Š e = next; //è®¿é—®ä¸‹ä¸€ä¸ªEntryé“¾ä¸Šçš„å…ƒç´  &#125; while (e != null); &#125; &#125; &#125; newTable[i]çš„å¼•ç”¨èµ‹ç»™äº†e.nextï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨äº†å•é“¾è¡¨çš„å¤´æ’å…¥æ–¹å¼ï¼ŒåŒä¸€ä½ç½®ä¸Šæ–°å…ƒç´ æ€»ä¼šè¢«æ”¾åœ¨é“¾è¡¨çš„å¤´éƒ¨ä½ç½®ï¼›è¿™æ ·å…ˆæ”¾åœ¨ä¸€ä¸ªç´¢å¼•ä¸Šçš„å…ƒç´ ç»ˆä¼šè¢«æ”¾åˆ°Entryé“¾çš„å°¾éƒ¨(å¦‚æžœå‘ç”Ÿäº†hashå†²çªçš„è¯ï¼‰ JDK1.8ä¼˜åŒ–äº†é‡æ–°è®¡ç®—hashè¿™ä¸€æ­¥ã€‚å› ä¸ºä½¿ç”¨çš„æ˜¯2æ¬¡å¹‚çš„æ‰©å±•(æŒ‡é•¿åº¦æ‰©ä¸ºåŽŸæ¥2å€)ï¼Œæ‰€ä»¥ï¼Œå…ƒç´ çš„ä½ç½®è¦ä¹ˆæ˜¯åœ¨åŽŸä½ç½®ï¼Œè¦ä¹ˆæ˜¯åœ¨åŽŸä½ç½®å†ç§»åŠ¨2æ¬¡å¹‚çš„ä½ç½®ã€‚å…ƒç´ åœ¨é‡æ–°è®¡ç®—hashä¹‹åŽï¼Œå› ä¸ºnå˜ä¸º2å€ï¼Œé‚£ä¹ˆn-1çš„maskèŒƒå›´åœ¨é«˜ä½å¤š1ä½. å› æ­¤ï¼Œåœ¨æ‰©å®¹HashMapçš„æ—¶å€™ï¼Œä¸éœ€è¦åƒJDK1.7çš„å®žçŽ°é‚£æ ·é‡æ–°è®¡ç®—hashï¼Œåªéœ€è¦çœ‹åŽŸæ¥çš„hashå€¼åœ¨æ–°å¢žçš„é‚£ä¸ªbitä½æ˜¯1è¿˜æ˜¯0å°±å¥½äº†ï¼Œæ˜¯0çš„è¯ç´¢å¼•æ²¡å˜ï¼Œæ˜¯1çš„è¯ç´¢å¼•å˜æˆåŽŸç´¢å¼•+oldCap. è¿™æ ·çœåŽ»äº†é‡æ–°è®¡ç®—hashå€¼çš„æ—¶é—´ï¼Œè€Œä¸”ç”±äºŽæ–°å¢žçš„1bitæ˜¯0è¿˜æ˜¯1å¯ä»¥è®¤ä¸ºæ˜¯éšæœºçš„ï¼Œå› æ­¤resizeçš„è¿‡ç¨‹ï¼Œå‡åŒ€çš„æŠŠä¹‹å‰çš„å†²çªçš„èŠ‚ç‚¹åˆ†æ•£åˆ°æ–°çš„bucketäº†ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// JDK1.8final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // è¶…è¿‡æœ€å¤§å€¼å°±ä¸å†æ‰©å……äº† if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // æ²¡è¶…è¿‡æœ€å¤§å€¼ï¼Œå°±æ‰©å……ä¸ºåŽŸæ¥çš„2å€ else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // è®¡ç®—æ–°çš„resizeä¸Šé™ if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // æŠŠæ¯ä¸ªbucketéƒ½ç§»åŠ¨åˆ°æ–°çš„bucketsä¸­ for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // åŽŸç´¢å¼• oldCap - 1: 0 1111 oldCap : 1 0000 åˆ¤æ–­ keyçš„ hashå€¼çš„é‚£ä¸€ä½æ˜¯å¦ä¸º1åˆ†ä¸ºä¸¤ç±» if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // åŽŸç´¢å¼•+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // åŽŸç´¢å¼•æ”¾åˆ°bucketé‡Œ if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // åŽŸç´¢å¼•+oldCapæ”¾åˆ°bucketé‡Œ if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; æ‰©å®¹çš„çº¿ç¨‹ä¸å®‰å…¨æ‰©å®¹æ—¶å­˜åœ¨æ¡ä»¶ç«žäº‰ï¼Œå¦‚æžœä¸¤ä¸ªçº¿ç¨‹éƒ½å‘çŽ°HashMapéœ€è¦è°ƒæ•´å¤§å°ï¼Œå®ƒä»¬ä¼šåŒæ—¶å°è¯•è°ƒæ•´å¤§å°ã€‚åœ¨è°ƒæ•´çš„è¿‡ç¨‹ä¸­ï¼Œä¸ºäº†é¿å…å°¾éƒ¨éåŽ†(tail traversing)è€Œé‡‡ç”¨é˜Ÿå¤´æ’å…¥çš„æ–¹å¼ï¼Œä¼šè®©åŽŸå…ˆçš„é“¾è¡¨é¡ºåºä¼šåè½¬ã€‚å¦‚æžœåœ¨å¤šçº¿ç¨‹çŽ¯å¢ƒä¸­å‘ç”Ÿæ¡ä»¶ç«žäº‰ï¼Œä¼šå¯¼è‡´æ­»å¾ªçŽ¯ã€‚å› æ­¤åœ¨å¹¶å‘çŽ¯å¢ƒä¸‹ï¼Œä½¿ç”¨CurrentHashMapæ¥æ›¿ä»£HashMap12345678910void transfer(Entry[] newTable) &#123; ... do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //ï¼ï¼é‡æ–°è®¡ç®—æ¯ä¸ªå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ä½ç½® e.next = newTable[i]; //æ ‡è®°[1], å˜ä¸ºå¤´èŠ‚ç‚¹ newTable[i] = e; //å°†å…ƒç´ æ”¾åœ¨æ•°ç»„ä¸Š e = next; //è®¿é—®ä¸‹ä¸€ä¸ªEntryé“¾ä¸Šçš„å…ƒç´  &#125; while (e != null); &#125; å¦‚æžœå½“ thread1 è¿è¡Œåˆ° int i = indexFor(e.hash, newCapacity);æ—¶e = key(3), next = key(7), è€Œthread2 å·²ç»æ‰§è¡Œå®Œæ¯•transfer(), æ­¤æ—¶çš„çŠ¶æ€æ˜¯.æ­¤æ—¶å®žé™…ä¸Šå·²ç»å®Œæˆäº†transfer()äº†, key(3)å’Œkey(7)é¡ºåºåè½¬äº†, key(7).next = key(3). ä½†thread1è¿˜æ²¡è·‘å®Œ, æ­¤æ—¶Thread1çš„ e = key(3)ï¼Œè€Œnext = key(7)ï¼ŒçŽ°åœ¨thread1ç»§ç»­è¿è¡Œ,1, e.next = newTable[i]; æ­¤æ—¶å°±æ˜¯æŠŠkey(3).nextæŒ‡å‘key(7), çŽ¯å½¢é“¾æŽ¥å‡ºçŽ°2, newTalbe[i] = e;, æŠŠkey(3)ç½®äºŽè¡¨å¤´. JDK1.8çš„ä¼˜åŒ–ï¼Œé€šè¿‡å¢žåŠ tailæŒ‡é’ˆï¼Œæ—¢é¿å…äº†æ­»å¾ªçŽ¯é—®é¢˜ï¼ˆè®©æ•°æ®ç›´æŽ¥æ’å…¥åˆ°é˜Ÿå°¾ï¼‰ï¼Œåˆé¿å…äº†å°¾éƒ¨éåŽ†ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/f4129fcfacdc/src/share/classes/java/util/HashMap.javafinal Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // è¶…è¿‡æœ€å¤§å€¼å°±ä¸å†æ‰©å……äº†ï¼Œå°±åªå¥½éšä½ ç¢°æ’žåŽ»å§ if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // æ²¡è¶…è¿‡æœ€å¤§å€¼ï¼Œå°±æ‰©å……ä¸ºåŽŸæ¥çš„2å€ else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // è®¡ç®—æ–°çš„resizeä¸Šé™ if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // æŠŠæ¯ä¸ªbucketéƒ½ç§»åŠ¨åˆ°æ–°çš„bucketsä¸­ for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // // æ–°æ‰©å®¹éƒ¨åˆ†ï¼Œæ ‡è¯†ä¸ºhiï¼ŒåŽŸæ¥oldçš„éƒ¨åˆ†æ ‡è¯†ä¸ºlo Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // åŽŸç´¢å¼• if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // åŽŸç´¢å¼•+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // åŽŸç´¢å¼•æ”¾åˆ°bucketé‡Œ if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // åŽŸç´¢å¼•+oldCapæ”¾åˆ°bucketé‡Œ if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMapæ€§èƒ½å‚æ•°HashMap åŒ…å«å¦‚ä¸‹å‡ ä¸ªæž„é€ å‡½æ•°ï¼š HashMap()ï¼šæž„å»ºä¸€ä¸ªåˆå§‹å®¹é‡ä¸º 16ï¼Œè´Ÿè½½å› å­ä¸º 0.75 çš„ HashMapã€‚ HashMap(int initialCapacity)ï¼šæž„å»ºä¸€ä¸ªåˆå§‹å®¹é‡ä¸º initialCapacityï¼Œè´Ÿè½½å› å­ä¸º 0.75 çš„ HashMapã€‚ HashMap(int initialCapacity, float loadFactor)ï¼šä»¥æŒ‡å®šåˆå§‹å®¹é‡ã€æŒ‡å®šçš„è´Ÿè½½å› å­åˆ›å»ºä¸€ä¸ª HashMapã€‚ è´Ÿè½½å› å­ loadFactor è¡¡é‡çš„æ˜¯ä¸€ä¸ªæ•£åˆ—è¡¨çš„ç©ºé—´çš„ä½¿ç”¨ç¨‹åº¦ï¼Œè´Ÿè½½å› å­è¶Šå¤§è¡¨ç¤ºæ•£åˆ—è¡¨çš„è£…å¡«ç¨‹åº¦è¶Šé«˜ï¼Œåä¹‹æ„ˆå°ã€‚å¯¹äºŽä½¿ç”¨é“¾è¡¨æ³•çš„æ•°ç»„æ¥è¯´ï¼ŒæŸ¥æ‰¾ä¸€ä¸ªå…ƒç´ çš„å¹³å‡æ—¶é—´æ˜¯ O(1+a)ï¼Œå› æ­¤å¦‚æžœè´Ÿè½½å› å­è¶Šå¤§ï¼Œå¯¹ç©ºé—´çš„åˆ©ç”¨æ›´å……åˆ†ï¼Œç„¶è€ŒåŽæžœæ˜¯æŸ¥æ‰¾æ•ˆçŽ‡çš„é™ä½Žï¼›å¦‚æžœè´Ÿè½½å› å­å¤ªå°ï¼Œé‚£ä¹ˆæ•°ç»„çš„æ•°æ®å°†è¿‡äºŽç¨€ç–ï¼Œå¯¹ç©ºé—´é€ æˆä¸¥é‡æµªè´¹ã€‚ HashMap çš„å®žçŽ°ä¸­ï¼Œé€šè¿‡ threshold å­—æ®µæ¥åˆ¤æ–­ HashMap çš„æœ€å¤§å®¹é‡ï¼šthreshold = (int) (capacity * loadFactor); threshold å°±æ˜¯åœ¨ç»™å®š loadFactor å’Œ capacity ä¸‹å…è®¸çš„æœ€å¤§å…ƒç´ æ•°ç›®ï¼Œè¶…è¿‡è¿™ä¸ªæ•°ç›®å°±é‡æ–° resizeï¼Œä»¥é™ä½Žå®žé™…çš„è´Ÿè½½å› å­ã€‚é»˜è®¤çš„çš„è´Ÿè½½å› å­ 0.75 æ˜¯å¯¹ç©ºé—´å’Œæ—¶é—´æ•ˆçŽ‡çš„ä¸€ä¸ªå¹³è¡¡é€‰æ‹©ã€‚å½“å®¹é‡è¶…å‡ºæ­¤æœ€å¤§å®¹é‡æ—¶ï¼Œ resize åŽçš„ HashMap å®¹é‡æ˜¯ç¿»å€. è¿­ä»£ä¸­çš„çº¿ç¨‹ä¸å®‰å…¨å¦‚æžœåœ¨ä½¿ç”¨è¿­ä»£å™¨çš„è¿‡ç¨‹ä¸­æœ‰å…¶ä»–çº¿ç¨‹ä¿®æ”¹äº† HashMapï¼Œé‚£ä¹ˆå°†æŠ›å‡ºConcurrentModificationExceptionï¼Œè¿™å°±æ˜¯æ‰€è°“ fail-fast ç­–ç•¥ã€‚Fail-fast æœºåˆ¶æ˜¯ java é›†åˆ(Collection)ä¸­çš„ä¸€ç§é”™è¯¯æœºåˆ¶ã€‚å½“å¤šä¸ªçº¿ç¨‹å¯¹åŒä¸€ä¸ªé›†åˆçš„å†…å®¹è¿›è¡Œæ“ä½œæ—¶ï¼Œå°±å¯èƒ½ä¼šäº§ç”Ÿ fail-fast äº‹ä»¶ã€‚ è¿™ä¸€ç­–ç•¥çš„å®žçŽ°æ˜¯é€šè¿‡ modCountå˜é‡ï¼Œå¯¹ HashMap å†…å®¹ï¼ˆå½“ç„¶ä¸ä»…ä»…æ˜¯ HashMap æ‰ä¼šæœ‰ï¼Œå…¶ä»–ä¾‹å¦‚ ArrayList ä¹Ÿä¼šï¼‰çš„ä¿®æ”¹éƒ½å°†å¢žåŠ è¿™ä¸ªå€¼ï¼ˆåœ¨å¾ˆå¤šæ“ä½œä¸­éƒ½æœ‰ modCount++ è¿™å¥ï¼‰ï¼Œé‚£ä¹ˆåœ¨è¿­ä»£å™¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­ä¼šå°†è¿™ä¸ªå€¼èµ‹ç»™è¿­ä»£å™¨çš„ expectedModCountã€‚12345678HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125;&#125; åœ¨è¿­ä»£è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­ modCount è·Ÿ expectedModCount æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æžœä¸ç›¸ç­‰å°±è¡¨ç¤ºå·²ç»æœ‰å…¶ä»–çº¿ç¨‹ä¿®æ”¹äº† Mapï¼šmodCount å£°æ˜Žä¸º volatileï¼Œä¿è¯çº¿ç¨‹ä¹‹é—´ä¿®æ”¹çš„å¯è§æ€§ã€‚1234final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; fail-fast æœºåˆ¶æ˜¯ä¸€ç§é”™è¯¯æ£€æµ‹æœºåˆ¶, å®ƒåªèƒ½è¢«ç”¨æ¥æ£€æµ‹é”™è¯¯ï¼Œå› ä¸º JDK å¹¶ä¸ä¿è¯ fail-fast æœºåˆ¶ä¸€å®šä¼šå‘ç”Ÿã€‚è‹¥åœ¨å¤šçº¿ç¨‹çŽ¯å¢ƒä¸‹ä½¿ç”¨ fail-fast æœºåˆ¶çš„é›†åˆï¼Œå»ºè®®ä½¿ç”¨java.util.concurrentåŒ…ä¸‹çš„ç±»ã€‚ HashMap çš„éåŽ†æ–¹å¼: ä½¿ç”¨entrySet()çš„éåŽ†æ•ˆçŽ‡è¾ƒé«˜1234567Map map = new HashMap(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); &#125; ä»€ä¹ˆwrapperç±»é€‚åˆä½œä¸ºé”®String, Interger.å› ä¸ºä¸å¯å˜æ€§è´¨, Stringæ˜¯ä¸å¯å˜çš„ï¼Œä¹Ÿæ˜¯finalçš„ï¼Œè€Œä¸”å·²ç»é‡å†™äº†equals()å’ŒhashCode()æ–¹æ³•äº†ã€‚å…¶ä»–çš„wrapperç±»ä¹Ÿæœ‰è¿™ä¸ªç‰¹ç‚¹ã€‚ ä¸å¯å˜æ€§æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºä¸ºäº†è¦è®¡ç®—hashCode()ï¼Œå°±è¦é˜²æ­¢é”®å€¼æ”¹å˜ï¼Œå¦‚æžœé”®å€¼åœ¨æ”¾å…¥æ—¶å’ŒèŽ·å–æ—¶è¿”å›žä¸åŒçš„hashcodeçš„è¯ï¼Œé‚£ä¹ˆå°±ä¸èƒ½ä»ŽHashMapä¸­æ‰¾åˆ°ä½ æƒ³è¦çš„å¯¹è±¡ã€‚ä¸å¯å˜æ€§è¿˜æœ‰å…¶ä»–çš„ä¼˜ç‚¹å¦‚çº¿ç¨‹å®‰å…¨ã€‚å¦‚æžœå¯ä»¥ä»…ä»…é€šè¿‡å°†æŸä¸ªfieldå£°æ˜Žæˆfinalå°±èƒ½ä¿è¯hashCodeæ˜¯ä¸å˜çš„ï¼Œé‚£ä¹ˆè¯·è¿™ä¹ˆåšå§ã€‚å› ä¸ºèŽ·å–å¯¹è±¡çš„æ—¶å€™è¦ç”¨åˆ°equals()å’ŒhashCode()æ–¹æ³•ï¼Œé‚£ä¹ˆé”®å¯¹è±¡æ­£ç¡®çš„é‡å†™è¿™ä¸¤ä¸ªæ–¹æ³•æ˜¯éžå¸¸é‡è¦çš„ã€‚å¦‚æžœä¸¤ä¸ªä¸ç›¸ç­‰çš„å¯¹è±¡è¿”å›žä¸åŒçš„hashcodeçš„è¯ï¼Œé‚£ä¹ˆç¢°æ’žçš„å‡ çŽ‡å°±ä¼šå°äº›ï¼Œè¿™æ ·å°±èƒ½æé«˜HashMapçš„æ€§èƒ½ å¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰çš„å¯¹è±¡ä½œä¸ºé”®ï¼Œåªè¦å®ƒéµå®ˆäº†equals()å’ŒhashCode()æ–¹æ³•çš„å®šä¹‰è§„åˆ™ï¼Œå¹¶ä¸”å½“å¯¹è±¡æ’å…¥åˆ°Mapä¸­ä¹‹åŽå°†ä¸ä¼šå†æ”¹å˜äº†ã€‚å¦‚æžœè¿™ä¸ªè‡ªå®šä¹‰å¯¹è±¡æ—¶ä¸å¯å˜çš„ï¼Œé‚£ä¹ˆå®ƒå·²ç»æ»¡è¶³äº†ä½œä¸ºé”®çš„æ¡ä»¶ï¼Œå› ä¸ºå½“å®ƒåˆ›å»ºä¹‹åŽå°±å·²ç»ä¸èƒ½æ”¹å˜äº†ã€‚ HashMapå’ŒHashTableçš„æ¯”è¾ƒå’ŒHash Tableçš„å‡è®¾ä¸€æ ·ï¼Œå‡å®šå“ˆå¸Œå‡½æ•°å°†å…ƒç´ é€‚å½“åœ°åˆ†å¸ƒåœ¨å„åŒºä¹‹é—´ï¼Œå¯ä¸ºåŸºæœ¬æ“ä½œï¼ˆget å’Œ putï¼‰æä¾›ç¨³å®šçš„æ€§èƒ½ã€‚ è·Ÿ Hash Table ç›¸æ¯”ï¼Œ Hash Mapçš„ä½œè€…å¤šäº† Doug Leaã€‚ä»–å†™äº†util.concurrentåŒ…ã€‚è‘—æœ‰å¹¶å‘ç¼–ç¨‹Concurrent Programming in Java: Design Principles and Patterns ä¸€ä¹¦ã€‚ Hashtableæ˜¯javaä¸€å¼€å§‹å‘å¸ƒæ—¶å°±æä¾›çš„é”®å€¼æ˜ å°„çš„æ•°æ®ç»“æž„ï¼Œä½†æ˜¯çŽ°åœ¨HashtableåŸºæœ¬ä¸Šå·²ç»è¢«å¼ƒç”¨äº†ã€‚è€Œäº§ç”ŸäºŽJDK1.2çš„HashMapå·²ç»æˆä¸ºåº”ç”¨æœ€ä¸ºå¹¿æ³›çš„ä¸€ç§æ•°æ®ç±»åž‹äº†ã€‚é€ æˆè¿™æ ·çš„åŽŸå› æ˜¯å› ä¸ºHashtableæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ˆåŒæ­¥çš„ï¼‰ï¼Œæ•ˆçŽ‡æ¯”è¾ƒä½Žã€‚ ç»§æ‰¿çš„çˆ¶ç±»ä¸ä¸€æ ·HashMapæ˜¯ç»§æ‰¿è‡ªAbstractMapç±»ï¼Œè€ŒHashTableæ˜¯ç»§æ‰¿è‡ªDictionaryç±»(Dictionaryç±»å·²ç»è¢«åºŸå¼ƒ)ã€‚ä¸è¿‡å®ƒä»¬éƒ½å®žçŽ°äº†åŒæ—¶å®žçŽ°äº†mapã€Cloneableã€Serializableè¿™ä¸‰ä¸ªæŽ¥å£ å¯¹å¤–æä¾›çš„æŽ¥å£ä¸åŒHashMapæ¯”Hashtableå°‘äº†elments()å’Œcontains()ä¸¤ä¸ªæ–¹æ³•ã€‚HashMap æœ‰containsKEY()å’ŒcontainsValue(), äº‹å®žä¸Šï¼ŒcontansValue()å°±æ˜¯è°ƒç”¨äº†contains()æ–¹æ³•ã€‚ å¯¹Nullçš„æ”¯æŒä¸åŒHashtableæ—¢ä¸æ”¯æŒNull keyä¹Ÿä¸æ”¯æŒNull valueã€‚HashMapä¸­ï¼Œnullå¯ä»¥ä½œä¸ºé”®ï¼Œè¿™æ ·çš„é”®åªæœ‰ä¸€ä¸ªï¼›å€¼å¯ä»¥ä¸ºnullä¸”ä¸åšæ•°é‡é™åˆ¶ã€‚å½“get()æ–¹æ³•è¿”å›žnullæ—¶ï¼Œå¯èƒ½æ˜¯ HashMap ä¸­æ²¡æœ‰è¯¥é”®ï¼Œä¹Ÿå¯èƒ½ä½¿è¯¥é”®æ‰€å¯¹åº”çš„å€¼ä¸ºnullã€‚å› æ­¤ï¼Œåœ¨HashMapä¸­ä¸èƒ½ç”±get()æ–¹æ³•æ¥åˆ¤æ–­HashMapä¸­æ˜¯å¦å­˜åœ¨æŸä¸ªé”®ï¼Œè€Œåº”è¯¥ç”¨containsKey()æ–¹æ³•æ¥åˆ¤æ–­ã€‚ çº¿ç¨‹å®‰å…¨æ€§ä¸åŒHashtableæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå®ƒçš„æ¯ä¸ªæ–¹æ³•ä¸­éƒ½åŠ å…¥äº†Synchronizeæ–¹æ³•ã€‚åœ¨å¤šçº¿ç¨‹å¹¶å‘çš„çŽ¯å¢ƒä¸‹ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨Hashtableï¼Œä¸éœ€è¦è‡ªå·±ä¸ºå®ƒçš„æ–¹æ³•å®žçŽ°åŒæ­¥. Hashmap ä¸æ˜¯åŒæ­¥çš„(ä¸æ˜¯çº¿ç¨‹å®‰å…¨)ï¼Œå¦‚æžœå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®ä¸€ä¸ª HashMapï¼Œè€Œå…¶ä¸­è‡³å°‘ä¸€ä¸ªçº¿ç¨‹ä»Žç»“æž„ä¸Šï¼ˆæŒ‡æ·»åŠ æˆ–è€…åˆ é™¤ä¸€ä¸ªæˆ–å¤šä¸ªæ˜ å°„å…³ç³»çš„ä»»ä½•æ“ä½œï¼‰ä¿®æ”¹äº†ï¼Œåˆ™å¿…é¡»ä¿æŒå¤–éƒ¨åŒæ­¥ï¼Œä»¥é˜²æ­¢å¯¹æ˜ å°„è¿›è¡Œæ„å¤–çš„éžåŒæ­¥è®¿é—®ã€‚ ç”±äºŽHashtableæ˜¯çº¿ç¨‹å®‰å…¨çš„ä¹Ÿæ˜¯synchronizedï¼Œæ‰€ä»¥åœ¨å•çº¿ç¨‹çŽ¯å¢ƒä¸‹å®ƒæ¯”HashMapè¦æ…¢ã€‚å¦‚æžœä¸éœ€è¦åŒæ­¥ï¼Œåªéœ€è¦å•ä¸€çº¿ç¨‹ï¼Œé‚£ä¹ˆä½¿ç”¨HashMapæ€§èƒ½è¦å¥½è¿‡Hashtableã€‚ åˆå§‹å®¹é‡å’Œæ‰©å®¹ä¸åŒHashtableé»˜è®¤çš„åˆå§‹å¤§å°ä¸º11ï¼Œä¹‹åŽæ¯æ¬¡æ‰©å……ï¼Œå®¹é‡å˜ä¸ºåŽŸæ¥çš„2n+1ã€‚HashMapé»˜è®¤çš„åˆå§‹åŒ–å¤§å°ä¸º16ã€‚ä¹‹åŽæ¯æ¬¡æ‰©å……ï¼Œå®¹é‡å˜ä¸ºåŽŸæ¥çš„2nã€‚ åˆ›å»ºæ—¶ï¼Œå¦‚æžœç»™å®šäº†å®¹é‡åˆå§‹å€¼ï¼Œé‚£ä¹ˆHashtableä¼šç›´æŽ¥ä½¿ç”¨ä½ ç»™å®šçš„å¤§å°ï¼Œè€ŒHashMapä¼šå°†å…¶æ‰©å……ä¸º2çš„å¹‚æ¬¡æ–¹å¤§å°ã€‚ä¹Ÿå°±æ˜¯è¯´Hashtableä¼šå°½é‡ä½¿ç”¨ç´ æ•°ã€å¥‡æ•°ã€‚è€ŒHashMapåˆ™æ€»æ˜¯ä½¿ç”¨2çš„å¹‚ä½œä¸ºå“ˆå¸Œè¡¨çš„å¤§å°ã€‚ ä¹‹æ‰€ä»¥ä¼šæœ‰è¿™æ ·çš„ä¸åŒï¼Œæ˜¯å› ä¸ºHashtableå’ŒHashMapè®¾è®¡æ—¶çš„ä¾§é‡ç‚¹ä¸åŒã€‚Hashtableçš„ä¾§é‡ç‚¹æ˜¯å“ˆå¸Œçš„ç»“æžœæ›´åŠ å‡åŒ€ï¼Œä½¿å¾—å“ˆå¸Œå†²çªå‡å°‘ã€‚å½“å“ˆå¸Œè¡¨çš„å¤§å°ä¸ºç´ æ•°æ—¶ï¼Œç®€å•çš„å–æ¨¡å“ˆå¸Œçš„ç»“æžœä¼šæ›´åŠ å‡åŒ€ã€‚è€ŒHashMapåˆ™æ›´åŠ å…³æ³¨hashçš„è®¡ç®—æ•ˆçŽ‡é—®é¢˜ã€‚åœ¨å–æ¨¡è®¡ç®—æ—¶ï¼Œå¦‚æžœæ¨¡æ•°æ˜¯2çš„å¹‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æŽ¥ä½¿ç”¨ä½è¿ç®—æ¥å¾—åˆ°ç»“æžœï¼Œæ•ˆçŽ‡è¦å¤§å¤§é«˜äºŽåšé™¤æ³•ã€‚HashMapä¸ºäº†åŠ å¿«hashçš„é€Ÿåº¦ï¼Œå°†å“ˆå¸Œè¡¨çš„å¤§å°å›ºå®šä¸ºäº†2çš„å¹‚ã€‚å½“ç„¶è¿™å¼•å…¥äº†å“ˆå¸Œåˆ†å¸ƒä¸å‡åŒ€çš„é—®é¢˜ï¼Œæ‰€ä»¥HashMapä¸ºè§£å†³è¿™é—®é¢˜ï¼Œåˆå¯¹hashç®—æ³•åšäº†ä¸€äº›æ”¹åŠ¨ã€‚è¿™ä»Žè€Œå¯¼è‡´äº†Hashtableå’ŒHashMapçš„è®¡ç®—hashå€¼çš„æ–¹æ³•ä¸åŒ è®¡ç®—hashçš„æ–¹æ³•ä¸åŒHashtableç›´æŽ¥ä½¿ç”¨å¯¹è±¡çš„hashCodeã€‚hashCodeæ˜¯JDKæ ¹æ®å¯¹è±¡çš„åœ°å€æˆ–è€…å­—ç¬¦ä¸²æˆ–è€…æ•°å­—ç®—å‡ºæ¥çš„intç±»åž‹çš„æ•°å€¼ã€‚ç„¶åŽå†ä½¿ç”¨å–ä½™æ•°èŽ·å¾—æœ€ç»ˆçš„ä½ç½®ã€‚12int hash = key.hashCode();int index = (hash &amp; 0x7FFFFFFF) % tab.length; Hashtableåœ¨è®¡ç®—å…ƒç´ çš„ä½ç½®æ—¶éœ€è¦è¿›è¡Œä¸€æ¬¡é™¤æ³•è¿ç®—ï¼Œè€Œé™¤æ³•è¿ç®—æ˜¯æ¯”è¾ƒè€—æ—¶çš„ã€‚ HashMapä¸ºäº†æé«˜è®¡ç®—æ•ˆçŽ‡ï¼Œå°†å“ˆå¸Œè¡¨çš„å¤§å°å›ºå®šä¸ºäº†2çš„å¹‚ï¼Œè¿™æ ·åœ¨å–æ¨¡é¢„ç®—æ—¶ï¼Œä¸éœ€è¦åšé™¤æ³•ï¼Œåªéœ€è¦åšä½è¿ç®—ã€‚ä½è¿ç®—æ¯”é™¤æ³•çš„æ•ˆçŽ‡è¦é«˜å¾ˆå¤šã€‚è¿™æ ·æ•ˆçŽ‡è™½ç„¶æé«˜äº†ï¼Œä½†æ˜¯hashå†²çªå´ä¹Ÿå¢žåŠ äº†ã€‚å› ä¸ºå®ƒå¾—å‡ºçš„hashå€¼çš„ä½Žä½ç›¸åŒçš„æ¦‚çŽ‡æ¯”è¾ƒé«˜ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒHashMapé‡æ–°æ ¹æ®hashcodeè®¡ç®—hashå€¼åŽï¼Œåˆå¯¹hashå€¼åšäº†ä¸€äº›è¿ç®—æ¥æ‰“æ•£æ•°æ®ã€‚ä½¿å¾—å–å¾—çš„ä½ç½®æ›´åŠ åˆ†æ•£ï¼Œä»Žè€Œå‡å°‘äº†hashå†²çªã€‚å½“ç„¶äº†ï¼Œä¸ºäº†é«˜æ•ˆï¼ŒHashMapåªåšäº†ä¸€äº›ç®€å•çš„ä½å¤„ç†ã€‚ä»Žè€Œä¸è‡³äºŽæŠŠä½¿ç”¨2 çš„å¹‚æ¬¡æ–¹å¸¦æ¥çš„æ•ˆçŽ‡æå‡ç»™æŠµæ¶ˆæŽ‰ã€‚1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; å‚è€ƒèµ„æ–™]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ï¼›åžƒåœ¾å›žæ”¶æœºåˆ¶]]></title>
    <url>%2Fjava-garbage-collection%2F</url>
    <content type="text"><![CDATA[åœ¨Javaä¸­ï¼ŒJVMè´Ÿè´£å†…å­˜åŠ¨æ€åˆ†é…å’Œåžƒåœ¾å›žæ”¶çš„é—®é¢˜ã€‚Javaçš„å¯¹è±¡å¿…é¡»è¦æœ‰å¼•ç”¨æ‰èƒ½è¢«ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æžœè¦æ“ä½œå¯¹è±¡ï¼Œå¿…é¡»é€šè¿‡å¼•ç”¨æ¥è¿›è¡Œã€‚å¦‚æžœä¸€ä¸ªå¯¹è±¡å”¯ä¸€çš„å¼•ç”¨å˜é‡æ­»äº†ï¼ˆéšç€å †æ ˆå—ä¸€èµ·è§£æ•£ï¼‰ï¼Œå¯¹è±¡å°±ä¼šè¢«è®¤å®šä¸ºå¯è¢«åžƒåœ¾å›žæ”¶ï¼ˆGarbage Collectionï¼‰çš„ã€‚æ²¡æœ‰è¢«å¼•ç”¨çš„å¯¹è±¡ï¼Œæ˜¯æ²¡æœ‰å­˜åœ¨æ„ä¹‰çš„ï¼Œå› ä¸ºæ²¡æœ‰äººçŸ¥é“å®ƒçš„åœ°å€ï¼Œæ— æ³•è°ƒç”¨å®ƒï¼Œå®ƒçš„å­˜åœ¨åªä¼šæµªè´¹ç©ºé—´ã€‚ç›®å‰å†…å­˜çš„åŠ¨æ€åˆ†é…å’Œå†…å­˜å›žæ”¶æŠ€æœ¯å·²ç»ç›¸å½“æˆç†Ÿï¼Œä½†è¿˜æ˜¯éœ€è¦äº†è§£GCå’Œå†…å­˜åˆ†é…ï¼Œè¿™æ ·å½“éœ€è¦æŽ’æŸ¥å„ç§å†…å­˜æº¢å‡ºã€å†…å­˜æ³„æ¼é—®é¢˜æ—¶ï¼Œå½“GCæˆä¸ºç³»ç»Ÿè¾¾åˆ°æ›´é«˜å¹¶å‘é‡çš„ç“¶é¢ˆæ—¶ï¼Œéœ€è¦å¯¹è¿™äº›è‡ªåŠ¨åŒ–çš„æŠ€æœ¯å®žæ–½å¿…è¦çš„ç›‘æŽ§å’Œè°ƒèŠ‚ã€‚ åˆ¤æ–­å¯¹è±¡æ˜¯å¦å¯å›žæ”¶æœ€ç®€å•çš„æ–¹æ³•æ˜¯é€šè¿‡å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰æ¥åˆ¤æ–­ä¸€ä¸ªå¯¹è±¡æ˜¯å¦å¯ä»¥è¢«å›žæ”¶ã€‚ä¸å¤±ä¸€èˆ¬æ€§ï¼Œå¦‚æžœä¸€ä¸ªå¯¹è±¡æ²¡æœ‰ä»»ä½•å¼•ç”¨ä¸Žä¹‹å…³è”ï¼Œé‚£ä¹ˆè¿™ä¸ªå¯¹è±¡å°±è¢«åˆ¤å®šä¸ºå¯è¢«å›žæ”¶çš„å¯¹è±¡äº†ã€‚è¿™ç§æ–¹å¼å®žçŽ°ç®€å•ï¼Œè€Œä¸”æ•ˆçŽ‡è¾ƒé«˜ï¼Œä½†æ˜¯å®ƒæ— æ³•è§£å†³å¯¹è±¡é—´å¾ªçŽ¯å¼•ç”¨çš„é—®é¢˜ï¼Œå› æ­¤åœ¨Javaä¸­å¹¶æ²¡æœ‰é‡‡ç”¨è¿™ç§æ–¹å¼ï¼ˆPythoné‡‡ç”¨çš„æ˜¯å¼•ç”¨è®¡æ•°æ³•ï¼‰ã€‚ ä¸»æµçš„å•†ç”¨ç¨‹åºè¯­è¨€ï¼ˆJavaï¼ŒC#ï¼ŒLispï¼‰çš„ä¸»æµå®žçŽ°ä¸­ï¼Œä½¿ç”¨å¯è¾¾æ€§åˆ†æžï¼ˆreachability analysisï¼‰æ¥åˆ¤å®šå¯¹è±¡æ˜¯å¦å­˜æ´»ã€‚ ä½¿ç”¨ä¸€äº›åˆ—GC Rootå¯¹è±¡ä½œä¸ºèµ·å§‹ç‚¹ï¼Œä»Žè¿™äº›èŠ‚ç‚¹å¼€å§‹å¾€ä¸‹æ²¿ç€å¼•ç”¨é“¾æœç´¢ï¼Œå¦‚æžœGC Rootåˆ°æŸä¸ªå¯¹è±¡æ— æ³•é€šè¿‡ä»»ä½•å¼•ç”¨é“¾é¡¹é“¾ï¼Œåˆ™è¯¥å¯¹è±¡ä¼šè¢«æ ‡è®°ä¸€æ¬¡, å¹¶ä¸”è¿›è¡Œä¸€æ¬¡ç­›é€‰, ç­›é€‰çš„æ¡ä»¶æ˜¯æ­¤å¯¹è±¡æ˜¯å¦æœ‰å¿…è¦æ‰§è¡Œfinalize()æ–¹æ³•. å½“å¯¹è±¡æ²¡æœ‰è¦†ç›–finalize()æ–¹æ³•, æˆ–è€…è¯¥æ–¹æ³•å·²ç»è¢«JVMè°ƒç”¨è¿‡, JVMéƒ½ä¼šè§†ä¹‹ä¸ºæ²¡æœ‰å¿…è¦æ‰§è¡Œfinalize()ã€‚ å¦‚æžœè¯¥å¯¹è±¡è¢«åˆ¤å®šä¸ºæœ‰å¿…è¦æ‰§è¡Œfinalize()æ–¹æ³•, é‚£ä¹ˆè¿™ä¸ªå¯¹è±¡ä¼šè¢«æ”¾ç½®åœ¨F-Queueé˜Ÿåˆ—ä¸­, å¹¶åœ¨ç¨åŽç”±ä¸€ä¸ªç”±JVMè‡ªåŠ¨å»ºç«‹çš„, ä½Žä¼˜å…ˆçº§çš„Finalizerçº¿ç¨‹åŽ»æ‰§è¡Œ. æ‰§è¡Œåªæ˜¯è§¦å‘è¯¥æ–¹æ³•, ä½†ä¸ä¼šç­‰å¾…å®ƒç»“æŸ, å› ä¸ºå¯èƒ½ä¼šæœ‰æ‰§è¡Œç¼“æ…¢æˆ–è€…æ­»å¾ªçŽ¯ç­‰ç‰¹æ®Šæƒ…å†µ ç¨åŽGCä¼šåŠ¨F-Queueé‡Œçš„å¯¹è±¡è¿›è¡Œç¬¬äºŒæ¬¡æ ‡è®°, å¦‚æžœå¯¹è±¡è¦åœ¨finalize()ä¸­é¿å…è¢«æ¶ˆç­, åªéœ€è¦é‡æ–°ä¸Žå¼•ç”¨é“¾ä¸Šçš„ä»»ä½•ä¸€ä¸ªå¯¹è±¡å»ºç«‹å…³è”å³å¯(finalize()çš„ä¼˜å…ˆçº§è¾ƒä½Ž), è¿™æ ·ç¬¬äºŒæ¬¡æ ‡è®°æ—¶å®ƒå°†ä¸ä¼šè¢«è€ƒè™‘. å¦åˆ™å°±åªèƒ½è¢«å›žæ”¶. è¦æ³¨æ„, ä»»ä½•ä¸€ä¸ªå¯¹è±¡çš„finalize()åªä¼šè¢«ç³»ç»Ÿè‡ªåŠ¨è°ƒç”¨ä¸€æ¬¡, ä¸‹æ¬¡å†GCæ—¶ä¸ä¼šå†æ‰§è¡Œ, ä¹Ÿå°±æ˜¯åªæœ‰ä¸€æ¬¡è‡ªæ•‘æœºä¼š. åœ¨Javaä¸­ï¼Œå¯ä½œä¸ºGC Rootsçš„å¯¹è±¡åŒ…æ‹¬ï¼š è™šæ‹Ÿæœºæ ˆï¼ˆæ ˆå¸§ä¸­çš„æœ¬åœ°å˜é‡è¡¨ï¼‰ä¸­å¼•ç”¨çš„å¯¹è±¡ã€‚ æ–¹æ³•åŒºä¸­ç±»é™æ€å±žæ€§å¼•ç”¨çš„å¯¹è±¡ æ–¹æ³•åŒºä¸­å¸¸é‡å¼•ç”¨çš„å¯¹è±¡ æœ¬åœ°æ–¹æ³•æ ˆä¸­nativeæ–¹æ³•å¼•ç”¨çš„å¯¹è±¡ å¼•ç”¨å¼•ç”¨åˆ†ä¸ºå¼ºå¼•ç”¨ï¼Œè½¯å¼•ç”¨ï¼Œå¼±å¼•ç”¨ï¼Œè™šå¼•ç”¨ã€‚æ ¹æ®ä¸åŒå¼•ç”¨ï¼Œæœ‰ä¸åŒçš„GCå›žæ”¶ç­–ç•¥ã€‚ å¼ºå¼•ç”¨ï¼šç±»ä¼¼Object obj = new Object();è¿™ç§, åžƒåœ¾å›žæ”¶å™¨æ°¸è¿œä¸ä¼šå›žæ”¶ä»–ä»¬ è½¯å¼•ç”¨ï¼šéžå¿…é¡»å¼•ç”¨ï¼Œå†…å­˜æº¢å‡ºä¹‹å‰è¿›è¡Œå›žæ”¶. å¦‚æžœè¿™æ¬¡å›žæ”¶åŽå†…å­˜è¿˜ä¸è¶³,æ‰ä¼šæŠ›å‡ºå†…å­˜æº¢å‡ºå¼‚å¸¸1234Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;sf.get();//æœ‰æ—¶å€™ä¼šè¿”å›žnull è½¯å¼•ç”¨ä¸»è¦ç”¨æˆ·å®žçŽ°ç±»ä¼¼ç¼“å­˜çš„åŠŸèƒ½ï¼Œåœ¨å†…å­˜è¶³å¤Ÿçš„æƒ…å†µä¸‹ç›´æŽ¥é€šè¿‡è½¯å¼•ç”¨å–å€¼ï¼Œæ— éœ€ä»Žç¹å¿™çš„çœŸå®žæ¥æºæŸ¥è¯¢æ•°æ®ï¼Œæå‡é€Ÿåº¦ï¼›å½“å†…å­˜ä¸è¶³æ—¶ï¼Œè‡ªåŠ¨åˆ é™¤è¿™éƒ¨åˆ†ç¼“å­˜æ•°æ®ï¼Œä»ŽçœŸæ­£çš„æ¥æºæŸ¥è¯¢è¿™äº›æ•°æ®ã€‚ å¼±å¼•ç”¨ï¼šéžå¿…é¡»å¼•ç”¨, å¼ºåº¦æ¯”è½¯å¼•ç”¨æ›´å¼±. å½“GCå·¥ä½œæ—¶, æ— è®ºå½“å‰å†…å­˜æ˜¯å¦è¶³å¤Ÿ, éƒ½ä¼šå›žæ”¶æŽ‰åªæœ‰å¼±å¼•ç”¨å…³è”çš„å¯¹è±¡.12345Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;wf.get();//æœ‰æ—¶å€™ä¼šè¿”å›žnullwf.isEnQueued();//è¿”å›žæ˜¯å¦è¢«åžƒåœ¾å›žæ”¶å™¨æ ‡è®°ä¸ºå³å°†å›žæ”¶çš„åžƒåœ¾ è™šå¼•ç”¨ï¼šå¹½çµå¼•ç”¨ï¼Œ æœ€å¼±çš„å¼•ç”¨å…³ç³»ã€‚æ— æ³•é€šè¿‡è™šå¼•ç”¨å–åˆ°å®žä¾‹ï¼Œä¸ºä¸€ä¸ªå¯¹è±¡è®¾ç½®è™šå¼•ç”¨å…³è”çš„å”¯ä¸€ç›®çš„æ˜¯åœ¨è¿™ä¸ªå¯¹è±¡è¢«æ”¶é›†å™¨å›žæ”¶æ—¶æ”¶åˆ°ä¸€ä¸ªç³»ç»Ÿé€šçŸ¥ã€‚12345Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj=null;pf.get();//æ°¸è¿œè¿”å›žnullpf.isEnQueued();//è¿”å›žæ˜¯å¦ä»Žå†…å­˜ä¸­å·²ç»åˆ é™¤ GCæ”¶é›†ç®—æ³•æ ‡è®°ï¼æ¸…é™¤ç®—æ³•Mask-Sweep åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼šæ ‡è®°é˜¶æ®µå’Œæ¸…é™¤é˜¶æ®µã€‚æ ‡è®°é˜¶æ®µçš„ä»»åŠ¡æ˜¯æ ‡è®°å‡ºæ‰€æœ‰éœ€è¦è¢«å›žæ”¶çš„å¯¹è±¡ï¼Œæ¸…é™¤é˜¶æ®µå°±æ˜¯å›žæ”¶è¢«æ ‡è®°çš„å¯¹è±¡æ‰€å ç”¨çš„ç©ºé—´ã€‚ ç¼ºç‚¹ï¼šæ•ˆçŽ‡ä½Žï¼›é‡Šæ”¾ç©ºé—´ä¸è¿žç»­å®¹æ˜“å¯¼è‡´å†…å­˜ç¢Žç‰‡ï¼›ä¼šåœæ­¢æ•´ä¸ªç¨‹åºè¿è¡Œï¼› æ ‡è®°-æ•´ç†ç®—æ³•Mark-Compact è¯¥ç®—æ³•æ ‡è®°é˜¶æ®µå’ŒMark-Sweepä¸€æ ·ï¼Œä½†æ˜¯åœ¨å®Œæˆæ ‡è®°ä¹‹åŽï¼Œå®ƒä¸æ˜¯ç›´æŽ¥æ¸…ç†å¯å›žæ”¶å¯¹è±¡ï¼Œè€Œæ˜¯å°†å­˜æ´»å¯¹è±¡éƒ½å‘ä¸€ç«¯ç§»åŠ¨ï¼Œç„¶åŽæ¸…ç†æŽ‰ç«¯è¾¹ç•Œä»¥å¤–çš„å†…å­˜ã€‚ å¤åˆ¶ç®—æ³•å°†å¯ç”¨å†…å­˜æŒ‰å®¹é‡åˆ’åˆ†ä¸ºå¤§å°ç›¸ç­‰çš„ä¸¤å—ï¼Œæ¯æ¬¡åªä½¿ç”¨å…¶ä¸­çš„ä¸€å—ã€‚å½“è¿™ä¸€å—çš„å†…å­˜ç”¨å®Œäº†ï¼Œå°±å°†è¿˜å­˜æ´»ç€çš„å¯¹è±¡å¤åˆ¶åˆ°å¦å¤–ä¸€å—ä¸Šé¢ï¼Œç„¶åŽå†æŠŠå·²ä½¿ç”¨çš„å†…å­˜ç©ºé—´ä¸€æ¬¡æ¸…ç†æŽ‰ï¼Œè¿™æ ·ä¸€æ¥å°±ä¸å®¹æ˜“å‡ºçŽ°å†…å­˜ç¢Žç‰‡çš„é—®é¢˜ã€‚è¿™ç§ç®—æ³•å¯¹å†…å­˜ç©ºé—´çš„ä½¿ç”¨åšäº†ä¸€åŠçš„ç‰ºç‰²ï¼Œæ•ˆçŽ‡è·Ÿå­˜æ´»å¯¹è±¡çš„æ•°ç›®å¤šå°‘æœ‰å¾ˆå¤§çš„å…³ç³»ï¼Œå¦‚æžœå­˜æ´»å¯¹è±¡å¾ˆå¤šï¼Œé‚£ä¹ˆCopyingç®—æ³•çš„æ•ˆçŽ‡å°†ä¼šå¤§å¤§é™ä½Žã€‚ çŽ°åœ¨çš„å•†ä¸šè™šæ‹Ÿæœºï¼ŒåŸºäºŽIBMçš„ç ”ç©¶å‡è®¾ï¼šæ–°ç”Ÿä»£ä¸­çš„å¯¹è±¡98%æ˜¯æœç”Ÿæš®æ­»çš„ï¼Œæ‰€ä»¥å¹¶ä¸éœ€è¦æŒ‰ç…§1:1åˆ’åˆ†å†…å­˜ï¼Œè€Œæ˜¯æŒ‰ç…§ä¸€å®šçš„æ¯”ä¾‹æŠŠå†…å­˜ç©ºé—´åˆ’åˆ†ä¸ºä¸€å—è¾ƒå¤§çš„Edenç©ºé—´ï¼ˆ80%ï¼‰å’Œä¸¤å—è¾ƒå°çš„Survivorç©ºé—´ï¼ˆ10%ï¼‰ï¼Œ æ¯æ¬¡ä½¿ç”¨Edenå’Œå…¶ä¸­ä¸€ä¸ªSurvivorã€‚æ‰€æœ‰å¯¹è±¡åˆ›å»ºåœ¨æ–°ç”Ÿä»£çš„EdenåŒºï¼Œå½“EdenåŒºæ»¡åŽè§¦å‘æ–°ç”Ÿä»£çš„Minor GCï¼Œå°†EdenåŒºå’Œéžç©ºé—²SurvivoråŒºå­˜æ´»çš„å¯¹è±¡å¤åˆ¶åˆ°å¦å¤–ä¸€ä¸ªç©ºé—²çš„SurvivoråŒºä¸­ï¼Œç„¶åŽå†æ¸…ç†æŽ‰åŽŸå…ˆçš„ç©ºé—´ã€‚è¿™æ ·ä¿è¯å…¶ä¸­ä¸€ä¸ªSurvivoråŒºæ˜¯ç©ºçš„ï¼Œæ–°ç”Ÿä»£Minor GCå°±æ˜¯åœ¨ä¸¤ä¸ªSurvivoråŒºä¹‹é—´ç›¸äº’å¤åˆ¶å­˜æ´»å¯¹è±¡ï¼Œç›´åˆ°SurvivoråŒºæ»¡ä¸ºæ­¢ã€‚ åˆ†ä»£æ”¶é›†ç®—æ³•Generational Collection æ˜¯ç›®å‰å¤§éƒ¨åˆ†JVMçš„åžƒåœ¾æ”¶é›†å™¨é‡‡ç”¨çš„ç®—æ³•ã€‚æ ¹æ®å¯¹è±¡å­˜æ´»çš„ç”Ÿå‘½å‘¨æœŸå°†å†…å­˜åˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªä¸åŒçš„åŒºåŸŸã€‚ä¸€èˆ¬æƒ…å†µä¸‹å°†å †åŒºåˆ’åˆ†ä¸ºè€å¹´ä»£ï¼ˆTenured Generationï¼‰å’Œæ–°ç”Ÿä»£ï¼ˆYoung Generationï¼‰ã€‚è€å¹´ä»£çš„ç‰¹ç‚¹æ˜¯æ¯æ¬¡åžƒåœ¾æ”¶é›†æ—¶åªæœ‰å°‘é‡å¯¹è±¡éœ€è¦è¢«å›žæ”¶ï¼Œè€Œæ–°ç”Ÿä»£çš„ç‰¹ç‚¹æ˜¯æ¯æ¬¡åžƒåœ¾å›žæ”¶æ—¶éƒ½æœ‰å¤§é‡çš„å¯¹è±¡æ­»äº¡ï¼Œé‚£ä¹ˆå°±å¯ä»¥æ ¹æ®ä¸åŒä»£çš„ç‰¹ç‚¹é‡‡å–æœ€é€‚åˆçš„æ”¶é›†ç®—æ³•ã€‚ ç›®å‰å¤§éƒ¨åˆ†åžƒåœ¾æ”¶é›†å™¨å¯¹äºŽæ–°ç”Ÿä»£éƒ½é‡‡å–Copyingç®—æ³•ï¼Œå› ä¸ºæ–°ç”Ÿä»£ä¸­æ¯æ¬¡åžƒåœ¾å›žæ”¶éƒ½è¦å›žæ”¶å¤§éƒ¨åˆ†å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯è¯´éœ€è¦å¤åˆ¶çš„æ“ä½œæ¬¡æ•°è¾ƒå°‘ã€‚ è€å¹´ä»£çš„ç‰¹ç‚¹æ˜¯æ¯æ¬¡å›žæ”¶éƒ½åªå›žæ”¶å°‘é‡å¯¹è±¡ï¼Œä¸€èˆ¬ä½¿ç”¨çš„æ˜¯Mark-Compactæˆ–è€…Mask-Sweepç®—æ³•ã€‚å½“æ–°ç”Ÿä»£SurvivoråŒºä¹Ÿæ»¡äº†ä¹‹åŽå°±é€šè¿‡Minor GCå°†å¯¹è±¡å¤åˆ¶åˆ°è€å¹´ä»£ã€‚è€å¹´ä»£ä¹Ÿæ»¡äº†çš„è¯ï¼Œå°±å°†è§¦å‘Full GCï¼Œé’ˆå¯¹æ•´ä¸ªå †ï¼ˆåŒ…æ‹¬æ–°ç”Ÿä»£ã€è€å¹´ä»£ã€æŒä¹…ä»£ï¼‰è¿›è¡Œåžƒåœ¾å›žæ”¶ã€‚ å †åŒºä¹‹å¤–è¿˜æœ‰ä¸€ä¸ªæ°¸ä¹…ä»£ï¼ˆPermanet Generationï¼‰ï¼Œå®ƒç”¨æ¥å­˜å‚¨classç±»ã€å¸¸é‡ã€æ–¹æ³•æè¿°ç­‰ã€‚å¯¹æ°¸ä¹…ä»£çš„å›žæ”¶ä¸»è¦å›žæ”¶ä¸¤éƒ¨åˆ†å†…å®¹ï¼šåºŸå¼ƒå¸¸é‡å’Œæ— ç”¨çš„ç±»ã€‚æŒä¹…ä»£å¦‚æžœæ»¡äº†ï¼Œå°†è§¦å‘Full GCã€‚ åžƒåœ¾æ”¶é›†å™¨åžƒåœ¾æ”¶é›†ç®—æ³•æ˜¯å†…å­˜å›žæ”¶çš„ç†è®ºåŸºç¡€ï¼Œè€Œåžƒåœ¾æ”¶é›†å™¨å°±æ˜¯å†…å­˜å›žæ”¶çš„å…·ä½“å®žçŽ°ã€‚JDK 7çš„HotSpotè™šæ‹Ÿæœºæä¾›å¤šç§åžƒåœ¾æ”¶é›†å™¨ï¼Œå¯ä»¥éœ€æ±‚ç»„åˆå‡ºå„ä¸ªå¹´ä»£ä½¿ç”¨çš„æ”¶é›†å™¨ã€‚ Serial/Serial Oldï¼šæœ€åŸºæœ¬æœ€å¤è€çš„æ”¶é›†å™¨ï¼Œå®ƒæ˜¯ä¸€ä¸ªå•çº¿ç¨‹æ”¶é›†å™¨ï¼Œå¹¶ä¸”åœ¨å®ƒè¿›è¡Œåžƒåœ¾æ”¶é›†æ—¶ï¼Œå¿…é¡»æš‚åœæ‰€æœ‰ç”¨æˆ·çº¿ç¨‹ã€‚Serialæ”¶é›†å™¨æ˜¯é’ˆå¯¹æ–°ç”Ÿä»£çš„æ”¶é›†å™¨ï¼Œé‡‡ç”¨çš„æ˜¯Copyingç®—æ³•ï¼ŒSerial Oldæ”¶é›†å™¨æ˜¯é’ˆå¯¹è€å¹´ä»£çš„æ”¶é›†å™¨ï¼Œé‡‡ç”¨çš„æ˜¯Mark-Compactç®—æ³•ã€‚å®ƒçš„ä¼˜ç‚¹æ˜¯å®žçŽ°ç®€å•é«˜æ•ˆï¼Œä½†æ˜¯ç¼ºç‚¹æ˜¯ä¼šç»™ç”¨æˆ·å¸¦æ¥åœé¡¿ã€‚ ParNewæ”¶é›†å™¨æ˜¯Serialæ”¶é›†å™¨çš„å¤šçº¿ç¨‹ç‰ˆæœ¬ï¼Œä½¿ç”¨å¤šä¸ªçº¿ç¨‹è¿›è¡Œåžƒåœ¾æ”¶é›†ã€‚ Parallel Scavengeæ”¶é›†å™¨æ˜¯ä¸€ä¸ªæ–°ç”Ÿä»£çš„å¤šçº¿ç¨‹æ”¶é›†å™¨ï¼ˆå¹¶è¡Œæ”¶é›†å™¨ï¼‰ï¼Œå®ƒåœ¨å›žæ”¶æœŸé—´ä¸éœ€è¦æš‚åœå…¶ä»–ç”¨æˆ·çº¿ç¨‹ï¼Œå…¶é‡‡ç”¨çš„æ˜¯Copyingç®—æ³•ï¼Œè¯¥æ”¶é›†å™¨ä¸Žå‰ä¸¤ä¸ªæ”¶é›†å™¨æœ‰æ‰€ä¸åŒï¼Œå®ƒä¸»è¦æ˜¯ä¸ºäº†è¾¾åˆ°ä¸€ä¸ªå¯æŽ§çš„åžåé‡ã€‚ Parallel Oldæ˜¯Parallel Scavengeæ”¶é›†å™¨çš„è€å¹´ä»£ç‰ˆæœ¬ï¼ˆå¹¶è¡Œæ”¶é›†å™¨ï¼‰ï¼Œä½¿ç”¨å¤šçº¿ç¨‹å’ŒMark-Compactç®—æ³•ã€‚ Current Mark Sweepï¼ˆCMSï¼‰æ”¶é›†å™¨æ˜¯ä¸€ç§ä»¥èŽ·å–æœ€çŸ­å›žæ”¶åœé¡¿æ—¶é—´ä¸ºç›®æ ‡çš„æ”¶é›†å™¨ï¼Œå®ƒæ˜¯ä¸€ç§å¹¶å‘æ”¶é›†å™¨ï¼Œé‡‡ç”¨çš„æ˜¯Mark-Sweepç®—æ³•ã€‚ G1æ”¶é›†å™¨æ˜¯å½“ä»Šæ”¶é›†å™¨æŠ€æœ¯å‘å±•æœ€å‰æ²¿çš„æˆæžœï¼Œå®ƒæ˜¯ä¸€æ¬¾é¢å‘æœåŠ¡ç«¯åº”ç”¨çš„æ”¶é›†å™¨ï¼Œå®ƒèƒ½å……åˆ†åˆ©ç”¨å¤šCPUã€å¤šæ ¸çŽ¯å¢ƒã€‚å› æ­¤å®ƒæ˜¯ä¸€æ¬¾å¹¶è¡Œä¸Žå¹¶å‘æ”¶é›†å™¨ï¼Œå¹¶ä¸”å®ƒèƒ½å»ºç«‹å¯é¢„æµ‹çš„åœé¡¿æ—¶é—´æ¨¡åž‹ã€‚ å†…å­˜åˆ†é…å¯¹è±¡çš„å†…å­˜åˆ†é…ï¼Œæ€»çš„æ¥è¯´å°±æ˜¯åœ¨å †ä¸Šåˆ†é…ï¼Œå¯¹è±¡ä¸»è¦åˆ†é…åœ¨æ–°ç”Ÿä»£çš„Eden Spaceå’ŒFrom Spaceï¼Œå°‘æ•°æƒ…å†µä¸‹ä¼šç›´æŽ¥åˆ†é…åœ¨è€å¹´ä»£ã€‚ å¯¹è±¡ä¼˜å…ˆåœ¨Edenåˆ†é…ã€‚ å¦‚æžœæ–°ç”Ÿä»£çš„Eden Spaceå’ŒFrom Spaceçš„ç©ºé—´ä¸è¶³ï¼Œåˆ™ä¼šå‘èµ·ä¸€æ¬¡Minor GCã€‚ åœ¨GCçš„è¿‡ç¨‹ä¸­ï¼Œä¼šå°†Eden Spaceå’ŒFrom Spaceä¸­çš„å­˜æ´»å¯¹è±¡ç§»åŠ¨åˆ°To Spaceï¼Œç„¶åŽå°†Eden Spaceå’ŒFrom Spaceè¿›è¡Œæ¸…ç†ã€‚ å¦‚æžœåœ¨æ¸…ç†çš„è¿‡ç¨‹ä¸­ï¼ŒTo Spaceæ— æ³•è¶³å¤Ÿæ¥å­˜å‚¨æŸä¸ªå¯¹è±¡ï¼Œå°±ä¼šå°†è¯¥å¯¹è±¡ç§»åŠ¨åˆ°è€å¹´ä»£ä¸­ã€‚ å¦‚æžœè¿›è¡Œäº†GCä¹‹åŽï¼ŒEden Spaceå’ŒFrom Spaceèƒ½å¤Ÿå®¹çº³è¯¥å¯¹è±¡å°±æ”¾åœ¨Eden Spaceå’ŒFrom Spaceã€‚ä¸‹æ¬¡GCæ—¶ä¼šå°†å­˜æ´»å¯¹è±¡å¤åˆ¶åˆ°From Spaceï¼Œå¦‚æ­¤åå¤å¾ªçŽ¯ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œå¤§å¯¹è±¡ä¼šè¢«ç›´æŽ¥åˆ†é…åˆ°è€å¹´ä»£ï¼Œæ‰€è°“çš„å¤§å¯¹è±¡æ˜¯æŒ‡éœ€è¦å¤§é‡è¿žç»­å­˜å‚¨ç©ºé—´çš„å¯¹è±¡ï¼Œæœ€å¸¸è§çš„ä¸€ç§å¤§å¯¹è±¡å°±æ˜¯å¤§æ•°ç»„ï¼Œæ¯”å¦‚ï¼šbyte[] data = new byte[4*1024*1024];è¿™ç§ä¸€èˆ¬ä¼šç›´æŽ¥åœ¨è€å¹´ä»£åˆ†é…å­˜å‚¨ç©ºé—´ã€‚ é•¿æœŸå­˜æ´»çš„å¯¹è±¡è¿›å…¥è€å¹´ä»£ã€‚è™šæ‹Ÿæœºç»™æ¯ä¸ªå¯¹è±¡å®šä¹‰äº†ä¸€ä¸ªå¯¹è±¡å¹´é¾„è®¡æ•°å™¨ï¼Œå¦‚å¯¹è±¡åœ¨SurvivoråŒºèº²è¿‡ä¸€æ¬¡GCçš„è¯ï¼Œå…¶å¯¹è±¡å¹´é¾„ä¾¿ä¼šåŠ 1ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æžœå¯¹è±¡å¹´é¾„è¾¾åˆ°15å²ï¼Œå°±ä¼šç§»åŠ¨åˆ°è€å¹´ä»£ä¸­ã€‚é˜ˆå€¼å¯ä»¥é€šè¿‡-XX : MaxTenuringThresholdè®¾ç½®. å¦‚æžœåœ¨Survivorç©ºé—´ä¸­ç›¸åŒå¹´é¾„çš„æ‰€æœ‰å¯¹è±¡å¤§å°çš„æ€»å’Œå¤§äºŽSurvivorç©ºé—´çš„ä¸€åŠï¼Œå¹´é¾„å¤§äºŽæˆ–ç­‰äºŽè¯¥å¹´é¾„çš„å¯¹è±¡å°±ç›´æŽ¥è¿›å…¥è€å¹´ä»£ï¼Œä¸å¿…ç­‰åˆ°MaxTenuringThreshold å½“ç„¶åˆ†é…çš„è§„åˆ™å¹¶ä¸æ˜¯ç™¾åˆ†ä¹‹ç™¾å›ºå®šçš„ï¼Œè¿™è¦å–å†³äºŽå½“å‰ä½¿ç”¨çš„æ˜¯å“ªç§åžƒåœ¾æ”¶é›†å™¨ç»„åˆå’ŒJVMçš„ç›¸å…³å‚æ•°ã€‚ å‚è€ƒèµ„æ–™æ·±å…¥ç†è§£Javaè™šæ‹Ÿæœº]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Hash Table]]></title>
    <url>%2Fjava-HashTable%2F</url>
    <content type="text"><![CDATA[Hash TablesSave items in a key-indexed table. Index is a function of the key - Hash function, method for computing array index from key. è¦å®žçŽ°å“ˆå¸Œè¡¨, éœ€è¦è§£å†³å‡ ä¸ªé—®é¢˜: å¦‚ä½•å®šä¹‰/è®¡ç®—å“ˆå¸Œå‡½æ•°ã€‚ ç›¸ç­‰åˆ¤å®šï¼šå¦‚ä½•æ£€æŸ¥ä¸¤ä¸ªé”®æ˜¯å¦ç›¸ç­‰ã€‚ å†²çªè§£å†³ï¼šå¯»æ‰¾èƒ½å¤Ÿå¤„ç†å“ˆå¸Œåˆ°åŒä¸€ç´¢å¼•çš„ä¸¤ä¸ªå¯†é’¥çš„ç®—æ³•å’Œæ•°æ®ç»“æž„ã€‚ æ—¶ç©ºæƒè¡¡è®¾è®¡é—®é¢˜: å¦‚æžœæ²¡æœ‰ç©ºé—´é™åˆ¶, é‚£ä¹ˆå¯ä»¥ä½¿ç”¨éžå¸¸ç®€å•çš„å“ˆå¸Œå‡½æ•°, æžç«¯æƒ…å†µå°±æ˜¯ç»™æ¯ä¸€ç§é”®åˆ†é…ä¸€ä¸ªç´¢å¼•ã€‚ å¦‚æžœæ²¡æœ‰æ—¶é—´é™åˆ¶, é‚£ä¹ˆå¯¹äºŽé”®å†²çªé—®é¢˜å¯ä»¥ä½¿ç”¨ç®€å•çš„é¡ºåºæœç´¢ã€‚ è€ŒçŽ°å®žä¸­, å“ˆå¸Œè¡¨å°±æ˜¯è§£å†³åŒæ—¶å­˜åœ¨ç©ºé—´å’Œæ—¶é—´é™åˆ¶çš„é—®é¢˜ã€‚ å“ˆå¸Œå‡½æ•°æœ€ç†æƒ³çš„ç›®æ ‡, ç”Ÿæˆå‡åŒ€åˆ†å¸ƒçš„ç´¢å¼•, è¿™æ ·è®¡ç®—é«˜æ•ˆ. æ¯”å¦‚ç”µè¯å·ç , ä½¿ç”¨å‰ä¸‰ä¸ªæ•°å­—ä½œä¸ºç´¢å¼•æ˜¯ä¸€ç§æ¯”è¾ƒè‰ç¨¿çš„è®¾è®¡, å› ä¸ºå‰ä¸‰ä¸ªæ•°å­—ä¸€èˆ¬ä»£è¡¨åŒºå·, ä¸”åŒºå·éƒ½æ˜¯æœ‰é™çš„, è¿™æ ·åŒä¸€ä¸ªåŒºçš„å·ç éƒ½ä¼šæŒ¤åœ¨åŒä¸€ä¸ªç´¢å¼•ä½ç½®. è¾ƒå¥½çš„æ–¹å¼æ˜¯ä½¿ç”¨åŽä¸‰ä½æ•°å­—. èº«ä»½è¯å·åŒç†. åœ¨å®žé™…è®¾è®¡è¿‡ç¨‹ä¸­, ä¸åŒçš„æ•°æ®ç±»åž‹é€‚ç”¨ä¸åŒçš„æ–¹æ³•. æ‰€æœ‰Javaç±»éƒ½ç»§æ‰¿äº†int hashCode()æ–¹æ³•. è¯¥æ–¹æ³•çš„åŸºæœ¬è¦æ±‚æ˜¯:If x.equals(y), then (x.hashCode() == y.hashCode())æœ€å¥½(ä½†ä¸æ˜¯å¿…é¡»çš„)èƒ½å¤Ÿæ»¡è¶³:If !x.equals(y), then (x.hashCode() != y.hashCode())é»˜è®¤çš„å®žçŽ°æ–¹å¼æ˜¯åˆ©ç”¨å†…å­˜ä½ç½®. Java integers, booleans, and doubles:1234567891011121314151617181920212223242526272829303132public final class Integer&#123; private final int value; ... public int hashCode() &#123; return value; &#125;&#125;public final class Boolean&#123; private final boolean value; ... public int hashCode() &#123; if (value) return 1231; else return 1237; &#125;&#125;// convert to IEEE 64-bit representation;// xor most significant 32-bits// with least significant 32-bitspublic final class Double&#123; private final double value; ... public int hashCode() &#123; long bits = doubleToLongBits(value); return (int) (bits ^ (bits &gt;&gt;&gt; 32)); &#125;&#125; strings123456789101112131415public final class String&#123; private int hash = 0; private final char[] s; ... public int hashCode() &#123; int h = hash; if (h != 0) return h; for (int i = 0; i &lt; length(); i++) hash = s[i] + (31 * h); hash = h; return h; &#125;&#125; Hornerâ€™s method to hash string of length L: L multiplies/adds$$h = s[0] \cdot 31^{L-1} + â€¦ + s[L-3] \cdot 31^2 + s[Lâ€“2] \cdot 31^1 + s[Lâ€“1]$$ String s = &quot;call&quot;; int code = s.hashCode();,$$code = 99 \cdot 31^3 + 97 \cdot 31^2 + 108 \cdot 31^1 + 108 = 3045982$$ â€œStandardâ€ recipe for user-defined types.ãƒ»Combine each significant field using the 31x + y rule.ãƒ»If field is a primitive type, use wrapper type hashCode().ãƒ»If field is null, return 0.ãƒ»If field is a reference type, use hashCode().ãƒ»If field is an array, apply to each entry, or use Arrays.deepHashCode(). Basic rule. Need to use the whole key to compute hash code; Modular hashingHash code. An int between $-2^{31}$ and $2^{31} - 1$.Hash function. An int between 0 and M - 1 (for use as array index, typically M is a prime or power of 2)A buggy version: 1-in-a-billion bug12private int hash(Key key)&#123; return Math.abs(key.hashCode()) % M; &#125; hashCode() of &quot;polygenelubricants&quot; is $-2^{31}$ A correct version12private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; é”®ç´¢å¼•å†²çªCollision. Two distinct keys hashing to same index. Separate chaining symbol tableUse an array of M &lt; N linked lists. (H. P. Luhn, IBM 1953) 1234567891011121314151617181920212223242526272829303132333435public class SeparateChainingHashST&lt;Key, Value&gt;&#123; private int M = 97; // number of chains private Node[] st = new Node[M]; // array of chains private static class Node &#123; private Object key; // no generic array creation private Object val; private Node next; public Node(Key key, Value val, Node next) &#123; this.key = key; this.val = val; this.next = next; &#125; &#125; private int hash(Key key) &#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; public Value get(Key key) &#123; int i = hash(key); for (Node x = st[i]; x != null; x = x.next) if (key.equals(x.key)) return (Value) x.val; return null; &#125; public void put(Key key, Value val) &#123; int i = hash(key); for (Node x = st[i]; x != null; x = x.next) if (key.equals(x.key)) &#123; x.val = val; return; &#125; st[i] = new Node(key, val, st[i]); //new key put ahead &#125;&#125; Proposition. Under uniform hashing assumption, prob. that the number of keys in a list is within a constant factor of N / M is extremely close to 1.Consequence. Number of probes for search/insert is proportional to N / M If M too large â‡’ too many empty chains. If M too small â‡’ chains too long. Typical choice: M ~ N / 5 â‡’ constant-time ops. Linear ProbingOpen addressing. (Amdahl-Boehme-Rocherster-Samuel, IBM 1953) When a new key collides, find next empty slot, and put it there. Hash. Map key to integer i between 0 and M-1.Insert. Put at table index i if free; if not try i+1, i+2, etcSearch. Search table index i; if occupied but no match, try i+1, i+2, etc. 12345678910111213141516171819202122232425public class LinearProbingHashST&lt;Key, Value&gt;&#123; private int M = 30001; private Value[] vals = (Value[]) new Object[M]; private Key[] keys = (Key[]) new Object[M]; private int hash(Key key) &#123; /* as before */ &#125; public Value get(Key key) &#123; for (int i = hash(key); keys[i] != null; i = (i+1) % M) if (key.equals(keys[i])) return vals[i]; return null; &#125; public void put(Key key, Value val) &#123; int i; for (i = hash(key); keys[i] != null; i = (i+1) % M) if (keys[i].equals(key)) break; keys[i] = key; vals[i] = val; &#125;&#125; Knuthâ€™s parking problem æä¾›äº†ä¸€ä¸ªç†è§£ linear probingçš„æ¨¡åž‹: Cars arrive at one-way street with M parking spaces. Each desires a random space i : if space i is taken, try i + 1, i + 2, etc. So what is mean displacement of a car? Half-full. With M / 2 cars, mean displacement is ~ 3 / 2.Full. With M cars, mean displacement is ~ sqrt(Ï€ M / 8) Proposition. Under uniform hashing assumption, the average # of probes in a linear probing hash table of size M that contains N = Î± M keys is:search hit ~ (1 + 1 / (1 - Î±)) / 2,search miss / insert $1/2 (1 + 1 / (1 - Î±)^ 2)$ Typical choice: Î± = N / M ~ Â½. So that # probes for search hit is about 3/2, # probes for search miss is about 5/2. ä¸åŒå“ˆå¸Œè¡¨å®žçŽ°æ¯”è¾ƒSeparate chaining.ãƒ»Easier to implement delete.ãƒ»Performance degrades gracefully.ãƒ»Clustering less sensitive to poorly-designed hash function. Linear probing.ãƒ»Less wasted space.ãƒ»Better cache performance. å…¶ä»–å˜ç§Two-probe hashing. (separate-chaining variant)ãƒ»Hash to two positions, insert key in shorter of the two chains.ãƒ»Reduces expected length of the longest chain to log log N Double hashing. (linear-probing variant)ãƒ»Use linear probing, but skip a variable amount, not just 1 each time.ãƒ»Effectively eliminates clustering.ãƒ»Can allow table to become nearly full.ãƒ»More difficult to implement delete. Cuckoo hashing. (linear-probing variant)ãƒ»Hash key to two positions; insert key into either position; if occupied,reinsert displaced key into its alternative position (and recur).ãƒ»Constant worst case time for search. å“ˆå¸Œè¡¨å’Œå¹³è¡¡äºŒå‰æ ‘çš„æ¯”è¾ƒHash tables.ãƒ»Simpler to code.ãƒ»No effective alternative for unordered keys.ãƒ»Faster for simple keys (a few arithmetic ops versus log N compares).ãƒ»Better system support in Java for strings (e.g., cached hash code). Balanced search trees.ãƒ»Stronger performance guarantee.ãƒ»Support for ordered ST operations.ãƒ»Easier to implement compareTo() correctly than equals() and hashCode(). Java system includes both.ãƒ»Red-black BSTs: java.util.TreeMap, java.util.TreeSet.ãƒ»Hash tables: java.util.HashMap, java.util.IdentityHashMap. æœ‰å…³å“ˆå¸Œè¡¨çš„æ”»å‡»å‡åŒ€å“ˆå¸Œå‡è®¾åœ¨å®žè·µä¸­æ˜¯å¦é‡è¦ï¼Ÿæ¶æ„æ”»å‡»è€…å­¦ä¹ ä½ çš„å“ˆå¸Œå‡½æ•°ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡é˜…è¯»Java APIï¼‰å¹¶å¯¼è‡´å•ä¸ªæ’æ§½å¤§é‡å †ç§¯ï¼Œä»Žè€Œä½¿æ€§èƒ½åœæ»žä¸å‰ æ¡ˆä¾‹: BroæœåŠ¡å™¨ï¼šä½¿ç”¨æ¯”æ‹¨å·è°ƒåˆ¶è§£è°ƒå™¨æ›´å°‘çš„å¸¦å®½ï¼Œå°†ç²¾å¿ƒé€‰æ‹©çš„æ•°æ®åŒ…å‘é€åˆ°DOSæœåŠ¡å™¨ã€‚ Perl 5.8.0ï¼šå°†ç²¾å¿ƒæŒ‘é€‰çš„å­—ç¬¦ä¸²æ’å…¥å…³è”æ•°ç»„ä¸­ã€‚ Linux 2.4.20å†…æ ¸ï¼šä½¿ç”¨ç²¾å¿ƒé€‰æ‹©çš„åç§°ä¿å­˜æ–‡ä»¶ã€‚ å•å‘å“ˆå¸Œå‡½æ•°, ä½¿å¾—æ‰¾åˆ°ä¸€ä¸ªé”®å¯¹åº”çš„å“ˆå¸Œå€¼ï¼ˆæˆ–ä¸¤ä¸ªå“ˆå¸Œåˆ°ç›¸åŒå€¼çš„é”®ï¼‰å˜å¾—å›°éš¾. å¦‚å·²çŸ¥æ˜¯ä¸å®‰å…¨çš„MD4, MD5, SHA-0å’ŒSHA-1. å…¶ä»–çš„è¿˜æœ‰SHA-2, WHIRLPOOL, RIPEMD-160, â€¦.1234/* prints bytes as hex string */String password = args[0];MessageDigest sha1 = MessageDigest.getInstance("SHA1");byte[] bytes = sha1.digest(password); è¿™ç§å“ˆå¸Œå‡½æ•°å¯¹äºŽç¬¦å·è¡¨è€Œè¨€æœ‰ç‚¹è¿‡äºŽæ˜‚è´µäº† Bit MapBit-mapç”¨ä¸€ä¸ªbitä½æ¥æ ‡è®°æŸä¸ªå…ƒç´ å¯¹åº”çš„Valueï¼Œ è€ŒKeyå³æ˜¯è¯¥å…ƒç´ ã€‚ç”±äºŽé‡‡ç”¨äº†Bitä¸ºå•ä½æ¥å­˜å‚¨æ•°æ®ï¼Œå› æ­¤åœ¨å­˜å‚¨ç©ºé—´æ–¹é¢ï¼Œå¯ä»¥å¤§å¤§èŠ‚çœã€‚ å‡è®¾æˆ‘ä»¬è¦å¯¹0-7å†…çš„5ä¸ªå…ƒç´ 4,7,2,5,3æŽ’åºï¼ˆå‡è®¾è¿™äº›å…ƒç´ æ²¡æœ‰é‡å¤ï¼‰ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥é‡‡ç”¨Bit-mapçš„æ–¹æ³•æ¥è¾¾åˆ°æŽ’åºçš„ç›®çš„ã€‚è¦è¡¨ç¤º8ä¸ªæ•°ï¼Œæˆ‘ä»¬å°±åªéœ€è¦8ä¸ªBitï¼ˆ1Bytesï¼‰ï¼Œ é¦–å…ˆæˆ‘ä»¬å¼€è¾Ÿ1Byteçš„ç©ºé—´ï¼Œå°†è¿™äº›ç©ºé—´çš„æ‰€æœ‰Bitä½éƒ½ç½®ä¸º0ï¼Œ0 0 0 0 0 0 0 0. ç„¶åŽéåŽ†è¿™5ä¸ªå…ƒç´ ï¼Œé¦–å…ˆç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯4ï¼Œé‚£ä¹ˆå°±æŠŠ4å¯¹åº”çš„ä½ç½®è®¾ä¸º1, p+(i/8)|(0x01&lt;&lt;(i%8)), è¿™é‡Œé»˜è®¤ä¸ºBig-ending, 0 0 0 0 1 0 0 0. ç„¶åŽå†å¤„ç†ç¬¬äºŒä¸ªå…ƒç´ 7ï¼Œå°†ç¬¬å…«ä½ç½®ä¸º1,ï¼ŒæŽ¥ç€å†å¤„ç†ç¬¬ä¸‰ä¸ªå…ƒç´ ï¼Œä¸€ç›´åˆ°æœ€åŽå¤„ç†å®Œæ‰€æœ‰çš„å…ƒç´ ï¼Œå°†ç›¸åº”çš„ä½ç½®ä¸º1ï¼Œè¿™æ—¶å€™çš„å†…å­˜çš„Bitä½çš„çŠ¶æ€0 0 1 1 1 1 0 1 éåŽ†ä¸€éBitåŒºåŸŸï¼ŒæŠŠ1çš„ç´¢å¼•ä¾æ¬¡è¾“å‡ºï¼ˆ2ï¼Œ3ï¼Œ4ï¼Œ5ï¼Œ7ï¼‰ï¼Œè¿™æ ·å°±è¾¾åˆ°äº†æŽ’åºçš„ç›®çš„ã€‚ ç®—æ³•çš„å…³é”®æ˜¯å¦‚ä½•ç¡®å®šåè¿›åˆ¶çš„æ•°æ˜ å°„åˆ°äºŒè¿›åˆ¶bitä½çš„mapå›¾ã€‚ç®—æ³•å ç”¨å¾ˆå°‘å†…å­˜ï¼Œæ¯”å¦‚N=10000000ï¼›åªéœ€å ç”¨å†…å­˜ä¸ºN/8=1250000Byte=1.25Mã€‚ç¼ºç‚¹æ˜¯ä¸èƒ½æœ‰é‡å¤æ•°æ®ã€‚ Mapæ˜ å°„è¡¨å‡è®¾éœ€è¦æŽ’åºæˆ–è€…æŸ¥æ‰¾çš„æ€»æ•°N=10000000ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ç”³è¯·å†…å­˜ç©ºé—´çš„å¤§å°ä¸ºint a[1 + N/32]ï¼Œå…¶ä¸­ï¼ša[0]åœ¨å†…å­˜ä¸­å 32ä½, å¯ä»¥å¯¹åº”åè¿›åˆ¶æ•°0-31ï¼Œä¾æ¬¡ç±»æŽ¨ï¼šbitmapè¡¨ä¸ºï¼š12345a[0]---------&gt;0-31a[1]---------&gt;32-63a[2]---------&gt;64-95a[3]---------&gt;96-127.......... åè¿›åˆ¶æ•°éœ€è¦è½¬æ¢ä¸ºå¯¹åº”çš„bitä½ ä½ç§»è½¬æ¢å°†åè¿›åˆ¶æ•°è½¬æ¢ä¸ºå¯¹åº”çš„bitä½, ç”³è¯·ä¸€ä¸ªintä¸€ç»´æ•°ç»„ï¼Œä½œä¸º32åˆ—çš„äºŒç»´æ•°ç»„ï¼Œ1234567int a[0] |0000000000000000000000000000000000000|int a[1] |0000000000000000000000000000000000000|â€¦â€¦â€¦â€¦â€¦â€¦int a[N] |0000000000000000000000000000000000000| ä¾‹å¦‚åè¿›åˆ¶0ï¼Œå¯¹åº”åœ¨a[0]ç¬¬ä¸€ä½ï¼š 00000000000000000000000000000001 æ±‚åè¿›åˆ¶0-Nå¯¹åº”åœ¨æ•°ç»„açš„ç´¢å¼•ï¼šåè¿›åˆ¶0-31ï¼Œå¯¹åº”a[0]ï¼Œå…ˆç”±åè¿›åˆ¶æ•°nè½¬æ¢ä¸ºä¸Ž32çš„ä½™å¯è½¬åŒ–ä¸ºå¯¹åº”åœ¨æ•°ç»„aä¸­çš„ç´¢å¼•0ã€‚æ¯”å¦‚n=24,é‚£ä¹ˆ n/32=0ï¼Œåˆ™24å¯¹åº”a[0]ã€‚åˆæ¯”å¦‚n=60, é‚£ä¹ˆn/32=1ï¼Œåˆ™60å¯¹åº”a[1]ã€‚ æ±‚0-Nå¯¹åº”0-31ä¸­çš„æ•°ï¼šåè¿›åˆ¶0-31å°±å¯¹åº”0-31ï¼Œè€Œ32-63åˆ™å¯¹åº”ä¹Ÿæ˜¯0-31ï¼Œå³ç»™å®šä¸€ä¸ªæ•°nå¯ä»¥é€šè¿‡æ¨¡32æ±‚å¾—å¯¹åº”0-31ä¸­çš„æ•°ã€‚ åˆ©ç”¨ç§»ä½0-31ä½¿å¾—å¯¹åº”32bitä½ä¸º1. æ‰¾åˆ°å¯¹åº”0-31çš„æ•°ä¸ºM, å·¦ç§»Mä½ï¼šå³2 ^ M, ç½®1. Bloom Filterä¸ºäº†é™ä½Žé”®å€¼å†²çªçš„æ¦‚çŽ‡ï¼ŒBloom Filterä½¿ç”¨äº†å¤šä¸ªå“ˆå¸Œå‡½æ•°ï¼šåˆ›å»ºä¸€ä¸ªmä½BitSetï¼Œå…ˆå°†æ‰€æœ‰ä½åˆå§‹åŒ–ä¸º0ï¼Œç„¶åŽé€‰æ‹©kä¸ªä¸åŒçš„å“ˆå¸Œå‡½æ•°ã€‚ç¬¬iä¸ªå“ˆå¸Œå‡½æ•°å¯¹å­—ç¬¦ä¸²strå“ˆå¸Œçš„ç»“æžœè®°ä¸ºh(i, str)ï¼Œä¸”h(i, str)çš„èŒƒå›´æ˜¯0åˆ°m-1 ã€‚ å¯¹äºŽå­—ç¬¦ä¸²strï¼Œåˆ†åˆ«è®¡ç®—h(1, str), h(2, str), ... h(k, str), ä»¥è¿™äº›å“ˆå¸Œå€¼ä½œä¸ºç´¢å¼•, å°†BitSetçš„å¯¹åº”ä½ç½®çš„ä½è®¾ä¸º1, è¿™æ ·å°±æŠŠstræ˜ å°„åˆ°BitSetçš„kä¸ªäºŒè¿›åˆ¶ä½äº†. å¦‚æžœè¦æ£€æŸ¥æŸstringæ˜¯å¦å·²ç»è¢«è®°å½•åœ¨BitSetä¸­, åªéœ€è¦è®¡ç®—å…¶å“ˆå¸Œå€¼æ•°ç»„, å¹¶æ£€æŸ¥BitSetä¸Šå¯¹åº”ä½ç½®çš„å€¼æ˜¯å¦ä¸º1, è‹¥å¯¹åº”ä½ç½®ä¸­æœ‰ä»»ä½•ä¸€ä¸ªä¸æ˜¯1, é‚£ä¹ˆè¯¥å­—ç¬¦ä¸²ä¸€å®šæ²¡æœ‰è¢«è®°å½•è¿‡, è‹¥å…¨éƒ¨å¯¹åº”ä½ç½®éƒ½ä¸º1, é‚£ä¹ˆæŒ‰ç…§false positiveè®¤ä¸ºè¯¥å­—ç¬¦ä¸²å·²ç»è¢«è®°å½•è¿‡äº†(ä½†ä¸æ˜¯100%è‚¯å®š). åˆ é™¤æ“ä½œä¼šå½±å“åˆ°å…¶ä»–å­—ç¬¦ä¸²ã€‚å¦‚æžœéœ€è¦åˆ é™¤å­—ç¬¦ä¸²çš„åŠŸèƒ½ï¼Œä½¿ç”¨Counting bloomfilter(CBF)ï¼Œè¿™æ˜¯ä¸€ç§Bloom Filterçš„å˜ä½“ï¼ŒCBFå°†Bloom Filteræ¯ä¸€ä¸ªBitæ”¹ä¸ºä¸€ä¸ªè®¡æ•°å™¨ï¼Œè¿™æ ·å°±å¯ä»¥å®žçŽ°åˆ é™¤å­—ç¬¦ä¸²çš„åŠŸèƒ½äº†ã€‚ Bloom Filterè·Ÿå•å“ˆå¸Œå‡½æ•°Bit-Mapä¸åŒä¹‹å¤„åœ¨äºŽï¼šBloom Filterä½¿ç”¨äº†kä¸ªå“ˆå¸Œå‡½æ•°ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²è·Ÿkä¸ªbitå¯¹åº”ã€‚ä»Žè€Œé™ä½Žäº†å†²çªçš„æ¦‚çŽ‡ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java æ ¼å¼]]></title>
    <url>%2Fjava-formatting%2F</url>
    <content type="text"><![CDATA[Javaæ ¼å¼åŒ–æŒ‡ä»¤â€è·Ÿåœ¨%åŽé¢çš„éƒ½æ˜¯æ ¼å¼åŒ–æŒ‡ä»¤.% [argument number] [flags] [width] [.precision] type[]å†…éƒ½æ˜¯é€‰æ‹©æ€§çš„å‚æ•°, ä¸”å¿…é¡»æŒ‰ç…§é¡ºåº. argument number å½“è¦æ ¼å¼åŒ–çš„å‚æ•°è¶…è¿‡ä¸€ä¸ª, è¿™é‡ŒæŒ‡å®šæ˜¯å“ªä¸€ä¸ª flags ç‰¹å®šç±»åž‹çš„ç‰¹å®šé€‰é¡¹, å¦‚æ•°å­—æ˜¯å¦è¦åŠ é€—å·æˆ–æ­£è´Ÿå· width æœ€å°çš„å­—ç¬¦æ•°. ä½†ä¸æ˜¯æ€»æ•°, è¾“å‡ºå¯ä»¥è¶…è¿‡æ­¤å®½åº¦, è‹¥ä¸è¶³åˆ™ä¼šä¸»åŠ¨è¡¥é›¶ .precision ç²¾ç¡®åº¦ type ç±»åž‹æ ‡è¯† d decimal, åè¿›åˆ¶æ•´æ•° f æµ®ç‚¹æ•° x hexadecimal, 16è¿›åˆ¶ c character å¦‚format(&quot;%, 6.1f&quot;, 33.000); å¦‚æžœæœ‰å¤šä¸ªå¾…è¾“å‡ºçš„å‚æ•°, å¯ä»¥æŠŠæ–°çš„å‚æ•°åŠ åˆ°åŽé¢, å¹¶å¯¹åº”ä¸¤ä¸ªä¸åŒçš„æ ¼å¼åŒ–è®¾å®š, ä¹Ÿå°±æ˜¯ä¸¤ä¸ª%æ ¼å¼æŒ‡ä»¤ String s = String.format(&quot;%,.2f out of %,d&quot;, 999, 1000) å¯å˜å‚æ•°åˆ—è¡¨å¯ä»¥çœ‹åˆ°æ ¼å¼åŒ–çš„å‚æ•°ä¼¼ä¹Žå¯ä»¥ä¸æ–­æ·»åŠ ï¼Œå¦‚æžœç”¨é‡è½½æ¥å®žçŽ°ä¼šæ˜¾å¾—ä¸çŽ°å®žã€‚ä¸ºäº†åº”å¯¹æ ¼å¼åŒ–çš„APIï¼ŒJavaæ”¯æŒå¯å˜å‚æ•°åˆ—è¡¨ varable argument list (vararg). æ—¥æœŸæ—¥æœŸæ ¼å¼åŒ–çš„ç±»åž‹æ˜¯ç”¨tå¼€å¤´çš„ä¸¤ä¸ªå­—ç¬¦è¡¨ç¤º %tc å®Œæ•´çš„æ—¥æœŸä¸Žæ—¶é—´ Sun Nov 03 14:52:41 2018 %tr åªæœ‰æ—¶é—´ 03:01:47 PM å‘¨æœˆæ—¥Sunday, November 03, é€šè¿‡ç»„åˆè€Œæ¥12Date today = new Date();String.format('%tA, %tB %td', today, today, today); å¦‚æžœä¸æƒ³é‡å¤ç»™å‚æ•°1String.format('%tA, %&lt;tB %&lt;td', today); &lt;ç¬¦å·æŒ‡ç¤ºæ ¼å¼åŒ–ç¨‹åºé‡å¤åˆ©ç”¨å‚æ•° ä½†é™¤äº†è¦åŽ»çš„å½“å‰æ—¥æœŸç”¨åˆ°Dateä¹‹å¤–, å…¶ä½™çš„æ—¶é—´åŠŸèƒ½å‡ ä¹Žéƒ½åœ¨Calendarä¸Šé¢.å› Calendaræ˜¯æŠ½è±¡ç±», æ‰€ä»¥ä¸èƒ½å–å¾—å®ƒçš„å®žä¾‹, ä½†å¯è°ƒç”¨å®ƒçš„é™æ€æ–¹æ³•, å¯¹Calendaré™æ€æ–¹æ³•çš„è°ƒç”¨ä»¥å–å¾—ä¸€ä¸ªå…·ä½“å­ç±»çš„å®žä¾‹, Calendar cal = Calendar.getInstance();]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java æ³›åž‹]]></title>
    <url>%2Fjava-generics%2F</url>
    <content type="text"><![CDATA[æ³›åž‹æ³›åž‹æ„å‘³ç€æ›´å¥½çš„ç±»åž‹å®‰å…¨æ€§ã€‚ä¸»è¦ç›®çš„æ˜¯æ”¯æŒç±»åž‹å®‰å…¨æ€§çš„é›†åˆï¼Œè®©é—®é¢˜å°½å¯èƒ½åœ¨ç¼–è¯‘é˜¶æ®µå°±èƒ½æ‰åˆ°ã€‚ æ³›åž‹å®šä¹‰åœ¨ç±»å£°æ˜Žä¸­123public class ArrayLiat&lt;E&gt; extends AbstractLÃ¬st&lt;E&gt; implements List&lt;E&gt; &#123; public boolean add (E o);&#125; Eä»£è¡¨ç”¨æ¥åˆ›å»ºèµ‹äºˆåˆå§‹ArrayListçš„ç±»åž‹1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;; ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æŠŠEçœ‹åšString. æ³›åž‹æ–¹æ³•ä½¿ç”¨æœªå®šä¹‰åœ¨ç±»å£°æ˜Žçš„ç±»åž‹å‚æ•°: åœ¨è¿”å›žç±»åž‹ä¹‹å‰æŒ‡å®šæ³›åž‹ maxKey: è¿”å›žç»™å®šArrayMapä¸­æ‰€æœ‰keysçš„æœ€å¤§å€¼ï¼ˆä»…åœ¨keyå¯ä»¥æ¯”è¾ƒçš„æƒ…å†µä¸‹ï¼‰ã€‚å‡å¦‚è¿™æ ·å†™public static K maxKey(Map61B&lt;K, V&gt; map) { ... }ä¼šæŠ¥é”™. è¦å°†æ–¹æ³•å£°æ˜Žä¸ºæ³›åž‹ï¼Œå¿…é¡»åœ¨è¿”å›žç±»åž‹å‰é¢æŒ‡å®šæ­£å¼çš„ç±»åž‹å‚æ•°12345678910public static &lt;K extends Comparable&lt;K&gt;, V&gt; K maxKey(Map61B&lt;K, V&gt; map) &#123; List&lt;K&gt; keylist = map.keys(); K largest = map.get(0); for (K k: keylist) &#123; if (k.compareTo(largest)) &#123; largest = k; &#125; &#125; return largest;&#125; K extends Comparable&lt;K&gt; ä¿è¯äº†keyså¿…é¡»å®žçŽ°ComparableæŽ¥å£ï¼ˆä¹Ÿæ˜¯ä¸€ä¸ªgenericæŽ¥å£ï¼‰, å¹¶å¯ä»¥ä¸Žå…¶ä»–Kè¿›è¡Œæ¯”è¾ƒã€‚ è¿™é‡Œæ²¡æœ‰ä½¿ç”¨implement, è€Œæ˜¯ç”¨extends, è¿™é‡Œè·Ÿå¤šæ€ä¸åŒ. K extends Comparable&lt;K&gt;æ˜¯type upper bounding, æ„å‘³ç€kå¿…é¡»æ˜¯ä¸€ç§Comparable, ä½†ä¸éœ€è¦å…·å¤‡Comparableçš„æ‰€æœ‰æ–¹æ³•è¡Œä¸º. åœ¨inheritanceçš„å«ä¹‰ä¸­ï¼ŒextendsæŒ‡ä¸ºå­ç±»æä¾›è¶…ç±»çš„èƒ½åŠ›. åœ¨æ³›åž‹èŒƒç•´å†…, extendsåªæ˜¯é™ˆè¿°ä¸€ä¸ªäº‹å®žï¼šè¯¥ç±»æ˜¯å…¶æ‰©å±•çš„ç±»çš„ä¸€ä¸ªå­ç±», æ˜¯åŠ äº†çº¦æŸ, è€Œä¸æ˜¯èµ‹äºˆèƒ½åŠ›. æ³›åž‹ä¸Žå¤šæ€å¦‚æžœä½¿ç”¨å¤šæ€ç±»å®šä¹‰ä¸‹é¢çš„æ–¹æ³•æ˜¯æ²¡æœ‰é—®é¢˜çš„12345678910111213141516public void takeAnimals(ArrayList&lt;Animal&gt; animals) &#123; for (Animal a : animals) a.eat();&#125;public void go() &#123; ArrayList&lt;Animal&gt; animals = new ArrayList&lt;&gt;(); animals.add(new Dog()); animals.add(new Cat()); takeAnimals(animals); // å¯ä»¥ç¼–è¯‘ ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); dogs.add(new Dog()); dogs.add(new Dog()); takeAnimals(dogs); // ! æ— æ³•ç¼–è¯‘&#125; é‚£ä¹ˆåœ¨å®žé™…è¿è¡Œæ—¶, å¦‚æžœå£°æ˜Žä¸ºArrayList&lt;Animal&gt;, åˆ™ä¸ç®¡ä¼ å…¥çš„animalsåŒ…å«çš„æ˜¯Dogè¿˜æ˜¯Cat, è¿™ä¸ªæ–¹æ³•è°ƒç”¨çš„éƒ½æ˜¯Animalçš„eat(), å¤šæ€æ”¯æŒè¿™ç§æ“ä½œ. ä½†å¦‚æžœå£°æ˜Žä¸ºArrayList&lt;Dog&gt;å°±ä¸è¡Œ, é™æ€ç±»åž‹æ£€æŸ¥ä¸é€šè¿‡. é‚£ä¹ˆJavaä¸ºä½•ä¸å…è®¸è¿™ç§æƒ…å†µç¼–è¯‘å‘¢? åè¿‡æ¥æƒ³, å¦‚æžœå¯ä»¥ä¼šæ€Žæ ·? å‡å¦‚æ–¹æ³•æ¢ä¸ºè¿™ç§123public void takeAnimals(ArrayList&lt;Animal&gt; animals) &#123; animals.add(new Cat());&#125; å¯ä»¥çœ‹åˆ°ä¼šæœ‰å¾ˆå¤§é—®é¢˜. åœ¨æ–¹æ³•å†…éƒ¨çœ‹æ¥, æŠŠCatåŠ åˆ°ArrayList&lt;Animal&gt;ä¸­æ˜¯å®Œå…¨åˆæ³•çš„, ä½†æ˜¯å¯¹äºŽä»Žå¤–éƒ¨ä¼ å…¥çš„å‚æ•°ArrayList&lt;Dog&gt;æ¥è¯´, å°±ä¸åˆç†äº†. æ‰€ä»¥éœ€è¦ä¿è¯è¿™ç§æƒ…å†µæ— æ³•é€šè¿‡ç¼–è¯‘. ä½†å¦‚æžœæ˜¯æŠŠDog[] dogsä¸­çš„å…ƒç´ æ”¹ä¸ºCat, å´å¯ä»¥é€šè¿‡ç¼–è¯‘.123public void takeAnimals(ArrayList[] animals) &#123; animals[0] = new Cat();&#125; ä½†åœ¨è¿è¡Œæ—¶, JVMä¼šæŒ‡å‡ºé”™è¯¯. å› ä¸ºæ•°ç»„çš„ç±»åž‹æ˜¯åœ¨runtimeæœŸé—´æ£€æŸ¥çš„. è¦æƒ³åœ¨ä½¿ç”¨å¤šæ€çš„æƒ…å†µä¸‹, è®©æ–¹æ³•è‡ªåŠ¨è°ƒç”¨å­ç±»åž‹å‚æ•°çš„æ–¹æ³•, å°±è¦ä½¿ç”¨ä¸‡ç”¨å­—ç¬¦(wildcard)123public void takeAnimals(ArrayList&lt;? extends Animal&gt; animals) &#123; for (Animal a : animals) a.eat();&#125; ä½¿ç”¨ä¸‡ç”¨å­—ç¬¦, ç¼–è¯‘å™¨ä¼šç»„ç»‡ä»»ä½•å¯èƒ½ç ´åå‚æ•°æ‰€æŒ‡å‘é›†åˆçš„è¡Œä¸º, æ¯”å¦‚åŠ å…¥å…ƒç´ animals.add(new Cat());æ˜¯æ— æ³•ç¼–è¯‘é€šè¿‡çš„. ä½¿ç”¨æ³›åž‹, ä¹Ÿå¯ä»¥å®žçŽ°ä¸Šé¢çš„æ–¹æ³•, å°±æ˜¯è®©æ³›åž‹ç»§æ‰¿çˆ¶ç±»1public &lt;T extends Animal&gt; void takeAnimals(ArrayList&lt;T&gt; list); è¿™æ„å‘³ç€Tå¯ä»¥æ˜¯ä»»ä½•ä¸€ç§Animal, ä»»ä½•è¢«å£°æ˜Žä¸ºAnimalæˆ–å…¶å­ç±»çš„ArrayListéƒ½æ˜¯åˆæ³•çš„. è¿™ä¸¤ç§æ–¹æ³•ç­‰ä»·, å¦‚æžœéœ€è¦ä¼ å…¥å¤šä¸ªå‚æ•°, é‚£ä¹ˆåªå£°æ˜Žä¸€æ¬¡ä¼šæ›´æœ‰æ•ˆçŽ‡123public &lt;T extends Animal&gt; void takeThing(ArrayList&lt;T&gt; one, ArrayList&lt;T&gt; two);public void takeAnimals(ArrayList&lt;? extends Animal&gt; one, ArrayList&lt;? extends Animal&gt; two); èžåˆä¸¤ç§æ–¹æ³•çš„å£°æ˜Ž1public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list); è¿™æ„å‘³ç€sortæ”¯æŒä»»ä½•ä¸€ç§å®žçŽ°äº†ä»¥Tçš„çˆ¶ç±»ä¸ºæ³›åž‹çš„Comparableçš„ç±»åž‹. Autoboxingåœ¨Javaä¸­è°ƒç”¨åŒ…å« Generics çš„classæ—¶ï¼Œéœ€è¦æä¾›ç¡®åˆ‡çš„ç±»åž‹å‚æ•°ã€‚å¯¹äºŽæ¯ä¸€ç§ primitive type (byte, short, int, long, float, double, boolean, char)ï¼Œå¿…é¡»è¦ç”¨å…¶å¯¹åº”çš„ reference type (Byte, Short, Integer, Long, Float, Double, Boolean, Character) - ä¹Ÿå³æ˜¯ wrapper classes ä½œä¸ºæ³›åž‹çš„å®žé™…ç±»åž‹å‚æ•°ã€‚è™½ç„¶å£°æ˜Žå‡½æ•°å’Œå˜é‡æ—¶å¿…é¡»è¦ç”¨ wraper classesï¼Œä½†åœ¨å®žé™…çš„æ•°å€¼ä¼ é€’ä¸­ï¼Œå¯¹äºŽ primitives ç±»åž‹çš„æ•°æ®ï¼Œå¹¶ä¸éœ€è¦æ˜¾å¼åœ°è½¬æ¢ä¸º reference typesã€‚ å› ä¸º Java æœ‰ Autoboxingï¼Œå¯ä»¥éšå¼åœ°åœ¨ wrapper/primitives ç±»åž‹é—´è½¬æ¢. Javaä¼šè‡ªåŠ¨ â€œboxâ€ å’Œ â€œunboxâ€ primitive type å’Œå…¶å¯¹åº”çš„ reference type ä¹‹é—´çš„å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æžœJavaæœŸæœ›çš„æ˜¯ wrapper classes ï¼ˆå¦‚Integerï¼‰ï¼Œå‡å¦‚å³ä½¿æŽ¥æ”¶åˆ°çš„æ˜¯ int è¿™æ ·çš„åŸºæœ¬ç±»åž‹ï¼ŒJavaä¹Ÿä¼šâ€œautoboxingâ€è¿™ç§æ•´æ•°ã€‚12345public static void blah(Integer x) &#123; System.out.println(x);&#125;int x = 20;blah(x); // å®žé™…ä¸Šä¼šè½¬æ¢ä¸º blah(new Integer(20)) åè¿‡æ¥å°±æ˜¯unboxingã€‚ Autoboxing/Unboxing æ³¨æ„äº‹é¡¹: ä¸é€‚ç”¨äºŽ array æ•°ç»„ æœ‰æ€§èƒ½è´Ÿæ‹… Wrapper types æ¯” primitive types å ç”¨æ›´å¤šå†…å­˜: åœ¨å¤§å¤šæ•°çŽ°ä»£çš„ç³»ç»Ÿé‡Œï¼Œå¯¹è±¡çš„å¼•ç”¨åœ°å€å ç”¨64ä½ï¼Œè¿˜éœ€è¦é¢å¤–çš„64ä½å¼€é”€ç”¨äºŽå­˜å‚¨åŠ¨æ€ç±»åž‹ç­‰ä¿¡æ¯ã€‚ æ›´å¤šä¿¡æ¯å‚è€ƒ Memory usage of Java objects: general guide æˆ– Memory Usage Estimation in Java. ç±»åž‹è½¬æ¢çš„é™æ€æ–¹æ³•: Integer.parseInt(&quot;2&quot;), Double.parseDouble(&quot;135.26&quot;), new Boolean(&quot;true&quot;).booleanValue(), å–String, è¿”å›žå¯¹åº”çš„primitiveç±»åž‹å€¼. å°† primitive ä¸»æ•°æ®ç±»åž‹å€¼è½¬æ¢ä¸ºString double d = 22.2; String DoubleString = &quot;&quot; + d;, +æ“ä½œæ•°æ˜¯Javaä¸­å”¯ä¸€æœ‰é‡è½½è¿‡çš„è¿ç®—ç¬¦ String s = Double.toString(d); WideningJavaä¼šæ ¹æ®éœ€è¦åœ¨ primitive types ä¹‹é—´è‡ªåŠ¨æ‰©å±•.12345public static void blahDouble(double x) &#123; System.out.println(â€œdouble: â€œ + x);&#125;int x = 20;blahDouble(x); //ç­‰åŒäºŽ blahDouble((double) x) ä½†å¦‚æžœæƒ³ä»Žä¸€ä¸ª wider type è½¬æ¢ä¸º narrower typeï¼Œåˆ™å¿…é¡»æ‰‹åŠ¨ cast.æœ‰å…³ widening çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬å“ªäº›ç±»åž‹æ¯”å…¶ä»–ç±»åž‹æ›´ wider ï¼Œå‚é˜…å®˜æ–¹çš„Javaæ–‡æ¡£ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java é«˜é˜¶å‡½æ•°å’Œå›žè°ƒ]]></title>
    <url>%2Fjava-higher-order-functions-call-back%2F</url>
    <content type="text"><![CDATA[Higher Order Functions A higher order function is a function that treats other functions as data. åœ¨ Java 7 åŠä¹‹å‰çš„ç‰ˆæœ¬, memory boxes (variables) ä¸èƒ½åŒ…å«æŒ‡å‘ functions çš„ pointers, ä¹Ÿå°±æ˜¯æ— æ³•ç»™ functions æŒ‡å®š types. æ‰€ä»¥ä¸èƒ½åƒPythonä¸€æ ·ç›´æŽ¥æŠŠ function ä½œä¸ºå‚æ•°ä¼ é€’åˆ°å¦ä¸€ä¸ª function ä¸­ã€‚åªèƒ½å€Ÿç”¨ interfaceï¼š123public interface IntUnaryFunction &#123; int apply(int x);&#125; 123456789101112131415// å®šä¹‰ä¸€ä¸ªæ–¹æ³•public class TenX implements IntUnaryFunction &#123; /* Returns ten times the argument. */ public int apply(int x) &#123; return 10 * x; &#125;&#125;// é«˜é˜¶æ–¹æ³•public static int do_twice(IntUnaryFunction f, int x) &#123; return f.apply(f.apply(x));&#125;// è°ƒç”¨é«˜é˜¶æ–¹æ³•System.out.println(do_twice(new TenX(), 2)); åœ¨JAVA 8ä¸­ï¼Œæä¾›äº†å¾ˆå¤šå‡½æ•°å¼çš„æŽ¥å£ã€‚Java 8 å¼•å…¥java.util.Function&lt;T, R&gt;æŽ¥å£, å¯ä»¥æŽ¥å—å­˜å‚¨ä¸€ä¸ªå‡½æ•°ï¼Œ&lt;T, R&gt;å¯¹åº”è¯¥å‡½æ•°çš„å‚æ•°å’Œè¿”å›žå¯¹è±¡ Call BackJavaæŽ¥å£æä¾›äº†å›žè°ƒ(call back)çš„èƒ½åŠ›: æœ‰æ—¶ä¸€ä¸ªå‡½æ•°éœ€è¦è°ƒç”¨å¦ä¸€ä¸ªå°šæœªå†™å¥½çš„ helper function, è¿™æ—¶è¿™ä¸ª helper function å°±æ˜¯ call backã€‚æ¯”å¦‚â€œæŽ’åºå‡½æ•°â€éœ€è¦â€œæ¯”è¾ƒå‡½æ•°â€çš„å¸®åŠ©ã€‚ ä¸åŒè¯­è¨€å¯¹äºŽå›žè°ƒæœ‰ä¸åŒçš„å¤„ç†æ–¹å¼ Python, Perl, ML, Javascript ç”¨å‡½æ•°ä¼ é€’ - first-class functions, Higher Order Functions Java é€‰æ‹©æŠŠå‡½æ•°åŒ…å«åœ¨ä¸€ä¸ªæŽ¥å£ä¸­ C: function pointers. C++: class-type functors. C#: delegates. æ¯”å¦‚Javaçš„ Insertion Sort å¯ä»¥æŽ’åºä»»ä½•ç±»åž‹çš„æ•°æ®Insertion.sort(a);, aå¯ä»¥æ˜¯Double, String, java.io.Fileæ•°ç»„. åœ¨è¿™é‡ŒCallbackå°±æ˜¯å¯¹ä¸€ä¸ªå¯æ‰§è¡Œä»£ç çš„å¼•ç”¨: ãƒ»Client passes array of objects to sort() function.ãƒ»The sort() function calls back objectâ€™s compareTo() method as needed.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Immutability]]></title>
    <url>%2Fjava-immutability%2F</url>
    <content type="text"><![CDATA[An immutable data type is a data type whose instances cannot change in any observable way after instantiation. æ¯”å¦‚Stringæ˜¯immutable, Arrayæ˜¯mutable. Immutable çš„ç±»åž‹: String, Integer, Double, Color, Vector, Transaction, Point2D.Mutable: StringBuilder, Stack, Counter, Java array.12345678910111213public final class Vector &#123; private final int N; private final double[] data; public Vector(double[] data) &#123; this.N = data.length; this.data = new double[N]; for (int i = 0; i &lt; N; i++) &#123; // defensive copy of mutable instance variables this.data[i] = data[i]; &#125; &#125; ...&#125; å¦‚ä½•é˜²æ­¢å˜é‡åœ¨ç¬¬ä¸€æ¬¡èµ‹å€¼åŽè¢«æ›´æ”¹ï¼š å¯ä»¥ä½¿ç”¨final: åœ¨ class constructor é‡Œé¢, æˆ–è€…å˜é‡åˆå§‹åŒ–æ—¶, ç»™å˜é‡èµ‹å€¼ä¸€æ¬¡, ä¹‹åŽå°±æ— æ³•å†è¢«èµ‹å€¼äº†. finalçš„å˜é‡ä»£è¡¨ä¸èƒ½æ”¹å˜å®ƒçš„å€¼, finalçš„æ–¹æ³•ä»£è¡¨ä¸èƒ½è¢«è¦†ç›–, finalçš„ç±»ä»£è¡¨ä¸èƒ½è¢«ç»§æ‰¿. è¦ä¿è¯immutableä¸ä¸€å®šè¦ä½¿ç”¨final, æœ‰æ—¶å€™ä¹Ÿå¯ä»¥ç”¨private. Immutable data types å› ä¸ºå±žæ€§ä¸èƒ½æ”¹å˜, ä¼˜ç‚¹æ˜¯ï¼š å¯ä»¥é˜²æ­¢bugs, å¹¶ä½¿debuggingæ›´å®¹æ˜“ å¯ä»¥ä¿¡èµ–å¯¹è±¡å…·æœ‰æŸç§è¡Œä¸º/ç‰¹è´¨ æ›´å®‰å…¨ï¼ˆå‡ºçŽ°æ”»å‡»æ€§ä»£ç æ—¶ï¼‰ ç®€åŒ–å¹¶å‘ å¯ä»¥æ”¾å¿ƒåœ°ç”¨ä½œä¼˜å…ˆé˜Ÿåˆ—å’Œç¬¦å·è¡¨çš„é”® ç¼ºç‚¹æ˜¯éœ€è¦æ›´æ”¹å±žæ€§ï¼Œå¤åˆ¶ç­‰æ“ä½œæ—¶ï¼Œéœ€è¦ç»™æ¯ä¸ªæ•°æ®ç±»åž‹åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡ æ³¨æ„ï¼š å°†ä¸€ä¸ªå¼•ç”¨å£°æ˜Žä¸ºfinalå¹¶ä¸ä¼šä¿è¯å¼•ç”¨æŒ‡å‘çš„å¯¹è±¡æ˜¯immutable. public final ArrayDeque&lt;String&gt;() deque = new ArrayDeque&lt;String&gt;();å˜é‡dequeæ˜¯finalçš„, ä»…æ„å‘³ç€ä¸èƒ½é‡æ–°è¢«èµ‹å€¼, ä½†å…¶æŒ‡å‘çš„æ•°ç»„é˜Ÿåˆ—å¯¹è±¡è‡ªèº«è¿˜æ˜¯å¯å˜çš„. ä½¿ç”¨Reflection APIï¼Œç”šè‡³å¯èƒ½å¯¹privateå˜é‡è¿›è¡Œæ›´æ”¹ Classes should be immutable unless thereâ€™s a very good reason to make them mutableâ€¦. If a class cannot be made immutable, you should still limit its mutability as much as possible.â€“ Effective Java, by Joshua Bloch]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java è¿­ä»£ Iteration]]></title>
    <url>%2Fjava-iteration%2F</url>
    <content type="text"><![CDATA[Javaæä¾›äº† foreach (enhanced for) çš„å¾ªçŽ¯ç®€å†™è¯­æ³•:12345ArrayMap&lt;String, Integer&gt; am = new ArrayMap&lt;String, Integer&gt;();for (String s : am) &#123; System.out.println(s);&#125; å®žçŽ°çš„å…³é”®åŽŸç†æ˜¯ä½¿ç”¨IterableæŽ¥å£ä½¿ä¸€ä¸ªç±»å˜æˆå¯è¿­ä»£çš„: è¯¥æŽ¥å£åŒ…å«ä¸€ä¸ªiterator()æ–¹æ³•ç”¨äºŽè¿”å›žä¸€ä¸ªIteratorå¯¹è±¡ã€‚IteratoræŽ¥å£å®šä¹‰Iteratorå¯¹è±¡å’ŒhasNext(), next()æ–¹æ³•æ¥è¿›è¡Œå®žé™…çš„è¿­ä»£æ“ä½œã€‚123456789101112131415161718192021222324252627public class ArrayMap&lt;K, V&gt; implements Map61B&lt;K, V&gt;, Iterable&lt;K&gt; &#123; private K[] keys; private V[] values; int size; public ArrayMap() &#123; keys = (K[]) new Object[100]; values = (V[]) new Object[100]; size = 0; &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new KeyIterator(); &#125; public class KeyIterator implements Iterator&lt;K&gt; &#123; private int ptr; public KeyIterator() &#123; ptr = 0; &#125; public boolean hasNext() &#123; return (ptr != size); &#125; public K next() &#123; K returnItem = keys[ptr]; ptr = ptr + 1; return returnItem; &#125; &#125;&#125; ä¸åŒçš„æ•°æ®ç»“æž„ï¼ŒIteratoræœ‰ä¸åŒçš„å®žçŽ°æ–¹å¼. KeyIteratorå³ä½¿æ˜¯privateä¹Ÿå¯ä»¥ç¼–è¯‘, å› ä¸ºiterator()åœ¨è¿™é‡Œæ˜¯publicçš„:1234567891011import java.util.Iterator;public class Demo&#123; public static void main(String[] args) &#123; ArrayMap&lt;String, Integer&gt; am = new ArrayMap&lt;String, Integer&gt;(); Iterator&lt;String&gt; it = am.iterator(); for (String s : am) &#123; ... &#125; &#125;1&#125; é™¤äº†ç”¨åµŒå¥—ç±»æ¥è‡ªå®šä¹‰å®žçŽ°Iterator, ä¹Ÿå¯ä»¥åˆ©ç”¨æ•°æ®ç»“æž„æœ¬èº«çš„ç‰¹æ€§. æ¯”å¦‚ArrayMapé‡Œé¢åˆšå¥½åŒ…å«ä¸€ä¸ªå¯è¿­ä»£çš„æ•°æ®ç»“æž„List keys1234public Iterator&lt;T&gt; iterator() &#123; List&lt;K&gt; keylist = keys(); return keylist.Iterator();&#125; æ³¨æ„è¦ç‚¹ hasNext()çš„åˆ¤æ–­ä¾æ®æ˜¯å½“å‰çŠ¶æ€ä¸‹èƒ½è¿”å›žè‡³å°‘ä¸€ä¸ªæˆå‘˜, ä¸è¦æ··æ·†ä¸ºä¸‹ä¸€æ¬¡èƒ½å¦è¿”å›ž: å› ä¸ºè¿­ä»£æ—¶è¿‡ç¨‹ä¸­, æ¯æ¬¡è°ƒç”¨next()ä¹‹å‰, java éƒ½ä¼šå…ˆè°ƒç”¨hasNext(). å®žçŽ°æ–¹æ³•æ—¶, è¦ä¿è¯ç¬¬ä¸€æ¬¡next()è¿”å›žçš„æ˜¯ç¬¬ä¸€ä¸ªæˆå‘˜.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Exceptions]]></title>
    <url>%2Fjava-exception%2F</url>
    <content type="text"><![CDATA[Exception-handlingå‡å¦‚è°ƒç”¨äº†ä¸€ä¸ªä¸æ˜¯è‡ªå·±å†™çš„æ–¹æ³•, è¯¥æ–¹æ³•æ‰§è¡ŒæŸäº›æœ‰é£Žé™©çš„ä»»åŠ¡(å½“ç„¶,è‡ªå·±å†™çš„ä¹Ÿå¯èƒ½ä¼šæœ‰é£Žé™©),å¯èƒ½ä¼šåœ¨è¿è¡ŒæœŸé—´å‡ºçŠ¶å†µ,é‚£ä¹ˆå°±å¿…é¡»è®¤è¯†åˆ°è¯¥æ–¹æ³•æ˜¯æœ‰é£Žé™©çš„, è¦å†™å‡ºå¯ä»¥åœ¨å‘ç”ŸçŠ¶å†µæ—¶åšå‡ºåº”å¯¹çš„ä»£ç . å½“ç¨‹åºå‡ºçŽ°é”™è¯¯æ—¶ï¼Œå‡å¦‚ç»§ç»­è¿è¡Œä¸‹åŽ»å·²ç»æ²¡æœ‰æ„ä¹‰ï¼ˆæˆ–è€…æ ¹æœ¬ä¸å¯èƒ½ç»§ç»­ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æƒ³è¦ä¸­æ–­æ­£å¸¸çš„æŽ§åˆ¶æµç¨‹ - throws an exceptionã€‚ Throwing Exceptionsæ¯”å¦‚å½“æƒ³ä»ŽæŸArrayMapä¸­æå–æŸä¸ªä¸å­˜åœ¨çš„é”®å€¼æ—¶, javaè‡ªåŠ¨æŠ›å‡ºä¸€ä¸ªimplicit exception1234$ java ExceptionDemoException in thread "main" java.lang.ArrayIndexOutOfBoundsException: -1at ArrayMap.get(ArrayMap.java:38)at ExceptionDemo.main(ExceptionDemo.java:6) å¦‚æžœæƒ³è®©è‡ªå·±çš„ç¨‹åºæŠ›å‡ºæ›´è¯¦ç»†çš„ä¿¡æ¯, å¯ä»¥åœ¨ç¨‹åºä¸­åŠ å…¥explicit exception1234567public V get(K key) &#123; intlocation = findKey(key); if(location &lt; 0) &#123; throw newIllegalArgumentException("Key " + key + " does not exist in map."\); &#125; return values[findKey(key)];&#125; 1234$java ExceptionDemoException in thread "main" java.lang.IllegalArgumentException: Key yolp does not exist in map.at ArrayMap.get(ArrayMap.java:40)at ExceptionDemo.main(ExceptionDemo.java:6) Catch Exceptionså•çº¯ throw exception ä¼šå¯¼è‡´ä»£ç å´©æºƒã€‚ä½†æ˜¯é€šè¿‡ try - catch â€œæ•æ‰â€å¼‚å¸¸(RuntimeException æ˜¯ Java object), å¯ä»¥é˜²æ­¢ç¨‹åºå´©æºƒã€‚ æ¯”å¦‚é€šè¿‡æ•æ‰å¼‚å¸¸, æ¥å¼•å…¥ä¿®æ­£æŽªæ–½: ä¸‹é¢è¿™ä¸ªä»£ç é€šè¿‡1234567891011121314/** å½“ç‹—åœ¨ç”Ÿæ°”æ—¶, å¦‚æžœå°è¯•æ‹æ‹å®ƒï¼Œä¼šæŠ›å‡ºä¸€ä¸ª RuntimeExceptionï¼Œæ•æ‰åˆ° exception åŽ, ç”¨é¦™è•‰æ¥æŠšæ…°å®ƒ. */Dog d = new Dog("Lucy", "Retriever", 80);d.becomeAngry();try &#123; // æŠŠæœ‰é£Žé™©çš„ä»£ç å—æ”¾åœ¨tryå— d.receivePat();&#125; catch (Exception e) &#123; System.out.println( "Tried to pat: " + e); d.eatTreat("banana");&#125;d.receivePat();System.out.println(d); 123$ java ExceptionDemoTried to pat: java.lang.RuntimeException: grrr... snarl snarlLucy is a displeased Retriever weighing 80.0 standard lb units. 1234567$ java ExceptionDemoTried to pat: java.lang.RuntimeException: grrr... snarl snarlLucy munches the bananaLucy enjoys the pat.Lucy is a happy Retriever weighing 80.0 standard lb units. Exception ç»§æ‰¿è‡ª Throwable, å¼‚å¸¸ä¹Ÿæ˜¯å¤šæ€çš„ã€‚1public class Throwable extends Object implements Serializable The Throwable class is the superclass of all errors and exceptions in the Java language. Direct Known Subclasses: Error, Exception å¦‚æžœä½¿ç”¨if elseæ¥ç®¡ç†å¼‚å¸¸ä¼šè®©ä»£ç å˜å¾—å¾ˆä¹±è€Œéš¾ä»¥é˜…è¯». è€Œä½¿ç”¨try catchå¯ä»¥ä¸ºæ¯ç§ç±»åž‹çš„ exception æä¾›ä¸åŒçš„åº”å¯¹ã€‚ä½¿ä»£ç åƒæ¸…æ™°çš„è®°è¿°æ–‡èˆ¬é“ºå±•å¼€æ¥: é¦–å…ˆï¼Œå°è¯•æ‰§è¡Œæ‰€éœ€çš„æ“ä½œã€‚ç„¶åŽï¼Œæ•æ‰ä»»ä½•é”™è¯¯ã€‚12345678910111213141516public class Laundry &#123; public void doLaundry() throws PantsException, LingerieException &#123;&#125;&#125;public class Foo &#123; public void go() &#123; Laundry laundry = new Laundry(); try &#123; laundry.doLaundry(); &#125; catch (PantsException pex) &#123; // doSomething &#125; catch (LingerieException lex) &#123; //doSomething &#125; &#125;&#125; è¿™ç§æ¸…æ™°åº¦ä½¿ä»£ç çš„é•¿æœŸç»´æŠ¤å˜å¾—æ›´å®¹æ˜“ã€‚ä»¥å¼‚å¸¸çš„çˆ¶ç±»æ¥å£°æ˜Žä¼šæŠ›å‡ºçš„å¼‚å¸¸, è¿™æ ·å°±ä¸å¿…å£°æ˜Žæ¯ä¸ªå­ç±»å¼‚å¸¸äº†, åœ¨catchå—ä¸­åªéœ€è¦æ•æ‰å¼‚å¸¸çš„çˆ¶ç±».12345public void doLaundry() throws ClothingException &#123;&#125;try &#123; laundry.doLaundry();&#125; catch (ClothingException cex) &#123;&#125; ä½†å¦‚æžœéœ€è¦å¯¹æ¯ä¸ªä¸åŒçš„å­ç±»å¼‚å¸¸é‡‡å–ä¸åŒçš„æŽªæ–½, é‚£ä¹ˆè¿˜æ˜¯éœ€è¦å£°æ˜Žå„ä¸ªå­ç±»å¼‚å¸¸, å¹¶åˆ†åˆ«æ•æ‰.123456789try &#123; laundry.doLaundry();&#125; catch (LingerieException lex) &#123; //doSomething&#125; catch (ClothingException cex) &#123; //doSomething&#125; catch (Exception ex) &#123; //doSomething&#125; æ­¤æ—¶å¤šä¸ªcatchå—è¦ä»Žå°æŽ’åˆ°å¤§(åœ¨ç»§æ‰¿æ ‘ä¸Šçœ‹, å°±æ˜¯å…ˆæ•æ‰å­ç±»), ä¸èƒ½æŠŠçˆ¶ç±»å¼‚å¸¸æ”¾åœ¨å­ç±»ä¸Šé¢,å¦åˆ™æ— æ³•é€šè¿‡ç¼–è¯‘. å› ä¸ºJVMåªä¼šä»Žä¸Šå¼€å§‹å¾€ä¸‹æ‰¾ç¬¬ä¸€ä¸ªç¬¦åˆèŒƒå›´çš„catchå—, å¦‚æžœç¬¬ä¸€ä¸ªcatchå°±æ˜¯catch (Exception ex), é‚£ä¹ˆå‰©ä¸‹çš„æ•æ‰éƒ½æ²¡ç”¨äº†. Finallyåœ¨try-catchåŽé¢, ä½¿ç”¨finallyæŒ‡ç¤ºæ— è®ºå¦‚ä½•éƒ½è¦æ‰§è¡Œçš„éƒ¨åˆ†(ä¸ç®¡æœ‰æ²¡æœ‰å¼‚å¸¸).12345678try &#123; turnOvenOn(); x.bake();&#125; catch (BakingException ex) &#123; ex.printStackTrace();&#125; finally &#123; // ä¸ç®¡æ€Žæ ·æœ€åŽéƒ½è¦å…³ç«! turnOvenOff();&#125; å¦‚æžœtryå—å¤±è´¥äº†, æŠ›å‡ºå¼‚å¸¸, æµç¨‹é©¬ä¸Šè½¬ç§»åˆ°catchå—. å½“catchå—å®Œæˆæ—¶, ç»§ç»­æ‰§è¡Œfinallyå—. å½“finallyå—å®Œæˆæ—¶, ç»§ç»­æ‰§è¡Œå…¶ä»–ä»£ç  å¦‚æžœtryå—æˆåŠŸ, æµç¨‹ä¼šè·³è¿‡catchå—å¹¶ç§»åŠ¨åˆ°finally. finallyå—å®Œæˆæ—¶, ç»§ç»­æ‰§è¡Œå…¶ä»–ä»£ç  å³ä½¿tryæˆ–è€…catchå—ä¸­æœ‰returnæŒ‡ä»¤ï¼Œfinallyè¿˜æ˜¯ä¼šæ‰§è¡Œï¼ï¼Œ æµç¨‹ä¼šå…ˆæš‚æ—¶ä¿å­˜returnçš„å€¼ï¼ŒåŽ»æ‰§è¡Œfinally, ç„¶åŽå†return. ä½†æ˜¯, å¦‚æžœfinallyä¸­ä¹Ÿæœ‰returnæŒ‡ä»¤ï¼Œé‚£ä¹ˆä¼šç›´æŽ¥æ‰§è¡Œè¯¥returnæŒ‡ä»¤ï¼Œç»“æŸæ•´ä¸ªæµç¨‹ï¼Œè¿™æ„å‘³ç€try/catchä¸­çš„returnå¾—ä¸åˆ°æ‰§è¡Œ, ä¸”å®ƒçš„å€¼ä¼šä¸¢å¤±. å¦‚æžœä¸æƒ³å¤„ç†å¼‚å¸¸æœ‰äº›æƒ…å†µä¸‹, æ¯”å¦‚æŸä¸ªå¼‚å¸¸æ˜¯åœ¨ä½ çš„ç¨‹åºè°ƒç”¨çš„å…¶ä»–ç¨‹åºä¸­æŠ›å‡ºçš„, ä½ å¯ä»¥é€‰æ‹©ä¸å¤„ç†è¿™ä¸ªå¼‚å¸¸, æŠŠå®ƒduckæŽ‰, è®©é‚£äº›è°ƒç”¨ä½ æ–¹æ³•çš„ç¨‹åºæ¥å¤„ç†è¿™ä¸ªå¼‚å¸¸. ä¹Ÿå°±è¯´ä½ çš„ç¨‹åºåªæ˜¯æŠŠå¼‚å¸¸è½¬ä¸ªæ‰‹, ç»™ä¸ªå‡ºè·¯.12// åªæœ‰æŠ›å‡º, æ²¡æœ‰try/catch å¼‚å¸¸public void foo() throws ReallyBadException &#123;&#125; æ–¹æ³•æŠ›å‡ºå¼‚å¸¸æ—¶, æ–¹æ³•ä¼šä»Žæ ˆä¸Šç«‹å³è¢«å–å‡º, è€Œå¼‚å¸¸ä¼šå†åº¦ä¸¢ç»™æ ˆä¸Šçš„æ–¹æ³•, ä¹Ÿå°±è¯´ä¸‹ä¸€ä¸ªè°ƒç”¨æ–¹, è¿™ç§è¿‡ç¨‹å¯ä»¥ä¸€ç›´å¾ªçŽ¯ä¸‹åŽ». ä½†duckingåªæ˜¯åœ¨å‡»é¼“ä¼ èŠ±, æœ€åŽæ€»å¾—æœ‰ä¸ªæ–¹æ³•æŽ¥ç›˜, å¦‚æžœè¿žmain()ä¹ŸduckæŽ‰, é‚£ä¹ˆå°±æ˜¯Uncaught Exceptions Stack Trace, å¼‚å¸¸åˆ°è¾¾å †æ ˆåº•éƒ¨åŽä»æœªè¢«æ•èŽ·ï¼ŒJVMå´©æºƒï¼ŒJava æ‰“å°å‡ºå †æ ˆçš„è·Ÿè¸ª:1234java.lang.RuntimeException in thread â€œmainâ€:at ArrayRingBuffer.peek:63at GuitarString.sample:48at GuitarHeroLite.java:110 ç¨‹åºçŒ¿å¯ä»¥æ®æ­¤è¿½è¸ªé”™è¯¯è·¯å¾„ã€‚ Checked vs Unchecked Exceptionsæœ‰æ—¶å€™ï¼ŒæŸäº›æŠ›å‡ºçš„ exception æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå¯ä»¥ç†è§£ä¸ºè¿™äº›å¼‚å¸¸åœ¨ç¼–è¯‘å™¨çœ‹æ¥æ˜¯éžå¸¸æ¶å¿ƒçš„å­˜åœ¨ï¼Œéœ€è¦ç¨‹åºçŒ¿å¿…é¡»ç»™è¿™äº› exception æä¾›æ˜Žç¡®çš„åº”å¯¹å¤„ç†æ–¹æ¡ˆ - è¿™ç§å« checked exception ï¼ˆâ€must be checkedâ€ï¼‰ã€‚è¿™ç§å¼‚å¸¸æ˜¯ä»¥äººæ— æ³•é¢„æµ‹æˆ–é˜²æ­¢çš„æ–¹æ³•å‡ºçŽ°çš„æ‰§è¡ŒæœŸå¤±è´¥çŠ¶å†µ, æ¯”å¦‚æˆ‘ä»¬æ— æ³•ä¿è¯æ–‡ä»¶ä¸€ç›´éƒ½åœ¨, æ— æ³•ä¿è¯æœåŠ¡å™¨ä¸ä¼šæ­»æœº.123456public class Eagle &#123; public static void gulgate() &#123; if (today == â€œThursdayâ€) &#123; throw new IOException("hi"); &#125; &#125;&#125; 1234$ javac EagleEagle.java:4: error: unreported exception IOException; must be caught or declared to be thrownthrow new IOException("hi"); &#125;^ å¾ˆæ˜Žæ˜¾ï¼ŒJavaå¯¹æ­¤IOExceptionå¹¶ä¸æ»¡æ„, å› ä¸ºIOExceptionsæ˜¯ checked exception, è€Œè¿™é‡Œæ²¡æœ‰æä¾›åº”å¯¹å¤„ç†æ–¹æ¡ˆã€‚ä½†å‡å¦‚æ¢åšRuntimeExceptionå°±å¯ä»¥ç¼–è¯‘é€šè¿‡ (è™½ç„¶åœ¨ runtime æ—¶ä¼šå´©æºƒ). InterruptExceptionä¹Ÿæ˜¯è¦æ£€æŸ¥çš„å¼‚å¸¸. å¤§å¤šæ•°check exceptionéƒ½æœ‰ä¿®æ­£çš„å¯èƒ½æ€§ã€‚ä¾‹å¦‚é‡åˆ°FileNotFoundï¼Œå¯ä»¥è€ƒè™‘è¦æ±‚ç”¨æˆ·é‡æ–°æŒ‡å®šä»–ä»¬æƒ³è¦çš„æ–‡ä»¶ (å¯èƒ½æ˜¯å› ä¸ºé”™è¯¯è¾“å…¥å¯¼è‡´çš„)ã€‚ Errors å’Œ Runtime Exceptions, ä»¥åŠå®ƒä»¬çš„å­ç±»éƒ½æ˜¯unchecked. å¤§éƒ¨åˆ†RuntimeExceptionéƒ½æ˜¯å› ä¸ºç¨‹åºé€»è¾‘çš„é—®é¢˜. è™½ç„¶check exceptionæ˜¯äººåŠ›æ— æ³•ä¿è¯, ä½†æˆ‘ä»¬å¯ä»¥ç¡®ä¿ç¨‹åºçš„é€»è¾‘ä¸å‡ºé”™, ä¾‹å¦‚å¯¹åªæœ‰é•¿åº¦Nçš„æ•°ç»„ä¸­å–ç¬¬N+1ä¸ªå…ƒç´ , è¿™ç§æ˜¯é€»è¾‘é”™è¯¯äº†, ä¸å­˜åœ¨ä»€ä¹ˆè¡¥æ•‘, è€Œæ˜¯åº”è¯¥åœ¨å†™ä»£ç æ—¶å°±è¦é¿å…ã€‚try/catchæ˜¯ç”¨æ¥å¤„ç†çœŸæ­£çš„å¼‚å¸¸, è€Œä¸æ˜¯ç¨‹åºçš„é€»è¾‘é”™è¯¯. Javaåœ¨å°½æœ€å¤§åŠªåŠ›ç¡®ä¿æ¯ä¸ªç¨‹åºè¿è¡Œæ—¶ä¸ä¼šå´©æºƒï¼Œæ‰€ä»¥å®ƒä¸ä¼šå…è®¸ç¨‹åºç•™ä¸‹ä»»ä½•æ˜Žæ˜Žå¯ä»¥åº”å¯¹ä¿®æ­£å´æ²¡æœ‰è¢«æ˜Žç¡®åœ°ä¿®æ­£çš„é”™è¯¯ã€‚ ä¸¤ç§æ–¹æ³•æ¥å¤„ç† checked error: Catch 123456789public static void gulgate() &#123; try &#123; if (today == â€œThursdayâ€) &#123; throw new IOException("hi"); &#125; &#125; catch (Exception e) &#123; System.out.println("psych!"); &#125;&#125; å‡å¦‚èƒ½å¤Ÿåº”å¯¹ï¼Œå°½é‡ç”¨ catch é”å®šå¼‚å¸¸é˜²æ­¢å…¶é€ƒé€¸ã€‚ Specify: å¦‚æžœå®žåœ¨ä¸æƒ³åœ¨è¯¥æ–¹æ³•ä¸­å¤„ç†è¿™ç§å¼‚å¸¸ï¼Œå¯ä»¥å°†è´£ä»»æŽ¨è¿Ÿåˆ°åˆ«çš„åœ°æ–¹ã€‚æˆ‘ä»¬å¯ä»¥æŒ‡å®šè¯¥æ–¹æ³•æ˜¯å±é™©çš„ 123public static void gulgate() throws IOException &#123; ... throw new IOException("hi"); ...&#125; ç„¶åŽä»»ä½•å…¶ä»–è°ƒç”¨gulgate()çš„æ–¹æ³•ä¹Ÿå˜æˆå±é™©çš„äº†, å®ƒä»¬ä¹Ÿéœ€è¦è¢«å¤„ç†(åŒæ ·ä½¿ç”¨ä¸¤ç§æ–¹æ³•ä¹‹ä¸€) 123456789101112// catchpublic static void main(String[] args) &#123; try &#123; gulgate(); &#125; catch(IOException e) &#123; System.out.println("Averted!"); &#125;&#125;// æˆ– specifypublic static void main(String[] args) throws IOException &#123; gulgate();&#125; éœ€è¦æ˜Žç¡®å¼‚å¸¸å¤„ç†è´£ä»»äººã€‚åŒæ—¶ç¡®ä¿è°ƒç”¨è€…çŸ¥é“è¯¥æ–¹æ³•æ˜¯å±é™©çš„ï¼ å¼‚å¸¸å¤„ç†è§„åˆ™ catchå’Œfinallyä¸èƒ½æ²¡æœ‰try tryå—å’Œcatchå—ä¹‹é—´ä¸èƒ½æœ‰å…¶ä»–ä»£ç  tryä¸€å®šè¦æœ‰catchæˆ–finally åªå¸¦æœ‰finallyè€Œæ²¡æœ‰catchçš„tryå¿…é¡»è¦å£°æ˜Žå¼‚å¸¸, ä¹Ÿå°±æ˜¯æ˜Žç¡®æŠ›å‡ºvoid go() throws FooException {try {} finally {} }]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java å †æ ˆ]]></title>
    <url>%2Fjava-stack-heap%2F</url>
    <content type="text"><![CDATA[è®¤è¯†æ ˆå’Œå †çš„æ¦‚å¿µï¼Œ æœ‰åŠ©äºŽäº†è§£å˜é‡çš„æœ‰æ•ˆèŒƒå›´ï¼ˆscopeï¼‰ï¼Œå¯¹è±¡çš„å»ºç«‹ï¼Œå†…å­˜ç®¡ç†ï¼Œçº¿ç¨‹ï¼ˆthreadï¼‰å’Œå¼‚å¸¸å¤„ç†ã€‚ å¯¹è±¡ç”Ÿå­˜åœ¨å¯åžƒåœ¾å›žæ”¶çš„å †ï¼ˆheapï¼‰ä¸Šé¢ï¼Œæ–¹æ³•è°ƒç”¨ï¼ˆæ–¹æ³•çš„å‚æ•°ï¼Œå±€éƒ¨å˜é‡çš„å¼•ç”¨ï¼‰çš„ç”Ÿå­˜ç©ºé—´ï¼ˆstackï¼‰ã€‚ å½“JVMå¯åŠ¨æ—¶ï¼Œä»Žåº•å±‚æ“ä½œç³»ç»Ÿå–å¾—ä¸€å—å†…å­˜ï¼Œ ä»¥æ­¤åŒºæ®µæ¥æ‰§è¡ŒJavaç¨‹åºã€‚ å®žä¾‹å˜é‡å’Œå±€éƒ¨å˜é‡å®žä¾‹å˜é‡å£°æ˜Žåœ¨ç±»æ–¹æ³•ä¹‹å¤–ï¼šå®žä¾‹å˜é‡ä¿å­˜åœ¨æ‰€å±žçš„å¯¹è±¡ä¸­ï¼Œä½äºŽå †ä¸Šã€‚å¦‚æžœå®žä¾‹å˜é‡æ˜¯ä¸ªå¯¹å¯¹è±¡çš„å¼•ç”¨ï¼Œåˆ™å¼•ç”¨å’Œå¯¹è±¡éƒ½åœ¨å †ä¸Šã€‚1234public class Duck &#123; int size; Mouth mouth;&#125; å½“æ–°å»ºä¸€ä¸ªDuck()æ—¶, Javaå¿…é¡»åœ¨å †ä¸Šå¸®å®ƒæ‰¾ä½ç½®, ä¿è¯ç©ºé—´è¶³å¤Ÿå­˜æ”¾è¯¥å¯¹è±¡æ‰€æœ‰å®žä¾‹å˜é‡. å¯¹äºŽprimitiveæ•°æ®ç±»åž‹çš„å®žä¾‹å˜é‡, Javaä¼šæ ¹æ®ç±»åž‹çš„å¤§å°ä¸ºå®ƒä»¬ç•™ä¸‹å †ç©ºé—´, int 32, long 64 .... å¦‚æžœå®žä¾‹å˜é‡æ˜¯ä¸ªå¯¹è±¡, ä¹Ÿå°±æ˜¯Duckå¯¹è±¡å¸¦æœ‰å¼•ç”¨å˜é‡mouth, Javaä¼šåœ¨å †ä¸Šç•™ç»™Duckçš„ä¸“å±žç©ºé—´åªåŒ…å«è¯¥å¼•ç”¨å˜é‡, ä¸åŒ…å«å¼•ç”¨çš„é‚£ä¸ªå¯¹è±¡. è¢«å¼•ç”¨çš„å¯¹è±¡, åªæœ‰å®žé™…å®žä¾‹åŒ–åŽ, æ‰ä¼šåœ¨å †ä¸Šå æœ‰ä¸€å¸­ä¹‹åœ°mouth = new Mouth(), è¯¥ç©ºé—´å¹¶ä¸å±žäºŽDuck. å±€éƒ¨å˜é‡å£°æ˜Žåœ¨æ–¹æ³•æˆ–æ–¹æ³•çš„å‚æ•°ä¸Šï¼šå®ƒä»¬æ˜¯æš‚æ—¶çš„ï¼Œä¸”ç”Ÿå‘½å‘¨æœŸåªé™äºŽè¢«æ”¾åœ¨æ ˆä¸Šçš„è¿™æ®µæ—¶é—´ï¼ˆä¹Ÿå°±æ˜¯æ–¹æ³•è°ƒç”¨è‡³æ‰§è¡Œå®Œæ¯•ä½æ­¢ï¼‰ã€‚æ‰€æœ‰å±€éƒ¨å˜é‡å­˜åœ¨æ ˆä¸Šç›¸å¯¹åº”çš„å †æ ˆå—ä¸­ï¼Œæ•…åˆç§°ä¸ºæ ˆå˜é‡ã€‚å¼•ç”¨å¯¹è±¡çš„å±€éƒ¨å˜é‡(åªæ˜¯å¯¹å¯¹è±¡çš„å¼•ç”¨)å’Œprimitiveæ•°æ®ç±»åž‹å˜é‡ä¹Ÿéƒ½æ”¾åœ¨æ ˆä¸Šã€‚123public void foo(int x) &#123; int i = x + 3;&#125; ä¸ç®¡æ˜¯å®žä¾‹å˜é‡è¿˜æ˜¯å±€éƒ¨å˜é‡ï¼Œ å®ƒä»¬æŒ‡å‘çš„å¯¹è±¡æœ¬èº«åœ¨å †ä¸Šã€‚ æ ˆç¨‹åºå¯¹æ–¹æ³•çš„è°ƒç”¨ï¼Œä»¥å¸¦æœ‰æ–¹æ³•çš„çŠ¶æ€çš„å †æ ˆå—çš„å½¢å¼ï¼Œä¸æ–­å †åœ¨æ ˆä¸Šé¢ï¼Œå½“å‰è¢«æ‰§è¡Œçš„æ–¹æ³•å¤„äºŽæ ˆé¡¶ã€‚æ‰§è¡Œå®Œæ¯•çš„æ–¹æ³•ä¼šå‡ºæ ˆã€‚é€’å½’è°ƒç”¨å¤ªæ·±å±‚ï¼Œä¼šå¯¼è‡´æ ˆç©ºé—´è€—å°½ã€‚ å¦‚æžœæ–¹æ³•ä¸­æœ‰å±€éƒ¨å˜é‡å¼•ç”¨å¯¹è±¡ï¼Œé‚£ä¹ˆè¯¥å±€éƒ¨å˜é‡ä¹Ÿæ˜¯å­˜åœ¨äºŽæ ˆä¸­. ä½†è¢«å¼•ç”¨çš„å¯¹è±¡è¿˜æ˜¯è¿è¡Œåœ¨å †ä¸Šé¢. å †å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ å±€éƒ¨å˜é‡åªä¼šå­˜æ´»åœ¨å£°æ˜Žè¯¥å˜é‡çš„æ–¹æ³•ä¸­, å…¶ä½™æ–¹æ³•æ— æ³•æŽ¥è§¦åˆ° å®žä¾‹å˜é‡çš„å¯¿å‘½ä¸Žæ‰€å±žå¯¹è±¡ç›¸åŒ. å¦‚æžœæ‰€å±žå¯¹è±¡è¿˜æ´»ç€, åˆ™å®žä¾‹å˜é‡ä¹Ÿä¼šæ´»ç€. 12345public class Life &#123; int size; // size åœ¨ç±»ä¸­ä¸€ç›´å¯ä»¥ç”¨ public void setSize(int s) &#123; size = s; &#125; // ä½† s ä»…é™äºŽsetSizeä¸­, ä¸”åœ¨æ–¹æ³•ç»“æŸåŽæ¶ˆå¤±&#125; æ‰€ä»¥è¿™é‡Œå­˜åœ¨ç”Ÿå‘½å‘¨æœŸlifeå’ŒèŒƒå›´scopeçš„æ¦‚å¿µå·®åˆ« Lifeï¼šåªè¦å˜é‡çš„å †æ ˆå—è¿˜å­˜åœ¨äºŽå †æ ˆä¸Šï¼Œ å±€éƒ¨å˜é‡å°±è¿˜æ´»ç€ Scopeï¼šå±€éƒ¨å˜é‡çš„æ´»åŠ¨èŒƒå›´ä»…é™äºŽå£°æ˜Žå®ƒçš„æ–¹æ³•ä¹‹å†…ã€‚æ­¤æ–¹æ³•å¦‚æžœè°ƒç”¨åˆ«çš„æ–¹æ³•æ—¶ï¼Œè¯¥å˜é‡è¿˜æ´»ç€ï¼Œä½†ä¸åœ¨ç›®å‰æ´»è·ƒçš„æ–¹æ³•èŒƒå›´å†…ã€‚å¾—ç­‰åˆ°å…¶ä»–æ–¹æ³•æ‰§è¡Œå®Œæ¯•è¿”å›žæ—¶ï¼Œæ‰å›žåˆ°è¯¥å±€éƒ¨å˜é‡æ‰€å±žæ–¹æ³•çš„èŒƒå›´ã€‚ å¼•ç”¨å˜é‡åªèƒ½åœ¨å¤„äºŽå®ƒçš„èŒƒå›´å†…æ‰èƒ½è¢«å¼•ç”¨ã€‚å³ä½¿å¼•ç”¨å˜é‡æš‚æ—¶ä¸åœ¨æ´»è·ƒèŒƒå›´å†…ï¼Œåªè¦å¼•ç”¨å˜é‡è¿˜æ´»ç€ï¼Œè¢«å¼•ç”¨çš„å¯¹è±¡ä¹Ÿå°±æ´»ç€ã€‚å¦‚æžœä¸€ä¸ªå¯¹è±¡å”¯ä¸€çš„å¼•ç”¨å˜é‡æ­»äº†ï¼ˆéšç€å †æ ˆå—ä¸€èµ·è§£æ•£ï¼‰ï¼Œå¯¹è±¡å°±ä¼šè¢«è®¤å®šä¸ºå¯è¢«åžƒåœ¾å›žæ”¶ï¼ˆGarbage Collectionï¼‰çš„ã€‚æ²¡æœ‰è¢«å¼•ç”¨çš„å¯¹è±¡ï¼Œæ˜¯æ²¡æœ‰å­˜åœ¨æ„ä¹‰çš„ï¼Œå› ä¸ºæ²¡æœ‰äººçŸ¥é“å®ƒçš„åœ°å€ï¼Œæ— æ³•è°ƒç”¨å®ƒï¼Œå®ƒçš„å­˜åœ¨åªä¼šæµªè´¹ç©ºé—´ã€‚ ç¨‹åºå†…å­˜ä¸è¶³æ—¶ï¼ŒGCå°±ä¼šåŽ»æŠŠå¯GCçš„å¯¹è±¡å›žæ”¶ï¼Œé‡Šæ”¾å†…å­˜ï¼Œå…·ä½“æ€Žä¹ˆå›žæ”¶ï¼Œå›žæ”¶å¤šå°‘ï¼Œæœ‰å¾ˆå¤šä¸åŒç®—æ³•ã€‚å¦‚æžœå›žæ”¶å®Œå…¨ï¼Œå†…å­˜è¿˜æ˜¯ä¸å¤Ÿç”¨ï¼Œé‚£å°±ä¼šå˜æˆçœŸæ­£çš„å†…å­˜ä¸è¶³ã€‚ ä¸‰ç§æ–¹æ³•é‡Šæ”¾å¯¹è±¡çš„å¼•ç”¨ï¼š å¼•ç”¨æ°¸ä¹…æ€§åœ°ç¦»å¼€å®ƒçš„èŒƒå›´void go() { Life z = new Life(); }, zä¼šåœ¨æ–¹æ³•ç»“æŸæ—¶æ¶ˆå¤±. å¼•ç”¨è¢«èµ‹å€¼åˆ°å…¶ä»–å¯¹è±¡: Life z = new Life(); z = new Life();, ç¬¬ä¸€ä¸ªå¯¹è±¡å¤±åŽ»äº†å¼•ç”¨ ç›´æŽ¥nullå¼•ç”¨: z = null, nullä»£è¡¨ç©ºå­—èŠ‚ç»„åˆ, ä½†å®žé™…ä¸Šæ˜¯ä»€ä¹ˆåªæœ‰JVMçŸ¥é“]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java æŠ½è±¡æ•°æ®ç±»åž‹]]></title>
    <url>%2Fjava-adt%2F</url>
    <content type="text"><![CDATA[Abstract Data Types (ADTS)ADTS æ˜¯ç”±å…¶è¡Œä¸ºå±žæ€§å®šä¹‰çš„æŠ½è±¡ç±»åž‹, è·Ÿå¦‚ä½•å®žçŽ°æ— å…³. å †æ ˆ Stacks å’Œé˜Ÿåˆ— Queues æ˜¯ä¸¤ç§ç±»ä¼¼çš„çº¿æ€§é›†åˆã€‚å †æ ˆæ˜¯åŽè¿›å…ˆå‡ºçš„ADTï¼šå…ƒç´ æ€»æ˜¯ä»Žæ•°æ®ç»“æž„çš„ä¸€ç«¯æ·»åŠ æˆ–åˆ é™¤ã€‚é˜Ÿåˆ—æ˜¯å…ˆè¿›å…ˆå‡ºçš„ADT. äºŒè€…éƒ½æ”¯æŒä»¥ä¸‹æ“ä½œ:push(): åŠ å…¥peek(): è¿”å›žä¸‹ä¸€ä¸ªpoll(): è¿”å›žä¸‹ä¸€ä¸ªå¹¶åˆ é™¤ Javaçš„Deque(double ended queue, â€œdeckâ€) æŽ¥å£èžåˆäº†å †æ ˆå’Œé˜Ÿåˆ—, æ”¯æŒä¸¤ç«¯çš„å…ƒç´ æ’å…¥å’Œç§»é™¤. ArrayDequeå’ŒLinkedListDequeéƒ½æ˜¯å®žçŽ°dequeè¿™ä¸ªæŽ¥å£ï¼Œdequeåªæ˜¯ç½—åˆ—äº†ä¸€äº› methodsï¼Œä¹Ÿå³æ˜¯ä¸€ç§åˆçº¦ï¼Œä¿è¯ä¼šå®žçŽ°çš„è¡Œä¸ºã€‚è€Œè¿™äº›æ–¹æ³•çš„å…·ä½“å®žçŽ°åˆ™æ˜¯ç”±ArrayDequeå’ŒLinkedListDequeå®Œæˆã€‚ä»Žæ¦‚å¿µä¸Šè®²ï¼Œdequeå°±æ˜¯ä¸€ç§æŠ½è±¡çš„æ•°æ®ç±»åž‹ï¼Œåªè¯´ä¼šæœ‰ä»€ä¹ˆè¡Œä¸ºï¼Œä½†ä¸ä½“çŽ°è¿™äº›è¡Œä¸ºçš„å…·ä½“å®žçŽ°æ–¹å¼ï¼Œæ‰€ä»¥æ˜¯æŠ½è±¡çš„ã€‚ ä¼˜å…ˆçº§é˜Ÿåˆ— priority queue çš„æ¯ä¸ªå…ƒç´ éƒ½æœ‰ä¸€ä¸ªä¸Žä¹‹å…³è”çš„ä¼˜å…ˆçº§ï¼Œä»¥å†³å®šä»Žé˜Ÿåˆ—ä¸­å…ƒç´ æ“ä½œçš„é¡ºåºã€‚ ä¸‰ç§æ–¹å¼å®žçŽ°Stackçš„push(Item x): ç»§æ‰¿æ¨¡å¼ï¼šextends LinkedList&lt;Item&gt;ä»¥ä½¿ç”¨å…¶æ–¹æ³•: 12345public class ExtensionStack&lt;Item&gt; extends LinkedList&lt;Item&gt; &#123; public void push(Item x) &#123; add(x); &#125;&#125; å§”æ‰˜æ¨¡å¼Delegationï¼Œ ç”ŸæˆLinked Listå¹¶è°ƒç”¨å…¶æ–¹æ³•æ¥è¾¾åˆ°ç›®çš„ 123456public class DelegationStack&lt;Item&gt; &#123; private LinkedList&lt;Item&gt; L = new LinkedList&lt;Item&gt;(); public void push(Item x) &#123; L.add(x); &#125;&#125; ç±»ä¼¼å§”æ‰˜æ¨¡å¼, åªæ˜¯è¿™é‡Œå¯ä»¥åˆ©ç”¨ä»»ä½•å®žçŽ°äº†ListæŽ¥å£çš„ç±», å¦‚Linked List, ArrayList, ç­‰ç­‰ 12345678910public class StackAdapter&lt;Item&gt; &#123; private List L; public StackAdapter(List&lt;Item&gt; worker) &#123; L = worker; &#125; public void push(Item x) &#123; L.add(x); &#125;&#125; Delegation vs Extension: Extension ä¸€èˆ¬æ˜¯åŸºäºŽå¯¹çˆ¶ç±»æœ‰æ¯”è¾ƒæ¸…æ¥šçš„äº†è§£è®¤çŸ¥ä¸‹æ‰ä¼šä½¿ç”¨ã€‚æ­¤å¤–ï¼Œæ‰©å±•åŸºæœ¬ä¸Šç­‰äºŽåœ¨è¯´æ˜Žæ­£åœ¨æ‰©å±•çš„ç±»ä¸Žè¢«æ‰©å±•ç±»æ˜¯ç›¸ä¼¼çš„ã€‚å¦‚æžœä¸¤ä¸ªç±»æ— æ³•çœ‹åšæ˜¯åŒå±žçš„, é‚£ä¹ˆå°±ç”¨å§”æ‰˜æ¨¡å¼ã€‚ Views: é€šè¿‡è§†å›¾è¿›è¡Œçš„æ›´æ”¹ä¼šå½±å“åº•å±‚å¯¹è±¡ã€‚1234567/** Create an ArrayList. */List&lt;String&gt; L = new ArrayList&lt;&gt;();/** Add some items. */L.add(â€œatâ€); L.add(â€œaxâ€); â€¦List&lt;String&gt; SL = l.subList(1, 4);/** Mutate that thing. */SL.set(0, â€œjugâ€); APIâ€™s An API(Application Programming Interface) of an ADT is the list of constructors and methods and a short description of each. API åŒ…æ‹¬è¯­æ³•è§„èŒƒå’Œè¯­ä¹‰è§„èŒƒ ç¼–è¯‘å™¨ç¡®è®¤è¯­æ³•ç¬¦åˆè¦æ±‚ æµ‹è¯•ä»¥å¸®åŠ©ç¡®è®¤è¯­ä¹‰æè¿°æ˜¯å¦æ­£ç¡® Java LibrariesJavaæœ‰ä¸€äº›å†…ç½®çš„æŠ½è±¡æ•°æ®ç±»åž‹ï¼Œæ‰“åŒ…åœ¨Javaåº“ä¸­ã€‚ ä¸‰ä¸ªæœ€é‡è¦çš„ADTsæ¥è‡ªjava.utilåº“ï¼š List åˆ—è¡¨ï¼šä¸€ä¸ªæœ‰åºçš„å…ƒç´ é›†åˆï¼Œå¦‚ArrayList Set é›†åˆï¼šå…ƒç´ ä¸¥æ ¼å”¯ä¸€ï¼ˆä¸é‡å¤ï¼‰çš„(æ— åº)é›†åˆï¼Œå¦‚HashSet Map æ˜ å°„ï¼šA collection of Key - value æ˜ å°„, keyæ˜¯å”¯ä¸€çš„ã€‚é€šè¿‡keyè®¿é—®valueï¼Œå¦‚HashMapã€‚ 12345678910111213141516171819202122232425262728293031323334/** takes in a String inputFileNameand puts every word from the input file into a list*/public static List&lt;String&gt; getWords(String inputFileName) &#123; List&lt;String&gt; lst = new ArrayList&lt;String&gt;(); In in = new In(); while (!in.isEmpty()) &#123; lst.add(in.readString()); &#125; return lst;&#125;/** takes in a List&lt;String&gt; and counts how many unique words there are in the file.*/public static int countUniqueWords(List&lt;String&gt; words) &#123; Set&lt;String&gt; ss = new HashSet&lt;&gt;(); for (String s : words) &#123; ss.add(s); &#125; return ss.size();&#125;/** takes in a List&lt;String&gt; targets and a List&lt;String&gt; words,and finds the number of times each target word appears in the word list.*/public static Map&lt;String, Integer&gt; collectWordCount(List&lt;String&gt; words) &#123; Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;(); for (String t: target) &#123; counts.put(s, 0); &#125; for (String s: words) &#123; if (counts.containsKey(s)) &#123; counts.put(word, counts.get(s)+1); &#125; &#125; return counts;&#125; é€šè¿‡è®¾ç½®çŽ¯å¢ƒå˜é‡ï¼ˆå¦‚CLASSPATH =ï¼‰è®©Javaç¼–è¯‘å™¨/è§£é‡Šå™¨çŸ¥é“åŽ»å“ªé‡Œæ‰¾ librariesã€‚ CLASSPATHï¼šLinux or MacOS, paths are separated by :. In Windows, paths are separated by ;. /home/--/--/javalib/*, åœ¨.classå’Œ.jaræ–‡ä»¶å†…æŸ¥æ‰¾ä¾èµ–åŒ…ï¼Œç”¨äºŽæŒ‡å®šç»å¯¹è·¯å¾„ã€‚æœ‰åŒåæ—¶ï¼Œä¼šæ ¹æ®çŽ¯å¢ƒå˜é‡çš„å…ˆåŽé¡ºåºåŽ»æŽ’åºé å‰çš„ã€‚ ./æŒ‡å½“å‰ç›®å½•ï¼Œ../æŒ‡ä¸Šä¸€å±‚ç›®å½•ï¼Œç”¨äºŽæŒ‡å®šç›¸å¯¹è·¯å¾„ã€‚ ä¹Ÿå¯ä»¥æŒ‡å®šclasspath, è¿™æ ·ç³»ç»Ÿçš„CLASSPATHä¼šè¢«å¿½ç•¥: javac -cp ./:/home/stuff/:../ Foo.java, å½“æœ‰é‡åæ—¶, é€‰æ‹©é¡ºåºå°±æ˜¯æŒ‡æ˜Žçš„è·¯å¾„é¡ºåºï¼ˆå½“å‰ç›®å½•-stuffç›®å½•-ä¸Šä¸€å±‚ç›®å½•ï¼‰ IntelliJä¼šå¿½ç•¥CLASSPATHï¼Œå®ƒä¼šè‡ªåŠ¨è°ƒç”¨-cp, å˜é‡æ˜¯åŸºäºŽå½“å‰é¡¹ç›®æŒ‡å®šçš„ libraries.12345678910111213/** æŸ¥çœ‹ IntelliJ ä½¿ç”¨çš„ classpath*/import java.net.URL;import java.net.URLClassLoader;public static void main(String[] args) &#123; ClassLoader cl = ClassLoader.getSystemClassLoader(); URL[] urls = ((URLClassLoader)cl).getURLs(); for(URL url: urls)&#123; System.out.println(url.getFile()); &#125;&#125; Build Systemsï¼šå¯ä»¥ç®€å•åœ°å°†æ–‡ä»¶æ”¾å…¥é€‚å½“çš„ä½ç½®ï¼Œç„¶åŽé€šè¿‡ Maven, Ant å’Œ Gradle ç­‰å·¥å…·ä½¿ç”¨ Build Systems æ¥è‡ªåŠ¨è®¾ç½®é¡¹ç›®, çœåŽ»äº†æ‰‹åŠ¨åŠ è½½ä¸€é•¿ä¸² libraries.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java æ¯”è¾ƒå¯¹è±¡å¤§å°]]></title>
    <url>%2Fjava-compare%2F</url>
    <content type="text"><![CDATA[å¯¹ç‰©å“æŽ’åºé¦–å…ˆéœ€è¦æ¯”è¾ƒå„ä¸ªç‰©å“çš„å¤§å°, è¿™ä¸ªå¤§å°çš„å®šä¹‰æ—¢å¯ä»¥æ˜¯æŒ‰ç…§â€è‡ªç„¶é¡ºåºâ€, ä¹Ÿå¯ä»¥æ˜¯å…¶ä»–æŒ‡å®šçš„ç‰¹æ®Šè§„åˆ™. ComparableJavaçš„å¯¹è±¡ä¸èƒ½ç›´æŽ¥ä½¿ç”¨&gt;, &lt;, =è¿›è¡Œæ¯”è¾ƒ. åœ¨Pythonæˆ–C++ä¸­ï¼Œå½“åº”ç”¨äºŽä¸åŒå¯¹è±¡ç±»åž‹æ—¶ï¼Œæ¯”è¾ƒè¿ç®—ç¬¦å¯ä»¥é‡æ–°å®šä¹‰ï¼Œä½†Javaä¸æ”¯æŒã€‚ä½†å¯ä»¥å€Ÿç”¨æŽ¥å£ç»§æ‰¿ï¼ŒJavaæä¾›äº†ä¸€ä¸ªComparableæŽ¥å£ï¼ŒåŒ…å«ä¸€ä¸ªcompareToæ–¹æ³•, ä»¥ä¿è¯ä»»ä½•å®žçŽ°è¯¥æŽ¥å£çš„ç±»å¯ä»¥å’Œå…¶ä»–åŒç±»åšæ¯”è¾ƒï¼š1234567/** Return negative if this &lt; o. Return 0 if this equals o. Return positive if this &gt; o.*/public interface Comparable&lt;T&gt; &#123; public int compareTo(T obj);&#125; å½“æœ‰classéœ€è¦ä¸Žå…¶ä»–classæ¯”è¾ƒæ—¶, å°±å®žçŽ°è¿™ä¸ªæŽ¥å£:123456public class Dog implements Comparable&lt;Dog&gt; &#123; ... public int compareTo(Dog uddaDog) &#123; return this.size - uddaDog.size; &#125;&#125; Comparableå®šä¹‰äº†ç±»ç”¨äºŽæ¯”è¾ƒçš„è‡ªç„¶é¡ºåºï¼ˆNatural orderï¼‰, è¿”å›žçš„æ˜¯ä¸‰ç§ç»“æžœè´Ÿæ•´æ•°, 0, æ­£æ•´æ•°, åˆ†åˆ«å¯¹åº”å°äºŽ, ç­‰äºŽå’Œå¤§äºŽ. Insertion.sort()ä¸éœ€è¦çŸ¥é“è¦æŽ’åºçš„æ•°ç»„ç±»åž‹, å› ä¸ºå®ƒç›´æŽ¥è°ƒç”¨æ•°ç»„æˆå‘˜è‡ªå¸¦çš„compareToæ–¹æ³•. Javaçš„Integer, Double, String, Date, Fileæ•°æ®ç±»åž‹éƒ½æ‰©å±•äº†ComparableæŽ¥å£ã€‚ A comparable object is capable of comparing itself with another object Comparatorå¦‚æžœæˆ‘ä»¬æƒ³ç”¨çµæ´»çš„ä¸åŒæ–¹å¼å¯¹ç±»è¿›è¡Œæ¯”è¾ƒæ¯”è¾ƒå‘¢ï¼Ÿæ¯”å¦‚å¯¹éŸ³ä¹åº“é‡Œçš„æ­Œæ›²æ ¹æ®è‰ºæœ¯å®¶ã€æ­Œåç­‰æŽ’åºï¼ŒäºŒè€…éƒ½æ˜¯String, ä½†ä¸€ä¸ªç±»é‡Œé¢çš„Comparableåªèƒ½æœ‰ä¸€ä¸ª, æ‰€ä»¥ä»…ä»…é ComparableæŽ¥å£ä¸å¤Ÿ. åœ¨Pythonå¯ä»¥ä½¿ç”¨HOFï¼Œç¼–å†™æ–°çš„æ¯”è¾ƒå‡½æ•°ï¼Œç„¶åŽç›´æŽ¥ä»¥å‚æ•°å½¢å¼ä¼ é€’è¯¥å‡½æ•°ã€‚ Javaçš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨ComparatoræŽ¥å£ï¼š123public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; æ¯”å¦‚Javaç³»ç»Ÿè‡ªå¸¦çš„sort:12345678910/**ãƒ»Create Comparator object.ãƒ»Pass as second argument to Arrays.sort().*/String[] a;...Arrays.sort(a); // uses natural order...// uses alternate order defined by Comparator&lt;String&gt; objectArrays.sort(a, String.CASE_INSENSITIVE_ORDER); insertion sortçš„è§£å†³æ€è·¯ç±»ä¼¼:ãƒ»Use Object instead of Comparable.ãƒ»Pass Comparator to sort() and less().1234567891011121314public static void sort(Object[] a, Comparator comparator) &#123; int N = a.length; for (int i = 0; i &lt; N; i++) for (int j = i; j &gt; 0 &amp;&amp; less(comparator, a[j], a[j-1]); j--) exch(a, j, j-1);&#125;private static boolean less(Comparator c, Object v, Object w) &#123; return c.compare(v, w) &lt; 0;&#125;private static void exch(Object[] a, int i, int j) &#123; Object swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; éœ€è¦è‡ªå®šä¹‰æ—¶, æ ¹æ®éœ€è¦åœ¨classå†…éƒ¨ç¼–å†™å®žçŽ°ComparatoræŽ¥å£çš„(åµŒå¥—)ç±», å¹¶å®žçŽ°compareæ–¹æ³•:12345678910111213141516171819public class Student &#123; public static final Comparator&lt;Student&gt; BY_NAME = new ByName(); public static final Comparator&lt;Student&gt; BY_SECTION = new BySection(); private final String name; private final int section; ... private static class ByName implements Comparator&lt;Student&gt; &#123; // ç›´æŽ¥åˆ©ç”¨ String å·²ç»å®šä¹‰å¥½çš„ compareTo public int compare(Student v, Student w) &#123; return v.name.compareTo(w.name); &#125; &#125; private static class BySection implements Comparator&lt;Student&gt; &#123; public int compare(Student v, Student w) &#123; return v.section - w.section; &#125; &#125;&#125; åœ¨å…¶ä»–å‡½æ•°ä¸­è°ƒç”¨æ—¶12345678910Student s1;Student s2;...if (Student.BY_NAME.compare(s1, s2) &gt; 0) &#123; ...&#125;...Arrays.sort(a, Student.BY_NAME);Arrays.sort(a, Student.BY_SECTION); åŒç†è‹¥éœ€è¦å¢žåŠ å…¶ä»–åˆ¤æ–­æ ‡å‡†ï¼Œå°±åˆ›å»ºæ–°çš„å®žçŽ°Comparatorçš„ class. Comparatoræ˜¯å¯ä»¥å°†ä¸¤ä¸ªå¯¹è±¡è¿›è¡Œæ¯”è¾ƒçš„ç¬¬ä¸‰æ–¹å¯¹è±¡ã€‚ç”±äºŽåªæœ‰ä¸€ä¸ªcompareToçš„ç©ºé—´ï¼Œå¦‚æžœæƒ³è¦æ”¯æŒä¸åŒæ–¹å¼è¿›è¡Œæ¯”è¾ƒï¼Œåˆ™è¦ä½¿ç”¨ä¸åŒçš„Comparatorã€‚ A Comparator is its own definition of how to compare two objects, and can be used to compare objects in a way that might not align with the natural ordering.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java å°è£…, åŒ…, JAR, æƒé™æŽ§åˆ¶]]></title>
    <url>%2Fjava-encapsulation-packages-jar-access%2F</url>
    <content type="text"><![CDATA[Encapsulationå°è£…æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹çš„åŸºæœ¬åŽŸåˆ™ä¹‹ä¸€ï¼Œä¹Ÿæ˜¯ç¨‹åºå‘˜å¤„ç†å¤æ‚æ€§ä¸€ä¸ªæ–¹æ³•ã€‚ç®¡ç†å¤æ‚æ€§æ˜¯ç¼–å†™å¤§åž‹ç¨‹åºæ—¶å¿…é¡»é¢å¯¹çš„ä¸»è¦æŒ‘æˆ˜ä¹‹ä¸€ã€‚å¯¹æŠ—å¤æ‚æ€§çš„ä¸€äº›å·¥å…·åŒ…æ‹¬: Hierarchical abstraction: åˆ›å»ºä¸€ä¸ªä¸ªå…·æœ‰æ˜Žç¡®çš„ abstraction barriers çš„æŠ½è±¡å±‚ Abstraction Barriersï¼šä½¿ç”¨private, ä¿è¯å¯¹è±¡å†…éƒ¨ä¸èƒ½è¢«æŸ¥çœ‹, ç¡®ä¿åº•å±‚çš„å¤æ‚æ€§ä¸ä¼šæš´éœ²ç»™å¤–éƒ¨ä¸–ç•Œã€‚ â€œDesign for changeâ€ (D. Parnas) Organize program around objects. Let objects decide how things are done. Hide information others donâ€™t need. å¤§æ¦‚çš„æƒ³æ³•éƒ½æ˜¯ - ç¨‹åºåº”è¯¥è¢«æž„å»ºæˆæ¨¡å—åŒ–ï¼Œå¯äº’æ¢çš„ç‰‡æ®µï¼Œå¯ä»¥åœ¨ä¸ç ´åç³»ç»Ÿçš„æƒ…å†µä¸‹è¿›è¡Œäº¤æ¢ã€‚ å°è£…å°±æ˜¯æž„å»ºåœ¨è¿™ç§å¯¹å¤–éƒ¨éšè—ä¿¡æ¯çš„æ¦‚å¿µä¸Šã€‚ä»¥ç»†èƒžä¸ºç±»æ¯”ï¼šç»†èƒžå†…éƒ¨å¯èƒ½éžå¸¸å¤æ‚ï¼Œç”±æŸ“è‰²ä½“ï¼Œçº¿ç²’ä½“ï¼Œæ ¸ç³–ä½“ç­‰ç»„æˆï¼Œä½†å®ƒå®Œå…¨è¢«å°è£…åœ¨ä¸€ä¸ªå•ä¸€æ¨¡å—ä¸­ - æŠ½è±¡äº†å†…éƒ¨çš„å¤æ‚æ€§ã€‚ Module: A set of methods that work together as a whole to perform some task or set of related tasks.Encapsulated: A module is said to be encapsulated if its implementation is completely hidden, and it can be accessed only through a documented interface. PackagesåŒæ ·åŠŸèƒ½çš„ç±»å¯èƒ½æœ‰å¤šç§ç‰ˆæœ¬, æˆ–è€…ä¸åŒç±»åˆšå¥½å‘½åç›¸åŒã€‚é€šè¿‡ packages æ¥ä¸ºæ¯ä¸ª classes æä¾›å”¯ä¸€çš„æ ‡è¯†åç§°ï¼Œå¦‚java.util. A package is a namespace that organizes classes and interfaces. åœ¨IntelliJçš„æ“ä½œï¼š åˆ›å»º packageï¼š1, File â†’ New Package2, é€‰æ‹© package name (i.e. â€œug.joshh.animalâ€) ç»™ Package æ·»åŠ (æ–°) Java æ–‡ä»¶ï¼š1, å³é”® package name2, New â†’ Java Class3, å‘½å class, ç„¶åŽ IntelliJ ä¼šè‡ªåŠ¨æŠŠæ–‡ä»¶æ”¾è¿›æ­£ç¡®çš„è·¯å¾„, å¹¶æ·»åŠ  package declaration. ç§»åŠ¨å…¶ä»–.javaæ–‡ä»¶åˆ° Package1, åœ¨æ–‡ä»¶é¡¶éƒ¨å£°æ˜Ž package [packagename]2, å°†æ–‡ä»¶å­˜å‚¨åœ¨ï¼ˆç§»åŠ¨åˆ°ï¼‰ä¸Ž package name å¯¹åº”çš„æ–‡ä»¶å¤¹ä¸­ï¼šå¦‚ug.joshh.animal å¯¹åº”ug/joshh/animalæ–‡ä»¶è·¯å¾„. æ³¨æ„, ä¸å­˜åœ¨sub-packageè¿™ç§æ¦‚å¿µ, å³ug.joshh.Animalå’Œug.joshh.Plantæ˜¯å®Œå…¨ä¸åŒçš„. Packageå¥½å¤„: Organizing, making things package privateåå¤„: Specific Default packagesæ²¡æœ‰åœ¨æ–‡ä»¶é¡¶éƒ¨æ˜Žç¡®æŒ‡æ˜Ž package name çš„Javaç±»é»˜è®¤å±žäºŽ default package çš„ä¸€éƒ¨åˆ†ã€‚ ä¸€èˆ¬è€Œè¨€, Javaæ–‡ä»¶åº”è¯¥ä»¥æ˜Žç¡®çš„ package å£°æ˜Žå¼€å¤´ä»¥é¿å…å°†æ–‡ä»¶ç•™åœ¨ default package ä¸­ï¼ˆé™¤éžå®ƒæ˜¯ä¸€ä¸ªéžå¸¸å°çš„ç¤ºä¾‹ç¨‹åºï¼‰ã€‚å› ä¸ºæ¥è‡ª default package çš„ä»£ç æ— æ³• importï¼Œå¹¶ä¸”å¯èƒ½ä¼šæ„å¤–åœ°åœ¨ default package ä¸‹åˆ›å»ºç›¸åŒåç§°çš„ç±»ã€‚ JARä¸€èˆ¬æƒ…å†µä¸‹ï¼Œç¨‹åºä¼šåŒ…å«å¤šä¸ª.classæ–‡ä»¶ã€‚å¦‚æžœæƒ³å…±äº«æ­¤ç¨‹åºï¼Œå¯ä»¥æŠŠåŽ‹ç¼©æˆä¸€ä¸ª.jaræ–‡ä»¶ï¼Œæ­¤.jaræ–‡ä»¶å°†åŒ…å«ç¨‹åºæ‰€æœ‰.classæ–‡ä»¶ä»¥åŠå…¶ä»–é™„åŠ ä¿¡æ¯ã€‚JARæ–‡ä»¶å°±åƒzipæ–‡ä»¶ä¸€æ ·, å¯ä»¥å°†æ–‡ä»¶è§£åŽ‹ç¼©å›ž.javaæ–‡ä»¶ã€‚JARæ–‡ä»¶å¹¶ä¸ä¼šåŠ å¯†ä¿æŠ¤ä»£ç . Creating a JAR File (IntelliJ) Go to File â†’ Project Structure â†’ Artifacts â†’ JAR â†’ â€œFrom modules with dependenciesâ€ Click OK a couple of times Click Build â†’ Build Artifacts (this will create a JAR file in a folder called â€œArtifactsâ€) Distribute this JAR file to other Java programmers, who can now import it into IntelliJ (or otherwise) æƒé™æŽ§åˆ¶cs61b Josh Hug:Private Only code from the given class can access private members. Package Private The default access given to Java members if there is no explicit modifier written. Classes that belong in the same package can access, but not subclasses! Protected Classes within the same package and subclasses can access these members, but the rest of the world (e.g. classes external to the package or non-subclasses) cannot! Subtypes might need it, but subtype clients will not. Public Open and promised to the world, once deployed, the public membersâ€™ signatures should not change.å°±åƒæ‰¿è¯ºå’ŒåˆåŒï¼Œå°½é‡ä¸è¦æ›´æ”¹ï¼Œä»¥ä¾¿ç”¨æˆ·å§‹ç»ˆå¯ä»¥ï¼ˆç”¨å·²æœ‰çš„ä»£ç ï¼‰è®¿é—®ã€‚å¦‚æžœå¼€å‘è€…è¦èˆå¼ƒæŸä¸€ä¸ªPublicï¼Œä¸€èˆ¬æ ‡è¯†ä¸ºdeprecated. ç»†èŠ‚: Access is Based Only on Static Types æŽ¥å£çš„æ–¹æ³•é»˜è®¤æ˜¯publicçš„]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Digest]]></title>
    <url>%2Fpython-digest%2F</url>
    <content type="text"><![CDATA[What you will get from this Python digest:1, Learn advanced python programming.2, Learn new concepts, patterns, and methods that will expand your programming abilities, helping move you from a novice to an expert programmer.3, Practice going from a problem description to a solution, using a series of assignments. OperatorEmulating numeric typesIn-place operation: One modifies the data-structure itself 12345678910111213object.__iadd__(self, other)object.__isub__(self, other)object.__imul__(self, other)object.__imatmul__(self, other)object.__itruediv__(self, other)object.__ifloordiv__(self, other)object.__imod__(self, other)object.__ipow__(self, other[, modulo])object.__ilshift__(self, other)object.__irshift__(self, other)object.__iand__(self, other)object.__ixor__(self, other)Â¶object.__ior__(self, other) These methods are called to implement the augmented arithmetic assignments. These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self). If x is an instance of a class with an __iadd__() method, x += y is equivalent to x = operator.iadd(x, y) 1234B = np.arange(12).reshape(4,3)for b in B: b += 1print(B) # B will be changed Object oriented ProgrammingClass Name Guidlineunderscore (_):â€¢ For storing the value of last expression in interpreter.â€¢ For ignoring the specific values. (so-called â€œI donâ€™t careâ€)â€¢ To use as â€˜Internationalization(i18n)â€™ or â€˜Localization(l10n)â€™ functions.â€¢ To separate the digits of number literal value. To give special meanings and functions to name of variables or functionsâ€¢ _single_leading_underscore: weak â€œinternal useâ€ indicator, declaring private variables, functions, methods and classes in a module. Anything with this convention are ignored in from module import *.â€¢ single_trailing_underscore_: used by convention to avoid conflicts with Python keywordâ€¢ double_leading_underscore: when naming a class attribute, invokes name mangling (inside class FooBar, boo becomes _FooBar__boo; see Designing for inheritance)â€¢ double_leading_and_trailing_underscore: â€œmagicâ€ objects or attributes that live in user-controlled namespaces. E.g. init, import or file. Never invent such names; only use them as documented. See Magic Attributes Designing for inheritanceIf your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores. This invokes Pythonâ€™s name mangling algorithm, where the name of the class is mangled into the attribute name. This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name.â€¢ Note 1: Note that only the simple class name is used in the mangled name, so if a subclass chooses both the same class name and attribute name, you can still get name collisions.â€¢ Note 2: Name mangling can make certain uses, such as debugging and getattr(), less convenient. However the name mangling algorithm is well documented and easy to perform manually.â€¢ Note 3: Not everyone likes name mangling. Try to balance the need to avoid accidental name clashes with potential use by advanced callers. DescriptorMagic Attributes__init__ for initialization purpose. object.__dict__: A dictionary or other mapping object used to store an objectâ€™s (writable) attributes. Basically it contains all the attributes which describe the object under question. It can be used to alter or read the attributes. __call__ Is Python call-by-value or call-by-reference?Neither. In Python, (almost) everything is an object. What we commonly refer to as â€œvariablesâ€ in Python are more properly called names. A variable is not an alias for a location in memory. Rather, it is simply a binding to a Python object, likewise, â€œassignmentâ€ is really the binding of a name to an object. Each binding has a scope that defines its visibility, usually the block in which the name originates.â€“ https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/ Pythonå®žé™…ä¸Šæœ‰ä¸¤ç§å¯¹è±¡ã€‚ ä¸€ç§æ˜¯å¯å˜å¯¹è±¡ï¼Œè¡¨çŽ°å‡ºéšæ—¶é—´å˜åŒ–çš„è¡Œä¸ºã€‚å¯å˜å¯¹è±¡çš„å˜æ›´å¯¹ä¸Žå®ƒç»‘å®šçš„æ‰€æœ‰åç§°éƒ½å¯è§ï¼Œå¦‚ Python listã€‚ ä¸€ç§æ˜¯ä¸å¯å˜å¯¹è±¡ï¼Œå€¼åœ¨åˆ›å»ºåŽæ— æ³•ä¿®æ”¹ã€‚ è·Ÿjavaçš„ immutable referenceç±»ä¼¼çš„æ˜¯ Python tupleï¼šè™½ç„¶ tuple ä¸å¯å˜ï¼Œé‚£ä»…æ˜¯é’ˆå¯¹å…¶è‡ªèº«æ‰€ç»‘å®šå›ºå®šçš„å¯¹è±¡è€Œè¨€tuple(list1, list2)ï¼Œä½†tupleåŒ…å«çš„å…ƒç´ å¯¹è±¡list1, list2æœ¬èº«æœ‰è‡ªå·±çš„å¯å˜å±žæ€§. æ‰€ä»¥Pythonçš„æ–¹æ³•è°ƒç”¨ä¸­,foo(bar)åªæ˜¯åœ¨fooçš„ä½œç”¨åŸŸå†…åˆ›å»ºä¸€ä¸ªä¸Žå‚æ•°barçš„ç»‘å®šã€‚ å¦‚æžœbaræŒ‡å‘å¯å˜å¯¹è±¡ï¼Œå½“fooæ›´æ”¹æ—¶ï¼Œè¿™äº›æ›´æ”¹å¯ä»¥åœ¨å‡½æ•°fooçš„ä½œç”¨åŸŸå¤–å¯è§ã€‚ å¦‚æžœbaræŒ‡å‘ä¸€ä¸ªä¸å¯å˜çš„å¯¹è±¡ï¼Œfooåªèƒ½åœ¨å…¶è‡ªèº«æœ¬åœ°ç©ºé—´ä¸­åˆ›å»ºä¸€ä¸ªåç§°barå¹¶å°†å…¶ç»‘å®šåˆ°å…¶ä»–å¯¹è±¡ã€‚ Solving ProblemA general process to solve problem with three steps: understand, specify and design.1, Start with a vague understanding that you refine into a formal specification of a problem. In this step you want to take inventory of the concepts you are dealing with.2, Specify how this problem can be made amenable to being coded. What is the input and output? What output is desirable?3, Design working code ?? â€”-(1 Vague Understanding)â€“&gt;Formal specification of a problem â€”(2 Specify)â€”&gt;Amendable specificationâ€”(3 Design)â€”&gt;Working Code Program Design and DevelopmentDimensions of programming Correctness, Efficiency, Features, Elegance Each part takes time, learn to make Tradeoff: During the process, generally Correctness comes first. Test But pursuing the 100% Correctness is not the best choice. There is a balance of tradeoff, and sometimes saving some time and efforts to improving the Efficiency or adding more Features may be a better option. Elegance is good for maintaining and improving the program, which means saving for the future. Refactoring - moving along the Elegance direction without changing the other dimensions. DRY: donâ€™t repeat yourself Reuse: save time and code lines, also reduce the possibility of mistake Coding StyleFor Python, https://www.python.org/dev/peps/pep-0008 has emerged as the style guide that most projects adhere to; it promotes a very readable and eye-pleasing coding style. Here are the most important points extracted: Use 4-space indentation, and no tabs. 4 spaces are a good compromise between small indentation (allows greater nesting depth) and large indentation (easier to read). Tabs introduce confusion, and are best left out. Wrap lines so that they donâ€™t exceed 79 characters. This helps users with small displays and makes it possible to have several code files side-by-side on larger displays. Use blank lines to separate functions and classes, and larger blocks of code inside functions. When possible, put comments on a line of their own. Use docstrings. Use spaces around operators and after commas, but not directly inside bracketing constructs: a = f(1, 2) + g(3, 4). Name your classes and functions consistently; the convention is to use CamelCase for classes and lower_case_with_underscores for functions and methods. Always use self as the name for the first method argument (see A First Look at Classes for more on classes and methods). Donâ€™t use fancy encodings if your code is meant to be used in international environments. Pythonâ€™s default, UTF-8, or even plain ASCII work best in any case. Likewise, donâ€™t use non-ASCII characters in identifiers if there is only the slightest chance people speaking a different language will read or maintain the code. DocstringAn easy way to associate documentation with a function. Documentation Strings conventions The first line should always be a short, concise summary of the objectâ€™s purpose. The second line should be blank The following lines should be one or more paragraphs describing the objectâ€™s calling conventions, its side effects, etc. The following Python file shows the declaration of docstrings within a Python source file: 12345678910"""Assuming this is file mymodule.py, then this string, being thefirst statement in the file, will become the "mymodule" module'sdocstring when the file is imported."""class MyClass(object): """The class's docstring""" def my_method(self): """The method's docstring"""def my_function(): """The function's docstring""" The following is an interactive session showing how the docstrings may be accessed: 12345&gt;&gt;&gt; import mymodule&gt;&gt;&gt; help(mymodule)Assuming this is file mymodule.py then this string, being thefirst statement in the file will become the mymodule modulesdocstring when the file is imported&gt;&gt;&gt; help(mymodule.MyClass)The class&apos;s docstring&gt;&gt;&gt; help(mymodule.MyClass.my_method)The method&apos;s docstring&gt;&gt;&gt; help(mymodule.my_function)The function&apos;s docstring&gt;&gt;&gt; TestIt is important that each part of the specification gets turned into a piece of code that implements it and a test that tests it. Extreme valuesassertInsert debugging assertions into a program. Assertions are not a substitute for unit tests or system tests, but rather a complement. Using Assertions Effectively Places to consider putting assertions: checking parameter types, classes, or values checking data structure invariants checking â€œcanâ€™t happenâ€ situations (duplicates in a list, contradictory state variables.) after calling a function, to make sure that its return is reasonable TimeTrack which part of the code is the bottle neck of efficiency >&gt; python -m cProfile file.py import cProfile, cProfile.run(&#39;test()&#39;) Aspect-oriented programming correct efficiency Tracking time: to find out the bottle neck function or algorithm Rethinking the implementation of the bottle neck Fewer Easier/smaller: Divide and Conquer debuggingEach part is done with some line of codes. Instead of mix different part of the code together, it would be better to define them as different function/class. Try to seperate them as much as possible. FunctionThere are many special and useful function implementation and control flow in python: lambda, map, filter, reduce, generator, etc.. LambdaÎ», istead of defining function with def and a specific function name, Lambda provide a convinent way to define a function using its own native logic and methematical expression.The benifits areâ€¢ A small function could be defined wihtin the same code structure without seperating out a specific def functionâ€¢ Without bothering creating any proper funciton name for a small anonymous function. Lambda implementation1, Like nested function definitions, lambda functions can reference variables from the containing scope, returning a function from another function. This is often used to create function wrappers, such as Pythonâ€™s decorators.123456789# uses a lambda expression to return a function&gt;&gt;&gt; def make_incrementor(n):... return lambda x: x + n...&gt;&gt;&gt; f = make_incrementor(42) # f is declared as a lambda function "lambda x: x+42" with parameter n = 42&gt;&gt;&gt; f(0) # call f with x=0 to return the42&gt;&gt;&gt; f(1)43 This is like creating a compiler to save process cost: some parameters like default values or initial values are compiled into the compiler, program process these parameter only once, then this compiler as a function could be called many times with other input parameters which varies every time the compiler is being called(like user input values). 2, Pass a small function as an argument, sorting or max by an alternate key1234&gt;&gt;&gt; pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]&gt;&gt;&gt; pairs.sort(key=lambda pair: pair[1])&gt;&gt;&gt; pairs[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')] 123&gt;&gt;&gt; l =[('x',2),('y',4),('z',0)]&gt;&gt;&gt; max(l, key = lambda x: x[0])&gt;&gt;&gt; ('z', 0) Lambda with logic control flow1Lambda x,y: False if x&lt;y else x+y FilterConstruct a list from the elements of an iterable for which function returns true. If iterable is a string or a tuple, the result also has that type; otherwise it is always a list. filter(function, iterable) equals to if function is None: [item for item in iterable if item] if not: [item for item in iterable if function(item)] mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; [3, 6, 9] See itertools.ifilter() and itertools.ifilterfalse() for iterator versions of this function, including a variation that filters for elements where the function returns false. MapApply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel12&gt;&gt;&gt; map(lambda x: x % 2, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; [1, 0, 1, 0, 1, 0, 1, 0, 1] ReduceApply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value. 1234In [1]: reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])Out[1]: 15 # ((((1+2)+3)+4)+5)In [1]: reduce(lambda a, b: &apos;&#123;&#125;, &#123;&#125;&apos;.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])Out[1]: &apos;1, 2, 3, 4, 5, 6, 7, 8, 9&apos; List/Dict/Set Comprehensions List comprehensions: [ s for r, s in cards if r in &#39;JQK&#39; ] Dictionary comprehensions: {x: x ** 2 for x in range(5) if x % 2 == 0} Set comprehensions: {int(sqrt(x)) for x in range(30)} And in general, we can have any number of for statements, if statements, more for statements, more if statements. The whole is read from left to right Generator ExpressionsUnlike the for loop in the list comprehensions which walk through the whole loop, generator will walk one step in the for loop if a next() is called. The advantage is less indentation stop the loop early easier to edit Implementation of generator: g = (sq(x) for x in range(10) if x%2 == 0). The generator function is a promise, but no computation has been done yet. next(g) to call a one-time calculation. When reaching the end of for-loop in the generator, the next(g) comment will return a false called â€œStopIterationâ€. To avoid the â€œStopIterationâ€ false Use a outer for statement: for xx in g: ... convert the generator to list: list(g) Generator functionsUsing a yield expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function. Yield expressions The yield expression is only used when defining a generator function, and can only be used in the body of a function definition. Yield implementation 12345def ints(start, end=None): i = start while i &lt;= end or end is None: yield i i = i + 1 1234567def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b # print b a, b = b, a + b n = n + 1 IteratorThe true beneath For Statemet is iterable12for x in itmes: print x What the whole truth is:1234567it = iter(items)try: while True: x = next(it) print xexcept StopIteration: pass Overall, Python calls the thing that can be iterated over in a for loop an iterable. Strings and lists are examples of iterables, and so are generators. itertools library - Functions creating iterators for efficient looping.any(iterable): Return True if any element of the iterable is true. If the iterable is empty, return False. Unpacking Argument ListsThe * operator simply unpacks the tuple or list and passes them as the positional arguments to the function.12345&gt;&gt;&gt; list(range(3, 6)) # normal call with separate arguments[3, 4, 5]&gt;&gt;&gt; args = [3, 6]&gt;&gt;&gt; list(range(*args)) # call with arguments unpacked from a list[3, 4, 5] Handling different types of argument (*polymorphism)An argument could be different type: timedcalls(n,fn), if n is int isinstance(n,int), it means controling the how many times fn was called, while n is float, it means controling the total runtime of fn called eval()DecoratorMotivation: when applying a transformation to a function def f(self): ...definition...; f = dec(f), it becomes less readable with longer methods. It also seems less than pythonic to name the function three times for what is conceptually a single declaration. The solution is to place the decoration in the functionâ€™s declaration:123@decdef foo(cls): pass @propertyproperty(fget=None, fset=None, fdel=None, doc=None)A property object has three methods, getter(), setter(), and delete() to specify fget, fset and fdel at a later point. some_object = property(get_some_object,set_some_object) equals to123some_object = property() # make empty propertysome_object = some_object.getter(get_some_object) # assign fgetsome_object = some_object.setter(set_some_object) # assign fset Decorator as toolsâ€¢ Debug tool: help developping, count calls times, count excecute timeâ€¢ Performance: make the programme faster, such as dynamic programming algorithmâ€¢ Expressiveness: doc string, explaining funcitonâ€¢ Trace: help to monitor the execution of the program, such as each level result printed with different indentation Disable decorator: dec = disabled, make the decorator disabled. Regular Expressionimport re Reference: A Regular Expression Matcher In C language, any number start with â€˜0â€™ is interpreted as an octal number( base-8 number system ):â€˜012â€™ -&gt; int 10; â€˜09â€™ -&gt; invalid Special charactersâ€¢ * match 0 or more repetitions of the preceding character. ab* will match â€˜aâ€™, â€˜abâ€™, or â€˜aâ€™ followed by any number of â€˜bâ€™s.â€¢ ? Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. ab? will match either â€˜aâ€™ or â€˜abâ€™.â€¢ . (Dot) matches any single characterâ€¢ ^ (Caret) Matches the start of the stringâ€¢ $ Matches the end of the string or just before the newline at the end of the string, foo matches both â€˜fooâ€™ and â€˜foobarâ€™, while the regular expression foo$ matches only â€˜fooâ€™â€¢ + match 1 or more repetitions of the preceding RE. ab+ will match â€˜aâ€™ followed by any non-zero number of â€˜bâ€™s; it will not match just â€˜aâ€™. Commonly used expressionâ€¢ Upper case letter &#39;[A-Z]&#39;â€¢ Any alphanumeric character [a-zA-Z0-9_]â€¢ Decimal digit [0-9]â€¢ Non-digit character [^0-9]â€¢ Whitespace character [ \t\n\r\f\v] search(string[, pos[, endpos]]): Scan through string looking for a location where this regular expression produces a match, and return a corresponding MatchObject instance. Return None if no position in the string matches the pattern. re.findall(pattern, string, flags=0)ï¼šReturn all non-overlapping matches of pattern in string, as a list of strings. String FormattingModulo(%): String and Unicode objects have one unique built-in operation: the % operator (modulo). This is also known as the string formatting or interpolation operator. Given format % values (where format is a string or Unicode object), % conversion specifications in format are replaced with zero or more elements of values.%d: Signed integer decimal.%s: String (converts any python object using str()).print &#39;%d: %s&#39; % (1, &#39;animal&#39;) &gt;&gt; 1: animal Python data structureNumpy indexingEllipsis: The same as .... Special value used mostly in conjunction with extended slicing syntax for user-defined container data types. a = [1,2,3], a[...] is actually the same as a None: extends one more demention by further slicing the corresponding c into smallest units.12345t = np.arange(27).reshape(3,3,3), #t shape is (3,3,3)t[None,].shape # (1, 3, 3, 3)t[...,None].shape # (3, 3, 3, 1)t[:, None,:].shape # (3, 1, 3, 3)t[:,:, None].shape # (3, 3, 1, 3) Referenceâ€¢ CS212 Design of Computer Program @Udacity, Course Wiki SyllabusLesson 1: How to think to solve problemLesson 2: Python features; InstrumentationLesson 3: Build function as tools; Define language; GrammarLesson 4: Dealing with Complexity Through SearchLesson 5: Dealing with Uncertainty Through Probability â€¢ The Python Tutorialâ€¢ Open Book Project: How to Think Like a Computer Scientist: Learning with Python]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Programming Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java | Hash @Override equals() hashcode()]]></title>
    <url>%2Fjava-hashcode-equals%2F</url>
    <content type="text"><![CDATA[ä¸»è¦ä»‹ç»ï¼š Hashcodeï¼ˆå“ˆå¸Œç ï¼‰ä¸Ž equalsï¼ˆåˆ¤æ–­ç›¸ç­‰ï¼‰çš„å…³ç³» Hashcode æ–¹æ³•çš„åº•å±‚å®žçŽ°åŽŸç† å¼€å‘ä¸­éœ€è¦æŽŒæ¡çš„åŽŸåˆ™å’Œæ–¹æ³• HashSet, HashMap, HashTableHashSetåº•å±‚æ˜¯è°ƒç”¨HashMap. HashMap ä½¿ç”¨hashCodeå’Œequalsæ¥è¿›è¡Œå¯¹è±¡æ¯”è¾ƒã€‚æ‹¿HashSetå’Œadd()ä¸¾ä¾‹(å…¶ä½™çš„æ•°æ®ç»“æž„,å’Œ remove, containsç­‰æ–¹æ³•ç±»ä¼¼): å‡è®¾HashSeté‡Œé¢å·²ç»æœ‰äº†obj1, é‚£ä¹ˆå½“è°ƒç”¨HashSet.add(obj2)æ—¶: if (obj1 == obj2), é‚£ä¹ˆæ²¡æœ‰å¿…è¦è°ƒç”¨ hashCode(), å·²ç»æœ‰äº†è¿™ä¸ªå¯¹è±¡, æ²¡å¿…è¦æ·»åŠ äº† else, if hashCode ä¸åŒï¼Œé‚£ä¹ˆå¯ä»¥ç›´æŽ¥æ·»åŠ äº†, æ²¡å¿…è¦è¿›ä¸€æ­¥è°ƒç”¨ obj1.equals(obj2) æ¥åˆ¤æ–­å¯¹è±¡æ˜¯å¦ç›¸ç­‰ else hashCode ç›¸åŒï¼Œé‚£ä¹ˆéœ€è¦è¿›ä¸€æ­¥è°ƒç”¨obj1.equals(obj2) ä¸‹é¢è¿™æ®µä»£ç è™½ç„¶ HashSet åªå­˜äº† a å¯¹è±¡ï¼Œä½†å½“æ£€æŸ¥æ˜¯å¦åŒ…å« b å¯¹è±¡æ—¶ï¼Œè¿”å›žtrueã€‚12345HashSet&lt;String&gt; wordSet = new HashSet&lt;String&gt;();String a = "hello";String b = "hello";wordSet.add(a);return wordSet.contains(b); // return true æ ¹æ®Javadoc for Set. adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). æ ¹æ®Javadoc for String.equals Compares this string to the specified object. The result is true if and only if the argument is not null and is a String object that represents the same sequence of characters as this object. Javaçš„setæ˜¯ä½¿ç”¨å®ƒåŒ…å«çš„å…ƒç´ ï¼ˆå¯¹è±¡ï¼‰çš„ equals()æ¥æ¯”è¾ƒ b å’Œ a çš„ã€‚è¿™é‡Œ String ç±»çš„equals()method æ˜¯æ¯”è¾ƒå­—ç¬¦ä¸²å€¼æ˜¯å¦ç›¸ç­‰(å‡†ç¡®çš„è¯´ï¼Œæ˜¯å…ˆæ£€æŸ¥æ˜¯ä¸æ˜¯å¼•ç”¨åŒä¸€ä¸ªå¯¹è±¡ï¼Œå†çœ‹æ˜¯ä¸æ˜¯åŒä¸€ä¸ªç±»ï¼Œå†æ¯”è¾ƒå€¼)ï¼Œè€Œä¸æ˜¯å¼•ç”¨çš„å¯¹è±¡æ˜¯å¦ä¸€æ ·ï¼Œæ•…b.equals(a)æ˜¯ trueã€‚ åŒæ ·çš„ï¼Œremove å’Œ add ä¹Ÿä¼šå…ˆè¿›è¡Œç±»ä¼¼æ£€æŸ¥ã€‚ é—®é¢˜æ˜¯ï¼Œä¸ºä½• hashCode ä¸åŒï¼Œå°±æ²¡æœ‰è¿›ä¸€æ­¥è°ƒç”¨equals()çš„å¿…è¦å‘¢ï¼Ÿå› ä¸ºæœ‰ä¸€ä¸ªå‰ææ˜¯ä»£ç éµå®ˆThe hashCode contractã€‚ Hashcode and equalsåœ¨Javaä¸­ï¼Œæ¯ä¸ªå¯¹è±¡éƒ½æœ‰ä¸€ä¸ªhashCodeï¼Œå®ƒæœ‰æ—¶å®¹æ˜“è¢«äººé—å¿˜æˆ–è¯¯ç”¨ã€‚æœ‰ä»¥ä¸‹ä¸‰ç‚¹éœ€è¦æ³¨æ„ï¼Œé¿å…æŽ‰å…¥å¸¸è§çš„é™·é˜±ã€‚ æ ¹æ® The hashCode contract: Objects that are equal must have the same hash code within a running process. é™¤äº†å­—é¢æ„æ€ï¼Œä¹Ÿæœ‰å…¶ä»–éšå«çš„æ„æ€: ä¸ç›¸ç­‰çš„å¯¹è±¡çš„hashcodeä¹Ÿå¯èƒ½ä¸€æ ·; å…·æœ‰ç›¸åŒ hash code çš„å¯¹è±¡ä¸ä¸€å®šç›¸ç­‰. You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable. â€” Effective Java, by Joshua Bloch æ ¹æ®è¿™ä¸ªcontractï¼Œå¯ä»¥å»¶ä¼¸å‡ºä»¥ä¸‹å®žè·µåŽŸåˆ™ï¼š ä¸€ã€ æ¯å½“ä½  override equals æ—¶ï¼Œä¹Ÿè¦ override hashCodeå‡å¦‚ä½ éœ€è¦ä½¿ç”¨ä¸ä¸€æ ·çš„equalsåˆ¤æ–­æ ‡å‡†ï¼Œé‚£ä¹ˆå°±éœ€è¦é‡å†™equalsã€‚ä½†å‡å¦‚ä»…ä»…é‡å†™equalsï¼Œè€Œä¸é‡å†™hashcode()ï¼Œå°±å¯èƒ½ä¼šè¿èƒŒ The hashCode contractã€‚ ä¸ºä»€ä¹ˆï¼Ÿå› ä¸º hashCode method éœ€è¦åŒæ—¶é€‚é…çœŸæ­£ä½¿ç”¨åˆ°çš„ equals method çš„åˆ¤æ–­æ ‡å‡†ã€‚é€šè¿‡é‡å†™equalsï¼Œæˆ‘ä»¬é‡æ–°å£°æ˜Žäº†ä¸€ç§åˆ¤æ–­å¯¹è±¡æ˜¯å¦ç›¸ç­‰çš„æ ‡å‡†ï¼Œä½†åŽŸå§‹çš„ hashCode methodè¿˜æ˜¯ä¼šå°†æ‰€æœ‰å¯¹è±¡è§†ä¸ºä¸åŒçš„å¯¹è±¡ã€‚æ‰€ä»¥å¦‚æžœæ²¡æœ‰ä¸é‡å†™hashcodeï¼Œé‚£ä¹ˆæ ¹æ®@Override equals åˆ¤æ–­ä¸ºç›¸åŒçš„å¯¹è±¡å°†æ‹¥æœ‰ä¸åŒçš„hashcodeï¼ˆå¯èƒ½ï¼‰ã€‚è¿™æ ·ï¼Œå³ä½¿å·²ç»æœ‰äº†è¿™ä¸ªobjectï¼Œåœ¨HashMapä¸Šè°ƒç”¨ contains() ä¹Ÿä¼šè¿”å›žfalseã€‚ ä¾‹å­ï¼šåœ¨Javaçš„åˆ›å»ºè¡—é“streetè¿™ä¸ªç±»ï¼Œåœ¨åˆ¤æ–­ä¸¤æ¡è¡—é“æ˜¯å¦ç›¸åŒæ—¶ï¼Œæˆ‘ä»¬æœ‰è‡ªå®šä¹‰çš„è§„åˆ™ - åªè¦æ˜¯åœ¨åŒä¸€ä¸ªåŸŽå¸‚ï¼Œæœ‰åŒæ ·çš„è¡—é“åï¼Œé‚£ä¹ˆä¸¤ä¸ªstreetå°±ç›¸ç­‰ï¼Œå³ä½¿ä»–ä»¬æ˜¯å­˜æ”¾åœ¨ä¸åŒå†…å­˜ä½ç½®çš„ä¸¤ä¸ªå¯¹è±¡ï¼ˆJava çš„ Object åŽŸç”Ÿçš„equalsæ˜¯æ ¹æ®å¼•ç”¨çš„å¯¹è±¡å†…å­˜åœ°å€æ¥æ¯”è¾ƒåˆ¤æ–­çš„ï¼‰ã€‚1234567891011121314151617181920212223242526272829public class Street &#123; private String name; private String city; // ... @Override public boolean equals(Object obj) &#123; if (!(obj instanceof Street)) return false; if (obj == this) return true; Street rhs = (Street) obj; return new EqualsBuilder(). // if deriving: appendSuper(super.equals(obj)). append(name, rhs.name). append(age, rhs.city). isEquals(); &#125; @Override public int hashCode() &#123; return new HashCodeBuilder(17, 31). // two randomly chosen prime numbers // if deriving: appendSuper(super.hashCode()). append(name). append(city). toHashCode(); &#125;&#125; å¦‚æžœæ²¡æœ‰é‡å†™hashCode()ï¼Œ é‚£ä¹ˆä¸¤ä¸ªåå­—å’Œæ‰€åœ¨åŸŽå¸‚ä¸€æ ·çš„ï¼Œä½†å¼•ç”¨ä¸åŒåœ°å€çš„streetå°±ä¼šæŒ‰ç…§é»˜è®¤çš„ hashcode() è¿”å›žä¸ä¸€æ ·çš„codeï¼Œä½†æ˜¯æ ¹æ®é‡å†™çš„equals(), ä»–ä»¬æ˜¯ä¸€æ ·çš„, è¿™æ ·å°±è¿èƒŒäº† hashCode contractã€‚ ä¸ºäº†å®‰å…¨èµ·è§ï¼Œè®©Eclipse IDE ç”Ÿæˆ equals å’Œ hashCode å‡½æ•°ï¼šSource &gt; Generate hashCode() and equals()... ä¸ºäº†æé†’è‡ªå·±, è¿˜å¯ä»¥é…ç½®Eclipseä»¥æ£€æµ‹æ˜¯å¦æœ‰è¿åæ­¤è§„åˆ™çš„æƒ…å†µï¼Œå¹¶ä¸ºä»…é‡å†™äº†equalsä½†æ²¡é‡å†™hashCodeçš„æƒ…å†µæ˜¾ç¤ºé”™è¯¯ï¼šPreferences &gt; Java &gt; Compiler &gt; Errors/Warnings, then use the quick filter to search for â€œhashcodeâ€ HashCode collisionsHashCode collisions æŒ‡ä¸¤ä¸ªä¸åŒçš„å¯¹è±¡å…·æœ‰ç›¸åŒçš„hashcodeè¿™ç§æƒ…å†µ, è¿™ä¸æ˜¯ä»€ä¹ˆä¸¥é‡çš„é—®é¢˜. åªæ˜¯ä¼šå¯¼è‡´æ›´å¤šçš„æœç´¢æ­¥éª¤ï¼Œå¤ªå¤šcollisionså°±å¯èƒ½ä¼šé™ä½Žç³»ç»Ÿæ€§èƒ½ ä½†æ˜¯ï¼Œå¦‚æžœå°†HashCodeé”™è¯¯åœ°ç”¨ä½œå¯¹è±¡çš„å”¯ä¸€å¥æŸ„ï¼Œä¾‹å¦‚å°†å…¶ç”¨ä½œMapä¸­çš„keyï¼Œé‚£ä¹ˆæœ‰æ—¶ä¼šå¾—åˆ°é”™è¯¯çš„å¯¹è±¡ã€‚è™½ç„¶collisionsä¸€èˆ¬å¾ˆå°‘è§ï¼Œä½†å´æ˜¯ä¸å¯é¿å…çš„ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²â€œAaâ€å’Œâ€œBBâ€äº§ç”Ÿç›¸åŒçš„hashCodeï¼š2112. å› æ­¤è¡ç”Ÿå‡ºç¬¬äºŒä¸ªåŽŸåˆ™ äºŒã€æ°¸è¿œä¸è¦æŠŠhashcodeå½“åškeyæ¥ä½¿ç”¨ Javaä¸­æœ‰4,294,967,296ä¸ªï¼ˆ232)å¯èƒ½çš„intå€¼ï¼‰ã€‚æ—¢ç„¶æ‹¥æœ‰40äº¿ä¸ªæ’æ§½ï¼Œcollisionsä¼¼ä¹Žå‡ ä¹Žä¸å¯èƒ½å¯¹å§ï¼Ÿ ä½†äº‹å®žä¸Šï¼Œä¹Ÿä¸æ˜¯é‚£ä¹ˆä¸å¯èƒ½ã€‚è¯•æƒ³ï¼Œä¸€ä¸ªæˆ¿é—´é‡Œæœ‰23åéšæœºäººå‘˜ã€‚ä½ å¦‚ä½•ä¼°è®¡é‡Œé¢æœ‰ä¸¤ä¸ªäººç”Ÿæ—¥ä¸€æ ·çš„æ¦‚çŽ‡ï¼Ÿå¾ˆä½Žï¼Ÿå› ä¸ºä¸€å¹´æœ‰365å¤©ï¼Ÿäº‹å®žä¸Šï¼Œæ¦‚çŽ‡çº¦ä¸º50ï¼…ï¼è¿™ç§çŽ°è±¡è¢«ç§°ä¸ºç”Ÿæ—¥é—®é¢˜(æ‚–è®º)ã€‚ å¦‚æžœä¸€ä¸ªæˆ¿é—´é‡Œæœ‰23ä¸ªæˆ–23ä¸ªä»¥ä¸Šçš„äººï¼Œé‚£ä¹ˆè‡³å°‘æœ‰ä¸¤ä¸ªäººçš„ç”Ÿæ—¥ç›¸åŒçš„æ¦‚çŽ‡è¦å¤§äºŽ50%ã€‚ é—®é¢˜çš„æœ¬è´¨æ˜¯â€23äººä¹‹ä¸­ä¸¤ä¸¤ä¹‹é—´å­˜åœ¨ç”Ÿæ—¥ç›¸åŒçš„æ¦‚çŽ‡â€â€,è€Œä¸æ˜¯â€å…¶ä»–22äººä¸Žå…¶ä¸­ä¸€ä¸ªäººçš„ç”Ÿæ—¥ç›¸åŒçš„æ¦‚çŽ‡â€. ç±»æ¯”åˆ°hashcodeé‡Œï¼Œè¿™æ„å‘³ç€æœ‰77,163ä¸ªä¸åŒçš„å¯¹è±¡ï¼Œcollisionsæ¦‚çŽ‡æ˜¯50%ï¼ˆå‡è®¾æœ‰ä¸€ä¸ªç†æƒ³çš„hashCodeå‡½æ•°ï¼Œå°†å¯¹è±¡å‡åŒ€åˆ†å¸ƒåœ¨æ‰€æœ‰å¯ç”¨çš„bucketsä¸­ï¼‰ã€‚ HashCodes ä¼šå˜HashCode ä¸ä¿è¯åœ¨ä¸åŒçš„æ‰§è¡Œè¿‡ç¨‹ä¸­æ€»èƒ½è¿”å›žç›¸åŒçš„codeã€‚æ ¹æ®JavaDocï¼šWhenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. è¿™ç§æƒ…å†µå¹¶ä¸å¸¸è§ï¼Œå®žé™…ä¸Šï¼Œåº“ä¸­çš„æŸäº›ç±»ç”šè‡³æŒ‡å®šäº†ç”¨äºŽè®¡ç®—hashcodeçš„ç²¾ç¡®å…¬å¼ï¼ˆä¾‹å¦‚Stringï¼‰ã€‚å¯¹äºŽè¿™äº›ç±»ï¼Œhashcodeæ€»æ˜¯ç›¸åŒçš„ã€‚ä½†æ˜¯ï¼Œå°½ç®¡å¤§å¤šæ•°çš„hashCodeæ–¹æ³•æä¾›äº†ç¨³å®šçš„å€¼ï¼Œä½†æˆ‘ä»¬ä¸èƒ½ä¾èµ–å®ƒã€‚æ­£å¦‚è¿™ç¯‡æ–‡ç« æ‰€æŒ‡å‡ºçš„é‚£æ ·ï¼ŒJavaåº“å®žé™…ä¸Šåœ¨ä¸åŒçš„è¿›ç¨‹ä¸­è¿”å›žä¸åŒçš„hashCodeå€¼ï¼Œè¿™å¾€å¾€ä¼šè®©äººä»¬æ„Ÿåˆ°å›°æƒ‘ã€‚ Googleçš„Protocol Bufferså°±æ˜¯ä¸€ä¸ªä¾‹å­ã€‚ å› æ­¤ï¼Œæ‚¨ä¸åº”è¯¥åœ¨åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨hash codeã€‚å³ä½¿ä¸¤è€…ç›¸ç­‰ï¼Œè¿œç¨‹å¯¹è±¡çš„ hash code ä¹Ÿå¯èƒ½ä¸Žæœ¬åœ°çš„ä¸åŒã€‚ ä¸‰ã€ä¸è¦åœ¨åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨ hashCodeæ­¤å¤–ï¼Œè¦æ„è¯†åˆ°ï¼ŒhashCodeå‡½æ•°çš„å®žçŽ°å¯èƒ½ä¼šéšç€ç‰ˆæœ¬çš„æ›´æ”¹è€Œæ”¹å˜ã€‚å› æ­¤æˆ‘ä»¬çš„ä»£ç æœ€å¥½ä¸ä¾èµ–ä»»ä½•ç‰¹å®šçš„hash code å€¼ã€‚ä¾‹å¦‚ï¼Œä½ ä¸åº”è¯¥ä½¿ç”¨hash codeæ¥ä¿æŒæŸç§çŠ¶æ€ï¼Œä¸ç„¶ä¸‹æ¬¡è¿è¡Œæ—¶ï¼Œâ€œç›¸åŒâ€å¯¹è±¡çš„hash codeå¯èƒ½ä¼šä¸åŒã€‚ æ‰€ä»¥æœ€å¥½çš„å»ºè®®å¯èƒ½æ˜¯ï¼šé™¤éžè‡ªå·±åˆ›å»ºäº†åŸºäºŽ hashcode ç®—æ³•ï¼Œå¦åˆ™æ ¹æœ¬å°±ä¸è¦ä½¿ç”¨ hashCode å‘µå‘µâ€¦â€¦ æ€»ç»“åœ¨ä¾èµ–äºŽ HashSet, HashMap, HashTable â€¦ ç­‰æ•°æ®ç»“æž„çš„ç¨‹åºä¸­ï¼š ä»…é‡å†™ equals()ï¼Œä¼šå¯¼è‡´ä¸šåŠ¡å‡ºé”™ ä»…é‡å†™ hashcode(), åœ¨æ¯”è¾ƒä¸¤ä¸ªå¯¹è±¡æ—¶ä¸ä¼šå¼ºåˆ¶Javaå¿½ç•¥å†…å­˜åœ°å€ å¦‚æžœä¸æ¶‰åŠå¯¹è±¡æ¯”è¾ƒ(æ¯”å¦‚ä»…ä»…æ˜¯iteration), é‚£ä¹ˆä¸éœ€è¦hashCode and/or equals å‚è€ƒï¼šhttps://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/https://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java æŠ½è±¡ç±»]]></title>
    <url>%2Fjava-abstract-class%2F</url>
    <content type="text"><![CDATA[æŠ½è±¡ç±»æœ‰äº›æƒ…å†µä¸‹ï¼Œæœ‰äº›çˆ¶ç±»åœ¨å®žé™…åº”ç”¨ä¸­åªæœ‰è¢«ç»§æ‰¿çš„å’Œäº§ç”Ÿå¤šæ€çš„æ„ä¹‰ï¼Œè€Œæ²¡æœ‰å®žä¾‹åŒ–çš„æ„ä¹‰ï¼ˆæ¯”å¦‚æŠ½è±¡çš„Animal, Canineç­‰ï¼Œå®žä¾‹åŒ–è¿™äº›æŠ½è±¡æ¦‚å¿µæ²¡æœ‰å®žé™…æ„ä¹‰ï¼‰ï¼Œæ‰€ä»¥ä¸å¸Œæœ›è¿™ç§çˆ¶ç±»ä¼šè¢«åˆå§‹åŒ–ã€‚é€šè¿‡æ ‡è®°ç±»ä¸ºæŠ½è±¡ç±»ï¼Œç¼–è¯‘å™¨å°±çŸ¥é“è¯¥ç±»ä¸èƒ½åˆ›å»ºå®žä¾‹(ä¸èƒ½ä½œä¸ºnewå®žä¾‹, ä½†å¯ä»¥ç”¨äºŽå£°æ˜Žç±»åž‹).123456abstract class Canine extends Animal &#123; ...&#125;Canine c = new Dog;// Canine c = new Canine(); æ— æ³•ç¼–è¯‘ åä¹‹ï¼Œä¸æŠ½è±¡çš„ç±»å°±æ˜¯å…·ä½“ç±». æœ‰æŠ½è±¡ç±»è‡ªç„¶å°±æœ‰æŠ½è±¡æ–¹æ³•ï¼ŒæŠ½è±¡çš„æ–¹æ³•æ²¡æœ‰å®žä½“ï¼Œæ‰€æœ‰å°±ä¸ä¼šå«æœ‰å…·ä½“çš„å®žçŽ°public abstract void doSomething();. åªæœ‰æŠ½è±¡ç±»æ‰èƒ½æ‹¥æœ‰æŠ½è±¡æ–¹æ³•. åœ¨æŠ½è±¡çˆ¶ç±»ä¸­å®šä¹‰å¯ç»§æ‰¿çš„æŠ½è±¡æ–¹æ³•, å¯ä»¥å®šä¹‰å‡ºä¸€ç»„å­ç±»å…±åŒçš„åè®®, è¿™æ ·èƒ½å¤Ÿä¿è¯å¤šæ€. ä½†å› ä¸ºæŠ½è±¡æ–¹æ³•åªæ˜¯ä¸ºäº†æ ‡è®°å¤„å¤šæ€è€Œå­˜åœ¨, å®ƒä»¬æ²¡æœ‰å…·ä½“çš„å†…å®¹, è¿™æ ·åœ¨ç»§æ‰¿æ ‘ç»“æž„ä¸‹çš„ç¬¬ä¸€ä¸ªå…·ä½“ç±»å°±å¿…é¡»è¦å®žçŽ°æ‰€æœ‰çš„æŠ½è±¡æ–¹æ³•. å½“ç„¶, æ ‘ç»“æž„ä¸­çš„æŠ½è±¡ç±»ä¹Ÿå¯ä»¥æå‰æŠŠæŠ½è±¡æ–¹æ³•å®žçŽ°äº†(defaultæ–¹æ³•). æŠ½è±¡ç±»å’ŒæŽ¥å£çš„æ¯”è¾ƒæŽ¥å£æ˜¯æŠ½è±¡ç±»çš„æžç«¯å½¢å¼ï¼ŒæŽ¥å£æ˜¯å®Œå…¨æŠ½è±¡çš„ï¼Œä¸åŒ…å«å®žçŽ°ï¼ˆæ–°çš„ç‰¹æ€§æ”¯æŒdefault methodï¼‰ã€‚ æœ‰å¾ˆå¤šæƒ…æ™¯éœ€è¦æŸä¸ªç±»ç»§æ‰¿å¤šç§çˆ¶ç±»ã€‚æ¯”å¦‚ï¼Œå› ä¸ºåŽŸæ¥çš„ä¸šåŠ¡éœ€æ±‚æ¯”è¾ƒå•ä¸€ï¼Œåªéœ€è¦Animal - Canine - Dogè¿™ç§ç±»ç»“æž„å°±æ»¡è¶³éœ€æ±‚äº†, æ­¤æ—¶Dogåªæ˜¯Animalçš„å­ç±». ä½†åŽæ¥æœ‰äº†æ–°çš„åŠŸèƒ½éœ€æ±‚, ä¸Šçº¿äº†å® ç‰©åŠŸèƒ½, ç†è®ºä¸Šå¯ä»¥ä¸ºæ¯ä¸€ç§å…·ä½“çš„å±žäºŽå® ç‰©çš„å­ç±»æ·»åŠ å® ç‰©åŠŸèƒ½, è¿™å°±æ¶‰åŠå¤§é‡çš„äººå·¥å’Œbug. ä½†å‡å¦‚é¢å¤–è®¾è®¡ä¸€ç§Petç±», é‚£ä¹ˆPetå’ŒAnimalä¼šæœ‰äº¤å‰é‡å , å¦‚æžœè®©å® ç‰©å­ç±»åŒæ—¶ç»§æ‰¿ä¸¤ç§è¶…ç±», é‚£å°±æ˜¯å¤šé‡ç»§æ‰¿. å› ä¸ºå¤šé‡ç»§æ‰¿ä¼šæœ‰è‡´å‘½æ–¹å—çš„é—®é¢˜. æ‰€ä»¥Javaä¸æ”¯æŒè¿™ç§æ–¹å¼. è€ŒæŽ¥å£è¿™ä¸ªæ¦‚å¿µ, å°±æ˜¯ç”¨äºŽè§£å†³è¿™ä¸ªé—®é¢˜çš„:1234567public interface Pet&#123; public abstract void beFriendly(); public abstract void play();&#125;// å¯¹äºŽå±žäºŽå® ç‰©çš„å­ç±»ï¼Œè®©å…¶å®žçŽ°æŽ¥å£`Pet`.public class Dog extends Canine implements Pet &#123;&#125; åŸºæœ¬ä¸Šï¼ŒæŽ¥å£èƒ½åšçš„æŠ½è±¡ç±»éƒ½å¯ä»¥åšã€‚ ä½†æŽ¥å£çš„æœ€å¤§æ„ä¹‰å°±æ˜¯å…¶æ— æ¯”çš„é€‚ç”¨æ€§, è‹¥ä»¥æŽ¥å£å–ä»£å…·ä½“çš„å­ç±»æˆ–æŠ½è±¡ç±»ä½œä¸ºå‚æ•°æˆ–è¿”å›žç±»åž‹, é‚£ä¹ˆå°±å¯ä»¥ä¼ å…¥ä»»ä½•æœ‰å®žçŽ°è¯¥æŽ¥å£çš„ä¸œè¥¿. æœ‰äº†æŽ¥å£, ç±»å°±å¯ä»¥ç»§æ‰¿è¶…è¿‡ä¸€ä¸ªä»¥ä¸Šçš„æ¥æº: å¯ä»¥ç»§æ‰¿æŸä¸ªçˆ¶ç±», å¹¶ä¸”å®žçŽ°å…¶ä»–æŽ¥å£. æŽ¥å£è‡ªèº«å¯ä»¥extendså¤šä¸ªå…¶ä»–æŽ¥å£. ä¸€ä¸ªç±», å¯ä»¥å®žçŽ°å¤šä¸ªæŽ¥å£. class Dog extends Animal implements Pet, Saveable, paintable {} ä¸€ä¸ªæŽ¥å£, å¯ä»¥ç»™ä¸åŒçš„ç±»ä½¿ç”¨, å› æ­¤å°±å¯ä»¥ä¸ºä¸åŒçš„éœ€æ±‚ç»„åˆå‡ºä¸åŒçš„ç»§æ‰¿å±‚æ¬¡. ç­‰äºŽè¯´æœ‰äº†æŽ¥å£, é‚£ä¹ˆä¸ç®¡ä¸€ä¸ªç±»æ˜¯ä»€ä¹ˆç±», åªè¦å®ƒå®žçŽ°äº†ä¸€ä¸ªæŽ¥å£, é‚£ä¹ˆå°±çŸ¥é“å®ƒä¸€å®šä¼šå±¥è¡Œå¯¹åº”çš„è¡Œä¸ºåˆçº¦. å…è®¸ä¸åŒç»§æ‰¿æ ‘çš„ç±»å®žçŽ°å…±åŒçš„æŽ¥å£å¯¹Java APIæ¥è¯´æ˜¯éžå¸¸é‡è¦çš„, æ¯”å¦‚è¦å°†å¯¹è±¡çŠ¶æ€ä¿å­˜èµ·æ¥, åªè¦åŽ»å®žçŽ°SerializableæŽ¥å£å³å¯; æ‰“ç®—è®©å¯¹è±¡ä»¥å•ç‹¬çš„çº¿ç¨‹æ¥æ‰§è¡Œ, å°±å®žçŽ°Runnable. è¦æ³¨æ„ï¼ŒæŽ¥å£èƒ½æ‰©å±•extendså¤šä¸ªæŽ¥å£ï¼Œä¸èƒ½å®žçŽ°implementä»»ä½•æŽ¥å£. å®žé™…åº”ç”¨ä¸­ï¼ŒæŠ½è±¡ç±»é€šå¸¸ç”¨äºŽéƒ¨åˆ†åœ°å®žçŽ°æŽ¥å£ï¼Œåœ¨æŽ¥å£å’Œå®žé™…çš„ç±»ä¸­é—´æ‰®æ¼”ä¸€ä¸ªä¸­é—´æ¦‚å¿µã€‚1234567891011121314151617public interface Car &#123; void move(Speed x); void stop();&#125;public abstract class DeluxeModel implements Car &#123; public double x; ... public void move(Speed x) &#123; ... &#125; public abstract void autoPilot();&#125;// å®žçŽ°æ—¶, è¦ override æ‰€æœ‰æŠ½è±¡æ–¹æ³•public class TeslaX extends DeluxeModel &#123; public void stop() &#123; ... &#125; public void autoPilot() &#123; ... &#125;&#125; è‹¥ä¸ç¡®å®šç”¨å“ªç§, å°±ä¼˜å…ˆè€ƒè™‘æŽ¥å£ï¼Œä»¥é™ä½Žå¤æ‚æ€§ã€‚â€“ https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html Abstract classes ä»‹äºŽæŽ¥å£å’Œ classes ä¹‹é—´ã€‚ æ–¹æ³•å¯ä»¥æ˜¯publicæˆ–private, ä¹Ÿæ”¯æŒprotectedå’Œpackage private. æ”¯æŒä»»ä½•ç±»åž‹çš„å˜é‡ æ— æ³•å®žä¾‹åŒ– é™¤éžæŒ‡å®šä¸ºabstractï¼Œå¦åˆ™æ–¹æ³•é»˜è®¤æ˜¯å…·ä½“çš„å®žçŽ° æ¯ä¸ªç±»åªèƒ½å®žçŽ°ä¸€ä¸ª Abstract classes æŠ½è±¡ç±»ä¸éœ€è¦å®žçŽ°å…¶ç»§æ‰¿çš„æŽ¥å£æ‰€æœ‰æŠ½è±¡æ–¹æ³• Interface: é™¤éžæŒ‡å®šaccess modifier, å¦åˆ™æ‰€æœ‰çš„æ–¹æ³•é»˜è®¤éƒ½æ˜¯public ï¼ˆJava 9 æ”¯æŒ privateï¼‰ å¯ä»¥æä¾›å˜é‡, ä½†éƒ½æ˜¯public static final, ä¹Ÿå³æ²¡æœ‰å®žä¾‹å˜é‡ æ— æ³•å®žä¾‹åŒ– é™¤éžæŒ‡å®šä¸ºdefaultï¼Œå¦åˆ™æ‰€æœ‰æ–¹æ³•å‡ä¸ºæŠ½è±¡çš„ ä¸€ä¸ªç±»å¯ä»¥å®žçŽ°å¤šä¸ªæŽ¥å£ æ ¹æ®åè®®æ‰¿è¯º, å®žçŽ°ç±»å¿…é¡»å®žçŽ°å…¶ç»§æ‰¿çš„æŽ¥å£çš„æ‰€æœ‰æŠ½è±¡æ–¹æ³•; å¦åˆ™è¦å£°æ˜Žä¸ºæŠ½è±¡ç±». å¦‚ä½•åˆ¤æ–­åº”è¯¥è®¾è®¡ç±»ï¼Œå­ç±»ï¼ŒæŠ½è±¡ç±»ï¼Œè¿˜æ˜¯æŽ¥å£å‘¢ï¼Ÿ å¦‚æžœæ–°çš„ç±»æ— æ³•å¯¹å…¶ä»–çš„ç±»é€šè¿‡IS-Aæµ‹è¯•æ—¶ï¼Œå°±è®¾è®¡ä¸ç»§æ‰¿å…¶ä»–ç±»çš„ç±» åªæœ‰åœ¨éœ€è¦æŸç±»çš„ç‰¹æ®ŠåŒ–ç‰ˆæœ¬æ—¶ï¼Œä»¥è¦†ç›–æˆ–å¢žåŠ æ–°çš„æ–¹æ³•æ¥ç»§æ‰¿çŽ°æœ‰çš„ç±» å½“éœ€è¦å®šä¹‰ä¸€ç¾¤å­ç±»çš„æ¨¡æ¿ï¼Œåˆä¸æƒ³è®©ç¨‹åºå‘˜åˆå§‹åŒ–æ­¤æ¨¡æ¿æ—¶ï¼Œè®¾è®¡å‡ºæŠ½è±¡çš„ç±»ç»™ä»–ä»¬ç”¨ å¦‚æžœæƒ³è¦å®šä¹‰ç±»å¯ä»¥æ‰®æ¼”çš„è§’è‰²ï¼Œä½¿ç”¨æŽ¥å£]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java å¥—æŽ¥å­—Socket]]></title>
    <url>%2Fjava-socket%2F</url>
    <content type="text"><![CDATA[Socketç½‘ç»œä¸Šçš„ä¸¤ä¸ªç¨‹åºé€šè¿‡ä¸€ä¸ªåŒå‘çš„é€šè®¯è¿žæŽ¥å®žçŽ°æ•°æ®çš„äº¤æ¢ï¼Œè¿™ä¸ªåŒå‘é“¾è·¯çš„ä¸€ç«¯ç§°ä¸ºä¸€ä¸ªSocketï¼Œç¡®åˆ‡çš„è¯´Socketæ˜¯ä¸ªä»£è¡¨ä¸¤å°æœºå™¨ä¹‹é—´ç½‘ç»œè¿žæŽ¥çš„å¯¹è±¡ã€‚Socketæ˜¯TCP/IPåè®®çš„ä¸€ä¸ªååˆ†æµè¡Œçš„ç¼–ç¨‹ç•Œé¢ï¼Œä¸€ä¸ªSocketç”±ä¸€ä¸ªIPåœ°å€å’Œä¸€ä¸ªç«¯å£å·å”¯ä¸€ç¡®å®šã€‚Socket socket = new Socket(&quot;192.168.2.1&quot;, 5000), ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯IPåœ°å€, ç¬¬äºŒä¸ªå‚æ•°æ˜¯ç«¯å£. Socketè¿žæŽ¥çš„å»ºç«‹ä»£è¡¨ä¸¤å°æœºå™¨ä¹‹é—´å­˜æœ‰å¯¹æ–¹çš„ä¿¡æ¯, åŒ…æ‹¬ç½‘ç»œåœ°å€å’ŒTCPç«¯å£å·.ä½†æ˜¯ï¼ŒSocketæ‰€æ”¯æŒçš„åè®®ç§ç±»ä¹Ÿä¸å…‰TCP/IPä¸€ç§ï¼Œå› æ­¤ä¸¤è€…ä¹‹é—´æ˜¯æ²¡æœ‰å¿…ç„¶è”ç³»çš„ã€‚åœ¨JavaçŽ¯å¢ƒä¸‹ï¼ŒSocketç¼–ç¨‹ä¸»è¦æ˜¯æŒ‡åŸºäºŽTCP/IPåè®®çš„ç½‘ç»œç¼–ç¨‹ã€‚ ä½¿ç”¨BufferedReaderä»ŽSocketä¸Šè¯»å–æ•°æ®ï¼š å»ºç«‹å¯¹æœåŠ¡å™¨çš„Socketè¿žæŽ¥Socket socket = new Socket(&quot;192.168.2.1&quot;, 5000) å»ºç«‹è¿žæŽ¥åˆ°Socketä¸Šä½Žå±‚è¾“å…¥ä¸²æµçš„InputStreamReader InputStreamReader stream = new InputStreamReader(socket.getInputStream());, ä½œä¸ºä»Žä½Žå±‚å’Œé«˜å±‚ä¸²æµé—´çš„æ¡¥æ¢, æŠŠæ¥è‡ªæœåŠ¡å™¨çš„å­—èŠ‚è½¬æ¢ä¸ºå­—ç¬¦ å»ºç«‹ç¼“å†²åŒºBufferedReaderæ¥è¯»å–12BufferedReader reader = new BufferedReader(stream);String msg = reader.readLine(); ç”¨PrintWriterå†™æ•°æ®åˆ°Socketä¸Š: å»ºç«‹å¯¹æœåŠ¡å™¨çš„Socketè¿žæŽ¥ å»ºç«‹é“¾æŽ¥åˆ°Socketçš„PrintWriter PrintWriter writer = new PrintWriter(socket.getOutputStream()), ä½œä¸ºå­—ç¬¦æ•°æ®å’Œå­—èŠ‚é—´çš„è½¬æ¢æ¡¥æ¢, å¯ä»¥è¡”æŽ¥Stringså’ŒSocketä¸¤ç«¯ å†™å…¥æ•°æ®1writer.println("You have a message"); TCP/IPTCP/IPåè®®é›†åŒ…æ‹¬åº”ç”¨å±‚, ä¼ è¾“å±‚ï¼Œç½‘ç»œå±‚ï¼Œç½‘ç»œè®¿é—®å±‚ã€‚ åº”ç”¨å±‚åè®®ä¸»è¦åŒ…æ‹¬å¦‚ä¸‹å‡ ä¸ªï¼šFTPã€TELNETã€DNSã€SMTPã€NFSã€HTTPã€‚ FTP(File Transfer Protocolï¼‰æ˜¯æ–‡ä»¶ä¼ è¾“åè®®ï¼Œä¸€èˆ¬ä¸Šä¼ ä¸‹è½½ç”¨FTPæœåŠ¡ï¼Œæ•°æ®ç«¯å£æ˜¯20Hï¼ŒæŽ§åˆ¶ç«¯å£æ˜¯21Hã€‚ TelnetæœåŠ¡æ˜¯ç”¨æˆ·è¿œç¨‹ç™»å½•æœåŠ¡ï¼Œä½¿ç”¨23Hç«¯å£ï¼Œä½¿ç”¨æ˜Žç ä¼ é€ï¼Œä¿å¯†æ€§å·®ã€ç®€å•æ–¹ä¾¿ã€‚ DNS(Domain Name Serviceï¼‰æ˜¯åŸŸåè§£æžæœåŠ¡ï¼Œæä¾›åŸŸååˆ°IPåœ°å€ä¹‹é—´çš„è½¬æ¢ï¼Œä½¿ç”¨ç«¯å£53ã€‚ SMTP(Simple Mail Transfer Protocolï¼‰æ˜¯ç®€å•é‚®ä»¶ä¼ è¾“åè®®ï¼Œç”¨æ¥æŽ§åˆ¶ä¿¡ä»¶çš„å‘é€ã€ä¸­è½¬ï¼Œä½¿ç”¨ç«¯å£25ã€‚ NFSï¼ˆNetwork File Systemï¼‰æ˜¯ç½‘ç»œæ–‡ä»¶ç³»ç»Ÿï¼Œç”¨äºŽç½‘ç»œä¸­ä¸åŒä¸»æœºé—´çš„æ–‡ä»¶å…±äº«ã€‚ HTTP(Hypertext Transfer Protocolï¼‰æ˜¯è¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼Œç”¨äºŽå®žçŽ°äº’è”ç½‘ä¸­çš„WWWæœåŠ¡ï¼Œä½¿ç”¨ç«¯å£80ã€‚ ç½‘ç»œæŽ¥å£å±‚: Internetåè®®(IP): æ•°æ®é“¾è·¯å±‚æ˜¯è´Ÿè´£æŽ¥æ”¶IPæ•°æ®åŒ…å¹¶é€šè¿‡ç½‘ç»œå‘é€ï¼Œæˆ–è€…ä»Žç½‘ç»œä¸ŠæŽ¥æ”¶ç‰©ç†å¸§ï¼ŒæŠ½å‡ºIPæ•°æ®åŒ…ï¼Œäº¤ç»™IPå±‚ã€‚ æ­£å‘åœ°å€è§£æžåè®®(ARP): é€šè¿‡å·²çŸ¥çš„IPï¼Œå¯»æ‰¾å¯¹åº”ä¸»æœºçš„MACåœ°å€ã€‚ åå‘åœ°å€è§£æžåè®®(RARP): é€šè¿‡MACåœ°å€ç¡®å®šIPåœ°å€ã€‚æ¯”å¦‚æ— ç›˜å·¥ä½œç«™è¿˜æœ‰DHCPæœåŠ¡ã€‚ TCPå’ŒUDPTCP åè®®å’Œ UDP åè®®éƒ½å±žäºŽTCP/IPåè®®ç°‡ã€‚ä¹Ÿå«ç«¯åˆ°ç«¯ä¼ è¾“åè®®ï¼Œå› ä¸ºä»–ä»¬å°†æ•°æ®ä»Žä¸€ä¸ªåº”ç”¨ç¨‹åºä¼ è¾“åˆ°å¦ä¸€ä¸ªåº”ç”¨ç¨‹åºï¼Œè€Œ IP åè®®åªæ˜¯å°†æ•°æ®ä»Žä¸€ä¸ªä¸»æœºä¼ è¾“åˆ°å¦ä¸€ä¸ªä¸»æœºã€‚ TCPæ˜¯é¢å‘è¿žæŽ¥çš„é€šä¿¡åè®®ï¼Œé€šè¿‡ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹è¿žæŽ¥ï¼Œé€šè®¯å®Œæˆæ—¶è¦æ‹†é™¤è¿žæŽ¥ï¼Œç”±äºŽTCPæ˜¯é¢å‘è¿žæŽ¥çš„æ‰€ä»¥åªèƒ½ç”¨äºŽç«¯åˆ°ç«¯çš„é€šè®¯ã€‚TCPæä¾›çš„æ˜¯ä¸€ç§å¯é çš„æ•°æ®æµæœåŠ¡ï¼Œé‡‡ç”¨â€œå¸¦é‡ä¼ çš„è‚¯å®šç¡®è®¤â€æŠ€æœ¯æ¥å®žçŽ°ä¼ è¾“çš„å¯é æ€§ã€‚TCPè¿˜é‡‡ç”¨ä¸€ç§ç§°ä¸ºâ€œæ»‘åŠ¨çª—å£â€çš„æ–¹å¼è¿›è¡Œæµé‡æŽ§åˆ¶ï¼Œæ‰€è°“çª—å£å®žé™…è¡¨ç¤ºæŽ¥æ”¶èƒ½åŠ›ï¼Œç”¨ä»¥é™åˆ¶å‘é€æ–¹çš„å‘é€é€Ÿåº¦ã€‚ UDPæ˜¯é¢å‘æ— è¿žæŽ¥çš„é€šè®¯åè®®ï¼ŒUDPæ•°æ®åŒ…æ‹¬ç›®çš„ç«¯å£å·å’Œæºç«¯å£å·ä¿¡æ¯ï¼Œ UDPé€šè®¯æ—¶ä¸éœ€è¦æŽ¥æ”¶æ–¹ç¡®è®¤ï¼Œå±žäºŽä¸å¯é çš„ä¼ è¾“ï¼Œå¯èƒ½ä¼šå‡ºçŽ°ä¸¢åŒ…çŽ°è±¡ï¼Œå®žé™…åº”ç”¨ä¸­è¦æ±‚ç¨‹åºå‘˜ç¼–ç¨‹éªŒè¯ã€‚ ä¸ä¿è¯å¯é äº¤ä»˜ï¼Œä¸ä¿è¯é¡ºåºï¼Œå› æ­¤ä¸»æœºä¸éœ€è¦ç»´æŒå¤æ‚çš„é“¾æŽ¥çŠ¶æ€è¡¨ ç”±äºŽä¼ è¾“æ•°æ®ä¸å»ºç«‹è¿žæŽ¥ï¼Œå› æ­¤ä¹Ÿå°±ä¸éœ€è¦ç»´æŠ¤è¿žæŽ¥çŠ¶æ€ï¼ŒåŒ…æ‹¬æ”¶å‘çŠ¶æ€ç­‰ï¼Œå› æ­¤ä¸€å°æœåŠ¡æœºå¯åŒæ—¶å‘å¤šä¸ªå®¢æˆ·æœºä¼ è¾“ç›¸åŒçš„æ¶ˆæ¯ã€‚ åº”ç”¨ï¼š TCPåœ¨ç½‘ç»œé€šä¿¡ä¸Šæœ‰æžå¼ºçš„ç”Ÿå‘½åŠ›ï¼Œä¾‹å¦‚è¿œç¨‹è¿žæŽ¥ï¼ˆTelnetï¼‰å’Œæ–‡ä»¶ä¼ è¾“ï¼ˆFTPï¼‰éƒ½éœ€è¦ä¸å®šé•¿åº¦çš„æ•°æ®è¢«å¯é åœ°ä¼ è¾“ã€‚ä½†æ˜¯å¯é çš„ä¼ è¾“æ˜¯è¦ä»˜å‡ºä»£ä»·çš„ï¼Œå¯¹æ•°æ®å†…å®¹æ­£ç¡®æ€§çš„æ£€éªŒå¿…ç„¶å ç”¨è®¡ç®—æœºçš„å¤„ç†æ—¶é—´å’Œç½‘ç»œçš„å¸¦å®½ï¼Œå› æ­¤TCPä¼ è¾“çš„æ•ˆçŽ‡ä¸å¦‚UDPé«˜ã€‚ UDPæ“ä½œç®€å•ï¼Œè€Œä¸”ä»…éœ€è¦è¾ƒå°‘çš„ç›‘æŠ¤ï¼Œå› æ­¤é€šå¸¸ç”¨äºŽå±€åŸŸç½‘é«˜å¯é æ€§çš„åˆ†æ•£ç³»ç»Ÿä¸­client/serveråº”ç”¨ç¨‹åºã€‚ä¾‹å¦‚è§†é¢‘ä¼šè®®ç³»ç»Ÿï¼Œå¹¶ä¸è¦æ±‚éŸ³é¢‘è§†é¢‘æ•°æ®ç»å¯¹çš„æ­£ç¡®ï¼Œåªè¦ä¿è¯è¿žè´¯æ€§å°±å¯ä»¥äº†ï¼Œè¿™ç§æƒ…å†µä¸‹æ˜¾ç„¶ä½¿ç”¨UDPä¼šæ›´åˆç†ä¸€äº›ã€‚ TCPè¿žæŽ¥ä¸Žæ–­å¼€æœ€åˆä¸¤ç«¯çš„TCPè¿›ç¨‹éƒ½å¤„äºŽCLOSEDå…³é—­çŠ¶æ€ï¼Œå®¢æˆ·Aä¸»åŠ¨æ‰“å¼€è¿žæŽ¥ï¼Œè€ŒæœåŠ¡å™¨Bè¢«åŠ¨æ‰“å¼€è¿žæŽ¥, è¿‡ç¨‹ç±»ä¼¼äºŽæƒ³ç»™ä½ å‘æ•°æ®å¯ä»¥å—ï¼Ÿ - å¯ä»¥ï¼ŒçŽ°åœ¨å‘ï¼Ÿ - å¯¹ï¼Œè¯·å‡†å¤‡æŽ¥æ”¶â€ã€‚è¿‡ç¨‹æ˜¯ä¸‰æ¬¡æ¡æ‰‹ï¼š èµ·åˆä¸¤ç«¯éƒ½å¤„äºŽCLOSEDå…³é—­çŠ¶æ€ï¼ŒClientå°†æ ‡å¿—ä½SYNç½®ä¸º1ï¼Œéšæœºäº§ç”Ÿä¸€ä¸ªå€¼seq=xï¼Œå¹¶å°†è¯¥æ•°æ®åŒ…å‘é€ç»™Serverï¼ŒClientè¿›å…¥SYN-SENTçŠ¶æ€ï¼Œç­‰å¾…Serverç¡®è®¤ï¼› Serveræ”¶åˆ°æ•°æ®åŒ…åŽç”±æ ‡å¿—ä½SYN=1å¾—çŸ¥Clientè¯·æ±‚å»ºç«‹è¿žæŽ¥ï¼ŒServerå°†æ ‡å¿—ä½SYNå’ŒACKéƒ½ç½®ä¸º1ï¼Œack=x+1ï¼Œéšæœºäº§ç”Ÿä¸€ä¸ªå€¼seq=yï¼Œå¹¶å°†è¯¥æ•°æ®åŒ…å‘é€ç»™Clientä»¥ç¡®è®¤è¿žæŽ¥è¯·æ±‚ï¼ŒServerè¿›å…¥SYN-RCVDçŠ¶æ€ï¼Œæ­¤æ—¶æ“ä½œç³»ç»Ÿä¸ºè¯¥TCPè¿žæŽ¥åˆ†é…TCPç¼“å­˜å’Œå˜é‡ï¼› Clientæ”¶åˆ°ç¡®è®¤åŽï¼Œæ£€æŸ¥ackæ˜¯å¦ä¸ºx+1ï¼ŒACKæ˜¯å¦ä¸º1ï¼Œå¦‚æžœæ­£ç¡®åˆ™å°†æ ‡å¿—ä½ACKç½®ä¸º1ï¼Œack=y+1ï¼Œå¹¶ä¸”æ­¤æ—¶æ“ä½œç³»ç»Ÿä¸ºè¯¥TCPè¿žæŽ¥åˆ†é…TCPç¼“å­˜å’Œå˜é‡ï¼Œå¹¶å°†è¯¥æ•°æ®åŒ…å‘é€ç»™Serverï¼ŒServeræ£€æŸ¥ackæ˜¯å¦ä¸ºy+1ï¼ŒACKæ˜¯å¦ä¸º1ï¼Œå¦‚æžœæ­£ç¡®åˆ™è¿žæŽ¥å»ºç«‹æˆåŠŸï¼ŒClientå’ŒServerè¿›å…¥ESTABLISHEDçŠ¶æ€ï¼Œå®Œæˆä¸‰æ¬¡æ¡æ‰‹ï¼ŒéšåŽClientå’ŒServerå°±å¯ä»¥å¼€å§‹ä¼ è¾“æ•°æ®ã€‚ ä¹‹æ‰€ä»¥ä¸å¯ä»¥ä»…é äºŒæ¬¡æ¡æ‰‹, ä¸»è¦ä¸ºäº†é˜²æ­¢å·²å¤±æ•ˆçš„è¿žæŽ¥è¯·æ±‚æŠ¥æ–‡æ®µçªç„¶åˆä¼ é€åˆ°äº†B(å› ä¸ºå»¶è¯¯ç­‰åŽŸå› )ï¼Œå› è€Œäº§ç”Ÿé”™è¯¯, æ•…Aè¿˜è¦å‘é€ä¸€æ¬¡ç¡®è®¤. æ–­å¼€è¿žæŽ¥éœ€è¦å››æ¬¡æŒ¥æ‰‹: Açš„åº”ç”¨è¿›ç¨‹å…ˆå‘å…¶TCPå‘å‡ºè¿žæŽ¥é‡Šæ”¾æŠ¥æ–‡æ®µï¼ˆFIN=1ï¼Œåºå·seq=uï¼‰ï¼Œå¹¶åœæ­¢å†å‘é€æ•°æ®ï¼Œä¸»åŠ¨å…³é—­TCPè¿žæŽ¥ï¼Œè¿›å…¥FIN-WAIT-1ï¼ˆç»ˆæ­¢ç­‰å¾…1ï¼‰çŠ¶æ€ï¼Œæå‡ºåœæ­¢TCPè¿žæŽ¥çš„è¯·æ±‚, ç­‰å¾…Bçš„ç¡®è®¤ã€‚ Bæ”¶åˆ°è¿žæŽ¥é‡Šæ”¾æŠ¥æ–‡æ®µåŽå³å‘å‡ºç¡®è®¤æŠ¥æ–‡æ®µï¼Œï¼ˆACK=1ï¼Œç¡®è®¤å·ack=u+1ï¼Œåºå·seq=vï¼‰ï¼Œç¡®è®¤æ¥è·¯æ–¹å‘ä¸Šçš„TCPè¿žæŽ¥å°†å…³é—­, Bè¿›å…¥CLOSE-WAITï¼ˆå…³é—­ç­‰å¾…ï¼‰çŠ¶æ€ï¼Œæ­¤æ—¶çš„TCPå¤„äºŽåŠå…³é—­çŠ¶æ€ï¼ŒAåˆ°Bçš„è¿žæŽ¥é‡Šæ”¾ã€‚Aæ”¶åˆ°Bçš„ç¡®è®¤åŽï¼Œè¿›å…¥FIN-WAIT-2ï¼ˆç»ˆæ­¢ç­‰å¾…2ï¼‰çŠ¶æ€ï¼Œç­‰å¾…Bå‘å‡ºçš„è¿žæŽ¥é‡Šæ”¾æŠ¥æ–‡æ®µã€‚ Bå·²ç»æ²¡æœ‰è¦å‘Aå‘å‡ºçš„æ•°æ®ï¼ŒBå†æå‡ºåæ–¹å‘çš„å…³é—­è¯·æ±‚, Bå‘å‡ºè¿žæŽ¥é‡Šæ”¾æŠ¥æ–‡æ®µï¼ˆFIN=1ï¼ŒACK=1ï¼Œåºå·seq=wï¼Œç¡®è®¤å·ack=u+1ï¼‰ï¼ŒBè¿›å…¥LAST-ACKï¼ˆæœ€åŽç¡®è®¤ï¼‰çŠ¶æ€ï¼Œç­‰å¾…Açš„ç¡®è®¤ã€‚ Aæ”¶åˆ°Bçš„è¿žæŽ¥é‡Šæ”¾æŠ¥æ–‡æ®µåŽï¼Œå¯¹æ­¤å‘å‡ºç¡®è®¤æŠ¥æ–‡æ®µï¼ˆACK=1ï¼Œseq=u+1ï¼Œack=w+1ï¼‰ï¼ŒAè¿›å…¥TIME-WAITï¼ˆæ—¶é—´ç­‰å¾…ï¼‰çŠ¶æ€ã€‚æ­¤æ—¶TCPæœªé‡Šæ”¾æŽ‰ï¼Œéœ€è¦ç»è¿‡æ—¶é—´ç­‰å¾…è®¡æ—¶å™¨è®¾ç½®çš„æ—¶é—´2 Maximum Segment Lifetime (MSL)åŽï¼ŒAæ‰è¿›å…¥CLOSEDçŠ¶æ€ã€‚ æ€»çš„æµç¨‹å›¾å…¶ä¸­ä¸‰ä¸ªæ¯”è¾ƒé‡è¦çš„çŠ¶æ€ SYN_RECV ï¼šæœåŠ¡ç«¯æ”¶åˆ°å»ºç«‹è¿žæŽ¥çš„SYNæ²¡æœ‰æ”¶åˆ°ACKåŒ…çš„æ—¶å€™å¤„åœ¨SYN_RECVçŠ¶æ€ã€‚æœ‰ä¸¤ä¸ªç›¸å…³ç³»ç»Ÿé…ç½®. è¿™äº›å¤„åœ¨SYNC_RECVçš„TCPè¿žæŽ¥ç§°ä¸ºåŠè¿žæŽ¥ï¼Œå¹¶å­˜å‚¨åœ¨å†…æ ¸çš„åŠè¿žæŽ¥é˜Ÿåˆ—ä¸­ï¼Œåœ¨å†…æ ¸æ”¶åˆ°å¯¹ç«¯å‘é€çš„ackåŒ…æ—¶ä¼šæŸ¥æ‰¾åŠè¿žæŽ¥é˜Ÿåˆ—ï¼Œå¹¶å°†ç¬¦åˆçš„requst_sockä¿¡æ¯å­˜å‚¨åˆ°å®Œæˆä¸‰æ¬¡æ¡æ‰‹çš„è¿žæŽ¥çš„é˜Ÿåˆ—ä¸­ï¼Œç„¶åŽåˆ é™¤æ­¤åŠè¿žæŽ¥ã€‚å¤§é‡SYNC_RECVçš„TCPè¿žæŽ¥ä¼šå¯¼è‡´åŠè¿žæŽ¥é˜Ÿåˆ—æº¢å‡ºï¼Œè¿™æ ·åŽç»­çš„è¿žæŽ¥å»ºç«‹è¯·æ±‚ä¼šè¢«å†…æ ¸ç›´æŽ¥ä¸¢å¼ƒï¼Œè¿™å°±æ˜¯SYN Floodæ”»å‡»ã€‚ net.ipv4.tcp_synack_retries ï¼šINTEGER é»˜è®¤å€¼æ˜¯5. å¯¹äºŽè¿œç«¯çš„è¿žæŽ¥è¯·æ±‚SYNï¼Œå†…æ ¸ä¼šå‘é€SYN + ACKæ•°æ®æŠ¥ï¼Œä»¥ç¡®è®¤æ”¶åˆ°ä¸Šä¸€ä¸ª SYNè¿žæŽ¥è¯·æ±‚åŒ…ã€‚è¿™æ˜¯æ‰€è°“çš„ä¸‰æ¬¡æ¡æ‰‹(threeway handshake)æœºåˆ¶çš„ç¬¬äºŒä¸ªæ­¥éª¤ã€‚è¿™é‡Œå†³å®šå†…æ ¸åœ¨æ”¾å¼ƒè¿žæŽ¥ä¹‹å‰æ‰€é€å‡ºçš„ SYN+ACK æ•°ç›®ã€‚ä¸åº”è¯¥å¤§äºŽ255ï¼Œé»˜è®¤å€¼æ˜¯5ï¼Œå¯¹åº”äºŽ180ç§’å·¦å³æ—¶é—´ã€‚é€šå¸¸æˆ‘ä»¬ä¸å¯¹è¿™ä¸ªå€¼è¿›è¡Œä¿®æ”¹ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›TCPè¿žæŽ¥ä¸è¦å› ä¸ºå¶å°”çš„ä¸¢åŒ…è€Œæ— æ³•å»ºç«‹ã€‚ net.ipv4.tcp_syncookies ä¸€èˆ¬æœåŠ¡å™¨éƒ½ä¼šè®¾ç½® net.ipv4.tcp_syncookies=1æ¥é˜²æ­¢SYN Floodæ”»å‡»ã€‚å‡è®¾ä¸€ä¸ªç”¨æˆ·å‘æœåŠ¡å™¨å‘é€äº†SYNæŠ¥æ–‡åŽçªç„¶æ­»æœºæˆ–æŽ‰çº¿ï¼Œé‚£ä¹ˆæœåŠ¡å™¨åœ¨å‘å‡ºSYN+ACKåº”ç­”æŠ¥æ–‡åŽæ˜¯æ— æ³•æ”¶åˆ°å®¢æˆ·ç«¯çš„ACKæŠ¥æ–‡çš„ï¼ˆç¬¬ä¸‰æ¬¡æ¡æ‰‹æ— æ³•å®Œæˆï¼‰ï¼Œè¿™ç§æƒ…å†µä¸‹æœåŠ¡å™¨ç«¯ä¸€èˆ¬ä¼šé‡è¯•ï¼ˆå†æ¬¡å‘é€SYN+ACKç»™å®¢æˆ·ç«¯ï¼‰å¹¶ç­‰å¾…ä¸€æ®µæ—¶é—´åŽä¸¢å¼ƒè¿™ä¸ªæœªå®Œæˆçš„è¿žæŽ¥ï¼Œè¿™æ®µæ—¶é—´çš„é•¿åº¦æˆ‘ä»¬ç§°ä¸ºSYN Timeoutï¼Œä¸€èˆ¬æ¥è¯´è¿™ä¸ªæ—¶é—´æ˜¯åˆ†é’Ÿçš„æ•°é‡çº§ï¼ˆå¤§çº¦ä¸º30ç§’-2åˆ†é’Ÿï¼‰ã€‚ CLOSE_WAIT: è¢«åŠ¨å…³é—­çš„serveræ”¶åˆ°FINåŽï¼Œä½†æœªå‘å‡ºACKçš„TCPçŠ¶æ€æ˜¯CLOSE_WAITã€‚å‡ºçŽ°è¿™ç§çŠ¶å†µä¸€èˆ¬éƒ½æ˜¯ç”±äºŽserverç«¯ä»£ç çš„é—®é¢˜ï¼Œå¦‚æžœä½ çš„æœåŠ¡å™¨ä¸Šå‡ºçŽ°å¤§é‡CLOSE_WAITï¼Œåº”è¯¥è¦è€ƒè™‘æ£€æŸ¥ä»£ç ã€‚CLOSE_WAITçŠ¶æ€ä»€ä¹ˆæ—¶å€™ç»ˆç»“ï¼Œ å–å†³äºŽåº”ç”¨ç¨‹åºä»€ä¹ˆæ—¶å€™æ¥close socket, ä»Žç†è®ºä¸Šæ¥è®²ï¼Œåªè¦è¢«åŠ¨å…³é—­ç«¯ä¸æ–­ç”µï¼Œè¿›ç¨‹ä¸é€€å‡ºï¼Œ é‚£ä¹ˆCLOSE_WAITçŠ¶æ€å°±ä¼šä¸€ç›´æŒç»­ä¸‹åŽ»ã€‚å› æ­¤ç†è®ºä¸ŠCLOSE_WAITçš„æœ€å¤§æ—¶é—´å¯ä»¥è¾¾åˆ°æ— é™é•¿ã€‚ TIME_WAIT: å‘èµ·socketä¸»åŠ¨å…³é—­çš„ä¸€æ–¹ socketå°†è¿›å…¥TIME_WAITçŠ¶æ€ã€‚TIME_WAITçŠ¶æ€å°†æŒç»­2ä¸ªMSL(Max Segment Lifetime),åœ¨Windowsä¸‹é»˜è®¤ä¸º4åˆ†é’Ÿï¼Œå³240ç§’ã€‚TIME_WAITçŠ¶æ€ä¸‹çš„socketä¸èƒ½è¢«å›žæ”¶ä½¿ç”¨. å…·ä½“çŽ°è±¡æ˜¯å¯¹äºŽä¸€ä¸ªå¤„ç†å¤§é‡çŸ­è¿žæŽ¥çš„æœåŠ¡å™¨,å¦‚æžœæ˜¯ç”±æœåŠ¡å™¨ä¸»åŠ¨å…³é—­å®¢æˆ·ç«¯çš„è¿žæŽ¥ï¼Œå°†å¯¼è‡´æœåŠ¡å™¨ç«¯å­˜åœ¨å¤§é‡çš„å¤„äºŽTIME_WAITçŠ¶æ€çš„socketï¼Œ ç”šè‡³æ¯”å¤„äºŽEstablishedçŠ¶æ€ä¸‹çš„socketå¤šçš„å¤š,ä¸¥é‡å½±å“æœåŠ¡å™¨çš„å¤„ç†èƒ½åŠ›ï¼Œç”šè‡³è€—å°½å¯ç”¨çš„socketï¼Œåœæ­¢æœåŠ¡ã€‚TIME_WAITæ˜¯TCPåè®®ç”¨ä»¥ä¿è¯è¢«é‡æ–°åˆ†é…çš„socketä¸ä¼šå—åˆ°ä¹‹å‰æ®‹ç•™çš„å»¶è¿Ÿé‡å‘æŠ¥æ–‡å½±å“çš„æœºåˆ¶,æ˜¯å¿…è¦çš„é€»è¾‘ä¿è¯ã€‚ ç«¯å£é¢å‘è¿žæŽ¥æœåŠ¡TCPåè®®å’Œæ— è¿žæŽ¥æœåŠ¡UDPåè®®ä½¿ç”¨16bitsç«¯å£å·æ¥è¡¨ç¤ºå’ŒåŒºåˆ«ç½‘ç»œä¸­çš„ä¸åŒåº”ç”¨ç¨‹åºï¼Œç½‘ç»œå±‚åè®®IPä½¿ç”¨ç‰¹å®šçš„åè®®å·ï¼ˆTCP 6ï¼ŒUDP 17ï¼‰æ¥è¡¨ç¤ºå’ŒåŒºåˆ«ä¼ è¾“å±‚åè®®ã€‚ä»»ä½•TCP/IPå®žçŽ°æ‰€æä¾›çš„æœåŠ¡éƒ½æ˜¯1-1023ä¹‹é—´çš„ç«¯å£å·ï¼Œè¿™äº›ç«¯å£å·ç”±IANAåˆ†é…ç®¡ç†, ä½œä¸ºä¿ç•™ç«¯å£ä¾›ç‰¹å®šæœåŠ¡ä½¿ç”¨ã€‚å…¶ä¸­ï¼Œä½ŽäºŽ255çš„ç«¯å£å·ä¿ç•™ç”¨äºŽå…¬å…±åº”ç”¨ï¼›255åˆ°1023çš„ç«¯å£å·åˆ†é…ç»™å„ä¸ªå…¬å¸ï¼Œç”¨äºŽç‰¹æ®Šåº”ç”¨ï¼›å¯¹äºŽé«˜äºŽ1023çš„ç«¯å£å·ï¼Œç§°ä¸ºä¸´æ—¶ç«¯å£å·ï¼ŒIANAæœªåšè§„å®šã€‚ä¸åŒç¨‹åºæ— æ³•å…±äº«ä¸€ä¸ªç«¯å£, å› æ­¤æ–°ç¨‹åºåªèƒ½ä½¿ç”¨ç©ºé—²ç«¯å£. å¸¸ç”¨çš„ä¿ç•™TCPç«¯å£å·æœ‰ï¼šHTTP 80ï¼ŒFTP 20/21ï¼ŒTelnet 23ï¼ŒSMTP 25ï¼ŒDNS 53ç­‰ã€‚å¸¸ç”¨çš„ä¿ç•™UDPç«¯å£å·æœ‰ï¼šDNS 53ï¼ŒBootP 67ï¼ˆserverï¼‰/ 68ï¼ˆclientï¼‰ï¼ŒTFTP 69ï¼ŒSNMP 161ç­‰ã€‚ æ¯ä¸ªTCPæŠ¥æ–‡å¤´éƒ¨éƒ½åŒ…å«æºç«¯å£å·source portå’Œç›®çš„ç«¯å£å·destination portï¼Œç”¨äºŽæ ‡è¯†å’ŒåŒºåˆ†æºç«¯è®¾å¤‡å’Œç›®çš„ç«¯è®¾å¤‡çš„åº”ç”¨è¿›ç¨‹ã€‚åœ¨TCP/IPåè®®æ ˆä¸­ï¼Œæºç«¯å£å·å’Œç›®çš„ç«¯å£å·åˆ†åˆ«ä¸ŽæºIPåœ°å€å’Œç›®çš„IPåœ°å€ç»„æˆå¥—æŽ¥å­—ï¼Œå”¯ä¸€çš„ç¡®å®šä¸€æ¡TCPè¿žæŽ¥ã€‚ç›¸å¯¹äºŽTCPæŠ¥æ–‡ï¼ŒUDPæŠ¥æ–‡åªæœ‰å°‘é‡çš„å­—æ®µï¼šæºç«¯å£å·ã€ç›®çš„ç«¯å£å·ã€é•¿åº¦ã€æ ¡éªŒå’Œç­‰ï¼Œå„ä¸ªå­—æ®µåŠŸèƒ½å’ŒTCPæŠ¥æ–‡ç›¸åº”å­—æ®µä¸€æ ·ã€‚ åœ¨linuxä¸€èˆ¬ä½¿ç”¨netstatæ¥æŸ¥çœ‹ç³»ç»Ÿç«¯å£ä½¿ç”¨æƒ…å†µã€‚netstatå‘½ä»¤çš„åŠŸèƒ½æ˜¯æ˜¾ç¤ºç½‘ç»œè¿žæŽ¥ã€è·¯ç”±è¡¨å’Œç½‘ç»œæŽ¥å£ä¿¡æ¯ï¼Œå¯ä»¥è®©ç”¨æˆ·å¾—çŸ¥ç›®å‰éƒ½æœ‰å“ªäº›ç½‘ç»œè¿žæŽ¥æ­£åœ¨è¿ä½œã€‚æ¯”å¦‚æŸ¥çœ‹ TCP 22 ç«¯å£æœ‰ä¸¤ç§æ–¹æ³•ï¼šç¬¬ä¸€ç§æŸ¥çœ‹æ–¹æ³•1234567[root@Demon proc]# netstat -ntlp | grep 22tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1960/sshdtcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 2263/mysqldtcp 0 0 :::22 :::* LISTEN 1960/sshd ç¬¬äºŒç§æŸ¥çœ‹æ–¹æ³•1234567[root@Demon proc]# lsof -i tcp:22COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsshd 1960 root 3u IPv4 14435 0t0 TCP *:ssh (LISTEN)sshd 1960 root 4u IPv6 14441 0t0 TCP *:ssh (LISTEN) -i æ˜¾ç¤ºæ‰€æœ‰ç½‘ç»œæŽ¥å£çš„ä¿¡æ¯ã€‚ Socketé€šè®¯çš„è¿‡ç¨‹Serverç«¯Listen(ç›‘å¬)æŸä¸ªç«¯å£æ˜¯å¦æœ‰è¿žæŽ¥è¯·æ±‚ï¼ŒClientç«¯å‘Server ç«¯å‘å‡ºConnect(è¿žæŽ¥)è¯·æ±‚ï¼ŒServerç«¯å‘Clientç«¯å‘å›žAcceptï¼ˆæŽ¥å—ï¼‰æ¶ˆæ¯ã€‚ä¸€ä¸ªè¿žæŽ¥å°±å»ºç«‹èµ·æ¥äº†ã€‚Serverç«¯å’ŒClient ç«¯éƒ½å¯ä»¥é€šè¿‡Sendï¼ŒWriteç­‰æ–¹æ³•ä¸Žå¯¹æ–¹é€šä¿¡ã€‚ å¯¹äºŽä¸€ä¸ªåŠŸèƒ½é½å…¨çš„Socketï¼Œéƒ½è¦åŒ…å«ä»¥ä¸‹åŸºæœ¬ç»“æž„ï¼Œå…¶å·¥ä½œè¿‡ç¨‹åŒ…å«ä»¥ä¸‹å››ä¸ªåŸºæœ¬çš„æ­¥éª¤ï¼š ï¼ˆ1ï¼‰ åˆ›å»ºSocketï¼› ï¼ˆ2ï¼‰ æ‰“å¼€è¿žæŽ¥åˆ°Socketçš„è¾“å…¥/å‡ºæµï¼› ï¼ˆ3ï¼‰ æŒ‰ç…§ä¸€å®šçš„åè®®å¯¹Socketè¿›è¡Œè¯»/å†™æ“ä½œï¼› ï¼ˆ4ï¼‰ å…³é—­Socket.ï¼ˆåœ¨å®žé™…åº”ç”¨ä¸­ï¼Œå¹¶æœªä½¿ç”¨åˆ°æ˜¾ç¤ºçš„closeï¼Œè™½ç„¶å¾ˆå¤šæ–‡ç« éƒ½æŽ¨èå¦‚æ­¤ï¼Œä¸è¿‡åœ¨æˆ‘çš„ç¨‹åºä¸­ï¼Œå¯èƒ½å› ä¸ºç¨‹åºæœ¬èº«æ¯”è¾ƒç®€å•ï¼Œè¦æ±‚ä¸é«˜ï¼Œæ‰€ä»¥å¹¶æœªé€ æˆä»€ä¹ˆå½±å“ã€‚ï¼‰]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java å¤šçº¿ç¨‹]]></title>
    <url>%2Fjava-multithreading%2F</url>
    <content type="text"><![CDATA[å¤šçº¿ç¨‹çº¿ç¨‹æ˜¯ç‹¬ç«‹çš„æ‰§è¡Œç©ºé—´ï¼ŒJavaè¯­è¨€å†…ç½®å¤šçº¿ç¨‹åŠŸèƒ½ï¼Œç”¨ç±»Threadæ¥è¡¨è¾¾ã€‚æ¯ä¸ªJavaåº”ç”¨ç¨‹åºä¼šå¯åŠ¨ä¸€ä¸ªä¸»çº¿ç¨‹ â€“ å°†main()æ”¾åœ¨è‡ªå·±çš„æ‰§è¡Œç©ºé—´çš„æœ€å¼€å§‹å¤„. JVMä¼šè´Ÿè´£ä¸»çº¿ç¨‹çš„å¯åŠ¨(ä»¥åŠå…¶ä»–æ¯”å¦‚GCçš„ç³»ç»Ÿçº¿ç¨‹). ç¨‹åºå‘˜è´Ÿè´£å¯åŠ¨è‡ªå·±çš„å»ºç«‹çš„çº¿ç¨‹. å¯åŠ¨æ–°çº¿ç¨‹ å»ºç«‹Runnableå¯¹è±¡ä½œä¸ºçº¿ç¨‹ä»»åŠ¡Runnable job = new MyRunnable(), RunnableæŽ¥å£åªæœ‰ä¸€ä¸ªæ–¹æ³•run() å»ºç«‹Threadå¯¹è±¡å¹¶èµ‹å€¼Runnable Thread thread1 = new Thread(job); Thread thread2 = new Thread(job) å¯åŠ¨thread.start(); å¦ä¸€ç§åˆ›å»ºçº¿ç¨‹çš„æ–¹æ³•æ˜¯ç”¨Threadçš„å­ç±»è¦†ç›–æŽ‰run(), æž„é€ æ–°çº¿ç¨‹Thread t = new Thread();. ä»ŽOOçš„è§’åº¦çœ‹å¾…, æ­¤æ—¶Thread ä¸Žçº¿ç¨‹ä»»åŠ¡æ˜¯ä¸åŒæ¦‚å¿µçš„. è®©å­ç±»ç»§æ‰¿Threadçš„ç›®çš„é€šå¸¸æ˜¯éœ€è¦æ›´ç‰¹æ®Šçš„Thread, éœ€è¦ç‰¹æ®Šçš„è¡Œä¸º, å¦‚æžœæ²¡æœ‰è¿™ç§éœ€æ±‚, å°±æ²¡å¿…è¦ç»§æ‰¿Thread. çº¿ç¨‹è°ƒåº¦å™¨å¤šçº¿ç¨‹é—´çš„åˆ‡æ¢ç”±è°ƒåº¦å™¨scheduleræ¥ç®¡ç†, çº¿ç¨‹æœ‰å¤šç§çŠ¶æ€: æ‰§è¡Œä¸­, sleep(2000): ç¡çœ 2000ms, æ—¶é—´åˆ°ä¹‹å‰ä¸ä¼šè¢«æ‰§è¡Œ, ä½†æ—¶é—´åˆ°äº†å¹¶ä¸ä¿è¯ä¸€å®šä¼šè¢«æ‰§è¡Œ. å¯èƒ½ä¼šæŠ›å‡ºInterruptedException, æ‰€ä»¥å¯¹å®ƒçš„è°ƒç”¨è¦åŒ…å«åœ¨try/catchä¸­. locked. çº¿ç¨‹çš„runå®Œæˆæ‰§è¡ŒåŽ, å°†æ— æ³•é‡æ–°å¯åŠ¨. è°ƒåº¦å™¨åœ¨ä¸åŒçš„JVMæœ‰ä¸åŒçš„åšæ³•. æµ‹è¯•å¤šçº¿ç¨‹æ—¶éœ€è¦åœ¨ä¸åŒæœºå™¨ä¸Šæµ‹è¯•. å¹¶å‘Concurrencyå¹¶å‘çŽ¯å¢ƒä¸­, ä¸ºäº†é¿å…å†²çª, éœ€è¦ä¸Šé”, ä½¿ç”¨synchronizedæ¥ä¿®é¥°æ–¹æ³•ä½¿ä¹‹æ¯æ¬¡åªèƒ½è¢«å•ä¸€çº¿ç¨‹è¯»å†™. åŒæ­¥åŒ–æ˜¯æœ‰ä»£ä»·çš„, æŸ¥è¯¢é’¥åŒ™æœ‰æ€§èƒ½ä¸Šçš„æŸè€—, åŒæ­¥åŒ–ä¹Ÿä¼šå¼ºåˆ¶çº¿ç¨‹æŽ’é˜Ÿæ‰§è¡Œ, è¿˜å¯èƒ½å‡ºçŽ°æ­»é”. æ­»é”å› ä¸ºä¸¤ä¸ªçº¿ç¨‹äº’ç›¸æŒæœ‰å¯¹æ–¹æ­£åœ¨ç­‰å¾…çš„ä¸œè¥¿, å¯¼è‡´æ²¡æœ‰ä¸€æ–¹å¯ä»¥è„±ç¦»ç­‰å¾…. æ•°æ®åº“æœ‰äº‹åŠ¡å›žæ»šæœºåˆ¶æ¥å¤åŽŸæ­»é”çš„äº‹åŠ¡, ä½†Javaæ²¡æœ‰å¤„ç†æ­»é”çš„æœºåˆ¶. VolatileJavaä¸ºäº†æé«˜ç¨‹åºè¿è¡Œæ•ˆçŽ‡, ç¼–è¯‘å™¨è‡ªåŠ¨ä¼šä¼˜åŒ–, æŠŠç»å¸¸è¢«è®¿é—®çš„å˜é‡æ··å­˜èµ·æ¥, ç¨‹åºåœ¨è¯»å–è¿™ä¸ªå˜é‡æ—¶æœ‰å¯èƒ½ä¼šç›´æŽ¥ä»Žç¼“å­˜(ä¾‹å¦‚å¯„å­˜å™¨)ä¸­è¯»å–è¿™ä¸ªå€¼, è€Œä¸ä¼šåŽ»å†…å­˜ä¸­è¯»å–. ä½†åœ¨å¤šçº¿ç¨‹çŽ¯å¢ƒä¸­, å˜é‡çš„å€¼å¯èƒ½å› ä¸ºåˆ«çš„çº¿ç¨‹è€Œæ”¹å˜äº†, è€Œè¯¥ç¼“å­˜çš„å€¼ä¸ä¼šç›¸åº”æ”¹å˜, ä»Žè€Œé€ æˆåº”ç”¨ç¨‹åºè¯»å–çš„å€¼å’Œå®žé™…çš„å˜é‡å€¼ä¸ä¸€è‡´. ä½¿ç”¨volatileä¿®é¥°è¢«ä¸åŒçº¿ç¨‹è®¿é—®å’Œä¿®æ”¹çš„å˜é‡, ä½¿å¾—å…¶æ¯æ¬¡è¢«ç”¨åˆ°æ—¶, éƒ½æ˜¯ç›´æŽ¥ä»Žå¯¹åº”çš„å†…å­˜ä¸­æå–, è€Œä¸ä¼šåˆ©ç”¨ç¼“å­˜äº†.12345public class MyThread implements Runnable &#123; private volatile Boolean flag; public void stop() &#123; flag = false; &#125; public void run() &#123; while(flag) ; &#125;&#125; å¦‚æžœflagæ²¡æœ‰è¢«å£°æ˜Žä¸ºvolatile, é‚£ä¹ˆå½“è¿™ä¸ªåŽ¿åŸŽçš„run()åˆ¤æ–­flagæ—¶, ä½¿ç”¨çš„æœ‰å¯èƒ½æ˜¯ç¼“å­˜ä¸­çš„å€¼, æ­¤æ—¶å°±ä¸èƒ½åŠæ—¶åœ°èŽ·å–å…¶ä»–çº¿ç¨‹å¯¹flagæ‰€åšçš„æ“ä½œäº†. ä½†volatileä¸èƒ½ä¿è¯æ“ä½œçš„åŽŸå­æ€§, å› æ­¤ä¸€èˆ¬æƒ…å†µä¸‹ä¸èƒ½ä»£æ›¿sychronized. æ­¤å¤–, ä½¿ç”¨volatileä¼šé˜»æ­¢ç¼–è¯‘å™¨å¯¹ä»£ç çš„ä¼˜åŒ–, å› æ­¤ä¼šé™ä½Ž]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java ç±»çš„ç»§æ‰¿æ‰©å±• Extends]]></title>
    <url>%2Fjava-extends-class%2F</url>
    <content type="text"><![CDATA[ç±»çš„ç»§æ‰¿æ‰©å±•å®šä¹‰classä¹‹é—´çš„å±‚æ¬¡å…³ç³».å‡è®¾è¦æž„å»ºä¸€ä¸ªRotatingSLListï¼Œå®ƒå…·æœ‰ä¸ŽSLListç›¸åŒçš„åŠŸèƒ½ï¼Œå¦‚addFirst, sizeç­‰ï¼Œä½†æ˜¯éœ€è¦é¢å¤–çš„rotateRightæ“ä½œå°†æœ€åŽä¸€é¡¹æ”¾åˆ°åˆ—è¡¨çš„å‰é¢ï¼Œå› ä¸ºç»§æ‰¿å…è®¸å­ç±»é‡ç”¨å·²ç»å®šä¹‰çš„ç±»ä¸­çš„ä»£ç ã€‚æ‰€ä»¥è®©RotatingSLListç±»ä»ŽSLListç»§æ‰¿éƒ¨åˆ†ä»£ç :1public class RotatingSLList&lt;Item&gt; extends SLList&lt;Item&gt; &#123;&#125; RotatingSLListâ€œæ˜¯ä¸€ç§â€SLList, extendså¯ä»¥è®©æˆ‘ä»¬ç»§æ‰¿SLListçš„åŽŸå§‹åŠŸèƒ½ï¼Œå¹¶èƒ½ä¿®æ”¹æˆ–æ·»åŠ å…¶ä»–åŠŸèƒ½ã€‚123456789/** The rotateRight method takes in an existing list, and rotates every element one spot to the right, moving the last item to the front of the list. For example, input [5, 9, 15, 22] should return [22, 5, 9, 15].*/public void rotateRight() &#123; Item x = removeLast(); addFirst(x);&#125; é€šè¿‡extends, å­ç±»ç»§æ‰¿çˆ¶ç±»çš„æ‰€æœ‰æˆå‘˜ï¼Œæˆå‘˜åŒ…æ‹¬ï¼š æ‰€æœ‰å®žä¾‹å’Œé™æ€å˜é‡ æ‰€æœ‰æ–¹æ³• æ‰€æœ‰åµŒå¥—ç±» ä½†æ³¨æ„ï¼Œæž„é€ å‡½æ•°ä¸ç»§æ‰¿ï¼Œå¹¶ä¸”ç§æœ‰æˆå‘˜ä¸èƒ½è¢«å­ç±»ç›´æŽ¥è®¿é—®ã€‚ ä»Žå±žå’Œæ‹¥æœ‰çš„åŒºåˆ«ï¼šsubclass å’Œ superclass æ˜¯ä¸Šä¸‹çº§ä»Žå±žåˆ†ç±»ï¼Œè€Œä¸æ˜¯æ‹¥æœ‰ä¸Žè¢«æ‹¥æœ‰çš„å…³ç³»ï¼Œä¸è¦è·Ÿ nested class æ··æ·†ã€‚ Interface Methods: Default methods and abstract methods in interfaces are inherited like instance methods. However, when the supertypes of a class or interface provide multiple default methods with the same signature, the Java compiler follows inheritance rules to resolve the name conflict.â€“ https://docs.oracle.com/javase/tutorial/java/IandI/index.html Overridingä¸Šé¢çš„ä¾‹å­ä½¿ç”¨çˆ¶ç±»çš„removeLast()æŠŠæœ€åŽçš„å…ƒç´ ç›´æŽ¥ä¸¢å¼ƒäº†ï¼Œä½†å‡å¦‚æœ‰ä¸€ä¸ªå­ç±»VengefulSLListæƒ³ä¿ç•™è¢«ä¸¢å¼ƒçš„å…ƒç´ å‘¢? å­ç±»å¯ä»¥è¦†ç›– overrideçˆ¶ç±»çš„æ–¹æ³•ã€‚ åŒºåˆ† Override ä¸Ž é‡è½½ overloadedï¼šOverride çš„æ–¹æ³• signature ç›¸åŒï¼›overloadedçš„æ–¹æ³•åŒåä½†ä¸åŒsignatureã€‚ å­ç±»å¯ä»¥overrideçˆ¶ç±»çš„removeLast, é€šè¿‡æ·»åŠ ä¸€ä¸ªå®žä¾‹å˜é‡æ¥è¿½è¸ªæ‰€æœ‰å·²åˆ é™¤çš„å…ƒç´ .12345678910111213141516171819public class VengefulSLList&lt;Item&gt; extends SLList&lt;Item&gt; &#123; SLList&lt;Item&gt; deletedItems; public VengefulSLList() &#123; deleteItems = new SLList&lt;Item&gt;(); &#125; @Override public Item removeLast() &#123; Item x = super.removeLast(); deletedItems.addLast(x); return x; &#125; /** Prints deleted items. */ public void printLostItems() &#123; deletedItems.print(); &#125;&#125; ç»§æ‰¿çš„å¥½å¤„æ˜¯ä»£ç å¾—ä»¥é‡å¤åˆ©ç”¨. åå¤„æ˜¯å› ä¸ºâ€œIs aâ€çš„å…³ç³», debuggingçš„è·¯å¾„ä¼šå¾ˆçƒ¦äººã€‚ ä½†å³ä½¿ä¸åŒ…å«è¿™ä¸ª@Overrideï¼Œæˆ‘ä»¬ä»ç„¶overrideäº†è¿™ä¸ªæ–¹æ³•ã€‚æ‰€ä»¥ä»ŽæŠ€æœ¯ä¸Šæ¥è¯´ï¼Œ@Overrideå¹¶ä¸æ˜¯å¿…é¡»çš„ã€‚ä½†æ˜¯ï¼Œå®ƒå¯ä»¥ä½œä¸ºä¸€ä¸ªä¿éšœ, æé†’ç¼–è¯‘å™¨æˆ‘ä»¬æ‰“ç®—overrideæ­¤æ–¹æ³•, å¦‚æžœè¿‡ç¨‹ä¸­å‡ºçŽ°é—®é¢˜, ç¼–è¯‘å™¨å¯ä»¥æé†’ã€‚å‡è®¾å½“æˆ‘ä»¬æƒ³ override addLastï¼Œå´ä¸å°å¿ƒå†™æˆaddLsatã€‚æ­¤æ—¶å¦‚æžœä¸åŒ…å«@Overrideï¼Œé‚£ä¹ˆå¯èƒ½æ— æ³•å‘çŽ°é”™è¯¯ã€‚å¦‚æžœæœ‰äº†@Overrideï¼Œç¼–è¯‘å™¨å°±ä¼šæç¤ºæˆ‘ä»¬ä¿®å¤é”™è¯¯ã€‚ Constructors Are Not Inherited Javaè¦æ±‚æ‰€æœ‰å­ç±»çš„æž„é€ å‡½æ•°å¿…é¡»å…ˆè°ƒç”¨å…¶æŸä¸€è¶…ç±»çš„æž„é€ å‡½æ•°ã€‚â€“ https://docs.oracle.com/javase/tutorial/java/IandI/super.html å› ä¸ºé€»è¾‘ä¸Šï¼Œå¦‚æžœä½œä¸ºåŸºç¡€çš„è¶…ç±»æ²¡æœ‰æž„å»ºï¼Œé‚£ä¹ˆå­ç±»çš„æž„å»ºçš„æ— ä»Žè°ˆèµ·ã€‚å®Œæ•´çš„å­ç±»æž„é€ å‡½æ•°åº”è¯¥æ˜¯ï¼š1234public VengefulSLList() &#123; super(); // ç¬¬ä¸€è¡Œ deletedItems = new SLList&lt;Item&gt;();&#125; ä¹‹å‰çš„ä¾‹å­æ²¡æœ‰super();ä¹Ÿå¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œæ˜¯å› ä¸ºJavaä¼šè‡ªåŠ¨ä¸ºæˆ‘ä»¬è°ƒç”¨è¶…ç±»çš„æ— å‚æ•°æž„é€ å‡½æ•°ã€‚ å…·ä½“åˆ†æƒ…å†µè€ƒè™‘ï¼š ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ä¸ºä»»ä½•æ²¡æœ‰æž„é€ å‡½æ•°çš„ç±»æä¾›ä¸€ä¸ªæ— å‚æ•°çš„é»˜è®¤æž„é€ å‡½æ•°ï¼šè¿™ä¸ªé»˜è®¤æž„é€ å‡½æ•°å°†è°ƒç”¨å…¶è¶…ç±»çš„ï¼ˆaccessibleï¼‰æ— å‚æž„é€ å‡½æ•°ã€‚ å¦‚æžœå­ç±»æž„é€ å‡½æ•°æ²¡æœ‰æŒ‡å®šè¦è°ƒç”¨å“ªä¸ªè¶…ç±»æž„é€ å‡½æ•°ï¼šåˆ™ç¼–è¯‘å™¨å°†è‡ªåŠ¨è°ƒç”¨è¶…ç±»çš„å¯è®¿é—®çš„æ— å‚æ•°æž„é€ å‡½æ•° 12public class Base &#123; &#125;public class Derived extends Base &#123; &#125; å¦‚æžœå…¶è¶…ç±»æœ‰æœ‰å‚æ•°æž„é€ å‡½æ•°ï¼Œä½†æ²¡æœ‰æ— å‚æ•°æž„é€ å‡½æ•°ï¼Œé‚£ä¹ˆç¼–è¯‘å‡ºé”™ï¼š 1public class Base &#123; public Base(String s) &#123; &#125; &#125; æ­¤æ—¶è¦åœ¨å­ç±»æž„é€ å‡½æ•°ç¬¬ä¸€è¡Œæ·»åŠ super(s) å¦‚æžœè¶…ç±»çš„æ— å‚æ•°æž„é€ å‡½æ•°æ˜¯ä¸å¯è®¿é—®çš„ï¼Œé‚£ä¹ˆç¼–è¯‘å‡ºé”™ï¼š 1public class Base &#123; private Base() &#123; &#125; &#125; å¦‚æžœæ²¡æœ‰æ˜¾å¼çš„è¶…ç±»ï¼Œé‚£ä¹ˆå°±è°ƒç”¨éšå¼çš„è¶…ç±»Objectçš„æ— å‚æž„é€ å‡½æ•°ã€‚ Constructor Chainingï¼šå½“å­ç±»æž„é€ å‡½æ•°è°ƒç”¨å…¶çˆ¶ç±»çš„æž„é€ å‡½æ•°æ—¶ï¼ˆæ— è®ºæ˜¯æ˜¾å¼è¿˜æ˜¯éšå¼è°ƒç”¨ï¼‰ï¼Œå¯ä»¥è®¤ä¸ºæœ‰ä¸€é“¾å¼çš„è¿žç»­è°ƒç”¨æž„é€ å‡½æ•°ï¼Œä¸€ç›´åˆ°Objectçš„æž„é€ å‡½æ•° åŒæ ·ï¼Œ å¯ä»¥é€šè¿‡super.someMethod()åœ¨å­ç±»ä¸­è°ƒç”¨çˆ¶ç±»çš„æ–¹æ³• Inheritance CheatsheetVengefulSLList extends SLList means VengefulSLList â€œis-anâ€ SLList, and inherits all of SLListâ€™s members:æ€»ç»“ Inheritance çš„ä¸€äº›è¦ç‚¹: å½“å­ç±»VengefulSLList extends è¶…ç±»SLListæ—¶, æ„å‘³ç€VengefulSLListä¹Ÿâ€æ˜¯â€SLList, å¹¶ç»§æ‰¿SLListçš„æ‰€æœ‰æˆå‘˜: Variables, methods, nested classes é™¤äº† constructors: Subclass constructors å¿…é¡»å…ˆè°ƒç”¨ superclass constructor; é€šè¿‡ super è°ƒç”¨ overridden superclass methods å’Œ constructors. è°ƒç”¨ overridden methods éµå¾ªä¸¤ä¸ªè§„åˆ™: ç¼–è¯‘å™¨åªå…è®¸ä¸Ž static type ç¬¦åˆçš„è¡Œä¸º. å¯¹äºŽ overridden methods, è°ƒç”¨æ˜¯åŸºäºŽ dynamic type å¯ä»¥ä½¿ç”¨ casting æ¥è§„é¿ compiler type checking. ï¼ˆå­ç±»åž‹ï¼‰å¤šæ€Subtype Polymorphism å¤šæ€ï¼ˆpolymorphismï¼‰ï¼Œæ˜¯æŒ‡ç›¸åŒçš„æ¶ˆæ¯ç»™äºˆä¸åŒçš„å¯¹è±¡ä¼šå¼•å‘ä¸åŒçš„åŠ¨ä½œã€‚ åŠ¨æ€å¤šæ€ï¼ˆdynamic polymorphismï¼‰ï¼šé€šè¿‡ç±»ç»§æ‰¿æœºåˆ¶å’Œè™šå‡½æ•°æœºåˆ¶ç”Ÿæ•ˆäºŽè¿è¡ŒæœŸã€‚å¯ä»¥ä¼˜é›…åœ°å¤„ç†å¼‚è´¨å¯¹è±¡é›†åˆï¼Œåªè¦å…¶å…±åŒçš„åŸºç±»å®šä¹‰äº†è™šå‡½æ•°çš„æŽ¥å£ã€‚ åœ¨é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­ï¼Œå¤šæ€ä¸€èˆ¬æ˜¯æŒ‡å­ç±»åž‹å¤šæ€ï¼ˆSubtype polymorphismï¼‰æˆ–åŒ…å«å¤šæ€ï¼ˆinclusion polymorphismï¼‰ã€‚ä¸€èˆ¬æ˜¯é€šè¿‡æŸç§å¯ä»£æ¢æ€§ï¼ˆ substitutabilityï¼‰ä¸Žå¦ä¸€ä¸ªæ•°æ®ç±»åž‹ï¼ˆè¶…ç±»åž‹ï¼Œsupertypeï¼‰ç›¸å…³çš„æ•°æ®ç±»åž‹ï¼Œè¿™æ„å‘³ç€ä¸ºåœ¨è¿™ä¸ªè¶…ç±»åž‹çš„å…ƒç´ ä¸Šè¿ç®—è€Œå†™è®¡ç®—æœºç¨‹åºä¹Ÿå¯ä»¥åœ¨å­ç±»åž‹çš„å…ƒç´ ä¸Šè¿ç®—ã€‚ é™æ€å¤šæ€ï¼ˆstatic polymorphismï¼‰ï¼šæ¨¡æ¿ä¹Ÿå…è®¸å°†ä¸åŒçš„ç‰¹æ®Šè¡Œä¸ºå’Œå•ä¸ªæ³›åŒ–è®°å·ç›¸å…³è”ï¼Œç”±äºŽè¿™ç§å…³è”å¤„ç†äºŽç¼–è¯‘æœŸè€Œéžè¿è¡ŒæœŸï¼Œå› æ­¤è¢«ç§°ä¸ºâ€œé™æ€â€ã€‚å¯ä»¥ç”¨æ¥å®žçŽ°ç±»åž‹å®‰å…¨ã€è¿è¡Œé«˜æ•ˆçš„åŒè´¨å¯¹è±¡é›†åˆæ“ä½œã€‚C++ STLä¸é‡‡ç”¨åŠ¨æ€å¤šæ€æ¥å®žçŽ°å°±æ˜¯ä¸ªä¾‹å­ã€‚ éžå‚æ•°åŒ–å¤šæ€æˆ–è¯‘ä½œç‰¹è®¾å¤šæ€ï¼ˆAd-hoc polymorphismï¼‰ï¼š å‡½æ•°é‡è½½ï¼ˆFunction Overloadingï¼‰ è¿ç®—ç¬¦é‡è½½ï¼ˆOperator Overloadingï¼‰ å¸¦å˜é‡çš„å®å¤šæ€ï¼ˆmacro polymorphismï¼‰ å‚æ•°åŒ–å¤šæ€ï¼ˆParametric polymorphismï¼‰ï¼šæŠŠç±»åž‹ä½œä¸ºå‚æ•°çš„å¤šæ€ã€‚åœ¨é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä¸­ï¼Œè¿™è¢«ç§°ä½œæ³›åž‹ç¼–ç¨‹ã€‚ å­ç±»åž‹åæ˜ äº†ç±»åž‹ï¼ˆå³é¢å‘å¯¹è±¡çš„æŽ¥å£ï¼‰ä¹‹é—´çš„å…³ç³»ï¼›è€Œç»§æ‰¿åæ˜ äº†ä¸€ç±»å¯¹è±¡å¯ä»¥ä»Žå¦ä¸€ç±»å¯¹è±¡åˆ›é€ å‡ºæ¥ï¼Œæ˜¯è¯­è¨€ç‰¹æ€§çš„å®žçŽ°ã€‚å› æ­¤ï¼Œå­ç±»åž‹ä¹Ÿç§°æŽ¥å£ç»§æ‰¿ï¼›ç»§æ‰¿ç§°ä½œå®žçŽ°ç»§æ‰¿ã€‚ å¤šæ€å…è®¸å¼•ç”¨å’Œå¯¹è±¡ç±»åž‹ä¸åŒ, å¦‚å¼•ç”¨ç±»åž‹å¯ä»¥æ˜¯å®žé™…å¯¹è±¡ç±»åž‹çš„çˆ¶ç±»: Animal myDog = new Dog();. ä»»ä½•é€šè¿‡IS-Aæµ‹è¯•çš„ç±»åž‹ï¼Œä»»ä½•extendsè¿‡å£°æ˜Žå¼•ç”¨å˜é‡ç±»åž‹çš„å¯¹è±¡éƒ½å¯ä»¥è¢«èµ‹å€¼ç»™è¯¥å¼•ç”¨å˜é‡ã€‚ å¤šæ€æœ‰å¾ˆå¤šåº”ç”¨åœºæ™¯ï¼Œæ¯”å¦‚å¯ä»¥å®¹çº³ä¸åŒå­ç±»åž‹çš„æ•°ç»„ï¼š1234Animal[] animals = new Animal[3];animals[0] = new Dog();animals[1] = new Cat();animals[2] = new Wolf(); å‚æ•°å’Œè¿”å›žç±»åž‹ä¹Ÿå¯ä»¥å¤šæ€. è¿™æ ·é€šè¿‡å¤šæ€, å¯ä»¥ç¼–å†™è‡ªé€‚åº”ä»»ä½•æ–°ç±»åž‹å­ç±»çš„ç¨‹åº. The Object ClassJavaä¸­çš„æ¯ä¸ªç±»éƒ½æ˜¯ Object classçš„åŽä»£ï¼Œæˆ–è€…æ‰©å±•äº†Objectç±»ã€‚å³ä½¿åœ¨ç±»ä¸­æ²¡æœ‰æ˜¾å¼çš„extendsä»ç„¶éšå¼åœ°ç»§æ‰¿äº†Objectã€‚ä¹Ÿå°±æ˜¯æ‰€æœ‰ classes éƒ½ç»§æ‰¿äº† Object. æ—¢ç„¶Objectæ˜¯æ‰€æœ‰ç±»çš„è¶…ç±», é‚£ä¸ºä½•ä¸é€‚ç”¨å®ƒæ¥æž„é€ ä¸‡ç”¨æ•°æ®ç»“æž„(æˆ–è€…æ–¹æ³•)å‘¢? äº‹å®žä¸Šçš„ç¡®å¾ˆå¤šArrayListæ–¹æ³•éƒ½ç”¨åˆ°Objectè¶…çº§ç±»åž‹. Objectç±»æä¾›çš„æ–¹æ³•, éƒ½æ˜¯ä»»ä½•å¯¹è±¡éƒ½éœ€è¦ç”¨åˆ°çš„æ–¹æ³•:123456789101112// -- https://docs.oracle.com/javase/8/docs/api/java/lang/Object.htmlString toString()boolean equals(Object obj)Class&lt;?&gt; getClass()int hashCode()protected Object clone()protected void finalize()void notify()void notifyAll()void wait()void wait(long timeout)void wait(long timeout, int nanos) ==æ£€æŸ¥ä¸¤ä¸ªå˜é‡æ˜¯å¦å¼•ç”¨åŒä¸€ä¸ªå¯¹è±¡ï¼ˆæ£€æŸ¥å†…å­˜åœ°å€ä½ï¼‰; .equals()é»˜è®¤æ˜¯ç­‰åŒäºŽ==, ä½†ä¸åŒçš„ç±»å¯èƒ½ä¼šé€šè¿‡ override é‡å†™å®ƒçš„åŠŸèƒ½(å¦‚Array.equals()å°±æ˜¯é‡å†™ä¸ºæ£€æŸ¥æ•°ç»„å†…å®¹æ˜¯å¦ç›¸åŒ). å½“override .equals()æ—¶ï¼Œæ³¨æ„ï¼š å¿…é¡»ä½“çŽ° equivalence relation reflexive: x.equals(x) is true symmetric: x.equals(y) IFF y.equals(x) transitive: x.equals(y) and y.equals(z) implies x.equals(z) è¦ override åŽŸæœ¬çš„.equals()ï¼Œå¿…é¡»æŽ¥æ”¶ä¸€ä¸ª Object å‚æ•° å¿…é¡» consistentï¼šå‡å¦‚x.equals(y), é‚£ä¹ˆåªè¦xå’Œyä¿æŒä¸å˜, é‚£ä¹ˆxç»§ç»­ç­‰äºŽy. nullæ°¸è¿œéžçœŸ: x.equals(null) ä¸€å®šæ˜¯false Interfaces donâ€™t extend Object.â€“ http://docs.oracle.com/javase/specs/jls/se7/html/jls-9.html#jls-9.2 ä½†æ˜¯, ä½¿ç”¨Objectå¤šæ€æ˜¯æœ‰ä»£ä»·çš„:1234ArrayList&lt;Object&gt; dogs = new ArrayList&lt;Object&gt;();Dog a = new Dog();dogs.add(a);// Dog b = dogs.get(0); æ— æ³•ç¼–è¯‘ æ— æ³•ç¼–è¯‘æ˜¯å› ä¸º, dogs.get()è¿”å›žçš„æ˜¯Objectç±»åž‹, å› æ­¤ç¼–è¯‘å™¨æ— æ³•ä¿è¯è¿”å›žçš„æ˜¯Dog. æ ¹æœ¬åŽŸå› æ˜¯å› ä¸ºç±»åž‹æ£€æŸ¥ã€‚ ç±»åž‹æ£€æŸ¥Type Checking123456789101112131415public class VengefulSLList&lt;Item&gt; extends SLList&lt;Item&gt; &#123; ...&#125;public static void main(String[] args) &#123; VengefulSLList&lt;Integer&gt; vsl = new VengefulSLList&lt;Integer&gt;(9); SLList&lt;Integer&gt; sl = vsl; // è¶…ç±»åŒ…å«å­ç±» //sl dynamic type is VengefulSLList sl.addLast(50); sl.removeLast(); // æ ¹æ® dynamic type é€‰æ‹© VengefulSLList çš„ removeLast sl.printLostItems(); //ç¼–è¯‘ä¸è¿‡, å› ä¸ºç¼–è¯‘æ—¶æ£€æŸ¥çš„æ˜¯ static type VengefulSLList&lt;Integer&gt; vsl2 = sl; // ç¼–è¯‘ä¸è¿‡, å­ç±»æ— æ³•åŒ…å«è¶…ç±»&#125; Expressions æ˜¯ compile-time types (static), ä½¿ç”¨newçš„è¡¨è¾¾å¼å…·æœ‰æŒ‡å®šçš„ compile-time types: SLList&lt;Integer&gt; sl = new VengefulSLList&lt;Integer&gt;();, è¡¨è¾¾å¼å³è¾¹ compile-time types æ˜¯VengefulSLListã€‚ç¼–è¯‘å™¨æ£€æŸ¥å¹¶ä¿è¯VengefulSLListä¸€å®šä¹Ÿæ˜¯SLListï¼Œå› æ­¤å…è®¸æ­¤èµ‹å€¼. VengefulSLList&lt;Integer&gt; vsl = new SLList&lt;Integer&gt;();, è¡¨è¾¾å¼å³è¾¹ compile-time types æ˜¯SLListã€‚å› ä¸ºSLListå¹¶ä¸ä¸€å®šæ˜¯VengefulSLListï¼Œæ•…ç¼–è¯‘æŠ¥é”™. Static type checking å¥½å¤„: Checks for errors early , reads more like a story åå¤„å°±æ˜¯ä¸å¤Ÿçµæ´»ã€‚ Method calls have compile-time types equal to their declared type.1234567public static Dog maxDog(Dog d1, Dog d2) &#123; ... &#125;Poodle frank = new Poodle("Frank", 5);Poodle frankJr = new Poodle("Frank Jr.", 15);Dog largerDog = maxDog(frank, frankJr);// ç¼–è¯‘ä¸è¿‡! RHS compile-time type is DogPoodle largerPoodle = maxDog(frank, frankJr); ç¼–è¯‘å™¨æŠ¥é”™, maxDogè¿”å›žçš„æ˜¯Dog, è™½ç„¶æ­¤æ—¶æˆ‘ä»¬éƒ½çŸ¥é“è¿™é‡Œçš„â€ç‹—â€è‚¯å®šæ˜¯æŒ‡è´µå®¾çŠ¬, ä½†ç¼–è¯‘å™¨æ— æ³•ç¡®è®¤Dogä¸€å®šæ˜¯largerPoodle. æœ‰æ²¡æœ‰åŠžæ³•è®©ç¼–è¯‘å™¨è®¤å¯è¿™ç§å…³ç³»å‘¢? æœ‰ï¼ Castingé€šè¿‡ casting, å¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨ä¸€ä¸ªè¡¨è¾¾å¼æœ‰æŸä¸ªç‰¹å®šçš„ compile-time types.1Poodle largerPoodle = (Poodle) maxDog(frank, frankJr); ç¼–è¯‘é€šè¿‡, å³è¾¹ compile-time type è½¬æ¢ä¸º Poodle. Caution: Casting is a powerful but dangerous tool. Essentially, casting is telling the compiler not to do its type-checking duties - telling it to trust you and act the way you want it to. å¦‚æžœç¨‹åºçŒ¿ä¹Ÿæ— æ³•ç¡®è®¤ç±»åž‹, å¯ä»¥ä½¿ç”¨instanceofæ¥æ£€æŸ¥12if (o instanceof Poodle) Poodle largerPoodle = (Poodle) maxDog(frank, frankJr);]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 13 | æŽ¥å£é»˜è®¤æ–¹æ³•]]></title>
    <url>%2Fjava-13-implementation-inheritance%2F</url>
    <content type="text"><![CDATA[é™¤äº†å•çº¯æä¾›å£°æ˜Žä¹‹å¤–ï¼ŒJava 8 ä¹Ÿå…è®¸æŽ¥å£æä¾›å…·ä½“çš„å®žçŽ°æ–¹æ³•ã€‚ ç¼ºçœæ–¹æ³•ä»Ž Java 8å¼€å§‹æ”¯æŒ Default methodã€‚ æˆ‘ä»¬å¯ä»¥åœ¨Listä¸­åˆ—å‡ºå·²å®žçŽ°çš„methodã€‚è¿™äº›æ–¹æ³•å°±æ˜¯ default methodï¼Œå®šä¹‰äº†List hypernymsçš„ä¸€äº›é»˜è®¤è¡Œä¸ºï¼šdefault public void method() { ... }. æˆ‘ä»¬å¯ä»¥è‡ªç”±è°ƒç”¨interfaceä¸­å®šä¹‰çš„æ–¹æ³•ï¼Œè€Œä¸ç”¨æ“å¿ƒå…·ä½“çš„å®žçŽ°ã€‚Default method é€‚ç”¨äºŽå®žçŽ°æŽ¥å£çš„ä»»ä½•ç±»åž‹çš„å¯¹è±¡ï¼å­ç±»å¯ä»¥ç›´æŽ¥è°ƒç”¨ï¼Œè€Œä¸å¿…é‡æ–°å®žçŽ° default methodã€‚1234// Listdefault public void print() &#123; ...&#125; ä¸è¿‡ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥override default methodï¼Œåœ¨å­ç±»ä¸­é‡æ–°å®šä¹‰è¯¥æ–¹æ³•ã€‚è¿™æ ·ï¼Œåªè¦æˆ‘ä»¬åœ¨LinkedLListä¸Šè°ƒç”¨print()ï¼Œå®ƒå°±ä¼šè°ƒç”¨å­ç±»overrideçš„æ–¹æ¡ˆï¼Œè€Œä¸æ˜¯çˆ¶ç±»çš„ã€‚12345// LinkedList@Overridepublic void print() &#123; ...&#125; Dynamic typeJavaæ˜¯é€šè¿‡ä¸€ä¸ªå«â€œdynamic method selectionâ€çš„ç‰¹æ€§ï¼Œæ¥ç¡®å®šè¦è°ƒç”¨ default method è¿˜æ˜¯å·²ç»è¢«å­ç±»overrideçš„methodã€‚ å½“å®žä¾‹å£°æ˜ŽList&lt;String&gt; l = new LinkedList&lt;String&gt;();, åˆ™æŒ‡æ˜Žlæ˜¯ static ç±»åž‹çš„ Listã€‚ç”± new ç”Ÿæˆçš„ object æ˜¯LinkedListç±»åž‹ï¼Œä¹Ÿä»Žå±žäºŽ List ç±»åž‹ã€‚ä½†æ˜¯ï¼Œå› ä¸ºè¿™ä¸ªå¯¹è±¡æœ¬èº«æ˜¯ä½¿ç”¨ LinkedList æž„é€ å‡½æ•°å®žä¾‹åŒ–çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ç§°ä¹‹ä¸º dynamic typeã€‚ Dynamic type çš„åç§°æºäºŽ: å½“lè¢«é‡æ–°åˆ†é…æŒ‡å‘å¦ä¸€ç§ç±»åž‹çš„å¯¹è±¡æ—¶ï¼Œæ¯”å¦‚è¯´ä¸€ä¸ª ArrayList å¯¹è±¡ï¼Œlçš„åŠ¨æ€ç±»åž‹çŽ°åœ¨å°±å˜ä¸º ArrayList. å› ä¸ºå®ƒæ ¹æ®å½“å‰å¼•ç”¨çš„å¯¹è±¡çš„ç±»åž‹è€Œæ”¹å˜, æ‰€ä»¥æ˜¯åŠ¨æ€çš„ã€‚ Static vs. Dynamic Type: Java æ¯ä¸ªå˜é‡éƒ½æœ‰ä¸€ä¸ªstatic type ï¼ˆcompile-time typeï¼‰ï¼Œè¿™æ˜¯å˜é‡å£°æ˜Žæ—¶æŒ‡å®šçš„ç±»åž‹ï¼Œåœ¨ç¼–è¯‘æ—¶ä¼šæ£€æŸ¥ã€‚ æ¯ä¸ªå˜é‡ä¹Ÿæœ‰ä¸€ä¸ª Dynamic Typeï¼ˆrun-time typeï¼‰ï¼Œæ­¤ç±»åž‹åœ¨å˜é‡å®žä¾‹åŒ–ï¼ˆnewï¼‰æ—¶æŒ‡å®šï¼Œå¹¶åœ¨è¿è¡Œæ—¶æ£€æŸ¥ã€‚ç­‰åŒäºŽåœ°å€æŒ‡å‘çš„å¯¹è±¡çš„ç±»åž‹ã€‚ å½“Javaè¿è¡Œä¸€ä¸ªè¢«overridençš„æ–¹æ³•æ—¶ï¼Œä¼šæ ¹æ®è¯¥å®žä¾‹çš„dynamic type åŒ¹é…å¯¹åº”çš„ methodã€‚ æ³¨æ„ï¼Œå¦‚æžœæ˜¯overload:123456public static void peek(List&lt;String&gt; list) &#123; ...&#125;public static void peek(LinkedList&lt;String&gt; list) &#123; ...&#125; å¯¹äºŽä¸Šé¢çš„å®žä¾‹åŒ–çš„l, å½“Javaæ£€æŸ¥è¦è°ƒç”¨å“ªä¸ªæ–¹æ³•æ—¶ï¼Œå®ƒä¼šæ£€æŸ¥ static type (æ­¤æ—¶æ˜¯List)å¹¶ä½¿ç”¨ç›¸åŒç±»åž‹çš„å‚æ•°è°ƒç”¨è¯¥æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨Listä½œä¸ºç­¾åçš„é‚£ä¸ªæ–¹æ³•ã€‚ Implementation inheritance ä¹Ÿæœ‰ä¸€äº›ç¼ºç‚¹ï¼š äººä¼šçŠ¯é”™ã€‚æˆ‘ä»¬æœ‰å¯èƒ½å¿˜äº†è‡ªå·±æ›¾ç»overrideè¿‡ä¸€ä¸ªæ–¹æ³•ã€‚ å¦‚æžœä¸¤ä¸ªæŽ¥å£ç»™å‡ºå†²çªçš„ default methodï¼Œåˆ™å¯èƒ½å¾ˆéš¾è§£å†³å†²çªã€‚ æ— å½¢ä¸­é¼“åŠ±ä»£ç å¤æ‚åŒ–ã€‚ Breaks encapsulation!]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 12 | æŽ¥å£ Interface]]></title>
    <url>%2Fjava-12-interface%2F</url>
    <content type="text"><![CDATA[å­ç±»åœ¨ä»€ä¹ˆæƒ…å†µä¸‹éœ€è¦å¤šä¸ªçˆ¶ç±»ï¼Ÿæ¯”å¦‚ï¼Œå› ä¸ºåŽŸæ¥çš„ä¸šåŠ¡éœ€æ±‚æ¯”è¾ƒå•ä¸€ï¼Œåªéœ€è¦Animal - Canine - Dogè¿™ç§ç±»ç»“æž„å°±æ»¡è¶³éœ€æ±‚äº†, æ­¤æ—¶Dogåªæ˜¯Animalçš„å­ç±». ä½†åŽæ¥æœ‰äº†æ–°çš„åŠŸèƒ½éœ€æ±‚, ä¸Šçº¿äº†å® ç‰©åŠŸèƒ½, ç†è®ºä¸Šå¯ä»¥ä¸ºæ¯ä¸€ç§å…·ä½“çš„å±žäºŽå® ç‰©çš„å­ç±»æ·»åŠ å® ç‰©åŠŸèƒ½, è¿™å°±æ¶‰åŠå¤§é‡çš„äººå·¥å’Œbug. ä½†å‡å¦‚é¢å¤–è®¾è®¡ä¸€ç§Petç±», é‚£ä¹ˆPetå’ŒAnimalä¼šæœ‰äº¤å‰é‡å , å¦‚æžœè®©å® ç‰©å­ç±»åŒæ—¶ç»§æ‰¿ä¸¤ç§è¶…ç±», é‚£å°±æ˜¯å¤šé‡ç»§æ‰¿. å› ä¸ºå¤šé‡ç»§æ‰¿ä¼šæœ‰è‡´å‘½æ–¹å—çš„é—®é¢˜, ä¸åŒçˆ¶ç±»å¯¹åŒä¸€ä¸ªæ–¹æ³•çš„å¯èƒ½æœ‰ä¸åŒçš„å®žçŽ°æ–¹å¼, è¿™ä¼šå¯¼è‡´å†²çª. æ‰€ä»¥Javaä¸æ”¯æŒè¿™ç§æ–¹å¼. æŽ¥å£è€ŒæŽ¥å£è¿™ä¸ªæ¦‚å¿µ, å°±å¯ä»¥ç”¨äºŽè§£å†³è¿™ä¸ªé—®é¢˜çš„. ç±»ä¸éœ€è¦ç»§æ‰¿å¤šä¸ªçˆ¶ç±», åªéœ€è¦å®žçŽ°ä¸€ä¸ªæˆ–å¤šä¸ªæŽ¥å£æŒ‡å®šçš„æ‰€æœ‰æ–¹æ³•/è¡Œä¸ºçš„å…³ç³».1234567public interface Pet&#123; public abstract void beFriendly(); public abstract void play();&#125;// å¯¹äºŽå±žäºŽå® ç‰©çš„å­ç±»ï¼Œè®©å…¶å®žçŽ°æŽ¥å£`Pet`.public class Dog extends Canine implements Pet &#123;&#125; æŽ¥å£ä½œä¸ºå‚æ•°æˆ‘ä»¬å‰é¢åˆ›å»ºçš„ LinkedList and ArrayList å…¶å®žå¾ˆç›¸ä¼¼ - æ‰€æœ‰çš„methodéƒ½ä¸€æ ·. å¦‚æžœæˆ‘ä»¬éœ€è¦å†™ä¸€ä¸ªéœ€è¦ç”¨åˆ°æ•°ç»„çš„ç±»æ¯”å¦‚WordUtils class,1234567public class WordUtils &#123; /** Returns the length of the longest word. */ public static String longest(LinkedList&lt;String&gt; list) &#123; ... return list.get(maxDex); &#125;&#125; æˆ‘ä»¬å¦‚ä½•è®©longestæ–¹æ³•ä¹Ÿé€‚é…ArrayListï¼Ÿç®€å•çš„æ–¹æ³•åŠæ—¶å†™ä¸¤ä¸ªåŒåä¸åŒå‚æ•°çš„methodsã€‚å³æ‰€è°“method overloadingã€‚public static String longest(LinkedList&lt;String&gt; list)public static String longest(ArrayList&lt;String&gt; list) ä½† overload æœ‰å‡ ä¸ªç¼ºç‚¹: é‡å¤å†—ä½™ï¼Œå†™ä¸¤ä¸ªå‡ ä¹Žç›¸åŒçš„ä»£ç å—ã€‚ äº§ç”Ÿæ›´å¤šéœ€è¦ç»´æŠ¤çš„ä»£ç ï¼Œé‚£æ„å‘³ç€å¦‚æžœä½ æƒ³å¯¹çš„æ–¹æ³•åšä¸€ä¸ªå°ä¼˜åŒ–æˆ–debugï¼Œä½ éœ€è¦åœ¨å¯¹åº”æ¯ç§listçš„æ–¹æ³•ä¸­æ”¹å˜å®ƒã€‚ å¦‚æžœæˆ‘ä»¬æƒ³è¦é€‚é…æ›´å¤šçš„åˆ—è¡¨ç±»åž‹ï¼Œä¸å¾—ä¸å¤åˆ¶æ¯ä¸ªæ–°åˆ—è¡¨ç±»çš„æ–¹æ³•ã€‚ ä¸ºé¿å…ä»¥ä¸Šé—®é¢˜ï¼Œæˆ‘ä»¬ä¸€èˆ¬å¸Œæœ›èƒ½å°½é‡æŠŠä¸¤ä¸ªåŠŸèƒ½è¿‘ä¼¼çš„æ–¹æ³•åˆå¹¶ï¼Œä½†è¦ä¿è¯å…¶è¶³å¤Ÿå¹¿æ³›çš„é€‚ç”¨åœºæ™¯ã€‚ å®šä¹‰é€šç”¨åˆ—è¡¨æŽ¥å£ interface Listã€‚ç„¶åŽæŠŠLinkedListå’ŒArrayListå®žçŽ°Listã€‚1234public interface List&lt;Item&gt; &#123; public void addFirst(Item x); ...&#125; è¿™é‡Œçš„ List æ˜¯æŽ¥å£ã€‚æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæŒ‡å®šå¿…é¡»èƒ½å¤Ÿåšä»€ä¹ˆçš„åˆçº¦ï¼Œä½†ä¸æä¾›å…·ä½“å®žçŽ°ã€‚12345678910public class ArrayList&lt;Item&gt; implements List&lt;Item&gt;&#123; // å…·ä½“çš„æ‰§è¡Œ public void addFirst(Item x) &#123; insert(x, 0); &#125;&#125;public class LinkedList&lt;Item&gt; implements List&lt;Item&gt;&#123; // å…·ä½“çš„æ‰§è¡Œ&#125; ArrayList&lt;Item&gt; implements List&lt;Item&gt;ç±»ä¼¼ç­¾åˆçº¦ - ArrayListä¿è¯å®žçŽ°ListæŽ¥å£åˆ—å‡ºçš„æ‰€æœ‰å±žæ€§ï¼ˆå˜é‡ï¼‰å’Œæ–¹æ³•ã€‚ è¿™æ ·å°±å¯ä»¥åŒæ—¶é€‚é…å¤šç§listï¼š123456789101112131415public class WordUtils &#123; /** Returns the length of the longest word. */ public static String longest(List&lt;String&gt; list) &#123; ... return list.get(maxDex); &#125; public static void main(String[] args) &#123; ArrayList&lt;String&gt; someList = new ArrayList&lt;&gt;(); //or LinkedList&lt;String&gt; someList = new LinkedList&lt;&gt;(); ... System.out.println(longest(someList)); &#125;&#125; æŽ¥å£åˆ—å‡ºæ‰€æœ‰æ–¹æ³•çš„å£°æ˜Žï¼Œå°±åƒâ€˜åˆçº¦â€™ï¼Œä½†æ²¡æœ‰å…·ä½“çš„å®žçŽ°. æ ¹æ®â€˜åˆçº¦â€™ï¼Œç”±å­ç±»æ¥å®žçŽ°ä¸”å¿…é¡»å®žçŽ°ï¼ˆoverrideï¼‰æ¯ä¸€ä¸ªmethodï¼Œå¦åˆ™æ— æ³•é€šè¿‡ç¼–è¯‘. ç»§æ‰¿å…³ç³»å¯ä»¥å»¶ç»­å¤šä»£ã€‚ä¾‹å¦‚ï¼ŒBå¯ä»¥ç»§æ‰¿Aï¼ŒCå¯ä»¥ç»§æ‰¿B. GRoEæ ¹æ®Javaçš„Golden Rule of Equalsï¼Œæ¯ä¸€ä¸ªèµ‹å€¼a = bï¼Œæœ¬è´¨ä¸Šæ˜¯æŠŠbä¸­çš„bitsæ‹·è´åˆ°aä¸­ï¼Œç€è¦æ±‚bå’Œaçš„ç±»åž‹ç›¸åŒã€‚ åŒç†, å‡è®¾public static String longest(List&lt;String&gt; list)æ—¢æŽ¥å—List, ä¹ŸæŽ¥å—ArrayListå’ŒLinkedListï¼Œä½†æ˜¯ç”±äºŽArrayListå’ŒListæ˜¯ä¸åŒçš„ç±»ï¼Œé‚£æ€Žä¹ˆéµå®ˆGRoEå‘¢ï¼Ÿ å› ä¸ºArrayListä¸ŽListæœ‰ç€ä¸Šä¸‹ä½åŒ…å«çš„å…³ç³»ï¼Œè¿™æ„å‘³ç€ArrayListåº”è¯¥èƒ½å¤Ÿèµ‹å€¼ç»™Listçš„å†…å­˜ä½ä¸­.1234public static void main(String[] args) &#123; List&lt;String&gt; someList = new SLList&lt;String&gt;(); someList.addFirst("elk");&#125; è¿™æ®µä»£ç è¿è¡Œæ—¶ï¼Œä¼šåˆ›å»ºSLListå¹¶å°†å…¶åœ°å€å­˜å‚¨åœ¨someListå˜é‡ä¸­ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 11 | æµ‹è¯• Testing]]></title>
    <url>%2Fjava-11-testing%2F</url>
    <content type="text"><![CDATA[æµ‹è¯•å¦‚ä½•çŸ¥é“è‡ªå·±çš„ç¨‹åºæ˜¯å¦çœŸçš„åœ¨å·¥ä½œï¼Ÿåœ¨çŽ°å®žä¸–ç•Œä¸­ï¼Œç¨‹åºå‘˜ç›¸ä¿¡ä»–ä»¬çš„ä»£ç ï¼Œå› ä¸ºä»£ç é€šè¿‡äº†ä»–ä»¬è‡ªå·±ç¼–å†™çš„æµ‹è¯•ã€‚å¸¸ç”¨çš„æµ‹è¯•æœ‰ Ad Hoc Testingï¼Œ Unit test å’Œ Integration Testingã€‚ Ad Hoc Testingï¼Œæ˜¯æŒ‡æ²¡æœ‰è®¡åˆ’å’Œè®°å½•çš„è½¯ä»¶æµ‹è¯•ï¼Œé™¤éžå‘çŽ°ç¼ºé™·ï¼Œä¸ç„¶ä¸€èˆ¬åªè¿è¡Œä¸€æ¬¡ã€‚ Unit testç¨‹åºå¯åˆ†è§£ä¸ºå•å…ƒï¼ˆæˆ–ç¨‹åºä¸­å¯æµ‹è¯•çš„æœ€å°éƒ¨åˆ†ï¼‰ï¼ŒUnit test ä¸¥æ ¼æµ‹è¯•ä»£ç çš„æ¯ä¸ªå•å…ƒï¼Œæœ€ç»ˆç¡®ä¿é¡¹ç›®æ­£ç¡®è¿è¡Œã€‚Unit test å¥½å¤„ï¼š Unit test ä¿è¯è‰¯å¥½çš„ä»£ç ç»“æž„ï¼ˆæ¯ä¸ª method â€œåªæ‰“ä¸€ä»½å·¥â€ï¼‰ï¼Œå¸®åŠ©æˆ‘ä»¬è¾ƒå¥½åœ°è§£æžä»»åŠ¡ï¼Œ å…è®¸æˆ‘ä»¬è€ƒè™‘æ¯ä¸ªæ–¹æ³•çš„æ‰€æœ‰è¾¹ç•Œæƒ…å†µï¼Œå¹¶å•ç‹¬æµ‹è¯•å®ƒä»¬ã€‚ è®©æˆ‘ä»¬æ¯æ¬¡åªä¸“æ³¨äºŽä¸€ä¸ªå•å…ƒï¼Œè¿›è¡Œæµ‹è¯•ï¼Œdebugï¼Œå¯¹å‡†ç¡®åº¦æœ‰ä¿¡å¿ƒåŽï¼Œå†è¿›è¡Œä¸‹ä¸€ä¸ªå•å…ƒçš„å¼€å‘ã€‚ç›¸æ¯”äºŽä¸€æ¬¡æ€§å†™å®Œæ‰€æœ‰ä»£ç ï¼Œå†æµ‹è¯•debugï¼ŒUnit test å‡å°‘äº† debugging æ—¶é—´ã€‚ åå¤„ï¼š æµ‹è¯•ä¹Ÿè¦èŠ±æ—¶é—´ æµ‹è¯•æœ¬èº«ä¹Ÿæ˜¯æœ‰å¯èƒ½å‡ºé”™çš„ï¼Œæµ‹è¯•å¯èƒ½ä¸å…¨é¢ï¼Œä¸è§„èŒƒï¼Œæˆ–è€…æœ‰bug æœ‰äº›å•å…ƒæ˜¯ä¾èµ–äºŽå…¶ä»–å•å…ƒçš„ Unit testing æ— æ³•ä¿è¯å„ä¸ªæ¨¡å—çš„äº¤äº’ï¼Œæ— æ³•ä¿è¯æ•´ä¸ªç³»ç»Ÿä½œä¸ºä¸€ä¸ªæ•´ä½“æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚ JUnitJUnitæ˜¯ä¸€ä¸ªç»™Javaåšæµ‹è¯•çš„æ¡†æž¶ï¼Œç”±Erich Gammaï¼ˆDesign Patternsï¼‰å’ŒKent Beckï¼ˆeXtreme Programmingï¼‰ç¼–å†™ã€‚JUnitä½¿ç”¨Javaçš„ reflection åŠŸèƒ½ï¼ˆJavaç¨‹åºå¯ä»¥æ£€æŸ¥è‡ªå·±çš„ä»£ç ï¼‰å’Œæ³¨é‡Šã€‚JUnitå…è®¸æˆ‘ä»¬ï¼š å®šä¹‰å¹¶æ‰§è¡Œæµ‹è¯•å’Œæµ‹è¯•å¥—ä»¶ ä½¿ç”¨æµ‹è¯•ä½œä¸ºè§„èŒƒçš„æœ‰æ•ˆæ‰‹æ®µ ä½¿ç”¨æµ‹è¯•æ¥æ”¯æŒé‡æž„ å°†ä¿®æ”¹çš„ä»£ç é›†æˆåˆ°æž„å»ºä¸­JUnitå¯ç”¨äºŽå¤šä¸ªIDEï¼Œä¾‹å¦‚BlueJï¼ŒJBuilderå’ŒEclipseåœ¨ä¸€å®šç¨‹åº¦ä¸Šå…·æœ‰JUnité›†æˆã€‚ 1234567import org.junit.Test;import static org.junit.Assert.*;@Testpublic void testMethod() &#123; assertEquals(&lt;expected&gt;, &lt;actual&gt;);&#125; assertEqualsæµ‹è¯•ä¸€ä¸ªå˜é‡çš„å®žé™…å€¼æ˜¯å¦ç­‰äºŽå®ƒçš„æœŸæœ›å€¼ã€‚JUnit test å„ä¸ªæµ‹è¯•æ–¹æ³•ï¼Œå¿…é¡»æ˜¯éžé™æ€çš„ï¼ˆJUnitçš„è®¾è®¡äººå‘˜è®¾è®¡è§„å®šçš„ï¼‰ã€‚ JUnitçš„æœ¯è¯­ Test runnerï¼šæµ‹è¯•è¿è¡Œå™¨ï¼Œ è¿è¡Œæµ‹è¯•å’ŒæŠ¥å‘Šç»“æžœçš„è½¯ä»¶ã€‚å®žçŽ°æ–¹å¼ï¼šé›†æˆåˆ°IDEä¸­ï¼Œç‹¬ç«‹GUIï¼Œå‘½ä»¤è¡Œç­‰ Test suiteï¼šæµ‹è¯•å¥—ä»¶æ˜¯ä¸€ç»„æµ‹è¯•ç”¨ä¾‹ã€‚ Test caseï¼šæµ‹è¯•ç”¨ä¾‹ç”¨äºŽæµ‹è¯•å•ä¸ªæ–¹æ³•å¯¹ç‰¹å®šè¾“å…¥é›†çš„å“åº”ã€‚ Unit testï¼šå•å…ƒæµ‹è¯•çš„å•å…ƒï¼Œæ˜¯ä»£ç ä¸­æˆ‘ä»¬èƒ½å¤Ÿç›¸å¯¹åˆç†åœ°æµ‹è¯•çš„æœ€å°çš„å…ƒç´ ï¼Œé€šå¸¸æ˜¯å•ä¸ªç±»ã€‚ å¸¸ç”¨çš„JUnitæŽ¥å£å’Œæ–¹æ³•@Before: Creates a test fixture by creating and initialising objects and values. @After: Releases any system resources used by the test fixture. Java usually does this for free, but files, network connections etc. might not get tidied up automatically. @Testï¼štests cases. static void assertTrue(boolean test), static void assertTrue(String message, boolean test), static void assertFalse(boolean test), static void assertFalse(String message, boolean test) Integration Testingé‰´äºŽ Unit testing æ— æ³•ä¿è¯ï¼Œæœ‰äº¤äº’çš„å¤šä¸ªæ¨¡å—ï¼Œä½œä¸ºä¸€ä¸ªæ•´ä½“æ˜¯å¦æ­£å¸¸å·¥ä½œã€‚æˆ‘ä»¬å¯èƒ½éœ€è¦ integration testingï¼ŒæŠŠå„ä¸ªæ¨¡å—åˆå¹¶ï¼Œä½œä¸ºä¸€ä¸ªç»„åˆï¼Œè¿›è¡Œæµ‹è¯•ï¼ˆä¹Ÿå¯ä»¥æŠŠ Unit test ç»„åˆèµ·æ¥å˜æˆ integration testingï¼‰ã€‚ Integration testing ä¸€èˆ¬éƒ½æ¯”è¾ƒéº»çƒ¦ï¼Œä¹Ÿä¸å®¹æ˜“è‡ªåŠ¨åŒ–ï¼Œè€Œä¸”ä¸€èˆ¬æ˜¯åœ¨æ¯”è¾ƒé«˜çš„æŠ½è±¡å±‚è¿›è¡Œæµ‹è¯•ï¼Œå¯èƒ½ä¼šæ¼æŽ‰å¾®å°çš„é”™è¯¯ã€‚ å½“æŠŠæ‰€æœ‰æ¨¡å—éƒ½ä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œä¹Ÿå°±æ˜¯æ•´ä¸ªç³»ç»Ÿä½œä¸ºæµ‹è¯•å¯¹è±¡æ—¶ï¼Œå°±æ˜¯ system testingã€‚ Test driven developmentTDDå¼€å‘æ­¥éª¤ï¼š æ˜Žç¡®ä¸€é¡¹æ–°åŠŸèƒ½éœ€æ±‚ã€‚ ä¸ºè¯¥åŠŸèƒ½ç¼–å†™ Unit testã€‚ è¿è¡Œæµ‹è¯•ï¼ŒæŒ‰ç†åº”è¯¥æ— æ³•é€šè¿‡æµ‹è¯•ï¼ˆå› ä¸ºè¿˜æ²¡å†™åŠŸèƒ½ç¨‹åºï¼‰ã€‚ ç¼–å†™é€šè¿‡å®žçŽ°è¯¥åŠŸèƒ½çš„ä»£ç ï¼Œé€šè¿‡æµ‹è¯•ã€‚ å¯é€‰ï¼šé‡æž„ä»£ç ï¼Œä½¿å…¶æ›´å¿«ï¼Œæ›´æ•´æ´ç­‰ç­‰ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213]]></title>
    <url>%2Fcsapp%2F</url>
    <content type="text"><![CDATA[CSAPP éžå¸¸å·§å¦™çš„æŠŠç¨‹åºè®¾è®¡åŠä¼˜åŒ–ã€æ•°å­—ç”µè·¯åŸºç¡€ã€æŒ‡ä»¤é›†ä½“ç³»ã€æ±‡ç¼–è¯­è¨€ã€å­˜å‚¨å™¨ä½“ç³»ç»“æž„ã€é“¾æŽ¥ä¸Žè£…è½½ã€è¿›ç¨‹ã€è™šå­˜ç­‰æ¥è‡ªä¸åŒå­¦ç§‘çš„æ ¸å¿ƒçŸ¥è¯†ç‚¹å’Œåœ¨ä¸€èµ·ï¼Œå¹¶ä»¥ç¨‹åºå‘˜çš„è§†è§’å‘ˆçŽ°; å‘Šè¯‰æˆ‘ä»¬ä½œä¸ºä¸€ä¸ªç¨‹åºå‘˜ï¼Œç©¶ç«Ÿéœ€è¦å¯¹è®¡ç®—æœºçš„ç¡¬ä»¶äº†è§£åˆ°ä»€ä¹ˆç¨‹åº¦ï¼Ÿ æœ¬ç¬”è®°æ˜¯ CMU CSAPP çš„å­¦ä¹ ç¬”è®°, ä½¿ç”¨ CMU 15-213, UW CSE351 çš„è¯¾ç¨‹è§†é¢‘, lab, ä½œä¸š, project è¾…åŠ©ç»ƒä¹ . Computer Systems: A Programmerâ€™s Perspective (csapp), è±†ç“£-æ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿ å¡å†…åŸºæ¢…éš†å¤§å­¦ CMU 15-213 Introduction to Computer Systems (ICS) åŽç››é¡¿å¤§å­¦ UW CSE351: The Hardware/Software Interface ä¿¡æ¯çš„è¡¨è¾¾ä¸Žæ“ä½œInformation is Bits + Context. Study systems by tracing the lifetime of the hello program, from the time it is created by a programmer, until it runs on a system, prints its simple message, and terminates.123#include &lt;stdio.h&gt;int main()&#123; printf("hello, world\n"); &#125; The source program is a sequence of bits, each with a value of 0 or 1, organized in 8-bit chunks(bytes). Each byte represents some text character in the program. All information in a system â€” including disk files, programs stored in memory, user data stored in memory, and data transferred across a networkâ€”is represented as a bunch of bits. æ•´æ•°åŠ å‡ä¹˜ä½ç§»Most machines shift and add faster than multiply, compiler translate multiply to shift and add automatically. Power-of-2 Multiply with Shift: u &lt;&lt; k gives $u \times 2^k$, u * 24 = u * 32 - u * 8 = (u &lt;&lt; 5) - (u &lt;&lt; 3) Signed Power-of-2 Divide with Shift: x &gt;&gt; k using arithmetic shift(è¡¥1) gives $x / 2^k$, when u &lt; 0, say y = -15213 = b[11000100 10010011], y &gt;&gt; 1 = b[11100010 01001001] = -7607, the rounding is downward, which is not the same as the convention toward zero. Correct Power-of-2 Divide by adding bias: $x / 2^k$, computed as $(x + 2^k - 1) / 2^k$, in C (x&lt;0 ? x+(1&lt;&lt;k)-1 : x) &gt;&gt; k æµ®ç‚¹æ•°IEEE floating-point standard represents a number in a form $V = (âˆ’1)^s Ã— M Ã— 2^E$ sign s: determines whether the number is negative (s = 1) or positive (s = 0) exponent E weights the value by a (possibly negative) power of 2, encoded by the k-bit exponent field exp. significand M: a fractional binary number that ranges either [1, 2 âˆ’ Ïµ) or [0, 1 âˆ’ Ïµ), encoded by the n-bit fraction field frac Case 1: Normalized ValuesE is interpreted as representing a signed integer in biased form, E = e âˆ’ Bias, where e is the unsigned number, Bias equals to $2^{kâˆ’1}âˆ’1$.The significand is defined to be M = 1 + f, where f is the fraction field, 0 â‰¤ f &lt; 1, M = $1.f_{nâˆ’1}f_{nâˆ’2}â€¦f_0$ Case 2: Denormalized ValuesExponent field is all zeros, the exponent value is E = 1 âˆ’ Bias, and the significand value is M = f, M = $0.f_{nâˆ’1}f_{nâˆ’2}â€¦f_0$Denormalized numbers serve two purposes. provide a way to represent numeric value 0, +0.0, bit pattern all zeros, s = M = f = 0 âˆ’0.0, bit pattern all zeros except s = 1. represent numbers that are very close to 0.0: possible numeric values are spaced evenly near 0.0 Case 3: Special ValuesExponent field is all ones. When the fraction field is all zeros, the resulting values represent infinity, either +âˆž when s = 0, or âˆ’âˆž when s = 1. Infinity can represent results that overflow When the fraction field is nonzero, the resulting value is NaN Programs are traslated by other programs into different formsThe hello program begins as a high-level C program because it can be read and understood by human beings in that form. However, in order to run hello.c on the system, the individual C statements must be translated by other programs into a sequence of low-level machine-language instructions. These instructions are then packaged in a form called an executable object program and stored as a binary disk file. Object programs are also referred to as executable object files. The programs that perform the four phases (preprocessor, compiler, assembler, and linker) are known collectively as the compilation system. Preprocessing phase.The preprocessor (cpp) modifies the original C program according to directives that begin with the # character. Compilation phase. The compiler (cc1) translates the text file hello.i into the text file hello.s, which contains an assembly-language program. Assembly language is useful because it provides a common output language for different compilers for different high-level languages. Assembly phase. Next, the assembler (as) translates hello.s into machinelanguage instructions, packages them in a form known as a relocatable object program, and stores the result in the object file hello.o. The hello.o file is a binary file whose bytes encode machine language instructions rather than characters. Linking phase. The printf function resides in a separate precompiled object file called printf.o, which must somehow be merged with our hello.o program. The linker (ld) handles this merging. å¤§å¤šæ•° JVM å°†å†…å­˜åŒºåŸŸåˆ’åˆ†ä¸º Method Areaï¼ˆNon-Heapï¼‰ï¼ˆæ–¹æ³•åŒºï¼‰, Heapï¼ˆå †ï¼‰, Program Counter Registerï¼ˆç¨‹åºè®¡æ•°å™¨ï¼‰, VM Stackï¼ˆè™šæ‹Ÿæœºæ ˆ/JAVAæ–¹æ³•æ ˆï¼‰, Native Method Stackï¼ˆ æœ¬åœ°æ–¹æ³•æ ˆ ï¼‰ï¼Œå…¶ä¸­Method Areaå’ŒHeapæ˜¯çº¿ç¨‹å…±äº«çš„ï¼ŒVM Stackï¼ŒNative Method Stackå’ŒProgram Counter Registeræ˜¯éžçº¿ç¨‹å…±äº«çš„ã€‚ ç¨‹åºè®¡æ•°å™¨æ˜¯ä¸€ä¸ªæ¯”è¾ƒå°çš„å†…å­˜åŒºåŸŸï¼Œç”¨äºŽæŒ‡ç¤ºå½“å‰çº¿ç¨‹æ‰€æ‰§è¡Œçš„å­—èŠ‚ç æ‰§è¡Œåˆ°äº†ç¬¬å‡ è¡Œï¼Œæ˜¯çº¿ç¨‹éš”ç¦»çš„ è™šæ‹Ÿæœºæ ˆæè¿°çš„æ˜¯Javaæ–¹æ³•æ‰§è¡Œçš„å†…å­˜æ¨¡åž‹ï¼Œç”¨äºŽå­˜å‚¨å±€éƒ¨å˜é‡ï¼Œæ“ä½œæ•°æ ˆï¼ŒåŠ¨æ€é“¾æŽ¥ï¼Œæ–¹æ³•å‡ºå£ç­‰ä¿¡æ¯ï¼Œæ˜¯çº¿ç¨‹éš”ç¦»çš„ åŽŸåˆ™ä¸Šè®²ï¼Œæ‰€æœ‰çš„å¯¹è±¡éƒ½åœ¨å †åŒºä¸Šåˆ†é…å†…å­˜ï¼Œæ˜¯çº¿ç¨‹ä¹‹é—´å…±äº«çš„ æ–¹æ³•åŒºåŸŸå­˜æ”¾äº†æ‰€åŠ è½½çš„ç±»çš„ä¿¡æ¯ï¼ˆåç§°ã€ä¿®é¥°ç¬¦ç­‰ï¼‰ã€ç±»ä¸­çš„é™æ€å˜é‡ã€ç±»ä¸­å®šä¹‰ä¸ºfinalç±»åž‹çš„å¸¸é‡ã€ç±»ä¸­çš„Fieldä¿¡æ¯ã€ç±»ä¸­çš„æ–¹æ³•ä¿¡æ¯ï¼Œå½“å¼€å‘äººå‘˜åœ¨ç¨‹åºä¸­é€šè¿‡Classå¯¹è±¡ä¸­çš„getNameã€isInterfaceç­‰æ–¹æ³•æ¥èŽ·å–ä¿¡æ¯æ—¶ï¼Œè¿™äº›æ•°æ®éƒ½æ¥æºäºŽæ–¹æ³•åŒºåŸŸï¼ŒåŒæ—¶æ–¹æ³•åŒºåŸŸä¹Ÿæ˜¯å…¨å±€å…±äº«çš„ï¼Œåœ¨ä¸€å®šçš„æ¡ä»¶ä¸‹å®ƒä¹Ÿä¼šè¢«GCï¼Œå½“æ–¹æ³•åŒºåŸŸéœ€è¦ä½¿ç”¨çš„å†…å­˜è¶…è¿‡å…¶å…è®¸çš„å¤§å°æ—¶ï¼Œä¼šæŠ›å‡ºOutOfMemoryçš„é”™è¯¯ä¿¡æ¯ ä¸€ä¸ªä¸€èˆ¬æ€§çš„ Java ç¨‹åºå·¥ä½œè¿‡ç¨‹ï¼š ä¸€ä¸ª Java æºç¨‹åºæ–‡ä»¶ï¼Œä¼šè¢«ç¼–è¯‘ä¸ºå­—èŠ‚ç æ–‡ä»¶ï¼ˆä»¥ class ä¸ºæ‰©å±•åï¼‰ï¼Œæ¯ä¸ªjavaç¨‹åºéƒ½éœ€è¦è¿è¡Œåœ¨è‡ªå·±çš„JVMä¸Šï¼Œç„¶åŽå‘ŠçŸ¥ JVM ç¨‹åºçš„è¿è¡Œå…¥å£ï¼Œå†è¢« JVM é€šè¿‡å­—èŠ‚ç è§£é‡Šå™¨åŠ è½½è¿è¡Œã€‚ ç¨‹åºå¼€å§‹è¿è¡ŒåŽï¼Œå¼€å§‹æ¶‰åŠå„å†…å­˜åŒºåŸŸï¼š JVMåˆå§‹è¿è¡Œçš„æ—¶å€™éƒ½ä¼šåˆ†é…å¥½ Method Areaï¼ˆæ–¹æ³•åŒºï¼‰å’ŒHeapï¼ˆå †ï¼‰ï¼Œ è€ŒJVMæ¯é‡åˆ°ä¸€ä¸ªçº¿ç¨‹ï¼Œå°±ä¸ºå…¶åˆ†é…ä¸€ä¸ªProgram Counter Registerï¼ˆç¨‹åºè®¡æ•°å™¨ï¼‰, VM Stackï¼ˆè™šæ‹Ÿæœºæ ˆï¼‰å’ŒNative Method Stackï¼ˆæœ¬åœ°æ–¹æ³•æ ˆï¼‰ï¼Œå½“çº¿ç¨‹ç»ˆæ­¢æ—¶ï¼Œä¸‰è€…æ‰€å ç”¨çš„å†…å­˜ç©ºé—´ä¹Ÿä¼šè¢«é‡Šæ”¾æŽ‰ã€‚ è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæŠŠå†…å­˜åŒºåŸŸåˆ†ä¸ºçº¿ç¨‹å…±äº«å’Œéžçº¿ç¨‹å…±äº«çš„åŽŸå› ï¼Œéžçº¿ç¨‹å…±äº«çš„é‚£ä¸‰ä¸ªåŒºåŸŸçš„ç”Ÿå‘½å‘¨æœŸä¸Žæ‰€å±žçº¿ç¨‹ç›¸åŒï¼Œè€Œçº¿ç¨‹å…±äº«çš„åŒºåŸŸä¸ŽJAVAç¨‹åºè¿è¡Œçš„ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼Œæ‰€ä»¥è¿™ä¹Ÿæ˜¯ç³»ç»Ÿåžƒåœ¾å›žæ”¶çš„åœºæ‰€åªå‘ç”Ÿåœ¨çº¿ç¨‹å…±äº«çš„åŒºåŸŸï¼ˆå®žé™…ä¸Šå¯¹å¤§éƒ¨åˆ†è™šæ‹Ÿæœºæ¥è¯´çŸ¥å‘ç”Ÿåœ¨Heapä¸Šï¼‰çš„åŽŸå› ã€‚ Processors read and interpret instructions stored in memoryThe hello.c source program has been translated by the compilation system into an executable object file called hello that is stored on disk, to run the executable file on Unix:123unix&gt; ./hellohello, worldunix&gt; The shell is a command-line interpreter that prints a prompt, waits for you to type a command line, and then performs the command. Hardware organization of a systemsHardware organization of a typical system. BusesElectrical conduits that carry bytes of information back and forth between the components. Buses are typically designed to transfer fixed-sized chunks of bytes known as words. USB: Universal Serial bus. Input/output (I/O) devicesThe systemâ€™s connection to the external world. Each I/O deviceisconnected to the I/O bus by either a controller or an adapterï¼š Controllers are chip sets in the device itself or on the systemâ€™s main printed circuit board (often called the motherboard). An adapter is a card that plugs into a slot on the motherboard. Main MemoryA temporary storage device that holds both a program and the data it manipulates while the processor is executing the program. Physically, main memory consists of a collection of dynamic random access memory (DRAM) chips. Logically, memory is organized as a linear array of bytes, each with its own unique address (array index) starting at zero*Processor: Central Processing Unit (CPU) PC: Program counter, a word-sized storage device (or register) at CPU core. At any point in time, the PC points at (contains the address of) some machine-language instruction in main memory. Register: a quickly accessible location available to CPU, Register file: an array of registers, each with its own unique name. Arithmetic/logic unit: ALU computes new data and address values. A processor repeatedly executes the instruction pointed at by the program counter and updates the program counter to point to the next instruction. The processor reads the instruction from memory pointed at by the PC, interprets the bits in the instruction, performs some simple operation dictated by the instruction, and then updates the PC to point to the next instruction. CPU operations examplesLoad: Copy a byte or a word from main memory into a register, overwriting the previous contents of the register. Store(write): Copy a byte or a word from a register to a location in main memory, overwriting the previous contents of that location. Operate: Copy the contents of two registers to the ALU, perform an arithmetic operation on the two words, and store the result in a register, overwriting the previous contents of that register. Jump: Extract a word from the instruction itself and copy that word into the program counter (PC), overwriting the previous value of the PC. Branch greater than (BGT): compares two registers and decides whether to branch (target would be the address to branch to), i.e. it is implementing the â€œifâ€ decision. Running a programs Initially, the shell program is waiting for user types a command. As we type the characters â€œ./helloâ€ at the keyboard, the shell program reads each one into a register, and then stores it in memory. When we hit the enter key on the keyboard, the shell knows that we have finished typing the command. The shell then loads the executable hello file by executing a sequence of instructions that copies the code and data in the hello object file from disk to main memory. The data include the string of characters â€œhello, world\nâ€ that will eventually be printed out. Using a technique known as direct memory access (DMA), the data travels directly from disk to main memory, without passing through the processor. Once the code and data in the hello object file are loaded into memory, the processor begins executing the machine-language instructions in the hello programâ€™s main routine. These instructions copy the bytes in the hello, world\n string from memory to the register file, and from there to the display device, where they are displayed on the screen. CachesAn important lesson from this simple example is that a system spends a lot of time moving information from one place to another. From a programmerâ€™s perspective, muchof this copying is overhead that slows down the â€œreal workâ€ of the program. Because of physical laws, larger storage devices are slower than smaller storage devices. Speed that processor read from: register &gt; memory &gt; disk. It is easier and cheaper to make processors run faster than it is to make main memory run faster. To deal with the processor-memory gap, system designers include smallerfaster storage devices called cache memories (or simply caches) that serve as temporary staging areas for information that the processor is likely to need in the near future. The L1 and L2 caches are implemented with a hardware technology known as static random access memory (SRAM). Newer and more powerful systems even have three levels of cache: L1, L2, and L3. By setting up caches to hold data that is likely to be accessed often, we can perform most memory operations using the fast caches. Storage Devices Form a Hierarchy Operating systemThe operating system has two primary purposes: (1) to protect the hardware from misuse by runaway applications, and (2) to provide applications with simple and uniform mechanisms for manipulating complicated and often wildly different low-level hardware devices. Think of the operating system as a layer of software interposed between the application program and the hardware, with fundamental abstractions: processes, virtual memory, and files. Processè¿›ç¨‹A process is the operating systemâ€™s abstraction for a running program. Multiple processes can run concurrently on the same system by having the processor switch (context switching) among them, and each process appears to have exclusive use of the hardware. The os keeps track of all the state information that the process needs in order to run. This state, i.e. the context, includes information such as the current values of the PC, the register file, and the contents of main memory. When the operating system decides to transfer control from the current process to some new process, it performs a context switch by saving the context of the current process, restoring the context of the new process, and then passing control to the new process. The new process picks up exactly where it left off. Virtual MemoryVirtual memory is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its virtual address space. In Linux, the topmost region of the address space is reserved for code and data in the operating system that is common to all processes. The lower region of the address space holds the code and data defined by the userâ€™s process.Starting with the lowest addresses and working our way up: Program code and data: Fixed in size once the process begins running. The code and data areas are initialized directly from the contents of an executable object file, in our case the hello executable. Run-time heap: expands and contracts dynamically at run time as a result of calls to C standard library routines such as malloc and free. Shared libraries: holds the code and data for shared libraries such as the C standard library and the math library. User stack: the compiler uses to implement function calls. Each time we call a function, the stack grows. Each time we return from a function, it contracts. Kernel virtual memory: The kernel is the part of the operating system that is always resident in memory. Application programs are not allowed to read or write the contents of the top region of the address space (which is reserved for the kernel) or to directly call functions defined in the kernel code. Threadçº¿ç¨‹In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system. In most cases a thread is a component of a process. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources. Threads are an increasingly important programming model because of the requirement for concurrency in network servers, because it is easier to share data between multiple threads than between multiple processes, and because threads are typically more efficient than processes. FilesA file is a sequence of bytes. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as Unix I/O. Concurrency and ParallelismConcurrency: general concept of a system with multiple, simultaneous activities.Parallelism: the use of concurrency to make a system run faster. Parallelism could be achieved in different levels of abstraction in computer system. There are three common levels (from the highest to the lowest level in the system hierarchy): Thread-Level ConcurrencyBuilding on the process abstraction, we are able to devise systems where multiple programs execute at the same time, leading to concurrency. With threads, we can even have multiple control flows executing within a single process. When we construct a system consisting of multiple processors all under the control of a single operating system kernel, we have a multiprocessor system Multi-core processors: Several CPUs (referred to as â€œcoresâ€) integrated onto a single integrated-circuit chip. Hyperthreading: Sometimes called simultaneous multi-threading, is a technique that allows a single CPU to execute multiple flows of control. instruction-level parallelismAt a much lower level of abstraction, modern processors can execute multiple instructions at one time. Single-Instruction, Multiple-Data (SIMD) ParallelismAt the lowest level, special hardware that allows a single instruction to cause multiple operations to be performed in parallel. Memory, Data, &amp; Addressingåè¿›åˆ¶ï¼Œ2è¿›åˆ¶ï¼Œ16è¿›åˆ¶: A single byte consists of 8 bits. äºŒè¿›åˆ¶ value ranges from 000000002 to 111111112, åè¿›åˆ¶ value ranges from 010 to 25510 äºŒè¿›åˆ¶è¡¨ç¤ºæ³•è¿‡äºŽå†—é•¿ï¼Œè€Œä½¿ç”¨åè¿›åˆ¶è¡¨ç¤ºæ³•ï¼Œä¸Žbitsè¿›è¡Œæ¨¡å¼è½¬æ¢éžå¸¸ç¹çã€‚ åå…­è¿›åˆ¶ï¼Œhexadecimal numbers: Hexadecimal (or simply â€œhexâ€) uses digits â€˜0â€™ through â€˜9â€™ along with characters â€˜Aâ€™ through â€˜Fâ€™ to represent 16 possible values. Values range from 0016 to FF16. å†…å­˜ï¼š A machine-level program views memory as a very large array of bytes, referred to as virtual memory. Every byte of memory is identified by a unique number, known as its address. The set of all possible addresses is known as the virtual address space - è¿›ç¨‹å¯ç”¨çš„è™šæ‹Ÿåœ°å€èŒƒå›´ç§°ä¸ºè¯¥è¿›ç¨‹çš„â€œè™šæ‹Ÿåœ°å€ç©ºé—´â€ã€‚ è¿™ä¸ªè™šæ‹Ÿåœ°å€ç©ºé—´åªæ˜¯ä¸€ä¸ªå‘ˆçŽ°ç»™æœºå™¨çº§ç¨‹åºçš„è™šæ‹Ÿæ¦‚å¿µã€‚å®žé™…çš„å®žçŽ°éœ€è¦ç”¨åˆ°éšæœºè®¿é—®å­˜å‚¨å™¨ï¼ˆRAMï¼‰ï¼Œç£ç›˜å­˜å‚¨ï¼Œç‰¹æ®Šçš„ç¡¬ä»¶å’Œæ“ä½œç³»ç»Ÿè½¯ä»¶çš„ç»„åˆæ¥æž„å»ºç›¸å¯¹äºŽç¨‹åºè€Œè¨€çš„å•ç‰‡å­—èŠ‚æ•°ç»„ã€‚ Address and Pointersåœ°å€æ˜¯å†…å­˜çš„ä½ç½®ï¼ŒæŒ‡é’ˆæ˜¯ä¸€ç§åŒ…å«åœ°å€çš„æ•°æ®å¯¹è±¡ã€‚ Byte ordering: Endianness little endian - where the least significant byte comes first, followed by most Intel-compatible machines. big endian - where the most significant byte comes first, followed by most machines from IBM and Sun Microsystems Many recent microprocessors are bi-endian, meaning that they can be configured to operate as either little- or big-endian machines. Integer and floating point numbersæŠŠå¤šä¸ªbitsç»„åˆèµ·æ¥ï¼Œé€šè¿‡è§£ç ï¼Œå¯ä»¥è¡¨è¾¾æœ‰é™é›†åˆå†…çš„æ‰€æœ‰å…ƒç´ ã€‚æ¯”å¦‚äºŒè¿›åˆ¶æ•°å­—ç³»ç»Ÿå¯ä»¥è¡¨ç¤ºæ­£æ•´æ•°ã€‚ Three most important representations of numbers. Unsigned encodingsï¼šbased on traditional binary notation, representing numbers greater than or equal to 0. Twoâ€™s-complement encodings: the most common way to represent signed integers, that is, numbers that may be either positive or negative. Floating-point encodings: base-two version of scientific notation forrepresenting real numbers. CMethods Naming data types with typedef: Cçš„typedefå£°æ˜Žç”¨äºŽç»™æ•°æ®ç±»åž‹å‘½åã€‚è¿™å¯¹æé«˜ä»£ç å¯è¯»æ€§æœ‰å¾ˆå¤§çš„å¸®åŠ©ï¼Œå› ä¸ºæ·±å±‚åµŒå¥—ç±»åž‹å£°æ˜Žå¯èƒ½éš¾ä»¥è§£è¯»ã€‚ 12typedef int *int_pointer;int_pointer ip; ç­‰åŒäºŽint *ip; Formatted printing with printf(fprintf and sprintf): provides a way to print informationwith considerable control over the formatting details. The first argument is a format string. Each character sequence starting with â€˜%â€™ indicates how to format the next argument. %d - è¾“å‡ºåè¿›åˆ¶æ•´æ•°, %f - æµ®ç‚¹æ•°, %c - å­—ç¬¦ while any remaining arguments are values to be printed. sizeof(T) returns the number of bytes required to store an object of type T void *malloc(size_t size)åˆ†é…è¯·æ±‚çš„å†…å­˜(size in bytes)å¹¶è¿”å›žä¸€ä¸ªæŒ‡å‘å®ƒçš„æŒ‡é’ˆ(å¦‚æžœè¯·æ±‚å¤±è´¥ï¼Œåˆ™è¿”å›žNULL)ã€‚ Addresses and pointer in CæŒ‡é’ˆæ˜¯Cçš„æ ¸å¿ƒåŠŸèƒ½ï¼Œå¯ä»¥å¼•ç”¨æ•°æ®ç»“æž„å…ƒç´ ï¼ˆåŒ…æ‹¬æ•°ç»„ï¼‰ã€‚å°±åƒå˜é‡ä¸€æ ·ï¼ŒæŒ‡é’ˆæœ‰ä¸¤ä¸ªç»„æˆéƒ¨åˆ†ï¼šå€¼å’Œç±»åž‹ã€‚è¯¥å€¼æŒ‡ç¤ºæŸä¸ªå¯¹è±¡çš„ä½ç½®ï¼Œè€Œå…¶ç±»åž‹æŒ‡ç¤ºè¯¥ä½ç½®å¤„å­˜å‚¨ä»€ä¹ˆç±»åž‹çš„å¯¹è±¡ï¼ˆä¾‹å¦‚ï¼Œæ•´æ•°æˆ–æµ®ç‚¹æ•°ï¼‰ã€‚ &amp; - â€œaddress ofâ€, return a pointer; Variable declarationsï¼š int x, find location in memory in which to store integer. Pointer declarations use *: int *pointer, declares a variable pointer that is a pointer pointing to an object of type integer. Assignment to a pointer: pointer = &amp;x, assigns pointer to point to the address where x is stored. To use the value pointed to by a pointer, use *: if pointer = &amp;x, then x = *pointer +1 is the same as x = x + 1 å‡å¦‚xæ˜¯ä¸€ä¸ªå¯¹è±¡, é‚£ä¹ˆ*(&amp;x)=*&amp;x = x Pointers and arraysCé€šè¿‡æ•°ç»„å°†æ ‡é‡æ•°æ®èšåˆä¸ºæ›´å¤§çš„æ•°æ®ç±»åž‹ã€‚In C, we can dereference a pointer with array notation, and we can reference array elements with pointer notation.Cæœ‰ä¸€ä¸ªä¸å¸¸è§çš„ç‰¹æ€§, å°±æ˜¯æˆ‘ä»¬å¯ä»¥ç”ŸæˆæŒ‡å‘æ•°ç»„å†…çš„å…ƒç´ çš„æŒ‡é’ˆï¼Œå¹¶ä½¿ç”¨è¿™äº›æŒ‡é’ˆæ¥æ‰§è¡Œç®—æœ¯è¿ç®—ã€‚1T A[N]; é¦–å…ˆï¼Œå®ƒåœ¨å†…å­˜ä¸­åˆ†é…ä¸€ä¸ªL*Nå¤§å°çš„è¿žç»­åŒºåŸŸ, å…¶ä¸­Læ˜¯æ•°æ®ç±»åž‹Tçš„å¤§å°ï¼ˆä»¥bytesä¸ºå•ä½ï¼‰. æ•°ç»„çš„å…ƒç´ å¯ä»¥ä½¿ç”¨ 0 ~ N-1 ä¹‹é—´çš„æ•´æ•°ç´¢å¼•æ¥è®¿é—® A[i]; å…¶æ¬¡ï¼Œå®ƒå¼•å…¥äº†ä¸€ä¸ªæ ‡è¯†ç¬¦Aï¼Œå¯ä»¥ä½œä¸ºæŒ‡å‘æ•°ç»„å¼€å¤´çš„æŒ‡é’ˆ; åœ¨æŒ‡é’ˆä¸Šè¿›è¡Œç®—æœ¯è¿ç®—æ—¶ï¼Œå…¶å®žé™…çš„ç´¢å¼•å€¼ä¼šæ ¹æ®æŒ‡é’ˆå¼•ç”¨çš„æ•°æ®ç±»åž‹çš„å¤§å°è¿›è¡Œç¼©æ”¾, å³å‡è®¾Açš„å€¼æ˜¯xa, é‚£ä¹ˆA+içš„å€¼å°±æ˜¯xa + L * i, A[i] = *(A+i); å…¶ä»–#define æŒ‡ä»¤å…è®¸åœ¨æºä»£ç ä¸­å®šä¹‰å® macroã€‚è¿™äº›å®å®šä¹‰å…è®¸åœ¨æ•´ä¸ªä»£ç ä¸­å£°æ˜Žå¸¸é‡å€¼ã€‚ å®å®šä¹‰ä¸æ˜¯å˜é‡ï¼Œä¸èƒ½åƒå˜é‡é‚£æ ·é€šè¿‡ç¨‹åºä»£ç è¿›è¡Œæ›´æ”¹ã€‚åˆ›å»ºè¡¨ç¤ºæ•°å­—ï¼Œå­—ç¬¦ä¸²æˆ–è¡¨è¾¾å¼çš„å¸¸é‡æ—¶ï¼Œé€šå¸¸ä½¿ç”¨æ­¤è¯­æ³•ã€‚ å®šä¹‰å¸¸æ•°ï¼š#define CNAME value or #define CNAME (expression)ã€‚CNAMEæ˜¯å¸¸æ•°çš„åç§°ã€‚å¤§å¤šæ•°Cç¨‹åºå‘˜ç”¨å¤§å†™å­—æ¯æ¥å®šä¹‰å¸¸é‡åï¼Œä½†è¿™ä¸æ˜¯Cè¯­è¨€çš„è¦æ±‚ã€‚expressionå°±æ˜¯è¢«åˆ†é…ç»™å¸¸é‡çš„è¡¨è¾¾å¼ã€‚å¦‚æžœè¡¨è¾¾å¼åŒ…å«è¿ç®—ç¬¦ï¼Œåˆ™è¯¥è¡¨è¾¾å¼å¿…é¡»æ‹¬åœ¨æ‹¬å·å†…ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 10 | æ•°æ®ç»“æž„ - LinkedList è¿˜æ˜¯ ArrayList]]></title>
    <url>%2Fjava-10-data-structures-which-list%2F</url>
    <content type="text"><![CDATA[Java æä¾›äº† ArrayList, ArrayDeque å’Œ LinkedList å‡ ä¸ªAPI. é˜Ÿåˆ— queue, é€šä¿—çš„å«ä¹‰, å°±æ˜¯ä¸èƒ½æ’é˜Ÿ, åªèƒ½åœ¨æœ«å°¾æ’å…¥. åŒç«¯é˜Ÿåˆ— Double Ended Queue (Deque) æ˜¯å…·æœ‰åŠ¨æ€å¤§å°çš„åºåˆ—å®¹å™¨ï¼Œå¯ä»¥åœ¨ä¸¤ç«¯ï¼ˆå‰ç«¯æˆ–åŽç«¯ï¼‰æ‰©å±•æˆ–æ”¶ç¼©â€“http://www.cplusplus.com/reference/deque/deque/ CS61bçš„project 1aéœ€è¦å®žçŽ°ä¸¤ç§åŒç«¯é˜Ÿåˆ—ï¼ˆarray based å’Œ linkedklist basedï¼‰. ä¸åŒçš„API, åœ¨è€ƒè™‘ä»€ä¹ˆæ—¶å€™åº”è¯¥ç”¨å“ªä¸ªæ—¶, æˆ‘ä»¬éœ€è¦è€ƒè™‘å®ƒä»¬çš„æ€§èƒ½å·®å¼‚: æœç´¢/å®šä½ï¼šä¸ŽLinkedListç›¸æ¯”ï¼ŒArrayListæœç´¢æ›´å¿«ã€‚ ArrayListçš„get(int index)æ€§èƒ½æ˜¯O(1)çš„ï¼Œè€ŒLinkedListçš„æ€§èƒ½æ˜¯O(n)ã€‚å› ä¸ºArrayListåŸºäºŽarrayæ•°æ®ç»“æž„ï¼Œå¯ä»¥ç›´æŽ¥ç”¨ array index å®šä½å…ƒç´ ã€‚ åˆ é™¤/æ’å…¥ï¼šLinkedList æ“ä½œæ€§èƒ½æ˜¯O(1)ï¼Œè€ŒArrayListçš„æ€§èƒ½ä»ŽO(n)ï¼ˆåˆ é™¤/æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰åˆ°O(n)ï¼ˆæœ€åŽä¸€ä¸ªå…ƒç´ ï¼‰éƒ½æœ‰å¯èƒ½ã€‚å› ä¸ºLinkedListçš„æ¯ä¸ªå…ƒç´ éƒ½åŒ…å«ä¸¤ä¸ªæŒ‡å‘å…¶ç›¸é‚»å‰åŽå…ƒç´ çš„æŒ‡é’ˆï¼ˆåœ°å€ï¼‰ï¼Œå› æ­¤ä»…éœ€è¦æ”¹å˜ï¼Œè¢«åˆ èŠ‚ç‚¹çš„prevå’ŒnextæŒ‡é’ˆä½ç½®ã€‚è€Œåœ¨ArrayListä¸­ï¼Œéœ€è¦ç§»åŠ¨å‰©ä½™å…ƒç´ ï¼Œæ¥é‡æ–°å¡«å……arrayç©ºé—´ã€‚ å†…å­˜å¼€é”€ï¼šLinkedListçš„æ¯ä¸ªå…ƒç´ éƒ½æœ‰æ›´å¤šçš„å†…å­˜å¼€é”€(é¢å¤–çš„æŒ‡é’ˆ), è€ŒArrayListsæ²¡æœ‰è¿™ä¸ªå¼€é”€ã€‚ä½†æ˜¯ï¼ŒArrayListséœ€è¦å ç”¨åˆå§‹å®¹é‡ã€‚ä¸€èˆ¬ArrayListçš„é»˜è®¤åˆå§‹å®¹é‡éžå¸¸å°ï¼ˆJava 1.4 - 1.8ä½¿ç”¨10ï¼‰ã€‚ä½†æ˜¯ï¼Œå¾€ArrayListsæ·»åŠ å…ƒç´ æ—¶ï¼Œ å®ƒå¯èƒ½ä¼šé€‚å½“åœ°å¢žå¤§å®¹é‡ï¼Œæ‰€ä»¥å¦‚æžœæ·»åŠ äº†å¾ˆå¤šå…ƒç´ ï¼Œåˆ™å¿…é¡»ä¸æ–­è°ƒæ•´æ•°ç»„çš„å¤§å°ï¼Œé‚£æ ·ä¹Ÿå¯èƒ½ä¼šå¯¼è‡´å…ƒç´ é¢‘ç¹æŒªåŠ¨ä½ç½®ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼š å¦‚æžœåœ¨åº”ç”¨ä¸­éœ€è¦é¢‘ç¹æ’å…¥å’Œåˆ é™¤ï¼Œé‚£ä¹ˆé€‰æ‹©LinkedListã€‚ å‡å¦‚ä¸€å¼€å§‹ï¼Œå°±çŸ¥é“åŽé¢è¦æ·»åŠ å¤§é‡å…ƒç´ ï¼Œé‚£å°±ä½¿ç”¨è¾ƒé«˜çš„åˆå§‹å®¹é‡æ¥æž„é€ ArrayListã€‚ å¤§éƒ¨åˆ†ç”¨ä¾‹ä¸­, ç›¸æ¯”LinkedList, äººä»¬æ›´åçˆ±ArrayListä»¥åŠArrayDequeã€‚å¦‚æžœä½ ä¸ç¡®å®šåº”è¯¥é€‰å“ªä¸ª, é‚£ä¹ˆå°±ç›´æŽ¥è€ƒè™‘ArrayListå§(å‚è€ƒ https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist).]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 09 | æ•°æ®ç»“æž„ - åŒå‘é“¾è¡¨ Doubly Linked List]]></title>
    <url>%2Fjava-09-data-structures-doubly-linked-list%2F</url>
    <content type="text"><![CDATA[åŒå‘é“¾è¡¨Doubly Linked List å‰é¢ä»‹ç»è¿‡çš„å•å‘é“¾è¡¨æœ‰å‡ ä¸ªç¼ºç‚¹. ç¬¬ä¸€ä¸ªå°±æ˜¯å®ƒçš„addLastæ“ä½œéžå¸¸æ…¢ã€‚å•å‘é“¾è¡¨åªæœ‰ä¸€ä¸ªå˜é‡ä¿å­˜åˆ—è¡¨å¤´çš„åœ°å€, ä»¥åŠæ¯ä¸ªèŠ‚ç‚¹å¯¹åŽé¢èŠ‚ç‚¹çš„å•å‘å¼•ç”¨(é“¾æŽ¥). å¯¹äºŽå¾ˆé•¿çš„åˆ—è¡¨ï¼ŒaddLastæ–¹æ³•å¿…é¡»éåŽ†æ•´ä¸ªåˆ—è¡¨, ç›´åˆ°æ‰¾åˆ°åˆ—è¡¨æœ«å°¾æ‰èƒ½æ‰§è¡Œæ’å…¥æ“ä½œ.æœ€ç›´è§‚çš„ä¼˜åŒ–æ–¹æ¡ˆå°±æ˜¯åŠ ä¸ªâ€™è½¦å°¾â€™ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›´æŽ¥é€šè¿‡last.nextå¼•ç”¨æœ«å°¾ä½ç½®. ä¸è¿‡å¦ä¸€ä¸ªé—®é¢˜å¹¶æ²¡æœ‰è§£å†³, å°±æ˜¯åˆ é™¤åˆ—è¡¨æœ€åŽä¸€é¡¹removeLastè¿™ä¸ªæ“ä½œè¿˜æ˜¯å¾ˆæ…¢ã€‚å› ä¸ºåœ¨ç›®å‰çš„ç»“æž„è®¾è®¡ä¸‹, æˆ‘ä»¬éœ€è¦å…ˆæ‰¾åˆ°å€’æ•°ç¬¬äºŒé¡¹ï¼Œç„¶åŽå°†å…¶ä¸‹ä¸€ä¸ªæŒ‡é’ˆè®¾ç½®ä¸ºnullã€‚è€Œè¦æ‰¾åˆ°å€’æ•°ç¬¬äºŒèŠ‚ç‚¹, æˆ‘ä»¬å°±å¾—å…ˆæ‰¾åˆ°å€’æ•°ç¬¬ä¸‰ä¸ªèŠ‚ç‚¹â€¦â€¦ ä»¥æ­¤ç±»æŽ¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºŽåˆ é™¤æœ«å°¾çš„æ“ä½œï¼Œè¿˜æ˜¯è¦å‡ ä¹ŽéåŽ†æ•´ä¸ªåˆ—è¡¨ã€‚ åæ–¹å‘çš„é“¾æŽ¥åŸºäºŽå‰é¢å•å‘é“¾è¡¨æž„å»ºåŒå‘é“¾è¡¨, ä¸€ä¸ªæ¯”è¾ƒæœ‰æ•ˆçš„æ–¹æ³•æ˜¯é¢å¤–ä¸ºæ¯ä¸ªèŠ‚ç‚¹æ·»åŠ ä¸€ä¸ªæŒ‡å‘å‰é¢èŠ‚ç‚¹çš„é“¾æŽ¥ - æŒ‡é’ˆ.12345public class OneNode &#123; public OneNode prev; //æŒ‡å‘å‰ public int item; public OneNode next; //æŒ‡å‘åŽ&#125; å¢žåŠ è¿™äº›é¢å¤–çš„æŒ‡é’ˆä¼šå¯¼è‡´é¢å¤–çš„ä»£ç å¤æ‚åº¦, ä»¥åŠé¢å¤–çš„å†…å­˜å¼€é”€, è¿™å°±æ˜¯è¿½æ±‚æ—¶é—´æ•ˆçŽ‡çš„ä»£ä»·. Sentinel ä¸Žå°¾èŠ‚ç‚¹åŒå‘é“¾è¡¨çš„ä¸€ä¸ªè®¾è®¡åˆè¡·ï¼Œå°±æ˜¯ä¸ºäº†è§£å†³å•å‘é“¾è¡¨é’ˆå¯¹åˆ—è¡¨æœ«å°¾ä½ç½®çš„æ“ä½œæ•ˆçŽ‡ä¸é«˜çš„é—®é¢˜ï¼Œé™¤äº†sentinelå’Œåæ–¹å‘çš„é“¾æŽ¥è¿˜ä¸å¤Ÿï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆæŒ‡é’ˆï¼‰èƒ½å¤Ÿç›´æŽ¥å¸®æˆ‘ä»¬å®šä½åˆ°åˆ—è¡¨æœ«ç«¯ã€‚å¯ä»¥è€ƒè™‘æ·»åŠ ä¸€ä¸ªçš„å°¾èŠ‚ç‚¹last è¿™æ ·çš„åˆ—è¡¨å°±å¯ä»¥æ”¯æŒO(1)å¤æ‚åº¦çš„addLast,getLast å’Œ removeLastæ“ä½œäº†ã€‚ å¾ªçŽ¯åŒç«¯é˜Ÿåˆ—Circular double ended queue ä¸Šé¢çš„å°¾èŠ‚ç‚¹è®¾è®¡è™½ç„¶æ²¡ä»€ä¹ˆé”™è¯¯ï¼Œä½†æœ‰ç‚¹ç‘•ç–µï¼šæœ€åŽä¸€ä¸ªå°¾èŠ‚ç‚¹æŒ‡é’ˆæœ‰æ—¶æŒ‡å‘å‰å“¨èŠ‚ç‚¹ï¼Œæœ‰æ—¶æŒ‡å‘ä¸€ä¸ªçœŸæ­£çš„èŠ‚ç‚¹ã€‚æ›´å¥½çš„æ–¹æ³•æ˜¯ä½¿åŒå‘é“¾è¡¨é¦–å°¾ç›¸è¿ž, æž„æˆä¸€ä¸ªå¾ªçŽ¯ï¼Œå³å‰åŽèŠ‚ç‚¹å…±äº«å”¯ä¸€çš„ä¸€ä¸ªå‰å“¨èŠ‚ç‚¹ã€‚ è¿™æ ·çš„è®¾è®¡ç›¸å¯¹æ›´æ•´æ´ï¼Œæ›´ç¾Žè§‚(ä¸»è§‚ä¸Šçš„), sentinelçš„prevå°±æŒ‡å‘åˆ—è¡¨æœ€åŽä¸€ä¸ªèŠ‚ç‚¹, sentinelçš„nextæŒ‡å‘åˆ—è¡¨ç¬¬ä¸€ä¸ªèŠ‚ç‚¹.12345678910111213public class LinkedListDeque&lt;GType&gt; &#123; private class OneNode &#123; public OneNode prev; public GType item; public OneNode next; public OneNode(OneNode p, GType i, OneNode n) &#123; prev = p; item = i; next = n; &#125; &#125;&#125; Sentinelâ€™s forward link always points to the last element.Sentinelâ€™s backward link always points to the first element. ç„¶åŽä¿®æ”¹æž„é€ å‡½æ•°:123456789101112131415/** Creates an empty deque. */public LinkedListDeque()&#123; sentinel = new OneNode(null,null, null); sentinel.prev = sentinel; sentinel.next = sentinel; size = 0;&#125;/** Creates a deque with x */public LinkedListDeque(GType x)&#123; sentinel = new OneNode(null, null, null); sentinel.next = new OneNode(sentinel, x, sentinel); sentinel.prev = sentinel.next; size = 1;&#125; å¦‚æžœåˆå§‹åŒ–çš„æ˜¯ç©ºåˆ—è¡¨, å…¶å®žå°±æ˜¯ä¸€ä¸ªè‡ªå·±æŒ‡å‘è‡ªå·±çš„sentinelèŠ‚ç‚¹. å¦‚æžœæ˜¯éžç©ºåˆ—è¡¨, é‚£ä¹ˆsentinelèŠ‚ç‚¹å’ŒçœŸå®žçš„èŠ‚ç‚¹å°±æž„æˆäº†ä¸€ä¸ªæœ€ç®€å•çš„äºŒå…ƒå¾ªçŽ¯ä½“. é’ˆå¯¹åˆ—è¡¨æœ«å°¾ä½ç½®çš„æ“ä½œåŒç«¯é“¾è¡¨ç»“æž„ä¼˜é›…ï¼Œè™½ç„¶æŸäº›æ“ä½œå¦‚addFirstç­‰ç¼–ç å¤æ‚åº¦ä¼šæé«˜, ä½†ä¸å½±å“é€Ÿåº¦. æ›´é‡è¦çš„æ˜¯, ç›¸æ¯”å•å‘é“¾è¡¨, å®ƒåè€Œä½¿å¾—addLast, moveLastç­‰æ–¹æ³•çš„ä»£ç å®žçŽ°å˜å¾—ç®€å•äº†, è€Œä¸”è¿˜è¿›ä¸€æ­¥æå‡äº†è¿è¡Œé€Ÿåº¦(ä»ŽO(n)åˆ°O(c)).12345678910111213141516171819202122/** Adds an item to the back of the Deque - O(c) */public void addLast(GType x)&#123; OneNode oldBackNode = sentinel.prev; OneNode newNode = new OneNode(oldBackNode, x, sentinel); sentinel.prev = newNode; oldBackNode.next = newNode; size += 1;&#125;/** Removes and returns the item at the front of the Deque. * If no such item exists, returns null.O(c). */public GType removeFirst()&#123; if (isEmpty())&#123; return null; &#125; OneNode oldFrontNode = sentinel.next; sentinel.next = oldFrontNode.next; oldFrontNode.next.prev = sentinel; size -= 1; return oldFrontNode.item;&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 08 | æ•°æ®ç»“æž„ - å•å‘é“¾è¡¨ Singly Linked List]]></title>
    <url>%2Fjava-08-data-structures-singly-linked-list%2F</url>
    <content type="text"><![CDATA[é“¾è¡¨Linked List å‰é¢æœ‰ä»‹ç»ä»¥arrayä¸ºåŸºç¡€æ­å»ºçš„åˆ—è¡¨ï¼Œæ”¯æŒè‡ªåŠ¨æ‰©å®¹, å„ç§æ’å…¥ï¼Œåˆ é™¤é€Ÿåº¦éƒ½å¾ˆå¿«. è¿™é‡Œå†ä»‹ç»å¦ä¸€ç§æ–¹æ¡ˆ, é“¾è¡¨, ä¹Ÿå¯ä»¥å®žçŽ°åˆ—è¡¨è‡ªåŠ¨æ‰©å®¹. å¸¦é“¾æŽ¥çš„èŠ‚ç‚¹é“¾è¡¨çš„æ ¸å¿ƒç»„æˆæ˜¯å¸¦é“¾æŽ¥çš„èŠ‚ç‚¹, æ¯ä¸ªèŠ‚ç‚¹å°±åƒç«è½¦è½¦åŽ¢, æœ‰é’©å­è¿žæŽ¥ä¸‹ä¸€èŠ‚è½¦åŽ¢.ä»¥intèŠ‚ç‚¹ä¸ºä¾‹:123456789public class IntNode &#123; public int item; public IntNode next; public IntNode(int i, IntNode n) &#123; item = i; next = n; &#125;&#125; nextå°±æ˜¯è¿™ä¸ªé“¾æŽ¥, æ¯ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯å…¶ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„next. ä½¿ç”¨åµŒå¥—ç±»è¿™ä¸ªèŠ‚ç‚¹ä½œä¸ºä¸€ä¸ªç›¸å¯¹ç‹¬ç«‹çš„æ•°æ®ç»“æž„, æˆ‘ä»¬æ›´å¸Œæœ›è®©ä»–å•ç‹¬ä½œä¸ºä¸€ä¸ªç±»æ¥ç»´æŠ¤. å†å¦å¤–åˆ›å»ºä¸€ä¸ªåä¸ºLinkedListçš„classä¸Žç”¨æˆ·è¿›è¡Œäº¤äº’. è¿™æ ·è¿˜æœ‰å¦ä¸€ä¸ªå¥½å¤„å°±æ˜¯æä¾›ä¸€ä¸ªå‘½åä¸ºLinkedListçš„ç±»ç»™ç”¨æˆ·äº¤äº’ï¼Œç”¨æˆ·æ›´ç›´è§‚åœ°çŸ¥é“è‡ªå·±æ˜¯åœ¨è°ƒç”¨é“¾è¡¨ã€‚å¦‚æžœç›´æŽ¥ä¸Žnodeç±»äº¤äº’ï¼Œç”¨æˆ·å¯èƒ½ä¼šå›°æ‰°. ä½†åŒæ—¶è€ƒè™‘åˆ°è¿™ä¸ªnodeç±»åªæœ‰LinkedListä¼šè°ƒç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠnodeç±»åµŒå¥—è¿›LinkedListä¸­ã€‚1234567891011121314151617181920public class LinkedList&lt;XXX&gt; &#123; private class OneNode &#123; public XXX item; public OneNode next; public OneNode(XXX i, OneNode n) &#123; item = i; next = n; &#125; &#125; private OneNode first; private int size; public LinkedList(XXX x) &#123; first = new OneNode(x, null); size = 1; &#125; //ä¸‹é¢æ˜¯å„ç§æ–¹æ³•...&#125; ä»¥ä¸Šå®šä¹‰ä½¿ç”¨äº†æ³›åž‹ã€‚å£°æ˜ŽOneNodeå®žä¾‹firstä¸ºç§æœ‰å˜é‡, æ˜¯ä¸ºäº†é˜²æ­¢ç”¨æˆ·é”™è¯¯åœ°æ‘†å¼„é“¾æŽ¥æŒ‡å‘ï¼Œprivateå’Œpublicçš„ä½¿ç”¨å‚è€ƒ. è¡¥å……å¿…è¦çš„å®žä¾‹æ–¹æ³•æ’å…¥çš„æ“ä½œæ ¸å¿ƒæ˜¯æ”¹å˜é“¾æŽ¥æŒ‡å‘ï¼Œ æ¯”å¦‚åŽŸæ¥æ˜¯A-&gt;B-&gt;D, è¦æ’å…¥C, åˆ™æŠŠC.nextæŒ‡å‘D,ç„¶åŽæŠŠB.nextæ”¹ä¸ºæŒ‡å‘C, å˜ä¸ºA-&gt;B-&gt;C-&gt;D1234567891011121314151617181920212223242526272829303132333435363738394041public class LinkedList&lt;XXX&gt; &#123; private class OneNode &#123; ... &#125; private OneNode first; private int size; public LinkedList(XXX x) &#123; ... &#125; /** åœ¨åˆ—è¡¨å¼€å¤´æ’å…¥ x. */ public void addFirst(XXX x) &#123; first = new OneNode(x, first); size += 1; &#125; /** è¿”å›žåˆ—è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ . */ public XXX getFirst() &#123; return first.item; &#125; /** åœ¨åˆ—è¡¨æœ«å°¾æ’å…¥ x. */ public void addLast(XXX x) &#123; size += 1; OneNode p = first; /* æŠŠ p å½“åšæŒ‡é’ˆé¡ºè—¤æ‘¸ç“œä¸€ç›´æŒªåˆ°åˆ—è¡¨æœ«å°¾. */ while (p.next != null) &#123; p = p.next; &#125; p.next = new OneNode(x, null); &#125; /** åˆ é™¤åˆ—è¡¨æœ«å°¾çš„å…ƒç´ . */ public void removeLast()&#123; //è‡ªè¡Œè¡¥å……... &#125; public int size() &#123; return size; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æžœç”¨æˆ·ä¸å°å¿ƒæŠŠæŸèŠ‚ç‚¹xæŒ‡å›žè‡ªå·±x.next=x,é‚£å°±ä¼šè¿›å…¥æ­»å¾ªçŽ¯ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æŠŠOnoNodeå®žä¾‹firstå£°æ˜Žä¸ºç§æœ‰å˜é‡å·²æä¾›å¿…è¦çš„ä¿æŠ¤ã€‚ è¶…è½½Overloading å¦‚æžœæƒ³åˆå§‹åŒ–ä¸€ä¸ªç©ºåˆ—è¡¨, å¯ä»¥:12345/** æž„é€ ä¸€ä¸ªç©ºåˆ—è¡¨. */public LinkedList() &#123; fist = null; size = 0;&#125; å³ä½¿åŽŸæ¥å·²ç»æœ‰ä¸€ä¸ªå¸¦å‚æ•°xçš„æž„é€ å™¨äº†, è¿™é‡Œå†åŠ ä¸€ä¸ªåŒåæž„é€ å™¨ä¹Ÿæ²¡é—®é¢˜. å› ä¸ºJavaå…è®¸æœ‰ä¸åŒå‚æ•°çš„æ–¹æ³•é‡å, å³è¶…è½½ overloading. ç¨‹åºä¸å˜æ¡ä»¶Invariants ä¸Šé¢è¶…è½½äº†ä¸€ä¸ªåˆå§‹åŒ–ç©ºåˆ—è¡¨çš„æž„é€ å™¨, åŠ å…¥åˆå§‹åŒ–ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œç„¶åŽç›´æŽ¥è°ƒç”¨addLastï¼Œç¨‹åºä¼šæŠ¥é”™, å› ä¸ºnullæ²¡æœ‰next. æœ‰å‡ ç§ä¿®æ”¹æ–¹æ³•, æ¯”å¦‚ç”¨if elseè¿™ç§åŠ ç‰¹ä¾‹çš„æ–¹æ³•. è¿™ä¸ªæ–¹æ¡ˆè™½ç„¶å¯ä»¥èƒ½è§£å†³é—®é¢˜ï¼Œä½†æ˜¯åº”å°½é‡é¿å…åŠ å…¥ç‰¹ä¾‹ä»£ç ã€‚æ¯•ç«Ÿæœ‰ç‰¹ä¾‹å°±æ„å‘³ç€å¢žåŠ äº†å¤æ‚åº¦å’Œé¢å¤–çš„ä»£ç ç‰¹ä¾‹è®°å¿†éœ€æ±‚, è€Œäººè®°å¿†æ˜¯æœ‰é™çš„. ä¸€ä¸ªæ›´ç®€æ´ï¼ˆå°½ç®¡ä¸å¤ªæ˜¾è€Œæ˜“è§ï¼‰çš„è§£å†³æ–¹æ¡ˆæ˜¯ä¿®æ”¹æ•°æ®ç»“æž„æœ¬èº«ï¼Œè®©æ‰€æœ‰LinkedListï¼Œç»´æŠ¤èµ·æ¥éƒ½æ²¡æœ‰å·®åˆ«ï¼Œå³ä½¿æ˜¯ç©ºçš„ã€‚å¦‚æžœæŠŠåˆ—è¡¨æ¯”åšæ‹‰è´§çš„ç«è½¦ï¼Œé‚£ä¹ˆè´§ç‰©å°±æ˜¯åˆ—è¡¨æ‰¿è½½çš„æ•°æ®ã€‚ä¸€åˆ—ç«è½¦å¦‚æžœåªæœ‰è½¦åŽ¢è€Œæ²¡æœ‰è½¦å¤´ï¼ˆæˆ–è€…è½¦å°¾ï¼‰çš„è¯æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œå› ä¸ºæ²¡æœ‰åŠ¨åŠ›ã€‚æ‰€ä»¥ä¸ç®¡ç«è½¦æœ‰æ²¡æœ‰æ‹‰è´§ï¼Œæœ‰è½¦åŽ¢è¿˜æ˜¯æ²¡è½¦åŽ¢ï¼Œè¦ç§°ä¹‹ä¸ºç«è½¦æˆ‘ä»¬è‡³å°‘éœ€è¦ä¸€ä¸ªç«è½¦å¤´ï¼Œé€šè¿‡åˆ›å»ºä¸€ä¸ªç‰¹æ®ŠèŠ‚ç‚¹ - å‰å“¨èŠ‚ç‚¹ sentinelã€‚å‰å“¨èŠ‚ç‚¹å°†ä¿å­˜ä¸€ä¸ªå€¼ï¼Œå…·ä½“æ•°å€¼æˆ‘ä»¬ä¸å…³å¿ƒï¼Œå®ƒåªæ˜¯ä½œä¸ºç«è½¦å¤´ï¼Œä¸è£…è´§ã€‚æ‰€ä»¥æˆ‘ä»¬è¦ä¿®æ”¹LinkedListä¸ºï¼š12345678910111213141516171819202122/* ç¬¬ä¸€ä¸ªå…ƒç´  ï¼ˆå‡å¦‚æœ‰çš„è¯ï¼‰å°±æ˜¯ sentinel.next. */public class LinkedList&lt;XXX&gt; &#123; private class OneNode &#123; //... &#125; private OneNode sentinel; private int size; /** æž„é€ ä¸€ä¸ªç©ºåˆ—è¡¨. */ public LinkedList() &#123; sentinel = new OneNode(null, null); size = 0; &#125; /** æž„é€ ä¸€ä¸ªåˆå§‹å…ƒç´ ä¸ºxçš„åˆ—è¡¨. */ public LinkedList(XXX x) &#123; sentinel = new OneNode(null, null); sentinel.next = new OneNode(x, null); size = 1; &#125;&#125; å¯¹äºŽåƒLinkedListè¿™æ ·ç®€å•çš„æ•°æ®ç»“æž„æ¥è¯´ï¼Œç‰¹ä¾‹ä¸å¤šï¼Œæˆ‘ä»¬ä¹Ÿè®¸å¯ä»¥holdä½, ä¸€æ—¦åŽç»­é‡åˆ°åƒæ ‘treeç­‰æ›´å¤æ‚çš„æ•°æ®ç»“æž„ï¼ŒæŽ§åˆ¶ç‰¹ä¾‹æ•°é‡å°±æ˜¾å¾—æžä¸ºé‡è¦äº†ã€‚æ‰€ä»¥çŽ°åœ¨å°±è¦åŸ¹å…»è‡ªå·±çš„è¿™æ–¹é¢çš„ä¹ æƒ¯ï¼Œä¿æŒç¨‹åºä¸å˜æ¡ä»¶æˆç«‹ã€‚æ‰€è°“ invariants å°±æ˜¯æŒ‡æ•°æ®ç»“æž„ä»»ä½•æƒ…å†µä¸‹éƒ½æ˜¯ä¸ä¼šå‡ºé”™ï¼ˆé™¤éžç¨‹åºæœ‰bugï¼‰. å…·æœ‰å‰å“¨èŠ‚ç‚¹çš„LinkedListè‡³å°‘å…·æœ‰ä»¥ä¸‹ invariantsï¼š åˆ—è¡¨é»˜è®¤å­˜åœ¨å‰å“¨èŠ‚ç‚¹ã€‚ åˆ—è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆå¦‚æžœéžç©ºçš„è¯ï¼‰æ€»æ˜¯åœ¨sentinel.next.itemã€‚ sizeå˜é‡å§‹ç»ˆæ˜¯å·²æ·»åŠ çš„å…ƒç´ æ€»æ•°ã€‚ ä¸å˜æ¡ä»¶ä½¿å¾—ä»£ç çš„æŽ¨æ•²å˜å¾—æ›´åŠ å®¹æ˜“ï¼ŒåŒæ—¶ç»™ç¨‹åºå‘˜æä¾›äº†èƒ½å¤Ÿç¡®ä¿ä»£ç æ­£å¸¸å·¥ä½œçš„å…·ä½“ç›®æ ‡ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash ç›´æŽ¥å¯åŠ¨ sublime æˆ– atom ç­‰ç¼–è¾‘å™¨ä»¥æ‰“å¼€æˆ–æ–°å»ºæ–‡ä»¶]]></title>
    <url>%2FLaunch-editor-in-Gitbash%2F</url>
    <content type="text"><![CDATA[ç¨‹åºå‘˜æˆ–è€…å…¶ä»–éœ€è¦ç å­—å¤šçš„äººï¼Œç»å¸¸è¦ä½¿ç”¨ç¼–è¾‘å™¨å¦‚sublimeã€atom å’Œ Typoraç­‰ã€‚å¦‚æžœæ¯æ¬¡éƒ½è¦ç”¨é¼ æ ‡ç‚¹å‡»æ‰èƒ½ç”¨sublimeæ‰“å¼€æ–‡ä»¶ï¼Œæˆ–è€…åœ¨ç¼–è¾‘å™¨ä¸­æ–°å»ºæ–‡ä»¶ï¼Œé‚£ä¹ˆå°±ä¼šæœ‰ç‚¹éº»çƒ¦ï¼ä½†ä½ å¯ä»¥ç”¨ä¸€å¥å‘½ä»¤è§£å†³ï¼ é…ç½®åœ¨Git Bashä¸­ç”¨å„ç§æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€æ–‡ä»¶æˆ–è€…ç›´æŽ¥æ–°å»ºæ–‡ä»¶ã€‚è¿™é‡Œä»¥atomä¸ºä¾‹ã€‚ å¸¸è§„æ­¥éª¤ æ‰“å¼€Git Bashå¹¶cdåˆ°ä½ çš„ç›®æ ‡æ–‡ä»¶å¤¹, æˆ–è€…ç›´æŽ¥åœ¨ç›®æ ‡æ–‡ä»¶ä¸­å³é”®æ‰“å¼€Git Bash. atom xxx.md å°±ä¼šåœ¨å¼¹å‡ºçš„atomçª—å£ä¸­æ‰“å¼€åä¸ºxxx.mdçš„markdownæ–‡ä»¶, å¦‚æžœæ²¡æœ‰è¿™ä¸ªæ–‡ä»¶, ä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ª. é€‚ç”¨äºŽå…¶ä»–ç±»åž‹æ–‡ä»¶, å¦‚.javaç­‰. å¦‚æžœæƒ³ç”¨sublime, å¯ä»¥ç”¨subl xxx.java, åŒç†notepad++ å¯ä»¥ç”¨ notepad++ xxx.javaç­‰ã€‚ (è‹¥å‡ºçŽ°é”™è¯¯,çœ‹ä¸‹é¢) è‹¥ç³»ç»Ÿæ— æ³•è¯†åˆ«å‘½ä»¤ä¸€èˆ¬ä½¿ç”¨sublimeæˆ–è€…notepad++çš„ç”¨æˆ·, å¯èƒ½ä¼šå‡ºçŽ°error: ç³»ç»Ÿæ— æ³•è¯†åˆ«å‘½ä»¤...ä¹‹ç±»çš„, å¯ä»¥è¿™ä¹ˆè§£å†³: æ–¹æ³•1æ–°å»ºä¸€ä¸ªæ–‡ä»¶å‘½åä¸ºsublï¼ˆæ³¨æ„ä¸èƒ½æœ‰åŽç¼€åï¼‰ï¼Œå†…å®¹ï¼š12#!/bin/sh&quot;D:\Sublime Text 3\sublime_text.exe&quot; $1 &amp; ç¬¬ä¸€è¡ŒæŒ‡æ˜Žè¿™æ˜¯ä¸ª shell è„šæœ¬.ç¬¬äºŒè¡Œçš„å­—ç¬¦ä¸²æ˜¯sublimeçš„å®‰è£…ç›®å½•, ç¤ºä¾‹åªæ˜¯æˆ‘ç”µè„‘çš„ç›®å½•, æ³¨æ„è¿™é‡Œè¦æ”¹ä¸ºä½ è‡ªå·±çš„ç›®å½•,ç¬¬äºŒè¡Œçš„$1 æ˜¯å–çš„å‘½ä»¤ä¹‹åŽè¾“å…¥çš„å‚æ•°ç¬¬äºŒè¡Œçš„&amp;æ˜¯æ­¤å‘½ä»¤åœ¨åŽå°æ‰“å¼€ï¼Œè¿™æ ·sublimeæ‰“å¼€ä¹‹åŽï¼Œå°±ä¸ä¼šé˜»å¡žä½ çš„git bash æ–‡ä»¶ä¿å­˜åˆ° C:\Program Files (x86)\Git\mingW32\bin ç›®å½•ä¸‹(ä½ çš„gitç›®å½•å¯èƒ½ä¸Žæˆ‘çš„ä¸ä¸€æ ·ï¼Œæ³¨æ„æ”¹æˆä½ è‡ªå·±çš„) åŒç†é€‚ç”¨äºŽå…¶ä»–ç¼–è¾‘å™¨ï¼Œæ¯”å¦‚ç”¨chromeæ‰“å¼€.htmlæ–‡ä»¶ç­‰ã€‚å¦‚æžœä¸æƒ³æ¯æ¬¡éƒ½æ–°å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œå¯ä»¥ç”¨ä¸‹é¢çš„æ–¹æ³•2ã€‚ æ–¹æ³•2 æ‰¾åˆ° C:\Users\ä½ çš„è®¡ç®—æœºåç›®å½•ï¼Œå¦‚æžœä½ çš„è®¡ç®—æœºåæ˜¯Administratorï¼Œé‚£ä¹ˆä½ å°±è¦åŽ»C:\Users\Administratorç›®å½•ä¸‹, è¿™é‡Œä¸€èˆ¬å­˜æ”¾ç€windowsç³»ç»Ÿçš„æˆ‘çš„æ–‡æ¡£, æ¡Œé¢ç­‰æ–‡ä»¶å¤¹. åœ¨è¯¥ç›®å½•ä¸‹ç”¨Git Bashè¾“å…¥notepad .bashrc, è¿™ä¼šç”¨windowsè®°äº‹æœ¬æ–°å»ºå¹¶æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶.bashrcï¼Œè¿™ä¸ªæ–‡ä»¶æ²¡æœ‰åç§°åªæœ‰åŽç¼€åã€‚.bashrcé‡Œé¢å¯ä»¥ç»™Git Bashè®¾ç½®å‘½ä»¤çš„åˆ«å, è®¾ç½®è·¯å¾„ç­‰ã€‚ åœ¨.bashrcæ–‡ä»¶åŠ å…¥ä¸‹é¢ä¸€è¡Œæ–‡æœ¬alias notepad++=&quot;/D/Notepad++/notepad++.exe&quot;, è¿™é‡Œä½ éœ€è¦ä¿®æ”¹ä¸ºä½ ç”µè„‘çš„å®‰è£…è·¯å¾„ã€‚aliaså°±æ˜¯åˆ«åçš„æ„æ€ï¼Œå½“æˆ‘ä»¬æ‰§è¡Œnotepad++çš„æ—¶å€™ï¼Œå®žé™…æ‰§è¡Œçš„æ˜¯=åŽé¢çš„è¯­å¥. é‡æ–°æ‰“å¼€Git Bash, è®¾ç½®æ‰èƒ½ç”Ÿæ•ˆï¼Œå¦‚æžœä¸æƒ³å…³æŽ‰åœ¨æ‰“å¼€çš„è¯ï¼Œå¯ä»¥ç›´æŽ¥åœ¨bashä¸‹è¾“å…¥source ~/.bashrcå°±å¯ä»¥ç«‹åˆ»åŠ è½½ä¿®æ”¹åŽçš„è®¾ç½®ï¼Œè®¾ç½®ç«‹å³ç”Ÿæ•ˆã€‚çŽ°åœ¨åœ¨bashä¸‹è¾“å…¥notepad++ test.py, å°±ç›´æŽ¥æ‰“å¼€äº†notepad++å¹¶åˆ›å»ºäº†è¿™ä¸ªå«testçš„Pythonæ–‡ä»¶ã€‚è¿™é‡Œçš„åˆ«åä¸ä¸€å®šéžè¦å–notepad++ï¼Œéšä½ æƒ³å«ä»€ä¹ˆéƒ½è¡Œã€‚ åŒç†ä¹Ÿå¯ä»¥æ‰©å±•åˆ°åˆ«çš„æ–‡æœ¬ç¼–è¾‘å™¨ï¼Œalias atom=&quot;atomçš„è·¯å¾„&quot;, alias sublime=&quot;sublimeçš„è·¯å¾„&quot;ç­‰. æœ€åŽè¿˜è¦æ³¨æ„ä¸€ç‚¹ï¼Œä¸Šé¢æ‰€è¯´çš„è·¯å¾„æœ€å¥½ä¸è¦æœ‰ç©ºæ ¼ï¼Œæ‹¬å·ç­‰ï¼Œå¦åˆ™ä¼šé€ æˆå‘½ä»¤æ— æ•ˆ. .bashrcè¿˜æœ‰å¾ˆå¤šæœ‰ç”¨çš„é…ç½®,å¯ä»¥æ ¹æ®éœ€è¦è¿›è¡Œæ‰©å±•. æ¯”å¦‚å¾ˆå¤šç¨‹åºçŒ¿ä¼šé€‰æ‹©ä¿®æ”¹åˆ é™¤å‘½ä»¤rm(æ­¤å‘½ä»¤ä¸åŠ ä»»ä½•å‚æ•°çš„è¯ï¼Œä¼šç›´æŽ¥åˆ é™¤æ–‡ä»¶, å¯èƒ½ä¼šé€ æˆè¯¯åˆ çš„åŽæžœ)ã€‚è¿™ä¸ªæ—¶å€™å¯ä»¥ç»™rmåŠ ä¸ªå‚æ•°-iï¼Œæ„ä¸ºåœ¨åˆ é™¤çš„æ—¶å€™ç»™å‡ºæç¤ºã€‚åœ¨æ–‡ä»¶.bashrcé‡Œæ·»åŠ è¿™è¡Œä»£ç alias rm=&quot;rm -i&quot;ã€‚ä½†è¿™é‡Œä¸å»ºè®®è¿™ä¹ˆåšï¼Œå› ä¸ºrm=&quot;rm -i&quot;æ˜¯ä¸€ä¸ªå®šæ—¶ç‚¸å¼¹ï¼Œåœ¨ä½¿ç”¨å®ƒä¹‹åŽï¼Œä¹ æƒ¯äº†ä¹‹åŽ, ä½ ä¼šæœ¬èƒ½åœ°æœŸæœ›rmåœ¨åˆ é™¤æ–‡ä»¶ä¹‹å‰ä¼šæç¤ºä½ ã€‚ä½†æ˜¯ï¼Œæ€»æœ‰ä¸€å¤©ä½ å¯èƒ½ä¼šç”¨ä¸€ä¸ªæ²¡æœ‰rm alias åˆ«åçš„ç³»ç»Ÿ, è¿™æ—¶è‹¥ä½ ä¹Ÿç›´æŽ¥éšæ‰‹ä¸€ç”©rm, æœ¬ä»¥ä¸ºä¼šæœ‰æç¤º, ç»“æžœå‘çŽ°æ•°æ®çœŸçš„è¢«åˆ é™¤äº†ã€‚ åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œé¢„é˜²æ–‡ä»¶ä¸¢å¤±æˆ–æŸåçš„å¥½æ–¹æ³•å°±æ˜¯è¿›è¡Œå¤‡ä»½ã€‚ æ‰€ä»¥å¦‚æžœä½ æƒ³ä¸ªæ€§åŒ–åˆ é™¤å‘½ä»¤, æœ€å¥½ä¸è¦åŠ¨rmï¼Œè€Œæ˜¯åˆ›å»ºå±žäºŽä½ çš„å‘½ä»¤ï¼Œæ¯”å¦‚trash, myrm, deleteç­‰, ç”¨alias trash=&#39;/bin/rm -irv&#39;ä¼šåˆ›å»ºä¸€æ¡æŠŠæ–‡ä»¶æ”¾å…¥åžƒåœ¾å›žæ”¶ç«™çš„å‘½ä»¤.]]></content>
      <categories>
        <category>Productivity</category>
      </categories>
      <tags>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 07 | æ•°æ®ç»“æž„ - ç”¨æ•°ç»„æž„å»ºæ•°æ®åˆ—è¡¨ list]]></title>
    <url>%2Fjava-07-data-structures-array-based-list%2F</url>
    <content type="text"><![CDATA[åˆ—è¡¨Listå‰é¢è¯´åˆ°Javaçš„æ•°ç»„æ— æ³•æ›´æ”¹é•¿åº¦ï¼Œé‚£ä¹ˆä¹Ÿå°±æ— æ³•å®žçŽ°æ’å…¥æˆ–è€…åˆ é™¤æ•°ç»„æˆå‘˜ã€‚Javaæä¾›äº†åŠŸèƒ½æ›´ä¸°å¯Œçš„æ•°æ®ç»“æž„ - åˆ—è¡¨ï¼ˆlistï¼‰ã€‚æ‰€è°“åˆ—è¡¨ï¼Œå³æœ‰åºçš„é›†åˆï¼ˆåºåˆ—ï¼‰ï¼Œç”¨æˆ·å¯ä»¥ç²¾ç¡®åœ°æŽ§åˆ¶æ¯ä¸ªå…ƒç´ æ’å…¥åˆ°åˆ—è¡¨ä¸­çš„å“ªä¸ªä½ç½®ã€‚ç”¨æˆ·å¯ä»¥é€šè¿‡æ•´æ•°ç´¢å¼•ï¼ˆåˆ—è¡¨ä¸­çš„ä½ç½®ï¼‰æ¥è®¿é—®å…ƒç´ ï¼Œå¹¶æœç´¢åˆ—è¡¨ä¸­çš„å…ƒç´ ï¼ˆè¯¦ç»†å¯è¿›ä¸€æ­¥å‚è€ƒoracleå®˜ç½‘ï¼‰ã€‚è¿™é‡Œæˆ‘ä»¬å°è¯•ä»¥javaçš„arrayä¸ºåŸºç¡€å®žçŽ°ä¸€ä¸ªåˆ—è¡¨ï¼Œç›®æ ‡æ˜¯å®žçŽ°è‡ªåŠ¨æ‰©å®¹ (Javaä¸­çš„ArrayListä¸ä»…ä»…æœ‰è‡ªåŠ¨æ‰©å®¹, ä¹Ÿç»§æ‰¿äº†[List]çš„å…¶ä»–åŠŸèƒ½)ã€‚åœ¨æŽ¢ç´¢çš„è¿‡ç¨‹ä¸­, å¯ä»¥é¡ºå¸¦å­¦ä¹ å¾ˆå¤šç›¸å…³çš„å†…å®¹.ä½¿ç”¨è‡ªä¸Šè€Œä¸‹çš„è®¾è®¡æ€æƒ³æ­å»ºä¸€ä¸ªæ¡†æž¶:å…ˆå†™å‡ºæœ€åŸºç¡€çš„éƒ¨åˆ†, ä¹Ÿå°±æ˜¯ä¸€ä¸ªæž„é€ å™¨ï¼Œå‰é¢å­¦è¿‡äº†æ•´æ•°æ•°ç»„ï¼Œæˆ‘ä»¬ç›´æŽ¥æ‹¿æ¥ç”¨123456789101112131415161718/** Array based list. */// index 0 1 2 3 4 5 6 7// items: [6 9 -1 2 0 0 0 0 ...]// size: 5public class AList &#123; private int[] items; private int size; /** æž„é€ ä¸€ä¸ªåˆå§‹å®¹é‡100çš„æ•°ç»„ï¼Œåˆå§‹æœ‰æ•ˆæ•°æ®æˆå‘˜ä¸º0. */ public AList() &#123; items = new int[100]; size = 0; &#125; /** ä¸‹é¢æ·»åŠ å…¶ä»–æ–¹æ³• */&#125; ç„¶åŽæ€è€ƒæˆ‘ä»¬éœ€è¦ä»€ä¹ˆåŠŸèƒ½ï¼ŒæŠŠåŠŸèƒ½éœ€æ±‚è½¬åŒ–ä¸ºå®žä¾‹æ–¹æ³•instance methodçš„å½¢å¼ï¼Œå…ˆæŠŠæ–¹æ³•çš„å¤–å£³æç»˜å‡ºæ¥ï¼Œæ³¨é‡Šä¸Šè¯¥æ–¹æ³•çš„åŠŸèƒ½ï¼ˆç›®çš„ï¼‰ï¼Œè¾“å…¥å€¼ï¼Œè¿”å›žå€¼æ˜¯ä»€ä¹ˆä¹‹ç±»çš„ã€‚å…·ä½“çš„åŠŸèƒ½å®žçŽ°å¯ä»¥å…ˆç©ºç€ï¼Œä¹‹åŽä¸€æ­¥æ­¥ä¸°å¯Œã€‚ å…¬å…±ä¸Žç§æœ‰Public vs. Private åœ¨ä¸Šé¢çš„ä»£ç å—ä¸­ï¼Œå¯ä»¥çœ‹åˆ° items å’Œ size éƒ½è¢«å£°æ˜Žä¸º private ç§æœ‰å˜é‡, è¿™æ ·å°±åªèƒ½è¢«æ‰€åœ¨çš„javaæ–‡ä»¶å†…è°ƒç”¨. ç§æœ‰å˜é‡å’Œæ–¹æ³•çš„è®¾è®¡åˆè¡·æ˜¯æœåŠ¡äºŽç¨‹åºçš„å†…éƒ¨åŠŸèƒ½å®žçŽ°, è€Œä¸æ˜¯ç”¨æ¥å’Œå¤–éƒ¨ç¨‹åº(ç”¨æˆ·)è¿›è¡Œäº¤äº’çš„. è®¾ç½®æˆç§æœ‰, å¯ä»¥é¿å…è¿™äº›å˜é‡å’Œæ–¹æ³•è¢«å¤–éƒ¨ç¨‹åºç›´æŽ¥è°ƒç”¨, é¿å…ç”¨æˆ·é€šè¿‡ä¸æ°å½“/å®¹æ˜“å‡ºé”™çš„æ–¹å¼ä¿®æ”¹æŸäº›å˜é‡. åœ¨ç¨‹åºè¯´æ˜Žæ–‡æ¡£ä¸­, ä¸€èˆ¬ä¹Ÿä¼šæ˜Žç¡®è¯´æ˜Žç¨‹åºæä¾›ä»€ä¹ˆå…¬å…±å˜é‡å’Œæ–¹æ³•ç»™ç”¨æˆ·è°ƒç”¨. å› æ­¤æˆ‘ä»¬è¿™é‡Œä¹Ÿæä¾›å‡ ä¸ª public æ–¹æ³•è®©ç”¨æˆ·è°ƒç”¨, è¿™æ ·ç”¨æˆ·å°±èƒ½æŒ‰ç…§æˆ‘ä»¬è®¾è®¡çš„æ–¹å¼æ¥è®¿é—®æ•°æ®ã€‚åˆ†åˆ«æ˜¯getLast() - è®¿é—®åˆ—è¡¨æœ€åŽä¸€ä¸ªå…ƒç´ ï¼Œget(int i)è®¿é—®ç¬¬iä¸ªå…ƒç´ , å’Œsize()è®¿é—®åˆ—è¡¨çš„å¤§å°.12345678910111213141516/** ç¨‹åºå†…çš„æ–¹æ³•å¯ä»¥è®¿é—® private å˜é‡ *//** è¿”å›žåˆ—è¡¨æœ«å°¾çš„å€¼. */public int getLast() &#123; return items[size - 1];&#125;/** è¿”å›žç¬¬ i ä¸ªå€¼ (0 æ˜¯ç¬¬ä¸€ä¸ª). */public int get(int i) &#123; return items[i];&#125;/** è¿”å›žåˆ—è¡¨å…ƒç´ é•¿åº¦. */public int size() &#123; return size;&#125; æ³›åž‹æ•°ç»„æˆ‘ä»¬ä¸ä»…å¸Œæœ›æˆ‘ä»¬çš„åˆ—è¡¨å¯ä»¥å­˜æ•´æ•°ï¼Œä¹Ÿå¯ä»¥å­˜å…¶ä»–ç±»åž‹çš„æ•°æ®ï¼Œå¯ä»¥é€šè¿‡æ³›åž‹è§£å†³ï¼Œæ³›åž‹çš„ä»‹ç»å‚è€ƒè¿™ç¯‡æ–‡ç« . æ³›åž‹æ•°ç»„è·Ÿå‰é¢ä»‹ç»çš„æ³›åž‹ç¤ºä¾‹æœ‰ä¸€ä¸ªé‡è¦çš„è¯­æ³•å·®å¼‚ï¼šJavaä¸å…è®¸æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªé€šç”¨å¯¹è±¡çš„æ•°ç»„ï¼ŒåŽŸå› è¿™é‡Œä¸ç»†å±•å¼€ã€‚ å‡å¦‚æˆ‘ä»¬ç”¨Itemæ¥æ ‡è¯†æ³›åž‹, é‚£ä¹ˆåœ¨ä¸Šé¢çš„åˆ—è¡¨ç±»ä¸­æž„å»ºæ³›åž‹æ•°ç»„æ—¶, æˆ‘ä»¬ä¸èƒ½ç”¨items = new Item[8];, è€Œè¦ç”¨items = (Item []) new Object[8];12345678910public class AList&lt;Item&gt; &#123; private Item[] items; private int size; /** æž„é€ ä¸€ä¸ªåˆå§‹å®¹é‡100çš„æ•°ç»„ï¼Œåˆå§‹æœ‰æ•ˆæ•°æ®æˆå‘˜ä¸º0. */ public AList() &#123; items = (Item[]) new Object[100]; //ä¼šæœ‰ç¼–è¯‘è­¦å‘Š, æš‚æ—¶ä¸ç®¡ size = 0; &#125;&#125; å³ä½¿è¿™æ ·ä¹Ÿä¼šäº§ç”Ÿä¸€ä¸ªç¼–è¯‘è­¦å‘Šï¼Œä½†ä¸å½±å“å®žé™…ä½¿ç”¨, åŽé¢çš„Castingä¼šæ›´è¯¦ç»†åœ°è®¨è®ºè¿™ä¸ªé—®é¢˜ã€‚1234567891011% javac AList.javaNote: AList.java uses unchecked or unsafe operations.Note: Recompile with -Xlint:unchecked for details.% javac -Xlint:unchecked AList.javaAList.java:26: warning: [unchecked] unchecked castfound : java.lang.Object[]required: Item[] items = (Item[]) new Object[100]; ^1 warning æ•°ç»„æ‰©å®¹Resize ä¸€ä¸ªåˆ—è¡¨åº”è¯¥æ”¯æŒåŸºæœ¬çš„æ’å…¥å’Œåˆ é™¤æ•°æ®çš„æ“ä½œï¼Œä½†æ˜¯å› ä¸ºæ•°ç»„æœ¬èº«æ— æ³•æ›´æ”¹é•¿åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±éœ€è¦ä¸€ä¸ªæ–¹æ³•ï¼Œåœ¨ç»™æ•°ç»„æ’å…¥æ–°æ•°æ®æ—¶ï¼Œå…ˆæ£€æŸ¥é•¿åº¦å®¹é‡æ˜¯å¦è¶³å¤Ÿï¼Œå¦‚æžœä¸å¤Ÿï¼Œé‚£ä¹ˆå°±è¦å¢žåŠ é•¿åº¦ã€‚æˆ‘ä»¬è€ƒè™‘ç®€å•çš„æƒ…å†µ, å³éœ€è¦åœ¨æ•°ç»„æœ«å°¾æ’å…¥æˆ–è€…åˆ é™¤æ•°æ®æ€Žä¹ˆåŠžã€‚ æ’å…¥å…ƒç´ ï¼š123456789101112/** æŠŠ X æ’å…¥åˆ°åˆ—è¡¨æœ«å°¾. */public void addLast(Item x) &#123; /** æ£€æŸ¥é•¿åº¦å®¹é‡æ˜¯å¦è¶³å¤Ÿï¼Œå¦‚æžœä¸å¤Ÿï¼Œé‚£ä¹ˆå°±è¦å¢žåŠ é•¿åº¦ */ if (size == items.length) &#123; Item[] temp = (Item[]) new Object[size + 1]; System.arraycopy(items, 0, temp, 0, size); items = temp; &#125; items[size] = x; size = size + 1;&#125; åˆ›å»ºæ–°arrayå¹¶æŠŠæ—§æ•°æ®å¤åˆ¶è¿‡åŽ»çš„è¿‡ç¨‹é€šå¸¸ç§°ä¸ºâ€œresizingâ€ã€‚å…¶å®žç”¨è¯ä¸å½“ï¼Œå› ä¸ºæ•°ç»„å®žé™…ä¸Šå¹¶æ²¡æœ‰æ”¹å˜å¤§å°ï¼Œåªæ˜¯æŠŠå°æ•°ç»„ä¸Šçš„æ•°æ®å¤åˆ¶åˆ°å¤§æ•°ç»„ä¸Šè€Œå·²ã€‚ ä¸ºäº†è®©ä»£ç æ›´æ˜“äºŽç»´æŠ¤ï¼Œå¯ä»¥æŠŠä¸Šé¢çš„ä»£ç ä¸­è´Ÿè´£å¤§å°è°ƒæ•´çš„éƒ¨åˆ†åŒ…è£…åœ¨ä¸€ä¸ªç‹¬ç«‹çš„methodä¸­12345678910111213141516/** æ”¹å˜åˆ—è¡¨å®¹é‡, capacityä¸ºæ”¹å˜åŽçš„å®¹é‡. */private void resize(int capacity) &#123; Item[] temp = (Item[]) new Object[capacity]; System.arraycopy(items, 0, temp, 0, size); items = temp;&#125;/** æŠŠ X æ’å…¥åˆ°åˆ—è¡¨æœ«å°¾. */public void addLast(Item x) &#123; if (size == items.length) &#123; resize(size + 1); &#125; items[size] = x; size = size + 1;&#125; åˆ é™¤å…ƒç´ ï¼š1234567/** åˆ åŽ»åˆ—è¡¨æœ€åŽä¸€ä¸ªå€¼ï¼Œå¹¶è¿”å›žè¯¥å€¼ */public int removeLast() &#123; Item x = getLast(); items[size - 1] = null; // æ›¾ç»å¼•ç”¨â€œåˆ é™¤â€çš„å…ƒç´ çš„å†…å­˜åœ°å€è¢«æ¸…ç©º size = size - 1; return x;&#125; äº‹å®žä¸Šå³ä½¿æ²¡æœ‰items[size - 1] = null;,ä¹Ÿå¯ä»¥è¾¾åˆ°åˆ é™¤å…ƒç´ çš„ç›®çš„.åˆ é™¤å¯¹å­˜å‚¨å¯¹è±¡çš„å¼•ç”¨, æ˜¯ä¸ºäº†é¿å…â€œloiteringâ€ã€‚æ‰€è°“ loiteringï¼Œå¯ä»¥ç†è§£ä¸ºå ç€èŒ…å‘ä¸æ‹‰å±Žçš„å¯¹è±¡ï¼Œå®ƒä»¬å·²ç»æ²¡å•¥ç”¨äº†ï¼Œå´è¿˜æ˜¯å ç”¨ç€å†…å­˜ã€‚å¦‚æžœè¿™ä¸ªå¯¹è±¡æ˜¯äº›å‡ åå…†çš„é«˜æ¸…å›¾ç‰‡ï¼Œé‚£ä¹ˆå°±ä¼šå¾ˆæ¶ˆè€—å†…å­˜ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå®‰å“æ‰‹æœºè¶Šç”¨è¶Šæ…¢çš„ä¸€ä¸ªåŽŸå› ã€‚ å½“å¼•ç”¨/å†…å­˜åœ°å€ä¸¢å¤±æ—¶ï¼ŒJavaä¼šé”€æ¯å¯¹è±¡ã€‚å¦‚æžœæˆ‘ä»¬ä¸æ¸…ç©ºå¼•ç”¨ï¼Œé‚£ä¹ˆJavaå°†ä¸ä¼šåžƒåœ¾å›žæ”¶è¿™äº›æœ¬æ¥é¢„è®¡è¦åˆ é™¤çš„å¯¹è±¡, å› ä¸ºå®ƒä»¬å®žé™…è¿˜è¢«åˆ—è¡¨å¼•ç”¨ç€ã€‚ æ‰©å®¹æ•ˆçŽ‡åˆ†æžæˆ‘ä»¬ç›´è§‰ä¹Ÿä¼šæ„Ÿè§‰åˆ°ï¼Œå¦‚æžœæŒ‰ç…§çŽ°åœ¨çš„è®¾è®¡ï¼Œå³æ¯æ’å…¥ä¸€ä¸ªæ–°å…ƒç´ ï¼Œå°±é‡æ–°å¤åˆ¶ä¸€éæ•°ç»„ï¼Œè¿™æ ·éšç€æ•°ç»„è¶Šæ¥è¶Šå¤§ï¼Œæ•ˆçŽ‡è‚¯å®šä¼šè¶Šæ¥è¶Šå·®ã€‚äº‹å®žä¸Šä¹Ÿæ˜¯è¿™æ ·ï¼Œå¦‚æžœæ•°ç»„ç›®å‰é•¿åº¦æ˜¯100ä¸ªå†…å­˜å—ï¼Œé‚£ä¹ˆæ’å…¥1000æ¬¡ï¼Œéœ€è¦åˆ›å»ºå¹¶å¡«å……å¤§çº¦50ä¸‡ä¸ªå†…å­˜å—ï¼ˆç­‰å·®æ•°åˆ—æ±‚å’ŒN(N+1)/2ï¼Œ101+102+â€¦+1000 â‰ˆ 500000ï¼‰ã€‚ä½†å‡å¦‚æˆ‘ä»¬ç¬¬ä¸€æ¬¡å°±æ‰©å®¹åˆ°1000ï¼Œé‚£ä¹ˆå°±çœå´äº†å¾ˆå¤šè¿ç®—æ¶ˆè€—ã€‚å¯æƒœæˆ‘ä»¬ä¸çŸ¥é“ç”¨æˆ·éœ€è¦æ’å…¥å¤šå°‘æ•°æ®ï¼Œæ‰€ä»¥è¦é‡‡å–å…¶ä»–æ–¹æ³•-å‡ ä½•è°ƒæ•´ã€‚ä¹Ÿå°±æ˜¯ä¸Žå…¶æŒ‰ç…§size + FACTORè¿™æ ·çš„é€ŸçŽ‡å¢žåŠ å®¹é‡, ä¸å¦‚æŒ‰ç…§size * RFACTORæˆå€æ‰©å®¹, å‰è€…çš„å¢žåŠ é€ŸçŽ‡ä¸º1, åŽè€…ä¸º RFACTOR, åªè¦è®¾ç½® RFACTOR å¤§äºŽ1, å°±èƒ½å‡å°‘æ‰©å®¹çš„æ¬¡æ•°.123456789/** æŠŠ X æ’å…¥åˆ°åˆ—è¡¨æœ«å°¾. */public void addLast(Item x) &#123; if (size == items.length) &#123; resize(size * RFACTOR); //ç”¨ RFACTOR ä½œä¸ºå› å­æ‰©å®¹æ•°ç»„, &#125; items[size] = x; size = size + 1;&#125; ç›®å‰æˆ‘ä»¬è§£å†³äº†æ—¶é—´æ•ˆçŽ‡é—®é¢˜, ä½†ä»£ä»·æ˜¯éœ€è¦æ›´å¤§çš„å†…å­˜ç©ºé—´, ä¹Ÿå°±æ˜¯ç©ºé—´æ•ˆçŽ‡ä¸‹é™äº†. å‡è®¾æˆ‘ä»¬æ’å…¥äº†åäº¿ä¸ªitemï¼Œç„¶åŽå†åˆ åŽ»ä¹äº¿ä¹åƒä¸‡ä¸ªé¡¹ç›®ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†åªä½¿ç”¨10,000,000ä¸ªå†…å­˜å—ï¼Œå‰©ä¸‹99ï¼…å®Œå…¨æ²¡æœ‰ä½¿ç”¨åˆ°ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ•°ç»„å®¹é‡åˆ©ç”¨çŽ‡æ¯”è¾ƒä½Žæ—¶æŠŠå®¹é‡é™ä¸‹æ¥. å®šä¹‰åˆ©ç”¨çŽ‡ R ä¸ºåˆ—è¡¨çš„å¤§å°é™¤ä»¥itemsæ•°ç»„çš„é•¿åº¦ã€‚ä¸€èˆ¬å½“Rä¸‹é™åˆ°å°äºŽ0.25æ—¶ï¼Œæˆ‘ä»¬å°†æ•°ç»„çš„å¤§å°å‡åŠã€‚ å…¶ä»–åŠŸèƒ½æ¯”å¦‚æŽ’åºç­‰, åœ¨åŽé¢ä»‹ç»é“¾è¡¨çš„æ–‡ç« ä¸­å†è®¨è®º.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 06 | æ•°æ®ç»“æž„ - array æ•°ç»„]]></title>
    <url>%2Fjava-06-data-structures-array%2F</url>
    <content type="text"><![CDATA[æ•°ç»„ï¼ˆArrayï¼‰æ•°ç»„æ˜¯ä¸€ç§ç‰¹æ®Šçš„å¯¹è±¡ï¼Œæœ‰ä¸€ä¸ªå›ºå®šçš„æ•°ç»„é•¿åº¦å‚æ•°Nï¼Œç”±ä¸€è¿žä¸²ï¼ˆNä¸ªï¼‰è¿žç»­çš„å¸¦ç¼–å·çš„å†…å­˜å—ç»„æˆï¼Œæ¯ä¸ªéƒ½æ˜¯ç›¸åŒçš„ç±»åž‹(ä¸åƒPythonå¯ä»¥åŒ…å«ä¸åŒç±»åž‹)ï¼Œç´¢å¼•ä»Ž0åˆ°N-1ç¼–å·ã€‚A[i]èŽ·å¾—æ•°ç»„Açš„ç¬¬iä¸ªå…ƒç´ ã€‚è¿™ä¸Žæ™®é€šçš„ç±»å®žä¾‹ä¸åŒï¼Œç±»å®žä¾‹æœ‰å…·ä½“å˜é‡åå‘½åçš„å†…å­˜å—ã€‚ æ•°ç»„å®žä¾‹åŒ–ï¼ŒåŒ…å«å¯¹è±¡çš„æ•°ç»„Array Instantiation, Arrays of Objects è¦åˆ›å»ºæœ€ç®€å•çš„æ•´æ•°æ•°ç»„, æœ‰ä¸‰ç§æ–¹å¼:123x = new int [3]; //åˆ›å»ºä¸€ä¸ªæŒ‡å®šé•¿åº¦çš„æ•°ç»„ï¼Œå¹¶ç”¨é»˜è®¤å€¼ï¼ˆ0ï¼‰å¡«å……æ¯ä¸ªå†…å­˜å—ã€‚y = new int [] &#123;1ï¼Œ2ï¼Œ3ï¼Œ4ï¼Œ5&#125;; //åˆ›å»ºä¸€ä¸ªåˆé€‚å¤§å°çš„æ•°ç»„ï¼Œä»¥å®¹çº³æŒ‡å®šçš„åˆå§‹å€¼int [] z = &#123;9ï¼Œ10ï¼Œ11ï¼Œ12ï¼Œ13&#125;; //çœç•¥äº†newï¼Œåªèƒ½ç»“åˆå˜é‡å£°æ˜Žä½¿ç”¨ã€‚ åˆ›å»ºä¸€ç»„å®žä¾‹åŒ–å¯¹è±¡:12345678910public class DogArrayDemo &#123; public static void main(String[] args) &#123; /* Create an array of two dogs. */ Dog[] dogs = new Dog[2]; dogs[0] = new Dog(8); dogs[1] = new Dog(20); /* Yipping will result, since dogs[0] has weight 8. */ dogs[0].makeNoise(); &#125;&#125; æ³¨æ„åˆ°newæœ‰ä¸¤ç§ä¸åŒçš„ä½¿ç”¨æ–¹å¼ï¼šä¸€ç§æ˜¯åˆ›å»ºä¸€ä¸ªå¯ä»¥å®¹çº³ä¸¤ä¸ªDogå¯¹è±¡çš„æ•°ç»„ï¼Œå¦å¤–ä¸¤ä¸ªåˆ›å»ºå„ä¸ªå®žé™…çš„Dogå®žä¾‹ã€‚ æ•°ç»„å¤åˆ¶123x = new int[]&#123;-1, 2, 5, 4, 99&#125;;int[] b = &#123;9, 10, 11&#125;;System.arraycopy(b, 0, x, 3, 2); //æ•ˆæžœç±»ä¼¼äºŽPythonçš„`x[3:5] = b[0:2]` System.arraycopyçš„äº”ä¸ªå‚æ•°åˆ†åˆ«ä»£è¡¨ï¼š å¾…å¤åˆ¶çš„æ•°ç»„(æº) æºæ•°ç»„å¤åˆ¶èµ·ç‚¹ ç›®æ ‡æ•°ç»„ ç›®æ ‡æ•°ç»„ç²˜è´´èµ·ç‚¹ æœ‰å¤šå°‘é¡¹è¦å¤åˆ¶ 2Dæ•°ç»„Javaçš„äºŒç»´æ•°ç»„å®žè´¨ä¸Šæ˜¯ä¸€æ•°ç»„çš„æ•°ç»„, å³æ¯ä¸€ä¸ªæ•°ç»„å…ƒç´ é‡Œé¢ä¹Ÿæ˜¯ä¸€ä¸ªæ•°ç»„ã€‚1234567891011121314151617int[][] matrix; //å£°æ˜Žä¸€ä¸ªå¼•ç”¨æ•°ç»„çš„æ•°ç»„matrix = new int[4][]; //åˆ›å»ºå››ä¸ªå†…å­˜å—, ç”¨é»˜è®¤nullå€¼å¡«å……, ä¹‹åŽç”¨äºŽå‚¨å­˜å¯¹æ•´æ•°æ•°ç»„çš„å¼•ç”¨, å³åœ°å€,int[] rowZero = matrix[0];/** å®žä¾‹åŒ–æ•´æ•°æ•°ç»„, æŠŠå…¶åœ°å€/å¼•ç”¨åˆ†åˆ«èµ‹å€¼ç»™/å‚¨å­˜åˆ° matrix çš„ç¬¬Nä¸ªå†…å­˜å—*/matrix[0] = new int[]&#123;1&#125;;matrix[1] = new int[]&#123;1, 1&#125;;matrix[2] = new int[]&#123;1, 2, 1&#125;;matrix[3] = new int[]&#123;1, 3, 3, 1&#125;;int[] rowTwo = matrix[2];rowTwo[1] = -5;/** åˆ›å»ºå››ä¸ªå†…å­˜å—, å…¶ä¸­æ¯ä¸ªè¢«å¼•ç”¨çš„æ•´æ•°æ•°ç»„é•¿åº¦ä¸º4,æ¯ä¸ªå…ƒç´ éƒ½æ˜¯0.*/matrix = new int[4][4];int[][] matrixAgain = new int[][]&#123;&#123;1&#125;, &#123;1, 1&#125;,&#123;1, 2, 1&#125;, &#123;1, 3, 3, 1&#125;&#125;;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 05 | æ•°æ®ç±»åž‹]]></title>
    <url>%2Fjava-05-variable-types%2F</url>
    <content type="text"><![CDATA[æ•°æ®ç±»åž‹æ•°æ®ç±»åž‹æ˜¯ç¨‹åºè®¾è®¡è¯­è¨€æè¿°äº‹ç‰©ã€å¯¹è±¡çš„æ–¹æ³•ã€‚Javaæ•°æ®ç±»åž‹åˆ†ä¸ºåŸºæœ¬ç±»åž‹ï¼ˆå†…ç½®ç±»åž‹ï¼‰å’Œå¼•ç”¨ç±»åž‹(æ‰©å±•ç±»åž‹ï¼‰ä¸¤å¤§ç±»ã€‚åŸºæœ¬ç±»åž‹å°±æ˜¯Javaè¯­è¨€æœ¬èº«æä¾›çš„åŸºæœ¬æ•°æ®ç±»åž‹ï¼Œæ¯”å¦‚ï¼Œæ•´åž‹æ•°ï¼Œæµ®ç‚¹æ•°ï¼Œå­—ç¬¦ï¼Œå¸ƒå°”å€¼ç­‰ç­‰ã€‚è€Œå¼•ç”¨ç±»åž‹åˆ™æ˜¯Javaè¯­è¨€æ ¹æ®åŸºæœ¬ç±»åž‹æ‰©å±•å‡ºçš„å…¶ä»–ç±»åž‹ï¼ŒJavaè¦æ±‚æ‰€æœ‰çš„å¼•ç”¨æ‰©å±•ç±»åž‹éƒ½å¿…é¡»åŒ…æ‹¬åœ¨ç±»å®šä¹‰é‡Œé¢ï¼Œè¿™å°±æ˜¯Javaä¸ºä»€ä¹ˆæ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€çš„åŽŸå› â€¦ä¸Šé¢çš„å®šä¹‰æœ‰ç‚¹æŠ½è±¡ï¼Œè¦ç†è§£æ•°æ®ç±»åž‹ï¼Œéœ€è¦å…ˆç†è§£ä¸€ä¸ªé—®é¢˜: ç¥žç§˜çš„æµ·è±¡é—®é¢˜ å°è¯•é¢„æµ‹ä¸‹é¢çš„ä»£ç è¿è¡Œæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚bçš„å˜åŒ–æ˜¯å¦ä¼šå½±å“aï¼Ÿæç¤ºï¼šç±»ä¼¼Pythonã€‚123456Walrus a = new Walrus(1000, 8.3);Walrus b;b = a;b.weight = 5;System.out.println(a);System.out.println(b); åŒæ ·å°è¯•é¢„æµ‹ä¸‹é¢çš„ä»£ç è¿è¡Œæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚xçš„æ”¹å˜æ˜¯å¦å½±å“yï¼Ÿ123456int x = 5;int y;y = x;x = 2;System.out.println("x is: " + x);System.out.println("y is: " + y); ç­”æ¡ˆæ˜¯bçš„å˜åŒ–ä¼šå½±å“a, ä½†xçš„æ”¹å˜ä¸å½±å“yï¼Œå…·ä½“è§å¯è§†åŒ–è¿‡ç¨‹.è¿™é‡Œçš„å·®åˆ«è™½ç„¶å¾®å¦™, ä½†å…¶èƒŒåŽçš„åŽŸç†å¯¹äºŽæ•°æ®ç»“æž„çš„æ•ˆçŽ‡æ¥è¯´æ˜¯éžå¸¸é‡è¦çš„ï¼Œå¯¹è¿™ä¸ªé—®é¢˜çš„æ·±å…¥ç†è§£ä¹Ÿå°†å¼•å¯¼æˆ‘ä»¬å†™å‡ºæ›´å®‰å…¨ï¼Œæ›´å¯é çš„ä»£ç ã€‚ åŸºæœ¬ç±»åž‹Primative Types è®¡ç®—æœºä¸­çš„æ‰€æœ‰ä¿¡æ¯éƒ½ä»¥ä¸€ç³»åˆ—1å’Œ0çš„å½¢å¼å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œè¿™äº›äºŒè¿›åˆ¶çš„0å’Œ1å°±æ˜¯æ¯”ç‰¹ä½ï¼ˆbitsï¼‰ã€‚æ¯”å¦‚72å’Œâ€œHâ€åœ¨å†…å­˜ä¸€èˆ¬ä»¥01001000çš„å½¢å¼å­˜å‚¨ï¼Œå¯¹ä»–ä»¬çš„å½¢å¼æ˜¯ä¸€æ ·çš„ã€‚ä¸€ä¸ªå¼•ç”³é—®é¢˜å°±æ˜¯ï¼šJavaä»£ç å¦‚ä½•è§£é‡Š01001000ï¼Œæ€Žä¹ˆçŸ¥é“åº”è¯¥è§£é‡Šä¸º72è¿˜æ˜¯â€œHâ€ï¼Ÿ é€šè¿‡ç±»åž‹typesï¼Œé¢„å…ˆå®šä¹‰å¥½ç±»åž‹å³å¯, ä»¥ä¸‹ä»£ç 1234char x = 'H';int y = x;System.out.println(x);System.out.println(y); ä¼šåˆ†åˆ«å¾—åˆ°â€œHâ€å’Œ72. åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œxå’Œyå˜é‡éƒ½åŒ…å«å‡ ä¹Žç›¸åŒçš„bitsï¼Œä½†æ˜¯Javaè§£é‡Šå™¨åœ¨è¾“å‡ºæ—¶å¯¹å®ƒä»¬è¿›è¡Œäº†ä¸åŒçš„å¤„ç†ã€‚ Javaæœ‰8ç§åŸºæœ¬ç±»åž‹ï¼šbyteï¼Œshortï¼Œintï¼Œlongï¼Œfloatï¼Œdoubleï¼Œbooleanå’Œcharã€‚ å˜é‡å£°æ˜ŽDeclaring Variables è®¡ç®—æœºçš„å†…å­˜å¯ä»¥è§†ä¸ºåŒ…å«å¤§é‡ç”¨äºŽå­˜å‚¨ä¿¡æ¯çš„å†…å­˜æ¯”ç‰¹ä½ï¼Œæ¯ä¸ªä½éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„åœ°å€ã€‚çŽ°ä»£è®¡ç®—æœºå¯ä»¥ä½¿ç”¨è®¸å¤šè¿™æ ·çš„ä½ã€‚ å½“ä½ å£°æ˜Žä¸€ä¸ªç‰¹å®šç±»åž‹çš„å˜é‡æ—¶ï¼ŒJavaä¼šç”¨ä¸€ä¸²è¿žç»­çš„å†…å­˜ä½å­˜å‚¨å®ƒã€‚ä¾‹å¦‚ï¼Œå¦‚æžœä½ å£°æ˜Žä¸€ä¸ªintï¼Œä½ ä¼šå¾—åˆ°ä¸€ä¸ªé•¿åº¦32çš„å†…å­˜listï¼Œé‡Œé¢æœ‰32bitsã€‚Javaä¸­çš„æ¯ä¸ªæ•°æ®ç±»åž‹éƒ½æœ‰ä¸åŒçš„æ¯”ç‰¹æ•°ã€‚ é™¤äº†ç•™å‡ºå†…å­˜ç©ºé—´å¤–ï¼ŒJavaè§£é‡Šå™¨è¿˜ä¼šåœ¨ä¸€ä¸ªå†…éƒ¨è¡¨ä¸­åˆ›å»ºä¸€ä¸ªæ¡ç›®ï¼Œå°†æ¯ä¸ªå˜é‡åç§°æ˜ å°„åˆ°å†…å­˜å—ä¸­ç¬¬ä¸€ä¸ªä½ç½®ï¼ˆè¡¨å¤´list headï¼‰ã€‚ ä¾‹å¦‚ï¼Œå¦‚æžœå£°æ˜Žäº†int xå’Œdouble yï¼Œé‚£ä¹ˆJavaå¯èƒ½ä¼šå†³å®šä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„352åˆ°384ä½æ¥å­˜å‚¨xï¼Œè€Œ20800åˆ°20864ä½åˆ™ç”¨æ¥å­˜å‚¨yã€‚ç„¶åŽè§£é‡Šå™¨å°†è®°å½•int xä»Ž352å¼€å§‹ï¼Œyä»Ž20800å¼€å§‹ã€‚ åœ¨Javaè¯­è¨€é‡Œæ— æ³•çŸ¥é“å˜é‡çš„å…·ä½“å†…å­˜ä½ç½®ï¼Œä¾‹å¦‚ä½ ä¸èƒ½ä»¥æŸç§æ–¹å¼å‘çŽ°xåœ¨ä½ç½®352ã€‚ä¸åƒC++è¿™æ ·çš„è¯­è¨€ï¼Œå¯ä»¥èŽ·å–ä¸€æ®µæ•°æ®çš„ç¡®åˆ‡åœ°å€ã€‚Javaçš„è¿™ä¸ªç‰¹æ€§æ˜¯ä¸€ä¸ªæŠ˜è¡·ï¼éšè—å†…å­˜ä½ç½®è‡ªç„¶æ„å‘³ç€ç¨‹åºçŒ¿çš„æŽ§åˆ¶æƒæ›´å°‘ï¼Œå°±æ— æ³•åšæŸäº›ç±»åž‹çš„ä¼˜åŒ–ã€‚ä½†æ˜¯ï¼Œå®ƒä¹Ÿé¿å…äº†ä¸€å¤§ç±»éžå¸¸æ£˜æ‰‹çš„ç¼–ç¨‹é”™è¯¯ã€‚åœ¨çŽ°åœ¨è®¡ç®—æˆæœ¬å¦‚æ­¤ä½Žå»‰çš„æ—¶ä»£ï¼Œä¸æˆç†Ÿçš„ä¼˜åŒ–è¿˜ä¸å¦‚å°‘ç‚¹bugã€‚ å½“å£°æ˜Žä¸€ä¸ªå˜é‡æ—¶ï¼ŒJavaä¸ä¼šåœ¨é¢„ç•™çš„å†…å­˜ä½ç½®ä¸­å†™å…¥ä»»ä½•å†…å®¹, ä¹Ÿå³æ²¡æœ‰é»˜è®¤å€¼ã€‚å› æ­¤ï¼Œå¦‚æžœæ²¡æœ‰èµ‹å€¼, Javaç¼–è¯‘å™¨ä¼šé˜»æ­¢ä½ ä½¿ç”¨å˜é‡ã€‚ ä»¥ä¸Šåªæ˜¯å†…å­˜åˆ†é…çš„ç®€è¦è¯´æ˜Ž, å †å’Œæ ˆçš„ä»‹ç»å¯ä»¥å‚è€ƒ CS106B ç¬”è®°ã€‚ å¼•ç”¨ç±»åž‹Reference Types æ‰€æœ‰åŸºæœ¬æ•°æ®ç±»åž‹ä¹‹å¤–çš„ç±»åž‹éƒ½æ˜¯å¼•ç”¨ç±»åž‹ã€‚å¼•ç”¨ç±»åž‹é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯å¯¹å¯¹è±¡çš„å¼•ç”¨ã€‚åœ¨javaä¸­å†…å­˜ä½ç½®æ˜¯ä¸å¼€æ”¾ç»™ç¨‹åºå‘˜çš„, ä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡å¼•ç”¨ç±»åž‹è®¿é—®å†…å­˜ä¸­æŸå¤„å¯¹è±¡ã€‚æ‰€æœ‰å¼•ç”¨ç±»åž‹éƒ½æ˜¯ java.lang.Object ç±»åž‹çš„å­ç±»ã€‚ å¯¹è±¡å®žä¾‹åŒ–Object Instantiation å¯¹è±¡å®žä¾‹åŒ–ï¼šå½“æˆ‘ä»¬ä½¿ç”¨newï¼ˆä¾‹ new Dogï¼‰å®žä¾‹åŒ–å¯¹è±¡æ—¶ï¼ŒJavaé¦–å…ˆä¸ºç±»çš„æ¯ä¸ªå®žä¾‹å˜é‡åˆ†é…ä¸€ä¸²é•¿åº¦åˆé€‚çš„bitsä½ï¼Œå¹¶ç”¨ç¼ºçœå€¼å¡«å……å®ƒä»¬ã€‚ç„¶åŽï¼Œæž„é€ å‡½æ•°é€šå¸¸ï¼ˆä½†ä¸æ€»æ˜¯ï¼‰ç”¨å…¶ä»–å€¼å¡«å……æ¯ä¸ªä½ç½®.123456789public static class Walrus &#123; public int weight; public double tuskSize; public Walrus(int w, double ts) &#123; weight = w; tuskSize = ts; &#125;&#125; ç”¨new Walrus(1000, 8.3)åˆ›å»ºä¸€ä¸ªWalruså®žä¾‹åŽ, æˆ‘ä»¬å¾—åˆ°åˆ†åˆ«ç”±ä¸€ä¸ª32ä½(int weight = 1000)å’Œä¸€ä¸ª64ä½(double tuskSize = 8.3)çš„å†…å­˜å—ç»„æˆçš„å®žä¾‹ï¼šé€šè¿‡ç¨‹åºå¯è§†åŒ–è¿‡ç¨‹)æ¥æ›´å¥½åœ°ç†è§£. å½“ç„¶åœ¨Javaç¼–ç¨‹è¯­è¨€çš„å®žé™…å®žçŽ°ä¸­ï¼Œå®žä¾‹åŒ–å¯¹è±¡æ—¶éƒ½æœ‰ä¸€äº›é¢å¤–çš„å†…å­˜å¼€é”€, è¿™é‡Œä¸å±•å¼€. é€šè¿‡ new å®žä¾‹åŒ–å¯¹è±¡ï¼Œnew ä¼šè¿”å›žè¯¥å¯¹è±¡çš„å†…å­˜åœ°å€ç»™æˆ‘ä»¬ï¼Œä½†å‡å¦‚æˆ‘ä»¬æ²¡æœ‰ç”¨ä¸€ä¸ªå˜é‡åŽ»æŽ¥æ”¶è¿™ä¸ªåœ°å€ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ— æ³•è®¿é—®è¿™ä¸ªå¯¹è±¡ã€‚ä¹‹åŽè¯¥å¯¹è±¡ä¼šè¢«ä½œä¸ºåžƒåœ¾å›žæ”¶ã€‚ å¼•ç”¨å˜é‡å£°æ˜ŽReference Variable Declaration å‰é¢æœ‰æåˆ°ï¼Œæˆ‘ä»¬éœ€è¦å£°æ˜Žå˜é‡æ¥æŽ¥å—å®žä¾‹åŒ–çš„å¯¹è±¡åœ¨å†…å­˜ä¸­çš„åœ°å€ã€‚å½“å£°æ˜Žä»»ä½•å¼•ç”¨ç±»åž‹çš„å˜é‡ï¼ˆæ¯”å¦‚array, å‰é¢çš„Dogç±»ç­‰ï¼‰æ—¶ï¼ŒJavaéƒ½ä¼šåˆ†é…ä¸€ä¸²64ä½çš„å†…å­˜ä½ç½®. è¿™ä¸ª64ä½çš„å†…å­˜å—ä»…ç”¨äºŽè®°å½•å˜é‡çš„å†…å­˜åœ°å€, æ‰€è°“å†…å­˜åœ°å€, å¯ä»¥ç†è§£ä¸ºå†…å­˜(æˆ¿å­)çš„ç¼–å·(åœ°å€), ä¸€èˆ¬æ˜¯å†…å­˜å—çš„è¡¨å¤´ä½ç½®çš„64ä½è¡¨è¾¾å¼1234Walrus someWalrus; // åˆ›å»ºä¸€ä¸ª64ä½çš„å†…å­˜ä½ç½®someWalrus = new Walrus(1000, 8.3); //åˆ›å»ºä¸€ä¸ªæ–°çš„å®žä¾‹/** å†…å­˜åœ°å€ç”± new è¿”å›ž, å¹¶è¢«å¤åˆ¶/èµ‹å€¼ç»™ someWalrus å¯¹åº”çš„å†…å­˜ä½ç½®*/ æ¯”å¦‚, å‡è®¾weightæ˜¯ä»Žå†…å­˜ä½5051956592385990207å¼€å§‹å­˜å‚¨çš„ï¼ŒåŽé¢è¿žç»­è·Ÿç€å…¶ä»–å®žä¾‹å˜é‡ï¼Œé‚£ä¹ˆå°±å¯ä»¥æŠŠ5051956592385990207å­˜å‚¨åœ¨someWalruså˜é‡ä¸­ã€‚5051956592385990207ç”±64ä½çš„äºŒè¿›åˆ¶0100011000011100001001111100000100011101110111000001111000111111è¡¨è¾¾ï¼Œè¿™æ ·someWalrusçš„å†…å­˜å°±å¯ä»¥æŠ½è±¡çš„ç†è§£ä¸ºä¸€ä¸ªè¡¨someWalrus: 0100011000011100001001111100000100011101110111000001111000111111 -&gt; å…·ä½“å­˜æ”¾å®žä¾‹çš„å†…å­˜(Walrus: weight=1000, tuskSize=8.3)â€˜-&gt;â€™å¯ä»¥ç†è§£ä¸ºæŒ‡é’ˆ. å‰é¢æœ‰æåˆ°ï¼Œå¦‚æžœä¸¢å¤±äº†å¼•ç”¨å˜é‡å­˜å‚¨çš„å†…å­˜åœ°å€ï¼Œé‚£ä¹ˆè¯¥åœ°å€å¯¹åº”çš„å¯¹è±¡å°±æ‰¾ä¸å›žæ¥äº†ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœä¸€ä¸ªç‰¹å®šçš„ Walrus åœ°å€çš„å”¯ä¸€å‰¯æœ¬å­˜å‚¨åœ¨xä¸­ï¼Œé‚£ä¹ˆx = nullè¿™è¡Œä»£ç å°†åˆ åŽ»åœ°å€ï¼Œæˆ‘ä»¬åˆ™ä¸¢å¤±äº†è¿™ä¸ª Walrus å¯¹è±¡ã€‚è¿™ä¹Ÿä¸ä¸€å®šæ˜¯åäº‹ï¼Œå¾ˆå¤šæ—¶å€™åœ¨å®Œæˆäº†ä¸€ä¸ªå¯¹è±¡åŽå°±ä¸åœ¨éœ€è¦äº†ï¼Œåªéœ€ç®€å•åœ°ä¸¢å¼ƒè¿™ä¸ªå‚è€ƒåœ°å€å°±å¯ä»¥äº†ã€‚ ç­‰å€¼è§„åˆ™Java Rule of Equals å¯¹äºŽy = xï¼ŒJavaè§£é‡Šå™¨ä¼šå°†xçš„ä½æ‹·è´åˆ°yä¸­,è¿™ä¸ªè§„åˆ™é€‚ç”¨äºŽjavaä¸­ä»»ä½•ä½¿ç”¨=èµ‹å€¼çš„è¯­æ³•, æ˜¯ç†è§£å¼€å¤´çš„â€ç¥žç§˜çš„æµ·è±¡â€é—®é¢˜çš„å…³é”®. åŸºæœ¬ç±»åž‹å˜é‡çš„ä½, å­˜å‚¨èµ‹å€¼çš„å€¼ï¼ˆåŸºæœ¬ç±»åž‹ï¼‰åœ¨å†…å­˜ä¸­å€¼(å…·ä½“ä½æ•°å–å†³äºŽå…·ä½“çš„ç±»åž‹) 1234int x = 5; // æ­¤æ—¶æ˜¯æŠŠå†…å­˜ä¸­çš„æŸä¸€ä¸ªåœ°å€ p å¤åˆ¶ç»™ xint y;y = x; // y ä¹ŸæŒ‡å‘ px = 2; // æŠŠä¸€ä¸ªæ–°çš„å†…å­˜åœ°å€ new p å¤åˆ¶ç»™x, ä½†yè¿˜æ˜¯æŒ‡å‘åŽŸæ¥çš„p xçš„ä½å­˜å‚¨çš„æ˜¯åŸºæœ¬ç±»åž‹int 5(32 bits), x = 2æ˜¯æŠŠæ–°çš„åŸºæœ¬ç±»åž‹int 2å¤åˆ¶ç»™x, ä½†yè¿˜æ˜¯æŒ‡å‘åŽŸæ¥çš„int 5ï¼Œ æ‰€ä»¥yæ²¡å˜åŒ–ã€‚ å¼•ç”¨ç±»åž‹ reference type å˜é‡çš„ä½, å­˜å‚¨èµ‹å€¼çš„å€¼ï¼ˆå¼•ç”¨ç±»åž‹ï¼‰åœ¨å†…å­˜ä¸­çš„åœ°å€(å›ºå®šçš„64 bits) 1234Dog a = new Dog(5); // åˆ›å»ºä¸€ä¸ª64ä½çš„å†…å­˜ä½, å¹¶èµ‹å€¼ä¸€ä¸ªæ–°çš„å®žä¾‹ pDog b; // ä»…åˆ›å»ºä¸€ä¸ª64ä½çš„å†…å­˜ä½, æ²¡æœ‰å¼•ç”¨å†…å­˜åœ°å€(null)b = a; // æŠŠaçš„ä½ï¼ˆæ˜¯å®žä¾‹ p çš„å†…å­˜åœ°å€ï¼‰å¤åˆ¶ç»™b, è¿™æ · b ä¹Ÿæ˜¯æŒ‡å‘å®žä¾‹ pb.weight = 21; // æ­¤æ—¶ä¿®æ”¹b, ä¼šæ”¹å†™bæŒ‡å‘çš„å†…å­˜å®žä¾‹ p aå’Œbåªå­˜å‚¨åœ°å€, è€Œå®ƒä»¬çš„åœ°å€éƒ½æŒ‡å‘ç›¸åŒçš„å®žä¾‹ï¼› å¦‚æžœå¯¹ b çš„ä¿®æ”¹æœ¬è´¨æ˜¯å¯¹ pçš„ä¿®æ”¹, é‚£ä¹ˆè¾“å‡ºa.weightçš„æ—¶å€™, å°±ä¼šå˜æˆ21. å‚æ•°ä¼ é€’Parameter Passing ç»™å‡½æ•°ä¼ é€’å‚æ•°ï¼Œæœ¬è´¨ä¸Šä¹Ÿæ˜¯èµ‹å€¼æ“ä½œï¼Œå‚è€ƒä¸Šé¢çš„ç­‰å€¼è§„åˆ™ï¼Œä¹Ÿå³å¤åˆ¶è¿™äº›å‚æ•°çš„bitsç»™å‡½æ•°ï¼Œä¹Ÿç§°ä¹‹ä¸ºpass by valueã€‚Javaçš„å‚æ•°ä¼ é€’éƒ½æ˜¯pass by valueã€‚è‡³äºŽä¼ é€’è¿‡åŽ»çš„å‚æ•°ä¼šä¸ä¼šå› ä¸ºå‡½æ•°å†…éƒ¨çš„æ“ä½œè€Œæ›´æ”¹ï¼Œå…¶åˆ¤æ–­åŽŸç†åœ¨ä¸Šé¢çš„ç­‰å€¼è§„åˆ™å·²ç»é˜æ˜Žã€‚ é€šç”¨æ•°æ®ç±»åž‹Generic åœ¨å®šä¹‰ç±»çš„æ—¶å€™ï¼Œæœ‰æ—¶å€™æˆ‘ä»¬å¯èƒ½å¸Œæœ›è¿™ä¸ªç±»èƒ½å¤ŸæŽ¥å—ä»»ä½•ç±»åž‹çš„æ•°æ®ï¼Œè€Œä¸ä»…ä»…æ˜¯é™å®šäº†åŸºæœ¬ç±»åž‹ä¸­çš„ä»»ä½•ä¸€ç§ã€‚æ¯”å¦‚æˆ‘ä»¬æƒ³å®žçŽ°ä¸€ä¸ªç±»ä¼¼excelè¡¨æ ¼çš„ç±»ï¼Œè‡ªç„¶éœ€è¦è¿™ä¸ªè¡¨æ ¼ç±»èƒ½å¤ŸæŽ¥æ”¶å„ç§ç±»åž‹çš„å­—ç¬¦ï¼Œæ•°å­—ï¼Œå¹¶å‘ˆçŽ°å‡ºæ¥ã€‚è¿™ä¸ªæ—¶å€™å°±éœ€è¦ä½¿ç”¨æ³›åž‹ Generic, ä¹Ÿå³é€šç”¨æ•°æ®ç±»åž‹ã€‚ Guiding principles. Welcome compile-time errors; avoid run-time errors. åœ¨2004å¹´ï¼ŒJavaçš„è®¾è®¡è€…åœ¨è¯­è¨€ä¸­åŠ å…¥äº†æ³›åž‹ï¼Œä½¿â€‹â€‹æˆ‘ä»¬èƒ½å¤Ÿåˆ›å»ºåŒ…å«ä»»ä½•å¼•ç”¨ç±»åž‹çš„æ•°æ®ç»“æž„ã€‚æ–¹æ³•å°±æ˜¯åœ¨ç±»å£°æ˜Žçš„ç±»ååŽé¢ï¼Œä½¿ç”¨ä¸€ä¸ªä»»æ„çš„å ä½ç¬¦ï¼Œå¹¶ç”¨å°–æ‹¬å·æ‹¬ä½&lt;éšä¾¿ä»€ä¹ˆå­—ç¬¦&gt;ã€‚ç„¶åŽï¼Œåœ¨ä»»ä½•ä½ æƒ³ä½¿ç”¨æ³›åž‹çš„åœ°æ–¹ï¼Œæ”¹ç”¨å ä½ç¬¦ã€‚1234567public class table &#123; public class table &#123; public int item; ... &#125; ...&#125; æ”¹ä¸º1234567public class table&lt;xxx&gt; &#123; public class table &#123; public xxx item; ... &#125; ...&#125; &lt;xxx&gt;é‡Œé¢çš„åç§°å¹¶ä¸é‡è¦, æ”¹æˆå…¶ä»–ä¹Ÿè¡Œ, åªæ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦, ç”¨æ¥æŽ¥å—å‚æ•°, å½“ç”¨æˆ·å®žä¾‹åŒ–è¿™ä¸ªç±»æ—¶, å¿…é¡»ä½¿ç”¨ç‰¹æ®Šçš„è¯­æ³•table&lt;String&gt; d = new table&lt;&gt;(&quot;hello&quot;); ç”±äºŽæ³›åž‹ä»…é€‚ç”¨äºŽå¼•ç”¨ç±»åž‹ï¼Œå› æ­¤æˆ‘ä»¬ä¸èƒ½å°†åŸºæœ¬ç±»åž‹intç­‰æ”¾åœ¨å°–æ‹¬å·å†…ã€‚ç›¸åï¼Œæˆ‘ä»¬ä½¿ç”¨åŸºæœ¬ç±»åž‹çš„å¼•ç”¨ç‰ˆæœ¬ï¼Œæ¯”å¦‚å¯¹äºŽint, ç”¨ Integerï¼Œtable&lt;Integer&gt; d = new table&lt;&gt;(&quot;10&quot;); æ€»ç»“ä½¿ç”¨æ–¹æ³•: åœ¨ä¸€ä¸ªå®žçŽ°æŸæ•°æ®ç»“æž„çš„.javaæ–‡ä»¶ä¸­ï¼Œåœ¨ç±»ååŽé¢, åªæŒ‡å®šæ³›åž‹ç±»åž‹ä¸€æ¬¡ã€‚ åœ¨å…¶ä»–ä½¿ç”¨è¯¥æ•°æ®ç»“æž„çš„javaæ–‡ä»¶ä¸­ï¼Œå£°æ˜Žå®žä¾‹å˜é‡æ—¶è¦æŒ‡å®šæ‰€éœ€çš„ç±»åž‹ã€‚ å¦‚æžœæ‚¨éœ€è¦åœ¨åŸºæœ¬ç±»åž‹ä¸Šå®žä¾‹åŒ–æ³›åž‹ï¼Œè¯·ä½¿ç”¨Integer, Double, Character, Boolean, Long, Short, Byte, Floatï¼Œè€Œä¸æ˜¯å…¶åŸºæœ¬ç±»åž‹ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 04 | ç±» class - 02 ç±»ä¸Žå®žä¾‹]]></title>
    <url>%2Fjava-04-02-class-instance%2F</url>
    <content type="text"><![CDATA[Classç±»çš„æ–¹æ³•å’Œå˜é‡ç»†åˆ†ä¸ºé™æ€çš„å’Œéžé™æ€çš„. é™æ€å°±æ˜¯å¯ä»¥è¢«ç±»è°ƒç”¨ï¼Œæ‰€ä»¥é™æ€æ–¹æ³•/å˜é‡ä¹Ÿç§°ä¹‹ä¸ºç±»æ–¹æ³•/å˜é‡ï¼›éžé™æ€åªèƒ½ç”±å®žä¾‹è°ƒç”¨ï¼Œæ‰€ä»¥ä¹Ÿç§°ä¹‹ä¸ºå®žä¾‹æ–¹æ³•/å˜é‡ã€‚ é™æ€å˜é‡ç±»å˜é‡ Class Variables æœ‰staticå£°æ˜Ž(é™æ€å˜é‡). é™æ€å˜é‡ä¸€èˆ¬æ˜¯ç±»æœ¬èº«å›ºæœ‰çš„å±žæ€§, è¢«è¯¥ç±»æ‰€æœ‰å®žä¾‹å…±äº«ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦ç”¨ç‹—ç±»çš„å¦ä¸€ç§ç”Ÿç‰©å­¦çš„ç»Ÿç§°â€œçŠ¬ç§‘â€æ¥ä½œä¸ºç±»çš„è¯´æ˜Žï¼Œ è¿™ä¸ªæ—¶å€™å¯ä»¥ç”¨public static String binomen = &quot;çŠ¬ç§‘&quot;;ï¼Œè¿™ä¸ªå˜é‡ç†è®ºä¸Šæ˜¯ç”±ç±»æ¥è®¿é—®çš„ã€‚é™æ€æ–¹æ³•ä¹Ÿç±»ä¼¼. ä»¥ä¸‹ä»£ç å®šä¹‰äº†ä¸€ä¸ªç±»æ¥æ¨¡æ‹Ÿç‹—ï¼ŒåŒ…å«ä¸€ä¸ªç±»å˜é‡ä½œä¸ºè¿™ä¸ªç±»çš„è¯´æ˜Žï¼Œä¸€ä¸ªç±»æ–¹æ³•ç”¨äºŽå‘å‡ºå«å£°ï¼š12345678public class Dog &#123; public static String instruction = "ç‹—ç±»å®žä¾‹"; //ç±»å˜é‡, è¯´æ˜Ž public static void makeNoise() &#123; System.out.println("æ±ª!"); &#125;&#125; è¿™é‡Œæ²¡æœ‰å®šä¹‰main(), åœ¨è¿™ç§æƒ…å†µä¸‹å¦‚ä½•ç›´æŽ¥è¿è¡Œè¿™ä¸ªç±»(java Dog), ç¨‹åºæ˜¯ä¼šæŠ¥é”™çš„123é”™è¯¯: åœ¨ç±» Dog ä¸­æ‰¾ä¸åˆ° main æ–¹æ³•, è¯·å°† main æ–¹æ³•å®šä¹‰ä¸º: public static void main(String[] args)å¦åˆ™ JavaFX åº”ç”¨ç¨‹åºç±»å¿…é¡»æ‰©å±•javafx.application.Application. ä½ å¯ä»¥é€‰æ‹©åœ¨é‡Œé¢æ·»åŠ ä¸€ä¸ªmain()æ–¹æ³•. ä½†è¿™æ¬¡æˆ‘ä»¬é€‰æ‹©ä¸å®šä¹‰å…·ä½“çš„main(). å…·ä½“è¦å¦‚ä½•è¿è¡Œ, æˆ‘ä»¬å¯ä»¥å¦å†™ä¸€ä¸ªç±»å®šä¹‰ä¸€ä¸ªmain()æ–¹æ³•æ¥è°ƒç”¨è¿™ä¸ªç±».12345public class DogLauncher &#123; public static void main(String[] args) &#123; Dog.makeNoise(); &#125;&#125; ç±»å˜é‡å’Œæ–¹æ³•æ˜¯æœ‰å±€é™æ€§çš„ã€‚çŽ°å®žä¸–ç•Œä¸­, å¹¶ä¸æ˜¯æ‰€æœ‰çš„ç‹—éƒ½æ˜¯ä¸€æ ·çš„ç‰¹å¾ï¼Œä»…ä»…é ç±»è¿™ä¸ªæ¦‚å¿µæ˜¯æ— æ³•åŒºåˆ†ä¸åŒä¸ªä½“çš„ç‹—, é™¤éžä½ ä¸ºä¸åŒçš„ç‹—å®šä¹‰ä¸åŒçš„ç±»ï¼ˆä»¥åŠé‡Œé¢çš„å˜é‡å’Œæ–¹æ³•ï¼‰, é‚£ä¹ˆå°±ä¼šå¾ˆç¹çç—›è‹¦. é™æ€å˜é‡åˆå§‹åŒ–é™æ€å˜é‡ä¼šåœ¨è¯¥ç±»çš„ä»»ä½•å¯¹è±¡åˆ›å»ºä¹‹å‰å°±å®Œæˆäº†åˆå§‹åŒ–.é™æ€å˜é‡ä¼šåœ¨è¯¥ç±»çš„ä»»ä½•é™æ€æ–¹æ³•æ‰§è¡Œä¹‹å‰å°±åˆå§‹åŒ–. primitiveä¸»æ•°æ®ç±»åž‹æ•´æ•°é»˜è®¤å€¼æ˜¯0, æµ®ç‚¹æ•°é»˜è®¤å€¼æ˜¯0.0, booleané»˜è®¤å€¼æ˜¯false, å¯¹è±¡å¼•ç”¨æ˜¯null. é™æ€çš„finalå˜é‡æ˜¯å¸¸æ•°: ä¸€ä¸ªè¢«æ ‡è®°finalçš„å˜é‡ä»£è¡¨ä¸€æ—¦è¢«åˆå§‹åŒ–ä¹‹åŽå°±ä¸ä¼šæ”¹åŠ¨. å¸¸æ•°å˜é‡çš„åç§°å…¨éƒ¨éƒ½è¦å¤§å†™. é™æ€finalå˜é‡å¿…é¡»åˆå§‹åŒ–åŽæ‰èƒ½ä½¿ç”¨, åˆå§‹åŒ–æœ‰ä¸¤ç§æ–¹æ³•: å£°æ˜Žæ—¶public class Foo { public static final int FOO_X = 25; } ä½¿ç”¨é™æ€åˆå§‹åŒ–ç¨‹åº 1234public class Bar &#123; public static final double BAR_SIGN; static &#123; BAR_SIGN = (double) Math.random(); &#125;&#125; å®žä¾‹åŒ…æ‹¬å®žä¾‹å˜é‡Instance Variables å’Œå®žä¾‹æ–¹æ³•Instance method. Javaçš„ç±»å®šä¹‰å°±åƒå®šä¹‰ä¸€å¼ è“å›¾, æˆ‘ä»¬å¯ä»¥åœ¨è¿™ä¸ªè“å›¾çš„åŸºç¡€ä¸Š, ç”Ÿæˆä¸åŒçš„å®žä¾‹instance. å®žä¾‹æ˜¯æ¦‚å¿µæ€§çš„è¯´æ³•ï¼Œæœ¬è´¨ä¸Šåœ¨Javaé‡Œå°±æ˜¯å¯¹è±¡objectã€‚è¿™æ ·çš„ç‰¹æ€§æä¾›äº†ä¸€ä¸ªå¾ˆè‡ªç„¶è€Œç„¶åœ°åœ¨javaä¸­æ¨¡æ‹Ÿç”Ÿæˆå®žä½“ä¸–ç•Œçš„æ–¹æ³•ï¼šå®šä¹‰ä¸€ä¸ªç‹—çš„ç±»ï¼Œåœ¨è¿™ä¸ªç±»çš„åŸºç¡€ä¸Šï¼Œé€šè¿‡ä¸åŒçš„ç‰¹å¾å‚æ•°å®žä¾‹åŒ–ä¸åŒç‰¹å¾çš„ç‹—ï¼ˆinstancesï¼‰ï¼Œå¹¶ä½¿ç±»æ–¹æ³•çš„è¾“å‡ºå–å†³äºŽç‰¹å®šå®žä¾‹çš„ç‹—çš„å±žæ€§ã€‚1234567891011121314/** ä¸€åªç‹—çš„ç±»:*/public class Dog &#123; public int weight; public void makeNoise() &#123; if (weight &lt; 10) &#123; System.out.println("å˜¤å˜¤å˜¤!"); &#125; else if (weight &lt; 30) &#123; System.out.println("æ±ªæ±ªæ±ª"); &#125; else &#123; System.out.println("å—·å‘œ!"); &#125; &#125;&#125; è¿™é‡Œçš„æ–¹æ³•å’Œå˜é‡æ²¡æœ‰static, æ‰€ä»¥æ˜¯å®žä¾‹ï¼ˆéžé™æ€ï¼‰æ–¹æ³•å’Œå˜é‡. å¦‚æžœç›´æŽ¥ç”¨ Dog ç±»æ¥è°ƒç”¨è¿™äº›æ–¹æ³•, ä¼šæŠ¥é”™:123456public class DogLauncher &#123; public static void main(String[] args) &#123; Dog.weight = 21; Dog.makeNoise(); &#125;&#125; 123456DogLauncher.java:3: é”™è¯¯: æ— æ³•ä»Žé™æ€ä¸Šä¸‹æ–‡ä¸­å¼•ç”¨éžé™æ€ å˜é‡ weight Dog.weight = 21; ^DogLauncher.java:4: é”™è¯¯: æ— æ³•ä»Žé™æ€ä¸Šä¸‹æ–‡ä¸­å¼•ç”¨éžé™æ€ æ–¹æ³• makeNoise() Dog.makeNoise(); ^ è¿™ä¸ªæ—¶å€™, ä½ éœ€è¦å®žä¾‹åŒ–ä¸€åªç‹—, è®©è¿™ä¸ªå®žä¾‹æ¥è°ƒç”¨éžé™æ€å˜é‡å’Œæ–¹æ³•:1234567public class DogLauncher &#123; public static void main(String[] args) &#123; Dog bigDog = new Dog(); bigDog.weight = 5; bigDog.makeNoise(); &#125;&#125; è¿è¡Œæ—¶ï¼Œè¿™ä¸ªç¨‹åºå°†ä¼šåˆ›å»ºä¸€ä¸ªé‡é‡ä¸º5çš„ç‹—ï¼Œè¿™ä¸ªç‹—å°±ä¼šâ€œå—·å‘œâ€å«ã€‚ è™½ç„¶Javaåœ¨æŠ€æœ¯ä¸Šå…è®¸ä½¿ç”¨å®žä¾‹å˜é‡æ¥è®¿é—®é™æ€å˜é‡æˆ–é™æ€æ–¹æ³•ï¼Œä½†åˆæ³•çš„ä¸ä¸€å®šæ˜¯å¥½çš„, è¿™æ ·ä¼šäº§ç”Ÿå®¹æ˜“è¯¯è§£çš„ä»£ç ï¼Œæ‰€ä»¥è¿˜æ˜¯å°‘ç”¨ä¸ºå¥½ã€‚ æ€»çš„æ¥è¯´ï¼Œä¹‹æ‰€ä»¥éœ€è¦å®žä¾‹æ–¹æ³•å’Œå˜é‡ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦æ¨¡æ‹Ÿä¸ªä½“ï¼Œä¸€åªå…·ä½“çš„ç‹—ï¼Œå¹¶è®©å®ƒå‘å‡ºå£°éŸ³ã€‚è¿™ä¸ªweightå’ŒmakeNoise()åªèƒ½ç”±å…·ä½“çš„ç‹—è°ƒç”¨ã€‚ç‹—ç±»ä¸èƒ½è°ƒç”¨ï¼Œä¹Ÿæ²¡æœ‰è°ƒç”¨çš„æ„ä¹‰, æ¯•ç«Ÿæ¯åªç‹—çš„é‡é‡å’Œå£°éŸ³éƒ½ä¸åŒçš„. åœ¨è®¾è®¡ç¨‹åºæ—¶, å¦‚æžœå…¶ä¸­ä¸€ä¸ªæ–¹æ³•æˆ‘ä»¬åªæ‰“ç®—è®©ç‰¹å®šçš„å®žä¾‹æ¥è°ƒç”¨å®ƒ(è€Œä¸è®©ç±»åŽ»è°ƒç”¨å®ƒ), é‚£ä¹ˆè¿™ä¸ªæ–¹æ³•åº”è¯¥è®¾è®¡æˆå®žä¾‹æ–¹æ³•ã€‚ é™æ€æ–¹æ³•ä¸Žå®žä¾‹æ–¹æ³•ç±»(é™æ€)æ–¹æ³•Class Methodsç”±ç±»è°ƒç”¨Dog.makeNoise();. é™æ€æ–¹æ³•æ— æ³•è°ƒç”¨å®žä¾‹å˜é‡. å¦åˆ™ä¼šæŠ¥é”™non-static variable size cannot be referenced from a static context. é™æ€æ–¹æ³•ä¸èƒ½è°ƒç”¨éžé™æ€çš„æ–¹æ³•: å³ä½¿éžé™æ€æ–¹æ³•ä¸­æ²¡æœ‰æ¶‰åŠå®žä¾‹å˜é‡, ä¹Ÿæ— æ³•é€šè¿‡ç¼–è¯‘, å› ä¸ºä¸èƒ½ä¿è¯æ•´ä¸ªéžé™æ€æ–¹æ³•åœ¨ä»¥åŽä¼šä¸ä¼šæ”¹åŠ¨æ¶‰åŠå®žä¾‹å˜é‡, æˆ–è€…å¦‚æžœå­ç±»åŽ»è¦†ç›–æ­¤æ–¹æ³•å¯èƒ½ä¼šç”¨åˆ°å®žä¾‹å˜é‡. å®žä¾‹æ–¹æ³•Instance Methodsåªèƒ½ç”±å®žä¾‹æ¥è°ƒç”¨bigDog.makeNoise();. å®žä¾‹æ–¹æ³•è®¿é—®æœ¬æˆå‘˜å˜é‡æ˜¯ä¸å—é™åˆ¶çš„, ä¹Ÿå°±æ˜¯å®ƒå¯ä»¥è®¿é—®é™æ€å˜é‡å’Œé™æ€æ–¹æ³•. å¯ä»¥çœ‹åˆ°å®žä¾‹æ–¹æ³•æ›´å…·ä½“, æ›´è´´è¿‘å®žä½“ä¸–ç•Œ, é‚£æˆ‘ä»¬ä»éœ€è¦é™æ€æ–¹æ³•, å› ä¸º: æœ‰äº›ç±»ä¸éœ€è¦å®žä¾‹åŒ–, æ¯•ç«Ÿæˆ‘ä»¬ä¹Ÿç»å¸¸éœ€è¦å¤„ç†æŠ½è±¡çš„æ¦‚å¿µ, è¿™äº›æŠ½è±¡æ¦‚å¿µåœ¨äººç±»è®¤çŸ¥èŒƒç•´å†…æ˜¯ç»Ÿä¸€çš„, æ¯”å¦‚Javaçš„MathåŒ…å«å¾ˆå¤šæ•°å­¦è¿ç®—çš„é™æ€æ–¹æ³•, è¿™æ˜¯å®¢è§‚è§„å¾‹ï¼Œæ¯”å¦‚x = Math.sqrt(100)ä¸ç®¡åˆ›å»ºå¤šå°‘ä¸ªå®žä¾‹ï¼Œæ•°å­¦è¿ç®—çš„ç»“æžœéƒ½æ˜¯ä¸€æ ·çš„, æ‰€ä»¥æ²¡å¿…è¦å®žä¾‹åŒ–æ¥æµªè´¹ç©ºé—´. æœ‰äº›ç±»æœ‰é™æ€æ–¹æ³•, æ˜¯æœ‰å®žé™…ä½œç”¨çš„ - æ¯ä¸ªå®žä¾‹éƒ½é€šç”¨çš„æ–¹æ³•ã€‚è‹¥æƒ³æ¯”è¾ƒä¸€ä¸ªç±»é‡Œé¢çš„ä¸åŒå®žä¾‹, æ¯”å¦‚ä¸¤åªç‹—çš„é‡é‡ã€‚æ¯”è¾ƒç®€å•çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªæ¯”è¾ƒç‹—çš„é‡é‡çš„ç±»æ–¹æ³•: 123456789public static Dog maxDog(Dog d1, Dog d2) &#123; if (d1.weight &gt; d2.weight) &#123; return d1; &#125; return d2;&#125;Dog d = new Dog(15);Dog d2 = new Dog(100);Dog.maxDog(d, d2); è¿™ä¸ªæ—¶å€™, è‹¥ä½¿ç”¨å®žä¾‹æ–¹æ³•ä¹Ÿå¯ä»¥, ä½†æ²¡é‚£ä¹ˆç›´è§‚ï¼š12345678910/** æˆ‘ä»¬ä½¿ç”¨å…³é”®å­—thisæ¥å¼•ç”¨å½“å‰å¯¹è±¡dã€‚*/public Dog maxDog(Dog d2) &#123; if (this.weight &gt; d2.weight) &#123; return this; &#125; return d2;&#125;Dog d = new Dog(15);Dog d2 = new Dog(100);d.maxDog(d, d2); å¦‚æžœä¸€ä¸ªç±»åªæœ‰é™æ€çš„æ–¹æ³•, å¯ä»¥å°†æž„é€ å‡½æ•°æ ‡è®°ä¸ºprivateä»¥é¿å…è¢«åˆå§‹åŒ–, å°±åƒJavaçš„Mathä¸€æ ·.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 04 | ç±» class - 03 åµŒå¥—ç±»]]></title>
    <url>%2Fjava-04-03-class-nested-class%2F</url>
    <content type="text"><![CDATA[åµŒå¥—ç±»æˆ‘ä»¬ç»å¸¸éœ€è¦åœ¨æŸä¸ªç±»Aä¸­ä½¿ç”¨å¦ä¸€ä¸ªç±»Bï¼Œå¦‚æžœè®¾è®¡æ—¶æˆ‘ä»¬çŸ¥é“ç±»Båªæœ‰åœ¨ç±»Aä¸­æœ‰è¢«ä½¿ç”¨çš„å¯èƒ½æ€§, é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æŠŠç±»Bå®šä¹‰åœ¨ç±»Aä¸­, ä½œä¸ºç±»Açš„åµŒå¥—ç±», ç±»Aå°±ç§°ä¹‹ä¸ºå¤–éƒ¨ç±». è¿™æ ·åšå¯ä»¥éšè—ç±»åï¼Œå‡å°‘å…¨å±€çš„æ ‡è¯†ç¬¦ï¼Œä»Žè€Œé™åˆ¶ç”¨æˆ·èƒ½å¦ä½¿ç”¨è¯¥ç±»å»ºç«‹å¯¹è±¡ã€‚è¿™æ ·å¯ä»¥æé«˜ç±»çš„æŠ½è±¡èƒ½åŠ›ï¼Œå¹¶ä¸”å¼ºè°ƒäº†ä¸¤ä¸ªç±»(å¤–å›´ç±»å’ŒåµŒå¥—ç±»)ä¹‹é—´çš„ä¸»ä»Žå…³ç³»ã€‚ A nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class. åµŒå¥—ç±»åˆ†ä¸ºä¸¤ç±»ï¼šé™æ€å’Œéžé™æ€ã€‚å£°æ˜Žä¸ºstaticçš„åµŒå¥—ç±»ç®€ç§°ä¸ºé™æ€åµŒå¥—ç±»ã€‚éžé™æ€åµŒå¥—ç±»ç§°ä¸ºå†…éƒ¨ç±»(inner class)ã€‚123456789class OuterClass &#123; ... static class StaticNestedClass &#123; ... &#125; class InnerClass &#123; ... &#125;&#125; ä½œä¸ºOuterClassçš„æˆå‘˜ï¼ŒåµŒå¥—ç±»å¯ä»¥å£°æ˜Žä¸ºprivateï¼Œpublicï¼Œprotectedæˆ–package privateã€‚å¤–éƒ¨ç±»åªèƒ½å£°æ˜Žä¸ºpublicæˆ–package privateã€‚æ›´å¤šè¯¦æƒ…å‚è€ƒå®˜ç½‘. å†…éƒ¨ç±»å†…éƒ¨ç±»å¯ä»¥ç›´æŽ¥è®¿é—®å¤–éƒ¨ç±»çš„æ–¹æ³•å’Œå˜é‡(å³ä½¿æ˜¯privateçš„ä¹Ÿå¯ä»¥)ã€‚å¦‚æžœä»Žå¤–éƒ¨ç±»ç¨‹åºä»£ç ä¸­åˆå§‹åŒ–å†…éƒ¨ç±», æ­¤å†…éƒ¨å¯¹è±¡ä¼šç»‘åœ¨è¯¥å¤–éƒ¨å¯¹è±¡ä¸Š. ä¸€ä¸ªå†…éƒ¨ç±»çš„å®žä¾‹ä½œä¸ºæˆå‘˜å­˜åœ¨äºŽæ‰€å±žå¤–éƒ¨ç±»çš„å®žä¾‹ä¸­ã€‚123456789101112131415161718public class Outer &#123; private int outVar; class Inner &#123; public int inVar; void go() &#123; outVar += inVar; &#125; &#125; Inner myInner = new Inner(); public void do() &#123; myInner.go(); &#125;&#125;public static void main(String[] args) &#123; Outer O = new Outer(); Outer.Inner I = O.new Inner();&#125; ä¹Ÿå¯ä»¥ä»Žå¤–éƒ¨ç±»ä¹‹å¤–çš„ç¨‹åºæ¥åˆå§‹åŒ–å¤–éƒ¨ç±»çš„å†…éƒ¨å®žä¾‹, è¯­æ³•æ¯”è¾ƒç‰¹æ®Š123456class Foo &#123; public static void main (String[] args) &#123; Outer A = new Outer(); Outer.Inner B = A.new Inner(); &#125;&#125; å› ä¸ºå†…éƒ¨ç±»ä¸Žä¸€ä¸ªå®žä¾‹ç›¸å…³è”ï¼Œæ‰€ä»¥å®ƒä¸èƒ½è‡ªå·±å®šä¹‰ä»»ä½•é™æ€æˆå‘˜ã€‚ å†…éƒ¨ç±»æä¾›åœ¨ä¸€ä¸ªç±»ä¸­å®žçŽ°åŒä¸€ä¸ªæŽ¥å£çš„å¤šæ¬¡æœºä¼š. ä½¿ç”¨äº†å†…éƒ¨ç±», å°±å¯ä»¥å¤šæ¬¡å®žçŽ°åŒä¸€ä¸ªæ–¹æ³•. é™¤æ­¤ä¹‹å¤–, æ›´é‡è¦çš„æ˜¯, å¦‚æžœå¤–éƒ¨ç±»å·²ç»ç»§æ‰¿äº†ä¸€ç§çˆ¶ç±», ä½†åˆéœ€è¦å®žçŽ°å…¶ä»–ç±»çš„è¡Œä¸º. å¦‚æžœåªéœ€è¦å®žçŽ°ä¸€æ¬¡, é‚£ä¹ˆå¯ä»¥ä½¿ç”¨å®žçŽ°æŽ¥å£, ä½†å¦‚æžœè¦å¤šæ¬¡å®žçŽ°æŸç§è¡Œä¸º, é‚£ä¹ˆå°±éœ€è¦ä¸€ä¸ªå†…éƒ¨ç±»æ¥åˆ›å»ºå¤šä¸ªå†…éƒ¨å®žä¾‹, å·²è¾¾æˆéœ€è¦å¤šæ¬¡å®žçŽ°çš„è¡Œä¸º. è€Œè¿™ä¸ªå†…éƒ¨ç±»æ˜¯ä¸å¤ªå¯èƒ½è¢«å…¶ä»–éžå¤–éƒ¨ç±»çš„ç±»ä½¿ç”¨çš„. è¿™ç§æƒ…å†µå¤šè§äºŽGUIçš„ä½¿ç”¨ä¸­. é™æ€åµŒå¥—ç±»å¦‚æžœåµŒå¥—ç±»ä¸éœ€è¦ä½¿ç”¨å¤–éƒ¨ç±»çš„ä»»ä½•å®žä¾‹æ–¹æ³•æˆ–å˜é‡ï¼Œé‚£å¯ä»¥å£°æ˜ŽåµŒå¥—ç±»ä¸ºstaticã€‚åƒé™æ€ç±»æ–¹æ³•ä¸€æ ·ï¼Œ é™æ€åµŒå¥—ç±»ä¸èƒ½ç›´æŽ¥å¼•ç”¨å…¶å¤–éƒ¨ç±»ä¸­å®šä¹‰çš„å®žä¾‹å˜é‡æˆ–æ–¹æ³•ã€‚å¤–éƒ¨ç±»ä¸èƒ½ç›´æŽ¥è®¿é—®é™æ€åµŒå¥—ç±»çš„æˆå‘˜å˜é‡ï¼Œè¦é€šè¿‡é™æ€åµŒå¥—ç±»æ¥è®¿é—®ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 04 | ç±» class - 01 å˜é‡å’Œæ–¹æ³•]]></title>
    <url>%2Fjava-04-01-class-intro%2F</url>
    <content type="text"><![CDATA[ClassJavaçš„è¯­æ³•æ˜¯ä¸ºäº†æ›´å®¹æ˜“åœ°æ¨¡æ‹ŸçœŸå®žä¸–ç•Œè€Œè®¾è®¡çš„. æ¯”å¦‚ç”¨ç¨‹åºå®žçŽ°ä¸€åªç‹—, å¯ä»¥ç”¨å®šä¹‰ä¸€ä¸ªç±»classæ¥æè¿°å®ƒ. ç±»classé‡Œé¢åŒ…æ‹¬å˜é‡Variableï¼Œæ–¹æ³•methodï¼ˆå¯ä»¥ç†è§£ä¸ºPythonçš„å‡½æ•°functionï¼‰ã€‚å˜é‡å¯ä»¥å‚¨å­˜æ•°æ®ï¼Œæ–¹æ³•å¯ä»¥å¤„ç†æ•°æ®ã€‚å˜é‡å¿…é¡»åœ¨ç±»ä¸­å£°æ˜Ž(å³ä¸èƒ½ç¦»å¼€ç±»ç‹¬ç«‹å­˜åœ¨)ï¼Œä¸åƒPythonæˆ–Matlabè¿™æ ·çš„è¯­è¨€å¯ä»¥åœ¨è¿è¡Œæ—¶æ·»åŠ æ–°çš„å˜é‡ã€‚ æž„é€ å¯¹è±¡çš„è¿‡ç¨‹: å£°æ˜Ž(declaration)å¼•ç”¨å˜é‡: Dog smalldog; åˆ›å»ºå¯¹è±¡ï¼šå®žä¾‹åŒ– new Dog(20), å¦‚æžœæ²¡æœ‰æŠŠå®ƒä½œä¸ºå€¼èµ‹ç»™ä¸€ä¸ªç±»å£°æ˜Žå˜é‡, é‚£ä¹ˆè¿™ä¸ªå®žä¾‹åŒ–çš„å€¼ä¼šè¢«åžƒåœ¾å›žæ”¶. è¿žæŽ¥å¯¹è±¡å’Œå¼•ç”¨ï¼šèµ‹å€¼å¯¹è±¡ç»™å¼•ç”¨Dog smalldog = new Dog(5) åˆ›å»ºå¯¹è±¡è¿™ä¸€æ­¥ï¼Œè°ƒç”¨äº†Dog(), ä¸æ˜¯æ™®é€šçš„æ–¹æ³•, è€Œæ˜¯ç±»çš„æž„é€ å‡½æ•° Constructors. æž„é€ å‡½æ•°æž„é€ å‡½æ•°åœ¨åˆå§‹åŒ–ä¸€ä¸ªå¯¹è±¡æ—¶æ‰§è¡Œ, æž„é€ å‡½æ•°ä¸Žç±»ååŒåä¸”æ²¡æœ‰è¿”å›žç±»åž‹, è€Œä¸”å¯ä»¥å¸¦å‚æ•°ï¼š12345/** æ³¨æ„ï¼šæž„é€ å‡½æ•°ä¸Žclassç±»åŒå ä½†æ²¡æœ‰è¿”å›žç±»åž‹ */public Dog(int w) &#123; weight = w;&#125; ç„¶åŽåœ¨DogLauncheré‡Œå®žä¾‹åŒ–ä¸€åªç‹—æ—¶, ç›´æŽ¥Dog d = new Dog(20);å³å¯. åœ¨ä»¥ä¸Šä»£ç çš„åŸºç¡€ä¸Š, åŽç»­å½“æˆ‘ä»¬æƒ³ä½¿ç”¨newå’Œå‚æ•°åˆ›å»ºä¸€åªç‹—æ—¶ï¼Œå¯ä»¥éšæ—¶è°ƒç”¨public Dog(int w)æž„é€ å‡½æ•°ã€‚å¯¹äºŽç†Ÿæ‚‰Pythonçš„äººæ¥è¯´ï¼Œä½ å¯ä»¥ç†è§£javaçš„æž„é€ å‡½æ•°ä¸ºPythonçš„__init__ã€‚ Javaå¯ä»¥æœ‰ä¸Žç±»åŒåçš„æ–¹æ³•ï¼Œåªæ˜¯è¦æŒ‡æ˜Žè¿”å›žç±»åž‹ã€‚æž„é€ å‡½æ•°æ— æ³•è¢«ç»§æ‰¿å¦‚æžœç±»æœ‰ä¸€ä¸ªä»¥ä¸Šçš„æž„é€ å‡½æ•°ï¼Œåˆ™å‚æ•°ä¸€å®šè¦ä¸ä¸€æ ·ï¼ŒåŒ…æ‹¬å‚æ•°é¡ºåºå’Œç±»åž‹ æž„é€ å‡½æ•°é“¾æ‰§è¡ŒnewæŒ‡ä»¤ä¼šå¯åŠ¨æž„é€ å‡½æ•°çš„è¿žé”ååº”(Constructor Chaining), é¦–å…ˆä¼šæ‰§è¡Œå…¶çˆ¶ç±»çš„æž„é€ å‡½æ•°, ä¾æ­¤ç±»æŽ¨è¿žé”ååº”åˆ°Objectç±»ä¸ºæ­¢. å°±ç®—æ˜¯æŠ½è±¡ç±», ä¹Ÿä¼šæœ‰æž„é€ å‡½æ•°, è™½ç„¶ä¸èƒ½è¢«ç›´æŽ¥å®žä¾‹åŒ–, ä½†ä¹Ÿä¼šè¢«å”¤é†’. ç†è®ºä¸Šï¼Œæ¯ä¸ªç±»çš„æž„é€ å‡½æ•°éœ€è¦å…ˆè°ƒç”¨å…¶çˆ¶ç±»çš„æž„é€ å‡½æ•°super()ï¼Œä¾æ¬¡å…¥æ ˆ1234567public class Duck extends Animal &#123; int size; public Duck(int newSize) &#123; super(); // è°ƒç”¨çˆ¶ç±»æž„é€ å‡½æ•°, ä¸”å¿…é¡»æ˜¯åœ¨å‡½æ•°ä¸­çš„ç¬¬ä¸€è¡Œ size = newSize; &#125;&#125; å¦‚æžœæ˜Žç¡®å†™äº†super();, åˆ™å¿…é¡»ä½äºŽæž„é€ å‡½æ•°ç¬¬ä¸€è¡Œ. ä½†å¾ˆå¤šæž„é€ å‡½æ•°æ²¡æœ‰å†™super();ä¹Ÿå¯ä»¥ç¼–è¯‘é€šè¿‡, ç”šè‡³è¿žè‡ªèº«çš„æž„é€ å‡½æ•°public Duck(int newSize)ä¹Ÿä¸ä¸€å®šæ˜¯å¿…é¡»çš„ã€‚ å¦‚æžœæ²¡æœ‰super(), ç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬åŠ ä¸Š. å¦‚æžœè¿žè‡ªèº«çš„æž„é€ å‡½æ•°éƒ½æ²¡æœ‰, ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ä¸ºæ²¡æœ‰æž„é€ å‡½æ•°çš„ç±»æä¾›ä¸€ä¸ªæ— å‚æ•°çš„é»˜è®¤æž„é€ å‡½æ•°ã€‚è¿™ä¸ªé»˜è®¤æž„é€ å‡½æ•°å°†è°ƒç”¨å…¶è¶…ç±»çš„ï¼ˆå¯è°ƒç”¨çš„ï¼‰æ— å‚æž„é€ å‡½æ•°ã€‚ æ­¤æ—¶, å¦‚æžœå…¶extendsçš„çˆ¶ç±»æ²¡æœ‰æ— å‚æ•°æž„é€ å‡½æ•°ï¼Œç¼–è¯‘ä¼šå‡ºé”™ã€‚ å¦‚æžœæ²¡æœ‰æ˜¾å¼çš„è¶…ç±»ï¼Œé‚£ä¹ˆå°±è°ƒç”¨éšå¼çš„è¶…ç±»Objectçš„æ— å‚æž„é€ å‡½æ•°ã€‚ ä½†å¦‚æžœåœ¨ç±»ä¸­å·²ç»å®žçŽ°äº†å¸¦å‚æ•°çš„æž„é€ å‡½æ•°ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¸ä¼šå†å¸®ä½ æž„é€ æ— å‚æ•°çš„æž„é€ å‡½æ•°ï¼Œä½ éœ€è¦è‡ªå·±ç¼–å†™ã€‚å¦‚æžœæŸä¸ªçˆ¶ç±»åªæœ‰å¸¦å‚æ•°çš„æž„é€ å‡½æ•°, é‚£ä¹ˆç»§æ‰¿è¯¥çˆ¶ç±»çš„å­ç±»å¿…é¡»æœ‰æž„é€ å‡½æ•°, ä¸”è¦æœ‰å¸¦å‚æ•°çš„super(args). å¦‚æžœå­˜åœ¨ä¸åŒé‡è½½ç‰ˆæœ¬çš„æž„é€ å‡½æ•°, å…¶ä¸­æœ‰æŸä¸ªæž„é€ å‡½æ•°å¯ä»¥è´Ÿè´£å¤§éƒ¨åˆ†æž„é€ å·¥ä½œ, æˆ‘ä»¬è¿™ä¸ªæ—¶å€™è‚¯å®šå¸Œæœ›èƒ½å¤Ÿè®©åŒç±»çš„å…¶ä»–æž„é€ å‡½æ•°å…ˆè°ƒç”¨è¯¥æž„é€ å‡½æ•°, å®Œæˆå¤§éƒ¨åˆ†æž„é€ å·¥ä½œ, å·²è¾¾åˆ°ä»£ç é‡ç”¨çš„ç›®çš„, è¿™æ ·å¯ä»¥æ›´å¥½åœ°ç»´æŠ¤ä»£ç . this()å°±æ˜¯ç”¨æ¥ä»ŽæŸä¸ªæž„é€ å‡½æ•°ä¸­è°ƒç”¨åŒä¸€ä¸ªç±»çš„å¦å¤–ä¸€ä¸ªæž„é€ å‡½æ•°.1234567891011class Mini extends Car &#123; Color color;// è¿™é‡Œæ— å‚æ•°çš„æž„é€ å‡½æ•°ä½¿ç”¨é»˜è®¤é¢œè‰²è°ƒç”¨é˜µé˜µçš„æž„é€ å‡½æ•° public Mini() &#123; this(Color.Red); &#125; public Mini(Color c) &#123; super("Mini"); color = c; &#125;&#125; this()åªèƒ½å­˜åœ¨äºŽæž„é€ å‡½æ•°ä¸­, ä¸”å¿…é¡»è¦åœ¨ç¬¬ä¸€è¡Œ, æ‰€ä»¥ä¼šè·Ÿsuper()å†²çª, äºŒè€…ä¸èƒ½åŒæ—¶è°ƒç”¨.]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 03 | ä»£ç é£Žæ ¼ æ³¨é‡Š Javadoc]]></title>
    <url>%2Fjava-03-code-style-comments%2F</url>
    <content type="text"><![CDATA[ä»£ç é£Žæ ¼ä¸Žæ³¨é‡ŠåŠªåŠ›ä¿æŒä»£ç å¯è¯»æ€§ã€‚è‰¯å¥½çš„ç¼–ç é£Žæ ¼çš„ä¸€äº›æœ€é‡è¦çš„ç‰¹ç‚¹æ˜¯ï¼š ä¸€è‡´çš„é£Žæ ¼ï¼ˆé—´è·ï¼Œå˜é‡å‘½åï¼Œç¼©è¿›é£Žæ ¼ç­‰ï¼‰ å¤§å°ï¼ˆçº¿ä¸å¤ªå®½ï¼Œæºæ–‡ä»¶ä¸è¦å¤ªé•¿ï¼‰ æè¿°æ€§å‘½åï¼ˆå˜é‡ï¼Œå‡½æ•°ï¼Œç±»ï¼‰ï¼Œä¾‹å¦‚å˜é‡æˆ–å‡½æ•°åç§°ä¸ºå¹´ä»½æˆ–getUserNameè€Œä¸æ˜¯xæˆ–fã€‚è®©ä»£ç æœ¬èº«æä¾›å¯è§£è¯»æ€§ã€‚ é¿å…é‡å¤çš„ä»£ç ï¼šè‹¥æœ‰ä¸¤ä¸ªé‡è¦çš„ä»£ç å—åŠå…¶ç›¸ä¼¼ï¼Œåº”è¯¥æƒ³åŠžæ³•åˆå¹¶ã€‚ é€‚å½“çš„è¯„è®º, ä½¿å…¶ä»–è¯»è€…ä¹Ÿèƒ½è½»æ¾ç†è§£ä½ çš„ä»£ç  è¡Œæ³¨é‡Š: //åˆ†éš”ç¬¦å¼€å¤´è¡Œè¢«å½“åšæ³¨é‡Šã€‚ Blockï¼ˆåˆåå¤šè¡Œæ³¨é‡Šï¼‰æ³¨é‡Š: /*, */, ä½†æˆ‘ä»¬æ›´æŽ¨èjavadocå½¢å¼çš„æ³¨é‡Šã€‚ JavadocJavadoc: / **ï¼Œ*/, å¯ä»¥ï¼ˆä½†ä¸æ€»æ˜¯ï¼‰åŒ…å«æè¿°æ€§æ ‡ç­¾ã€‚ å€ŸåŠ©javadocå·¥å…·å¯ä»¥ç”ŸæˆHTMLæ ¼å¼çš„APIæ–‡æ¡£ã€‚ç¬¬ä¸€æ®µæ˜¯æ–¹æ³•çš„æè¿°ã€‚æè¿°ä¸‹é¢æ˜¯ä¸åŒçš„æè¿°æ€§æ ‡ç­¾, æ¯”å¦‚å‚æ•° @paramï¼Œ è¿”å›žå€¼ @returnï¼Œ å¯èƒ½æŠ›å‡ºçš„ä»»ä½•å¼‚å¸¸ @throws123456789/** * @author åå­—ï¼Œé‚®ç®±&lt;address @ example.com&gt; * @version 1.6 ç‰ˆæœ¬ * @param * @return */public class Test &#123; // class body&#125;]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 02 | è¯­æ³•åŸºç¡€]]></title>
    <url>%2Fjava-02-basic-syntax%2F</url>
    <content type="text"><![CDATA[JavaåŸºæœ¬è¯­æ³•12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello world!"); &#125;&#125; ä¸Šé¢çš„ç¨‹åºç”±ä¸€ä¸ªç±»å£°æ˜Žç»„æˆï¼Œè¯¥å£°æ˜Žä½¿ç”¨å…³é”®å­—public classå£°æ˜Žã€‚ Javaæ‰€æœ‰çš„ä»£ç éƒ½åº”è¯¥åŒ…å«åœ¨classé‡Œé¢ã€‚ çœŸæ­£è´Ÿè´£è¿è¡Œçš„ä»£ç ï¼Œæ˜¯ä¸€ä¸ªåä¸ºmainçš„methodï¼Œå®ƒå£°æ˜Žä¸ºpublic static void main(String[] args)ã€‚ publicï¼šå…¬å…±çš„ï¼Œå¤§éƒ¨åˆ†æ–¹æ³•éƒ½æ˜¯ä»¥è¿™ä¸ªå…³é”®å­—å¼€å§‹çš„ï¼ŒåŽé¢ä¼šè¿›ä¸€æ­¥è§£é‡Šã€‚ staticï¼šè¿™æ˜¯ä¸€ä¸ªé™æ€æ–¹æ³•ï¼Œä¸ä¸Žä»»ä½•ç‰¹å®šçš„å®žä¾‹å…³è”ï¼ŒåŽé¢ä¼šè§£é‡Šã€‚ voidï¼šå®ƒæ²¡æœ‰è¿”å›žç±»åž‹ã€‚ mainï¼šè¿™æ˜¯æ–¹æ³•çš„åç§°ã€‚ String [] argsï¼šè¿™æ˜¯ä¼ é€’ç»™mainæ–¹æ³•çš„å‚æ•°ã€‚ ä½¿ç”¨å¤§æ‹¬å·{ }æ¥è¡¨ç¤ºä¸€æ®µä»£ç çš„å¼€å§‹å’Œç»“æŸã€‚ å£°æ˜Žå¿…é¡»ä»¥åˆ†å·ç»“å°¾ é™æ€åˆ†ç±»Static Typing ç¨‹åºè¯­è¨€é™æ€ä¸ŽåŠ¨æ€çš„åˆ†ç±»ï¼Œå¯ä»¥å‚è€ƒoracleçš„è¯´æ˜Žæ–‡ä»¶ï¼Œå®ƒè§£é‡Šäº†åŠ¨æ€å’Œé™æ€ç±»åž‹ä¹‹é—´çš„åŒºåˆ«, å¸®åŠ©ä½ ç†è§£ç”±ç¨‹åºçš„é”™è¯¯æç¤ºä¿¡æ¯ã€‚ä¸¤ä¸ªä¸»è¦åŒºåˆ«:1. åŠ¨æ€ç±»åž‹è¯­è¨€åœ¨è¿è¡Œæ—¶æ‰§è¡Œç±»åž‹æ£€æŸ¥ï¼Œè€Œé™æ€ç±»åž‹è¯­è¨€åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œç±»åž‹æ£€æŸ¥ã€‚è¿™æ„å‘³å¦‚æžœä»¥é™æ€ç±»åž‹è¯­è¨€ï¼ˆå¦‚Javaï¼‰ç¼–å†™çš„è„šæœ¬åŒ…å«é”™è¯¯ï¼Œåˆ™åœ¨ç¼–è¯‘é”™è¯¯ä¹‹å‰å°†æ— æ³•ç¼–è¯‘. è€Œç”¨åŠ¨æ€ç±»åž‹è¯­è¨€ç¼–å†™çš„è„šæœ¬å¯ä»¥ç¼–è¯‘ï¼Œå³ä½¿å®ƒä»¬åŒ…å«ä¼šé˜»æ­¢è„šæœ¬æ­£å¸¸è¿è¡Œï¼ˆå¦‚æžœæœ‰çš„è¯ï¼‰çš„é”™è¯¯ã€‚2. é™æ€ç±»åž‹è¯­è¨€è¦æ±‚ä½ åœ¨ä½¿ç”¨å®ƒä»¬ä¹‹å‰å£°æ˜Žå˜é‡çš„æ•°æ®ç±»åž‹ï¼Œè€ŒåŠ¨æ€ç±»åž‹è¯­è¨€åˆ™ä¸éœ€è¦ã€‚è€ƒè™‘ä»¥ä¸‹ä¸¤ä¸ªä»£ç ç¤ºä¾‹ï¼š123// Javaint num;num = 5; 12# Pythonnum = 5 è¿™ä¸¤æ®µä»£ç éƒ½åˆ›å»ºä¸€ä¸ªåä¸ºnumçš„å˜é‡å¹¶èµ‹å€¼ä¸º5. ä¸åŒä¹‹å¤„åœ¨äºŽJavaéœ€è¦å°†numçš„æ•°æ®ç±»åž‹æ˜Žç¡®å®šä¹‰ä¸ºintã€‚å› ä¸ºJavaæ˜¯é™æ€ç±»åž‹çš„ï¼Œå› æ­¤å®ƒæœŸæœ›å˜é‡åœ¨è¢«èµ‹å€¼ä¹‹å‰è¢«å£°æ˜Žã€‚ Pythonæ˜¯åŠ¨æ€ç±»åž‹çš„ï¼Œä¸éœ€è¦å®šä¹‰ç±»åž‹, Pythonæ ¹æ®å˜é‡çš„å€¼ç¡®å®šå…¶æ•°æ®ç±»åž‹ã€‚åŠ¨æ€ç±»åž‹è¯­è¨€æ›´åŠ çµæ´»ï¼Œåœ¨ç¼–å†™è„šæœ¬æ—¶å¯ä»¥èŠ‚çœæ—¶é—´å’Œç©ºé—´ã€‚ä½†æ˜¯ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´è¿è¡Œæ—¶å‡ºçŽ°é—®é¢˜ã€‚ä¾‹å¦‚ï¼š123# pythonnumber = 5numbr = (number + 15) / 2 #æ³¨æ„é”™å­— ä¸Šé¢çš„ä»£ç æœ¬åº”åˆ›å»ºä¸€ä¸ªå€¼ä¸º5çš„å¯å˜æ•°å­—ï¼Œç„¶åŽå°†å…¶åŠ ä¸Š15å¹¶é™¤ä»¥2ä»¥å¾—åˆ°10. ä½†æ˜¯ï¼Œnumberåœ¨ç¬¬äºŒè¡Œçš„å¼€å¤´æ‹¼å†™é”™è¯¯ã€‚ç”±äºŽPythonä¸éœ€è¦å£°æ˜Žå˜é‡ï¼Œå› æ­¤ä¼šä¸ç”±åˆ†è¯´ç›´æŽ¥åˆ›å»ºä¸€ä¸ªåä¸ºnumbrçš„æ–°å˜é‡ï¼Œå¹¶æŠŠæœ¬åº”åˆ†é…ç»™numberçš„å€¼åˆ†é…ç»™å®ƒã€‚è¿™æ®µä»£ç ä¼šå¾ˆé¡ºåˆ©ç¼–è¯‘ï¼Œä½†æ˜¯å¦‚æžœç¨‹åºè¯•å›¾ç”¨numberæ¥åšæŸäº‹ï¼Œç¨‹åºå‘˜å‡è®¾å®ƒçš„å€¼æ˜¯10ï¼Œé‚£ä¹ˆåŽç»­å°±æ— æ³•äº§ç”ŸæœŸæœ›çš„ç»“æžœ,è€Œä¸”è¿˜å¾ˆéš¾æ³¨æ„åˆ°é—®é¢˜ã€‚ Javaçš„compilerå…¶ä¸­ä¸€ä¸ªå…³é”®ä½œç”¨æ˜¯è¿›è¡Œé™æ€ç±»åž‹æ£€æŸ¥ï¼ˆstatic type checkï¼‰ã€‚è‹¥å‰é¢å®šä¹‰äº† int x = 0;, é‚£ä¹ˆåŽé¢è‹¥ç»™xèµ‹å€¼å…¶ä»–çš„ç±»åž‹å€¼x = &#39;horse&#39;;, compilerå°±ä¼šæŠ¥é”™. è¿™æ ·å°±ä¿è¯äº†ç¨‹åºä¸ä¼šå‡ºçŽ°ç±»åž‹é”™è¯¯. é™¤äº†é”™è¯¯æ£€æŸ¥å¤–, static types ä¹Ÿå¯ä»¥è®©ç¨‹åºåª›/çŒ¿çŸ¥é“è‡ªå·±å¤„çš„æ˜¯ä»€ä¹ˆå¯¹è±¡. æ€»è€Œè¨€ä¹‹ï¼Œé™æ€ç±»åž‹å…·æœ‰ä»¥ä¸‹ä¼˜ç‚¹ï¼š ç¼–è¯‘å™¨ç¡®ä¿æ‰€æœ‰ç±»åž‹éƒ½æ˜¯å…¼å®¹çš„ï¼Œè¿™ä½¿å¾—ç¨‹åºå‘˜æ›´å®¹æ˜“è°ƒè¯•ä»–ä»¬çš„ä»£ç ã€‚ ç”±äºŽä»£ç ä¿è¯æ²¡æœ‰ç±»åž‹é”™è¯¯ï¼Œæ‰€ä»¥ç¼–è¯‘åŽç¨‹åºçš„ç”¨æˆ·å°†æ°¸è¿œä¸ä¼šé‡åˆ°ç±»åž‹é”™è¯¯ã€‚ä¾‹å¦‚ï¼ŒAndroidåº”ç”¨ç¨‹åºæ˜¯ç”¨Javaç¼–å†™çš„ï¼Œé€šå¸¸ä»…ä»¥.classæ–‡ä»¶çš„å½¢å¼åˆ†å‘ï¼Œå³ä»¥ç¼–è¯‘çš„æ ¼å¼ã€‚å› æ­¤ï¼Œè¿™æ ·çš„åº”ç”¨ç¨‹åºä¸åº”è¯¥ç”±äºŽç±»åž‹é”™è¯¯è€Œå´©æºƒã€‚ æ¯ä¸ªå˜é‡ï¼Œå‚æ•°å’Œå‡½æ•°éƒ½æœ‰ä¸€ä¸ªå£°æ˜Žçš„ç±»åž‹ï¼Œä½¿ç¨‹åºå‘˜æ›´å®¹æ˜“ç†è§£å’ŒæŽ¨ç†ä»£ç ã€‚]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 01 | å®‰è£…]]></title>
    <url>%2Fjava-01-install%2F</url>
    <content type="text"><![CDATA[Hello Worldå‚è€ƒäº†ä¼¯å…‹åˆ© Josh Hug çš„ cs61b spring 2017 å’Œ cs61b spring 2018. Lab, homework å’Œ project ä»£ç å®žçŽ°å‚è€ƒ https://github.com/ShootingSpace/cs61b-data-structures. Javaå®‰è£…ä¸Žé…ç½®å®‰è£…Javaï¼Œå‰å¾€Oracleä¸‹è½½java sdkï¼Œæˆ‘ç”¨çš„æ˜¯Java SE 8u151/ 8u152 ç‰ˆæœ¬ã€‚å®‰è£…sdkæ—¶ä¼šåŒæ—¶å®‰è£…sdrã€‚ Windowsç³»ç»Ÿé…ç½®: æŽ¨èå®‰è£…git bash, ä¸€åˆ‡æŒ‰ç…§é»˜è®¤å®‰è£…å°±å¥½. æ›´æ–°ç³»ç»ŸçŽ¯å¢ƒå˜é‡: ç›´æŽ¥åœ¨è¿è¡Œä¸­æœç´¢Environment Variables, é€‰æ‹©ç¼–è¾‘ç³»ç»ŸçŽ¯å¢ƒå˜é‡, åœ¨å¼¹å‡ºçš„æ¡†ä¸­é€‰æ‹©é«˜çº§-&gt;çŽ¯å¢ƒå˜é‡, åœ¨å¼¹å‡ºçš„æ¡†ä¸­ç³»ç»Ÿå˜é‡é‡Œé¢ æ–°å»ºå˜é‡: å˜é‡å = JAVA_HOME, å˜é‡å€¼ = ä½ çš„jdkè·¯å¾„,å¦‚C:\Program Files\Java\jdk1.8.0_151 ç¼–è¾‘Path: åœ¨å‰é¢åŠ å…¥%JAVA_HOME%\bin;%PYTHON_HOME%;(è¯·æ³¨æ„ï¼Œä¸èƒ½æœ‰ç©ºæ ¼.) OS Xç³»ç»Ÿé…ç½®: å®‰è£…Homebrewï¼Œä¸€ä¸ªéžå¸¸å¥½ç”¨çš„åŒ…ç®¡ç†å·¥å…·ã€‚è¦å®‰è£…ï¼Œè¯·åœ¨terminalç»ˆç«¯è¾“å…¥ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;(æ³¨æ„ï¼šåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šæç¤ºè¾“å…¥å¯†ç ã€‚å½“è¾“å…¥å¯†ç æ—¶ï¼Œç»ˆç«¯ä¸Šä¸ä¼šæ˜¾ç¤ºä»»ä½•å†…å®¹ï¼Œä½†è®¡ç®—æœºè¿˜æ˜¯ä¼šè®°å½•ä½ çš„å¯†ç çš„ã€‚è¿™æ˜¯ä¸€ä¸ªå®‰å…¨æŽªæ–½, è®©å…¶ä»–äººåœ¨å±å¹•ä¸Šçœ‹ä¸åˆ°ä½ çš„å¯†ç ã€‚åªéœ€è¾“å…¥æ‚¨çš„å¯†ç ï¼Œç„¶åŽæŒ‰å›žè½¦ã€‚) ç„¶åŽï¼Œé€šè¿‡è¾“å…¥ä»¥ä¸‹å‘½ä»¤æ¥æ£€æŸ¥brewç³»ç»Ÿæ˜¯å¦æ­£å¸¸å·¥ä½œbrew doctor. å¦‚æžœé‡åˆ°è­¦å‘Šï¼Œè¦æ±‚ä¸‹è½½å‘½ä»¤è¡Œå·¥å…·ï¼Œåˆ™éœ€è¦æ‰§è¡Œæ­¤æ“ä½œã€‚è¯·å‚è€ƒè¿™ä¸ªStackOverflowã€‚ å®‰è£…gitï¼šè¾“å…¥brew install git å®‰è£…å¹¶é…ç½®å¥½javaåŽï¼Œæµ‹è¯•æ˜¯å¦æˆåŠŸ:éšä¾¿åœ¨ä½ å–œæ¬¢çš„æ–‡ä»¶å¤¹é‡Œæ–°å»ºä¸€ä¸ªjavaæ–‡ä»¶HelloWorld.java12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello world!"); &#125;&#125; ä½ å¯ä»¥é€‰æ‹©ç”¨sublimeæ¥å¿«é€Ÿæ–°å»ºæ–‡ä»¶, ç›´æŽ¥åœ¨ä½ é€‰æ‹©çš„æ–‡ä»¶é‡Œå³é”® git bash, åœ¨git bash é‡Œé¢é”®å…¥subl HelloWorld.java, è¿˜è‡ªåŠ¨å¯åŠ¨sublimeå¹¶æ–°å»ºä¸€ä¸ªç©ºç™½çš„HelloWorld.javaæ–‡ä»¶, æŠŠä¸Šé¢çš„ä»£ç å¤åˆ¶è¿›åŽ»å¹¶ä¿å­˜å³å¯. (è‹¥å‡ºçŽ°ç±»ä¼¼æç¤º: æ‰¾ä¸åˆ°subl command, è§£å†³åŠžæ³•è¯·å‚è€ƒåšæ–‡åœ¨Gitbashä¸­ç›´æŽ¥å¯åŠ¨sublimeæˆ–atomç­‰ç¼–è¾‘å™¨ä»¥æ‰“å¼€æˆ–æ–°å»ºæ–‡ä»¶ )å¼€å§‹çœŸæ­£çš„æµ‹è¯•ã€‚ç›´æŽ¥åœ¨ä¹‹å‰æ‰“å¼€çš„git bashä¸­è¾“å…¥: ls, ä¼šçœ‹åˆ°HelloWorld.javaè¿™ä¸ªæ–‡ä»¶, lsä¼šåˆ—å‡ºè¿™ä¸ªç›®å½•ä¸­çš„æ–‡ä»¶/æ–‡ä»¶å¤¹ javac HelloWorld.java, ç†è®ºä¸Šè¿™ä¸€æ­¥ä¸ä¼šæœ‰ä»»ä½•è¾“å‡ºï¼Œæœ‰çš„è¯å¯èƒ½æ˜¯è®¾ç½®æœ‰é—®é¢˜ã€‚çŽ°åœ¨ï¼Œå¦‚æžœä½ ç»§ç»­lsï¼Œä¼šçœ‹åˆ°å¤šäº†ä¸€ä¸ªHelloWorld.classæ–‡ä»¶ï¼Œ è¿™æ˜¯javacåˆ›å»ºçš„ã€‚ java HelloWorld (æ³¨æ„æ²¡æœ‰.java), ä¼šçœ‹åˆ°è¾“å‡ºHello World, è¡¨æ˜Žä½ çš„Javaè®¾ç½®æ²¡æœ‰é—®é¢˜]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>cs61b</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Note - cs229 - Stanford]]></title>
    <url>%2Fmachine-learning%2F</url>
    <content type="text"><![CDATA[å‚è€ƒCS229: Machine Learning, Stanford ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ï¼Ÿç›®å‰æœ‰ä¸¤ä¸ªå®šä¹‰ã€‚ äºšç‘ŸÂ·å¡žç¼ªå°”ï¼ˆArthur Samuelï¼‰å°†å…¶æè¿°ä¸ºï¼šâ€œä¸éœ€è¦é€šè¿‡å…·ä½“çš„ç¼–ç¨‹ï¼Œä½¿è®¡ç®—æœºèƒ½å¤Ÿå­¦ä¹ â€ã€‚è¿™æ˜¯ä¸€ä¸ªè¾ƒè€çš„ï¼Œéžæ­£å¼çš„å®šä¹‰ã€‚ æ±¤å§†Â·ç±³åˆ‡å°”ï¼ˆTom Mitchellï¼‰æä¾›äº†ä¸€ä¸ªæ›´çŽ°ä»£çš„å®šä¹‰ï¼šEï¼šç»éªŒï¼Œå³åŽ†å²çš„æ•°æ®é›†ã€‚Tï¼šæŸç±»ä»»åŠ¡ã€‚Pï¼šä»»åŠ¡çš„ç»©æ•ˆè¡¡é‡ã€‚è‹¥è¯¥è®¡ç®—æœºç¨‹åºé€šè¿‡åˆ©ç”¨ç»éªŒEåœ¨ä»»åŠ¡Tä¸ŠèŽ·å¾—äº†æ€§èƒ½Pçš„æ”¹å–„ï¼Œåˆ™ç§°è¯¥ç¨‹åºå¯¹Eè¿›è¡Œäº†å­¦ä¹ â€œå¦‚æžœè®¡ç®—æœºç¨‹åºèƒ½å¤Ÿåˆ©ç”¨ç»éªŒEï¼Œæå‡å®žçŽ°ä»»åŠ¡Tçš„æˆç»©Pï¼Œåˆ™å¯ä»¥è®¤ä¸ºè¿™ä¸ªè®¡ç®—æœºç¨‹åºèƒ½å¤Ÿä»Žç»éªŒEä¸­å­¦ä¹ ä»»åŠ¡Tâ€ã€‚ä¾‹å¦‚ï¼šçŽ©è·³æ£‹ã€‚E =çŽ©è®¸å¤šæ£‹å­æ¸¸æˆçš„ç»éªŒï¼ŒT = çŽ©è·³æ£‹çš„ä»»åŠ¡ã€‚P = ç¨‹åºå°†èµ¢å¾—ä¸‹ä¸€åœºæ¯”èµ›çš„æ¦‚çŽ‡ã€‚ Supervised LearningLinear Regression Weights(parameters) Î¸: parameterizing the space of linear functions mapping from X to Y Intercept term: to simplify notation, introduce the convention of letting x0 = 1 Cost function J(Î¸): a function that measures, for each value of the Î¸â€™s, how close the h(x(i))â€™s are to the corresponding y(i)â€™s Purpose: to choose Î¸ so as to minimize J(Î¸). Implementation: By using a search algorithm that starts with some â€œinitial guessâ€ for Î¸, and that repeatedly changes Î¸ to make J(Î¸) smaller, until hopefully we converge to a value of Î¸ that minimizes J(Î¸). LMS(least mean squares) algorithm: gradient descent learning rate error term batch gradient descentï¼šlooks at every example in the entire training set on every step stochastic gradient descent(incremental gradient descent)ï¼šrepeatedly run through the training set, and each time we encounter a training example, we update the parameters according tothe gradient of the error with respect to that single training example only. particularly when the training set is large, stochastic gradient descent is often preferred over batch gradient descent. The normal equationsperforming the minimization explicitly and without resorting to an iterative algorithm. In this method, we will minimize J by explicitly taking its derivatives with respect to the Î¸jâ€™s, and setting them to zero.To enable us to do this without having to write reams of algebra and pages full of matrices of derivatives, letâ€™s introduce some notation for doing calculus with matrices Matrix derivatives: the gradient âˆ‡Af(A) is itself an m-by-n matrix, whose (i, j)-element is âˆ‚f/âˆ‚Aij Least squares revisited: Given a training set, define the design matrix X to be the m-by-n matrix (actually m-by-n + 1, if we include the intercept term) that contains the training examplesâ€™ input values in its rows, let y be the m-dimensional vector containing all the target values from the training set, used the fact that the trace of a real number is just the real number( trace operator, written â€œtr.â€ For an n-by-n matrix A, the trace of A is defined to be the sum of its diagonal entries: trA = Î£Aii To minimize J, find its derivatives with respect to Î¸: âˆ‡Î¸J(Î¸) = XTXÎ¸ âˆ’ XTy To minimize J, we set its derivatives to zero, and obtain the normal equations: XTXÎ¸ = XTy Thus the value of Î¸ that minimizes J(Î¸) is given in closed form by the equation: Î¸ = (XTX)-1XTy Probabilistic interpretationwhy the least-squares cost function J is a reasonable choice? With a set a probabilistic assumptions, under which least-squares regression is derived as a very natural algorithm. Locally weighted linear regression (LWR) algorithmassuming there is sufficient training data, makes the choice of features less critical. In the original linear regression algorithm, to make a prediction at a query point x (i.e., to evaluate h(x)), we would: Fit Î¸ to minimize Î£i(y(i) âˆ’ Î¸Tx(i))2. Output Î¸Tx. The locally weighted linear regression algorithm does the following: Fit Î¸ to minimize Î£iw(i)(y(i) âˆ’ Î¸Tx(i))2. Output Î¸Tx. Here, the w(i)â€™s are non-negative valued weights Intuitively, if w(i) is large for a particular value of i, then in picking Î¸, weâ€™ll try hard to make (y(i) âˆ’ Î¸Tx(i))2 small. If w(i) is small, then the error term will be pretty much ignored in the fit. A fairly standard choice for the weights is w(i) = exp(-(x(i)-x)2 / 2Ï„2 ) if |x(i)-x| is small, then w(i) â‰ˆ 1; if large, then w(i) is small. Hence, Î¸ is chosen giving a much higher â€œweightâ€ to the (errors on) training examples close to the query point x. The parameter Ï„ controls how quickly the weight of a training example falls off with distance of its x(i), from the query point x; Ï„ is called the bandwidth parameter Classification and logistic regressionLogistic regression logistic function or the sigmoid function: g(z) = (1 + eâˆ’z)-1. g(z) tends towards 1 as z â†’ âˆž, and g(z) tends towards 0 as z â†’ âˆ’âˆž. derivative of the sigmoid function: g(z)â€˜ = g(z)(1 - g(z)) endow our classification model with a set of probabilistic assumptions, and then fit the parameters via maximum likelihood: Similar to our derivation in the case of linear regression, we can use gradient ascent to maximize the likelihood. updates will therefore be given by Î¸ := Î¸ + Î±âˆ‡Î¸â„“(Î¸). (Note the positive rather than negative sign in the update formula, since weâ€™re maximizing,rather than minimizing, a function now.) This therefore gives us the stochastic gradient ascent rule: Î¸j := Î¸j + Î±(y(i)âˆ’ hÎ¸(x(i)))x(i)j If we compare this to the LMS update rule, we see that it looks identical; but this is not the same algorithm, because hÎ¸(x(i)) is now defined as a non-linear function of Î¸Tx(i). Nonetheless, itâ€™s a little surprising that we end up with the same update rule for a rather different algorithm and learning problem. Is this coincidence, or is there a deeper reason behind this? Check GLM models. Generalized Linear ModelsThe exponential family Bernoulli distributions Gaussianexponential distributions multinomial Poisson (for modelling count-data) beta and the Dirichlet (for distributions over probabilities) Constructing GLMs Ordinary Least Squares Logistic Regression Softmax Regression Softmax RegressionConsider a classification problem in which the response variable y can take on any one of k values, so y âˆˆ {1, 2, . . . , k}. We will thus model it as distributed according to a multinomial distribution. parameterize the multinomial with only k âˆ’ 1 parameters, Ï†1, . . . , Ï†kâˆ’1, where Ï†i = p(y = i; Ï†), and p(y = k; Ï†) = 1 âˆ’ Î£ki=1Ï†i. To express the multinomial as an exponential family distribution, we will definee T(y) âˆˆ Rk-1ï¼š Î· = [log(Ï†1/Ï†k),â€¦,log(Ï†k-1/Ï†k)], the Î·iâ€™s are linearly related to the xâ€™s. softmax function: a mapping from the Î·â€™s to the Ï†â€™s: Ï†i = eÎ·i / Î£kj=1eÎ·i softmax regression: the model, which applies to classification problems where y âˆˆ {1, . . . , k}: p(y = i|x; Î¸) = Ï†i = eÎ¸Ti x / Î£kj=1eÎ¸Ti x This hypothesis will output the estimated probability that p(y = i|x; Î¸), for every value of i = 1, . . . , k. parameter fitting: obtain the maximum likelihood estimate of the parameters by maximizing â„“(Î¸) in terms of Î¸, using a method such as gradient ascent or Newtonâ€™s method. Naive Bayes classification æœ´ç´ è´å¶æ–¯ä»¥äºŒå…ƒåˆ†ç±»ä¸ºä¾‹: æ ¹æ®Aå’ŒBå„è‡ªçš„å…ˆéªŒæ¦‚çŽ‡å’Œæ¡ä»¶æ¦‚çŽ‡, ç®—å‡ºé’ˆå¯¹æŸä¸€ç‰¹å¾äº‹ä»¶çš„åŽéªŒæ¦‚çŽ‡, ç„¶åŽæ­£åˆ™åŒ–(æ­£åˆ™åŒ–åŽä¸¤ä¸ªåŽéªŒæ¦‚çŽ‡ä¹‹å’Œä¸º1, ä½†ä¸å½±å“å¯¹äº‹ä»¶çš„è§¦å‘å¯¹è±¡æ˜¯Aæˆ–Bçš„åˆ¤æ–­) Why naÃ¯ve: å¿½ç•¥äº†äº‹ä»¶å‘ç”Ÿçš„é¡ºåº, æ•…ç§°ä¹‹ä¸ºâ€æœ´ç´ â€ Strength and Weakness: é«˜æ•ˆ, å¿«é€Ÿ, ä½†å¯¹äºŽç»„åˆæ€§çš„çŸ­è¯­è¯ç»„, å½“è¿™äº›çŸ­è¯­ä¸Žå…¶ç»„æˆæˆåˆ†çš„å­—çš„æ„æ€ä¸åŒæ—¶, NBçš„æ•ˆæžœå°±ä¸å¥½äº† è¯¦è§åŠ é€Ÿè‡ªç„¶è¯­è¨€å¤„ç†-æœ´ç´ è´å¶æ–¯ Problem: how to deal with continuous values features? Use Gaussian Naive Bayes. Gaussian Naive BayesWith real-valued inputs, we can calculate the mean and standard deviation of input values (x) for each class to summarize the distribution. This means that in addition to the probabilities for each class, we also store the mean Î¼ and standard deviations Ïƒ of each feature for each class. The class conditional probability P(x|c) is estimated by probability density of the normal distribution : Algorithm â€“ continuous Xi (but still discrete Y) Train NaÃ¯ve Bayes (examples) 1234for each class value yk: estimate P(Yk) for each attribute Xi: estimate class conditional mean, variance Classify(xnew): Ynew &lt;- argmax(k) âˆP(xi|Yk)P(Yk) Short: classes with the same distribution Missing data instances in NB Ignore attribute in instance where its value is missing compute likelihood based on observed attribtues no need to â€œfill inâ€ or explicitly model missing values based on conditional independence between attributes Generative and Discriminative Algorithm: Generative classifiers learn a model of the joint probability, p(x, y), of the inputs x and the label y, and make their predictions by using Bayes rules to calculate p(y|x), and then picking the most likely label y. Discriminative classifiers model the posterior p(y|x) directly, or learn a direct map(hypothesis/functions) from inputs x to the class labels. Generative models advantage: Can be good with missing data, naive Bayes handles missing data good for detecting outliers to generate likely input (x,y). Decision trees å†³ç­–æ ‘ Algorithm: ID3 algorithm Decision trees with continuous attributes: Create split based on threshold ID3 algorithmRecursive Split( node, {examples} ): 1. A &lt;- the best attribute for splitting the {examples} 2. For each value of A, create new child node 3. Split training {examples} to child nodes 4. For each child node, subset: * If subset is pure - stop * Else: split(child_node, {subset} ) How to decide which attribute is the best to split on: Entropy Entropy Use log2 here is to represent concepts of information - on average how many bits needed to tell X split purity To represent two classes, need one bit â€œ0, 1â€, to represent 4 classes, need 2 bits â€œ00, 01, 10, 11â€ If x is pure(one class only), entropy is 0. Information Gain: Expected drop in entropy after split, Gain( P, C) = Entropy(parent) - Î£w*Entropy(children), w is weighted average matrix., A is the split attribute Problems: tend to pick attributes with lots of values, could not generalize well on new data. use GainRation: for attribute A with many different values V, the SplitEntropy will be large, Overfitting in Decision Treesthe tree split too deep to try to classify almost every single sample. As a result the model could not predict new data well. Sub-tree replacement pruning For each node: Pretend remove node + all children from the tree Measure performance on validation set Remove node that results in greatest improvement Repeat until further pruning is harmful Decision boundaryLogistic Regression and trees differ in the way that they generate decision boundaries Decision Trees bisect the space into smaller and smaller regions, Logistic Regression fits a single line/hyperplane to divide the space exactly into two. Random Decision forest Grow K different decision trees: pick a random subset Sr of training examples grow a full ID3 tree (no prunning): When splitting: pick from d&lt;&lt;D random attributes Computing gain based on Sr instead of full set repeat for r =1â€¦K Given a new data point X: classify X using each of the trees T1 â€¦. Tk use majority vote: class predicted most often SVM Intuition: Suppose there is a good hyperplane to seperate data set, h(x)=g(wTx+b), (relation with fully connected layer and activation funciton in DNN). Want functional margin of hyperplane to be large: for dataset (xi,yi), functional margin Î³i = yi(wTxi+b), if yi=1, need wTxi+b&gt;&gt;0, if yi=-1, need wTxi+b&lt;&lt;0. Thus Î³i&gt;0 means the classification is correct. Geometric margins: Define the hyperplane as wTx+b=0, the normal of the hyperplane is w/||w||, thus a point A(xi)â€™s, which represents the input x(i) of some training example with label y(i) = 1, projection on the hyperplane is point B = xi - Î³iÂ·w/||w||, where Î³i is xiâ€™s distance to the decision boundary. Thus wT(xi - Î³iÂ·w/||w||) + b=0 =&gt; Î³i = (w/||w||)Txi+ b/||w||. More generally, the geometric margin of (w, b) with respect to a training example (xi, yi) is Î³i = yiÂ· (w/||w||)Txi+ b/||w|| If ||w|| = 1, then the functional margin equals the geometric margin The optimal margin classifier: Given a training set, a natural desideratum is to try to find a decision boundary that maximizes the minimum (geometric) margin, i.e want min(Î³i) as large as possible. Via some transformation, the object turns to minimize ||w||2, subject to y(i)Â·(wTxi+b) â‰¥ 1, Lagrange duality: solving constrained optimization problems. w = Î£Î±iyixi, Î±i is Lagrange multipliers. Support vector: The points with the smallest margins. The number of support vectors can be much smaller than the size the training set Training: fit our modelâ€™s parameters to a training set, and now wish to make a prediction at a new point input x. We would then calculate wTx + b, and predict y = 1 if and only if this quantity is bigger than zero. . In order to make a prediction, we have to calculate it which depends only on the inner product between x and the points in the training set. Moreover, Î±iâ€™s will all be zero except for the support vectors. Thus, many of the terms in the sum above will be zero, and we need to find only the inner products between x and the support vectors (of which there is often only a small number) in order to make our prediction. The inner product &lt;xi,x&gt; could be replaced by kernel k(xi,x) Kernels Define the â€œoriginalâ€ input value x as the input attributes of a problem. When that is mapped to some new set of quantities that are then passed to the learning algorithm, weâ€™ll call those new quantities the input features. Ï† denote the feature mapping, which maps from the attributes to the features. E.g. Ï†(x) = [x, x^2, x^3] given a feature mapping Ï†, we define the corresponding Kernel to be K(x, z) = Ï†(x)TÏ†(z) Often, Ï†(x) itself may be very expensive to calculate (perhaps because it is an extremely high dimensional vector, require memory), K(x, z) may be very inexpensive to calculate. We can get SVMs to learn in the high dimensional feature space given by Ï†, but without ever having to explicitly find or represent vectors Ï†(x). E.g. Based on Mercerâ€™s Theorem, you can either explicitly map the data with a Ï† and take the dot product, or you can take any kernel and use it right away, without knowing nor caring what Ï† looks like Keep in mind however that the idea of kernels has significantly broader applicability than SVMs. Specifically, if you have any learning algorithm that you can write in terms of only inner products &lt;x, z&gt; between input attribute vectors, then by replacing this with K(x, z) where K is a kernel, you can allow your algorithm to work efficiently in the high dimensional feature space corresponding to K. SVM vs. Logistic regression Logistic regression focuses on maximizing the probability of the data. The further the data lies from the separating hyperplane (on the correct side), the happier LR is. An SVM donâ€™t care about getting the right probability, i.e the right P(y=1|x), but only care about P(y=1|x)/P(y=0|x)â‰¥ c. It tries to find the separating hyperplane that maximizes the distance of the closest points to the margin (the support vectors). If a point is not a support vector, it doesnâ€™t really matter. P(y=1|x)/P(y=0|x) &gt; c, if c=1, that means P(y=1|x) &gt; P(y=0|x), thus y=1, take log of both side, and plug in P(y=1|x) = sigmoid(wTx + b), P(y=0|x)=1-P(y=1|x), recall the sigmoid, we get wTx + b &gt; 0 Underlying basic idea of linear prediction is the same, but error functions differ, the r = P(y=1|x)/P(y=0|x) = exp(wTx + b), different classifiers assigns different cost to r If cost(r)=log(1 + 1/r), this is logistic regression If cost(r)=max(0, 1-log(r))=max(0, 1-(wTx + b)), then SVM Logistic regression (non-sparse) vs SVM (hinge loss, sparse solution) Linear regression (squared error) vs SVM (Ïµ insensitive error) K Nearest NeighbourIntuition: predict based on nearby/similar training data. Algorithm: for a test data compute its distance to every training example xi select k closest training instances prediction: For Classification: predict as the most frequent label among the k instances. For regression: predict as the mean of label among the k instances. Choose k large k: everything classified as the most probable class small k: highly variable, unstable decision boundaries affects â€œsmoothnessâ€ of the boundary Use train-validation to choose k Distance meansures: Euclidian: symmetric, spherical, treats all dimensions equally, but sensitive to extreme differences in single attribtue Hamming: number of attribtues that differ Resolve ties: random prior: pick class with greater prior nearest: use 1-NN classifier to decide Missing values: have to fill in the missing values, otherwise cannot compute distance. Pro and cons: Almost no assumptions about data easy to update in online setting: just add new item to training set Need to handle missing data: fill-in or create a special distance Sensitive to outliers Sensitve to lots of irrelevant aeributes (affect distance) Computationally expensive: need to compute distance to all examples O(nd) - Vectorization Faster knn: K-D Trees, Inverted lists, Locality-sensitive hashing K-D Treeslow-dimensional, real-valued data A kd-tree is a binary tree data structure for storing a fi nite set of points from a k-dimensional space. Build the tree: Pick random dimension, Find median, Split data Nearest neighbor search: Traverse the whole tree, BUT make two modifications to prune to search space: Keep variable of closest point C found so far. Prune subtrees once their bounding boxes say that they canâ€™t contain any point closer than C Search the subtrees in order that maximizes the chance for pruning Inverted listshigh-dimensional, discrete data, sparse Application: text classification, most attribute values are zero (sparseness), training: list all training examples that contain particular attribute Testing: merge inverted list for attribtues presented in the test set, and choose those instances in the new inverted list as the neighbours Locality-sensitive hashinghigh-d, discrete or real-valued Unsupervised learning æ— ç›‘ç£å­¦ä¹ ClusteringK-meanssplit data into a specified number of populations Input: K (number of clusters in the data) Training set {x1, x2, x3 â€¦, xn) Algorithm: Randomly initialize K cluster centroids as {Î¼1, Î¼2, Î¼3 â€¦ Î¼K}, now centroid could represent cluster. Repeat until converge: Inner loop 1: repeatedly sets the c(i) variable to be the index of the closes variable of cluster centroid closes to xi, i.e. take ith example, measure squared distance to each cluster centroid, assign c(i)to the closest cluster(centroid) Inner loop 2: For each cluster j, new centroid c(j) = average mean of all the points assigned to the cluster j in previous step. Target (Distortion) function: J(c,Î¼)=Î£|| xi-Î¼i ||^2, coordinate ascent, decrease monotonically, thus guarantee to converge. What if thereâ€™s a centroid with no data: Remove that centroid, so end up with K-1 classes, Or, randomly reinitialize it, not sure when thoughâ€¦ How to choose cluster numbers: scree plot to find the best k. Hierarchical K-means A Top-down approach run k-means algorithm on the original dataset for each of the resulting clusters, recursively run k-means Pro cons: Fast nearby points may end up in different clusters Agglomerative ClusteringA bottom up algorithm:123451. starts with a collections of singleton clusters2. repeat until only one cluster is left: 1. Find a pair of clusters that is closest 2. Merge the pair of clusters into one new cluster 3. Remove the old pair of clusters Need to define a distance metric over clusters Produce a dendrogram: Hierarchical tree of clusters slow Gaussian MixturesFor non-Gaussian distribution data, assume it is a mixture of several(k) Gaussians. Algorithm: EM EM algorithmstrategy will be to repeatedly construct a lower-bound on â„“(E-step) based on Jensenâ€™s inequality, and then optimize that lower-bound(M-step). E step: For each i, let Qi be some distribution over the zâ€™s (Î£zQi(z) = 1, Qi(z) â‰¥ 0). z(i) indicating which of the k Gaussians each x(i) had come from, get P(Z)=Ï†, then compute the conditional probability wj as P(x|Z) via Gaussian Naive Bayes: M step: maximize, with respect to our parameters Ï†, Âµ, Î£, the quantity, by updating parameter(Ï†, Âµ, Ïƒ) ä¸¾ä¾‹ï¼šstart with two randomly placed Gaussians (Î¼a, Ïƒa), (Î¼b, Ïƒb), assume a uniform prior (P(a)=P(b)=0.5), iterate until convergence: E-step: for each point: P(b|xi), P(a|xi)=1-P(b|xi) , does it look like it came from b or a? M-step: adjust (Î¼a, Ïƒa) and (Î¼b, Ïƒb) to fit points soft assigned to them, The EM-algorithm is also reminiscent of the K-means clustering algorithm, except that instead of the â€œhardâ€ cluster assignments c, we instead have the â€œsoftâ€ assignments w. Similar to K-means, it is also susceptible to local optima, so reinitializing at several different initial parameters may be a good idea. How to pick k: cannot discover K, likelihood keeps growing with K K-means vs. EM Dimensionality Reduction Pros: reflects human intuitions about the data allows estimating probabilities in highadimensional data: no need to assume independence etc. dramatic reduction in size of data: faster processing (as long as reduction is fast), smaller storage Cons too expensive for many applications (Twitter, web) disastrous for tasks with fine-grained classes understand assumptions behind the methods (linearity etc.): there may be better ways to deal with sparseness Factor analysisIf the features n â‰« m, or nâ‰ˆm, in such a problem, it might be difficult to model the data even with a single Gaussian, æ›´åˆ«æé«˜æ–¯æ··åˆäº†. Because the variance matrix Î£ becomes singular - non invertable. Principal Components AnalysisPCA, automatically detect and reduce data to lower dimension k, k &lt;&lt; n, preserve dimenson that affects class separability most. Algorithm: Pre-process: data normalization to 0 mean and unit variance,Steps (3-4) may be omitted if we had apriori knowledge that the different attributes are all on the same scale to project data into a k-dimensional subspace (k &lt; n), we should choose e1,â€¦ ek to be the top k eigenvectors of Î£. The eâ€™s now form a new, orthogonal basis for the data. To represent a training data point x with d dimension into this basis (k dimension), e1Tx,â€¦ekTx The vectors u1,â€¦, uk are called the first k principal components of the data. Eigenvalue Î»i = variance along ei. Pick ei that explain the most variance by sorting eigenvectors s.t. Î»1 â‰¥ Î»2 â‰¥â€¦â‰¥ Î»n pick first k eigenvectors which explain 90% or 95% of the total variance Î£Î»(i). Maximize the variance of projection of x onto a unit vector u, Application: eigenfaces Linear Discriminant AnalysisLDA Idea: pick a new dimension that gives maximum separation between means of projected classes minimum variance within each projected class How: eigenvectors based on between-class and within-class covariance matrices LDA not guaranteed to be better for Classification assumes classes are unimodal Gaussians fails when discriminatory information is not in the mean, but in the variance of the data Singular Value DecompositionGeneralization and evaluationReceiver Operating CharacteristicROC, plot TPR(Sensitivity) vs. FPR(Specificity) as t varies from âˆž to -âˆž, shows performance of system across all possible thresholds A test with perfect discrimination (no overlap in the two distributions) has a ROC curve that passes through the upper left corner. Therefore the closer the ROC curve is to the upper left corner, the higher the overall accuracy of the test AUC: area under ROC curve, popular alternative to Accuracy Confidence intervaltell us how closed our estimation E = probability that misclassify a random instance: Take a random set of n instances, how many misclassified? Equal to Binomial distribution with mean = nE, variance = nE(1-E) Efuture: the next instanceâ€™s probability of misclassified = average #misclassifed = variance / n = mean E= E(1-E)/n, small variance means big confidence interval, a Gaussian distribution with one variance distance extend from mean will cover 2/3 future test sets p% Confidence interval for future error, 95% confidence interval needs about 2 variance extends from mean. .]]></content>
      <categories>
        <category>AI</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning with Scikit-learn (Sklearn) æœºå™¨å­¦ä¹ å®žè·µ]]></title>
    <url>%2Fmachine-learning-with-sklearn%2F</url>
    <content type="text"><![CDATA[Scikit-learn æä¾›ä¸€å¥—å®žç”¨çš„å·¥å…·ï¼Œç”¨äºŽè§£å†³æœºå™¨å­¦ä¹ ä¸­çš„å®žé™…é—®é¢˜ï¼Œå¹¶é…åˆé€‚å½“çš„æ–¹æ³•æ¥åˆ¶å®šè§£å†³æ–¹æ¡ˆã€‚ æ¶‰åŠæ•°æ®å’Œæ¨¡åž‹ç®€ä»‹ï¼Œå†³ç­–æ ‘ï¼Œè¯¯å·®çš„ä½œç”¨ï¼Œæœ€å°åŒ–è¯¯å·®ï¼Œå›žå½’æ‹Ÿåˆï¼Œé€»è¾‘å›žå½’ï¼Œç¥žç»ç½‘ç»œï¼Œæ„ŸçŸ¥å™¨ï¼Œæ”¯æŒå‘é‡æœºï¼Œæœ´ç´ è´å¶æ–¯ï¼Œé™ç»´ï¼ŒKå‡å€¼ï¼Œç®€å•é«˜æ–¯æ··åˆæ¨¡åž‹ï¼Œåˆ†å±‚èšç±»ï¼Œæ¨¡åž‹è¯„ä¼°ã€‚ å®žéªŒå’Œä»£ç åœ¨GitHub;ç»ƒä¹ ä½œä¸šç­”æ¡ˆå¯ä»¥å‚è€ƒGitHub]]></content>
      <categories>
        <category>AI</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>python</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Software Architecture, Process, and Management]]></title>
    <url>%2FUoE-sapm%2F</url>
    <content type="text"><![CDATA[çˆ±ä¸å ¡å¤§å­¦ä¿¡æ¯å­¦é™¢è¯¾ç¨‹ç¬”è®° Software Architecture, Process, and Management, Informatics, University of Edinburgh Reference:microsoftIBMSoftware Architecture in Practice (3rd edition), Bass, Clements, and Kazman What is Software Architecture?Software architecture is often described as the organization or structure of a system, where the system represents a collection of components that accomplish a specific function or set of functions. grouping components into areas of concern (layers): For example, the UI, business processing, and data access. focus on interaction between the components and how different components work together. åœ¨ä¹¦ä¸­çš„å®šä¹‰ï¼š The software architecture of a system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both.â€“ Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman æž¶æž„çš„å…³æ³¨ç‚¹åœ¨äºŽç³»ç»Ÿå†…å„ä¸ªåº”ç”¨å’Œæ¨¡å—çš„äº¤äº’å’Œè°ƒç”¨ã€‚è½¯ä»¶æž¶æž„çš„è®¾è®¡ï¼Œéœ€è¦è€ƒè™‘æ»¡è¶³ä»€ä¹ˆæ ·çš„éœ€æ±‚ï¼ˆç”¨æˆ·æˆ–ç”²æ–¹ï¼‰ï¼Œå¦‚ä½•è§£å†³å’Œä¼˜åŒ–é—®é¢˜ï¼ˆä¸åŒçš„æ–¹å‘å„æœ‰åé‡ï¼‰ï¼Œæ“ä½œä¸­å¦‚ä½•åšé€‰æ‹©ï¼ˆåœ¨ä¸åŒçš„æ–¹é¢å¹³è¡¡ï¼Œå¦¥åï¼‰ã€‚ Architecture and design concerns very often overlap - The selection of data structures and algorithms or the implementation details of individual components are design concerns. æ²¡å¿…è¦å¼ºç¡¬åŒºåˆ†äºŒè€…ï¼Œè€Œåº”è¯¥ç»¼åˆèµ·æ¥çœ‹å¾…ã€‚æŸäº›æƒ…å†µä¸‹ï¼Œå†³ç­–æ˜¯è‡ªç„¶è€Œç„¶çš„ç»“æž„å±‚é¢çš„ï¼›åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå†³ç­–æ›´å¤šæ˜¯å…³äºŽäºŽè®¾è®¡å±‚é¢ï¼Œä»¥åŠè®¾è®¡å¦‚ä½•å¸®åŠ©å®žçŽ°æž¶æž„ã€‚ è½¯ä»¶æž¶æž„çš„å®šä¹‰æœ‰å¦‚ä¸‹éšå«æ„æ€ï¼š1, Architecture Is a Set of Software StructuresThree frequently occurring types of structure:â€“ Modular structure: static structure that focus on how functionality is divided up, structured, and assigned to development and implementation teams.â€“ Component and Connector structure: runtime structures that focus on how components interact (e.g. information passing, synchronisation, interference,â€¦)â€“ Allocation structures: mapping to organizational, development, installation, execution environments. (e.g. Components are deployed onto hardware to execute) 2, Architecture Is an abstractionArchitecture specifcally omits certain information about elements that is not useful for reasoning about the system - in particular, it omits information that has no ramifcations outside of a single element. 3, Every Software System Has a Software architecture 4, Architecture Includes behaviorBehavior embodies how elements interact with each other. åœ¨æœ¬è¯¾ç¨‹, ä¸€ä¸ªè½¯ä»¶é¡¹ç›®æˆåŠŸä¸Žå¦, åŸºäºŽå¦‚ä¸‹ä¸‰ç‚¹è€ƒé‡:â€“ The software is delivered on scheduleâ€“ Development costs were within budgetâ€“ The software meets the needs of users Contexts for Software Architecture Technical: where architecture supports technical activity like measurement, V&amp;V, compliance,â€¦ Controlling Quality Attributes Availability - ensuring there is a system to take over if a system fails. Safety - ensuring that the system only behaves as intended and has no additonal behaviour. Testability - ensuring: elements are clearly able to be isolated we know what behaviour to expect of components of the system we know how components relate to modules so we can track down faulty code We know how components are intended to integrate to give the overall behaviour Other qa: performance, usability, interoperability,.. Design - Patterns, Styles, Domain Specific Architecture (DSSA) A DSSA is collection of (pre-decided) design decisions that: Capture important aspects of particular tasks (domain), Common across a range of systems in the domain Typically they will have some predefined structures These are not general purpose because they incorporate many specific characteristics of the domain. Architectural pattern is a set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears. Similar to DSSAs but capture less of the behaviour and attributes of the system More general because they are intended to abstract a common pattern over several domains. Three-Tiered Pattern: State(database)-Logic(Business)-Display(UI) Model-View-Controller (MVC): to separate between information, presentation and user interaction. Sense-Compute-Control: Structuring embedded control applications Project lifecycle: where architecture interacts with and supports development process Lifecycle Models: V-model, iterative models (Boehmâ€™s spiral model), Agile Business: where architecture supports organisations, e.g. customer organisations and development organisations. Professional: where the role of architect defines requirements and constraints on architects. Quality Attributes (QA)Architecture is the right level of abstraction to resolve conflicts between Stakeholders. Quality Attributes specify, usually quantitative, requirements on particular bits of functionality or on the whole systems (e.g. that the system should be available 99% of the time). Problems With QA1, Often QA requirements are not â€œtestableâ€, for example modifiable, usable, dependable or resilient.2, It can be difficult to map from a concern about the system to a QA. For example, a high failure rate in some transaction could be a performance issue or it could be an availability issue.3, Communities around a particular quality attribute have developed their own terminology (e.g. security has attacks, performance has events, etc). The solution for 1 and 2 is to use quality attribute scenarios to provide sufficient specificity to avoid some of these issues. Quality Attributes Scenarios åœºæ™¯A quality attribute requirement should be unambiguous and testable. To specify quality attribute requirements, we capture them formally as six-part scenarios: Source of stimulus. This is some entity (a human, a computer system, or a system administrator) that generated the stimulus. Stimulus. A condition (event) that requires a response when it arrives at a system. e.g. a user operation to the usability community, or an attack to the security community. Environment. The stimulus occurs under certain conditions. The system may be in an overload condition or in normal operation. For many systems, â€œnormalâ€ operation can refer to one of a number of modes. For these kinds of systems, the environment should specify in which mode the system is executing. Artifact. A collection of systems, the whole system, or part of the system that is stimulated e.g. the configuration checker in the system. Response. The response is the activity undertaken as the result of the arrival of the stimulus. e.g. the configuration issue is identified and then repaired. Response measure. how to measure the response so the scenario is testable. e.g. time to detect the wrong configuration and the time to repair. Each QA has a General Scenario associated with it that tries to capture the possible components involved in that particular QA. This acts as a template or guide for the architect specifying a specific QA Scenario. Specific QA Scenarios take account of specific stimuli and measures on response, they capture the specification of the QA for a particular system. Achieving QA through tacticsArchitectural tactics are design decisions to achieve the required quality attributes, more specifcally, to control responses to stimuli. The focus of a tactic is on a single quality attribute response. Within a tactic, there is no consideration of tradeoffs (differ from architectural patterns, where tradeoffs are built into the pattern). By cataloging tactics, we provide a way of making design more systematic within some limitations. An architecture can be viewed as the result of applying a collection of design decisions. A systematic categorization of these decisions: Allocation of responsibilities è´£ä»»åˆ†é…: Identifying the important responsibilities, and determining how these responsibilities are allocated to static and runtime elements (namely, modules, components, and connectors). Coordination model æ¨¡åž‹åè°ƒ - Components in the architecture interact with one another via a collection of mechanisms. What elements in the system need to coordinate with one another. What properties the coordination needs to have (e.g. timing properties, security of coordination, â€¦) Choosing the mechanisms (ideally a small number) that realize properties like statefulness, synchrony, delivery guarantees, performance. Data model: Every system must represent artifacts of system-wide interestâ€”dataâ€”in some internal fashion Choosing abstractions, operations, and properties. How data is created and destroyed, access methods, â€¦ Maintaining metadata that controls the interpretation of the data. Organising the data, what kind of system will be used to store it, how will it be backed up, how do we recover from data loss Management of resources: hard (CPU, memory, battery, I/O portsâ€¦) or soft resources(system locks, software buffers, thread poolsâ€¦): Identifying resources to be managed What system element should manage a resource èµ„æºå…±äº«ç­–ç•¥å’Œäº‰ç«¯ä»²è£ Work out sharing strategies and how to arbitrate in contention situations Consider the consequences of resource starvation(e.g. Memory). Mapping among architectural elements two important types of mapping: Mapping between different types of elements in the architecture, e.g. from static development structures (modules) to execution elements e.g. threads or processes. Mappings between software elements and environment elements, e.g. from processes to specific processors and other hardware. Useful mappings include: code to runtime structure; runtime elements to environment; data model elements to data stores. Binding time decisions: introduce allowable ranges of variation. This variation can range from design time by a designer to runtime by an end user might allocate a responsibility. The decisions in the other six categories have an associated binding time decision: we might want some variability in the resources to be managed determined at run time or we might make the coordination model negotiable at runtime if we want to inter-operate with a range of systems. Choice of technology: critical to being able to realize all the other decisions in a concrete system. What technologies are available What tools are available to support technologies How much training will it take to be able to use a technology? What are the full range of consequences of the choice of a technology (e.g. it may restrict markets because it is incompatible with some other technologies). If the technology is new, how does it fit into the existing preferred technologies for the organisation. Availability Availability refers to a property of software that it is there and ready to carry out its task when you need it to be. The availability of a system is usually defined to be the probability it will be there when you ask it to work: $\frac{mtbf}{mtbf+mttr}$ $mtbf$ â€“ mean time between failures: MTBF of a component is the sum of the lengths of the operational periods divided by the number of observed failures: $mtbf = \frac{t}{N(t)}$, $t$ is the cumulative operating time, $N(t)$ is the observed number of failures by time $t$. å‡è®¾æ’å®šçš„æ•…éšœçŽ‡ $\lambda$ï¼Œåˆ™ $mtbf = \frac{1}{\lambda}$ $mttr$ â€“ mean time to repair Availability measures the quality of service in terms of running versus down time Reliability indicates the fraction of all attempted operations that complete successfully. The reliability of the system is: $R(t) = e^{-\lambda t}$ where the parameter $\lambda$ is called the failure rate.ç”±äºŽMTBFä¸»è¦é’ˆå¯¹å¯ä»¥ä¿®å¤çš„ç³»ç»Ÿï¼Œå› æ­¤å»ºè®®é’ˆå¯¹ä¸å¯ä¿®å¤çš„ç³»ç»Ÿï¼ˆåœ¨æ•…éšœåŽé€‰æ‹©æ›´æ¢è€Œä¸æ˜¯ä¿®å¤ç³»ç»Ÿçš„æƒ…å†µï¼‰ä½¿ç”¨å¹³å‡æ•…éšœæ—¶é—´ï¼ˆMTTFï¼‰ï¼Œåœ¨æ•°å­¦ä¸ŠäºŒè€…æ˜¯ç­‰ä»·çš„ã€‚MTTF: Mean Time To (first) Failure, or Expected Life.$ MTTF = E(t_f) = \int_0^\infty R(t)dt = \frac{1}{\lambda}$ Faults, Errors, Failures: A fault is something in the system (e.g. failed component, wrong bit of code,â€¦) that can cause the system to move into an error state when the fault is activated, an error may then eventually cause an externally observable deviation from the intended operation - failure. Generic Scenario Design Checklist for AvailabilityAllocation of Responsibilitiesâ–  Determine the system responsibilities that need to be highly available.â–  Within those responsibilities, ensure that additional responsibilities have been allocated to detect an omission, crash, incorrect timing, or incorrect response.â–  Additionally, ensure that there are responsibilities to do the following:â€¢ Log the faultâ€¢ Notify appropriate entities (people or systems)â€¢ Disable the source of events causing the faultâ€¢ Be temporarily unavailableâ€¢ Fix or mask the fault/failureâ€¢ Operate in a degraded mode Coordination ModelDetermine the system responsibilities that need to be highly available. With respect to those responsibilities, do the following:â–  Ensure that coordination mechanisms can detect an omission, crash, incorrect timing, or incorrect response. For example, whether guaranteed delivery is necessary. Will the coordination work under conditions of degraded communication?â–  Ensure that coordination mechanisms enable the logging of the fault, notification of appropriate entities, disabling of the source of the events causing the fault, fxing or masking the fault, or operating in a degraded mode.â–  Ensure that the coordination model supports the replacement of the artifacts used (processors, communications channels, persistent storage, and processes). For example, does replacement of a server allow the system to continue to operate?â–  Determine if the coordination will work under conditions of degraded communication, at startup/shutdown, in repair mode, or under overloaded operation. For example, how much lost information can the coordination model withstand and with what consequences? Data Modelâ–  Determine which portions of the system need to be highly available.â–  Within those portions, determine which data abstractions, along with their operations or their properties, could cause a fault of omission, a crash, incorrect timing behavior, or an incorrect response.â–  For those data abstractions, operations, and properties, ensure that they can be disabled, be temporarily unavailable, or be fxed or masked in the event of a fault.â–  For example, ensure that write requests are cached if a server is temporarily unavailable and performed when the server is returned to service. Mapping among Architectural Elementsâ–  Determine which artifacts (processors, communication channels, persistent storage, or processes) may produce a fault.â–  Ensure that the mapping (or remapping) of architectural elements is ï¬‚exible enough to permit the recovery from the fault. This may involve a consideration of the following:â€¢ Which processes on failed processors need to be reassigned at runtimeâ€¢ Which processors, data stores, or communication channels can be activated or reassigned at runtimeâ€¢ How data on failed processors or storage can be served by replacement unitsâ€¢ How quickly the system can be reinstalled based on the units of delivery providedâ€¢ How to (re)assign runtime elements to processors, communication channels, and data storesâ€¢ When employing tactics that depend on redundancy of functionality, the mapping from modules to redundant components is important. For example, it is possible to write one module that contains code appropriate for both the active component and backup components in a protection group. Resource Managementâ–  Determine what critical resources are necessary to continue operating in the presence of a fault.â–  Ensure there are suffcient remaining resources in the event of a fault to log the fault; notify appropriate entities (people or systems); disable the source of events causing the fault; be temporarily unavailable; fx or mask the fault/failure; operate normally, in startup, shutdown, repair mode, degraded operation, and overloaded operation.â–  Determine the availability time for critical resources, what critical resources must be available during specifed time intervals, time intervals during which the critical resources may be in a degraded mode, and repair time for critical resources. Ensure that the critical resources are available during these time intervals.â–  For example, ensure that input queues are large enough to buffer anticipated messages if a server fails so that the messages are not permanently lost. Binding Timeâ–  Determine how and when architectural elements are bound.â–  If late binding is used to alternate between components that can themselves be sources of faults (e.g., processes, processors, communication channels), ensure the chosen availability strategy is suffcient to cover faults introduced by all sources.â–  For example:â€¢ If late binding is used to switch between artifacts such as processors that will receive or be the subject of faults, will the chosen fault detection and recovery mechanisms work for all possible bindings?â€¢ If late binding is used to change the defnition or tolerance of what constitutes a fault (e.g., how long a process can go without responding before a fault is assumed), is the recovery strategy chosen suffcient to handle all cases? For example, if a fault is ï¬‚agged after 0.1 milliseconds, but the recovery mechanism takes 1.5 seconds to work, that might be an unacceptable mismatch.â€¢ What are the availability characteristics of the late binding mechanism itself? Can it fail? Choice of Technologyâ–  Determine the available technologies that can (help) detect faults, recover from faults, or reintroduce failed components.â–  Determine what technologies are available that help the response to a fault (e.g., event loggers).â–  Determine the availability characteristics of chosen technologies themselves: What faults can they recover from? What faults might they introduce into the system? PerformanceTo ensure resource is effectively monitored and managed. Design Checklist for PerformanceAllocation of Responsibilitiesâ–  Work out areas responsibility of that require heavy resource use to ensure time-critical events take place.â–  Work out processing requirements.â–  Take account of:â€¢ Responsibilites arising from threads crossing boundaries of responsibilityâ€¢ Responsibilities for thread managementâ€¢ Responsibilities for scheduling shared resources Coordination Modelâ–  What needs to coordinate.â–  Is there concurrency? Ensure it is safe.â–  Ensure coordination is appropriate for the style of stimulus.â–  Ensure the properties of the coordination model are good for the stimuli and concurrency control? Data Modelâ–  Determine what parts of the data model will be heavily loaded or behaves tight time constraints.â–  For those data abstractions, determine:â€¢ Would keeping multiple copies help?â€¢ Would partitioning the data help?â€¢ Is it possible to reduce processing requirements for the data?â€¢ Does adding resource help deal with data bottlenecks? Mapping Among Architecture Elementsâ–  Does colocation of some components reduce latencies?â–  Ensure components with high processing needs are allocated to big processorsâ–  Consider introducing concurrency when you map.â–  Consider whether some mappings introduce bottlenecks (e.g. allocating non-interfering tasks to the same thread) Resource Managementâ–  Work out what needs high levels of resourceâ–  Ensure these are monitoredand managed under all operating modes.â–  For example:â€¢ Time critical componentsâ€¢ Thread managementâ€¢ Prioritizationâ€¢ Locking and scheduling strategiesâ€¢ Deploying additional resource to meet elevated load. Binding timeâ–  Look at when you bind.â–  Consider the cost of binding at different timesâ–  Try to avoid performance penalties caused by late binding. Choice of Technologyâ–  Is the technology right to let you meet hard deadlines and resource use (e.g. use a real-time OS with proper scheduling).â–  Do you know its characteristics under load and its limits?â–  Does your choice of technology give you the ability to set the following:â€¢ Good schedulingâ€¢ Prioritiesâ€¢ Policies for demand reductionâ€¢ Allocating processing to tasksâ€¢ Other performance-related parameters.â–  Does your choice of technology introduce excessive overhead for heavily used operations? Securityæœ€ç®€å•çš„è¡¨å¾å®‰å…¨çš„ä¸‰ä¸ªç‰¹å¾ - confdentiality, integrity, and availability (CIA): æœºå¯†æ€§ Confidentiality: Only those who should have access are given access. å®Œæ•´æ€§ Integrity: Data or services are not subject to unauthorised manipulation. å¯ç”¨æ€§ Availability: the system is available for legitimate use. å…¶ä»–ç”¨äºŽæ”¯æ’‘ CIA çš„ç‰¹å¾: è®¤è¯è¯†åˆ« Authentication verifes the identities of the parties to a transaction and checks if they are truly who they claim to be. ä¸å¯å¦è®¤æ€§ Nonrepudiation guarantees that the sender of a message cannot later deny having sent the message, and that the recipient cannot deny having received the message. æŽˆæƒ Authorization grants a user the privileges to perform a task. Security General Scenario A Design Checklist for SecurityAllocation of Responsibilitiesâ–  Ensure all actors have identitiesâ–  Authenticate identitiesâ–  Check authorizationsâ–  Ensure authorization is required for all such actorsâ–  Log attempts, successes and failures on all sensitive operationsâ–  Ensure data is encryptedâ–  Ensure responsibilities are allocated to appropriate actors. Coordination Modelâ–  Ensure coordination mechanisms use authentication and authorisation.â–  Ensure coordination mechanisms are not vulnerable to impersonation, tampering, interception, â€¦â–  Ensure data involved in coordination is protected using encryption.â–  Monitor level of demand for communication to identify excessive demands Data Modelâ–  Ensure there is a valid data model that disallows invalid data flows.â–  Ensure logging of access, modification and attempted access or modification.â–  Data is protected in flight and at rest using appropriate encryption.â–  Ensure appropriate backup/recovery mechanisms are in place. Mapping among Architectural Elementsâ–  Explore how different mappings change the way users can access resources.â–  Ensure for all of these mappings the models of access and authorisation are preserved.â€¢ Actors should be identified and authenticatedâ€¢ Use appropriate authorisation mechanismsâ€¢ Ensure logging is enabledâ€¢ Ensure data is protected by encryptionâ€¢ Recognise impact of attack on resourcesâ–  Ensure recovery from attack is possible Resource Managementâ–  Explore the overheads resulting from monitoring, detecting, preventing and recovering from attacks.â–  Analyse how a user can access and make demands on critical resources.â–  Manage resource access to ensure malicious use of resource is detected and managed.â–  Identify the potential for corruption/contamination and how to manage this.â–  Explore the potential for resource use to be used as a covert channel to transmit data.â–  Limit resources used to manage attempts at unauthorised use Binding Timeâ–  Explore the consequences of varying binding times on the ability to trust an actor or component.â–  Put in place appropriate mechanisms to ensure trust given binding time.â–  Explore potential impact on resource use, capacity/throughput, response timeâ–  Ensure appropriate encryption of all data around binding.â–  Explore the potential of variation in binding time as a covert channel. Choice of Technologiesâ–  Ensure limitations of technologies are understood and the potential for future compromise is well identified.â–  Ensure your chosen technologies support the tactics you want to deploy to protect the system. ConnectorsKey part of Architecturesâ–  Connect components and define the rules of interaction between componentsâ€¢ Simple: shared variable access; method calls; â€¦â€¢ Complex: database access; client-server; scheduler; load balancerâ–  Connectors provide: Interaction ducts; In coding often connectors are implicit, but in software architecture:â–  They are identified and have an identityâ–  Capture system interaction (at the level of components)â–  They have a specification that can be complex Relationship between Connectors and components:â–  Components have application-specific functionality.â–  Connectors provide interaction mechanisms that are generic across different applications.â–  Interaction may involve multiple componentsâ–  Interaction may have a protocol associated to it. The specification of the connector protocols determine: the types of interface that it works with; properties of interaction; rules about ordering of interaction; measurable features of interaction. Benefits of Explicit Connectorsâ–  Interaction is defined by the arrangement of the connectors (as far as possible)â–  Component interaction is defined by the pattern of connectors in the architectureâ–  Interaction is â€œindependentâ€ of the components The main roles(services) of Connectors are: Communication Information is transmitted between components (e.g. message passing; method call; remote procedure call,â€¦). Connectors constrain things: Direction of flow (e.g. pipes), Capacity, rates of flow, etc. May have other effects e.g. coordination (e.g. blocking I/O) Influences measurable Quality Attributes of the system Separates communication from functional aspects (components do the functional part). Coordination: Controls the timing relationship of functional aspects of the system, e.g. coordinating the arrival of data at a collection of components Conversion How to get components to interact that donâ€™t have the right means of interaction. å¦‚ä½•è®©å…¼å®¹æ€§å·®çš„ç»„ä»¶è¿›è¡Œäº¤äº’ï¼Ÿ Incompatibilities might be related to: datatypes, ordering, frequency, structure of parameters etc. Examples of types of converters: Wrappers (deal with structural issues), Adaptors (deal with datatype incompatibilities) Facilitation Enable interaction among a group of components that are intended to interact. Help manage the interaction Examples: load balancer; replication management; redundancy management; scheduler Can also relate to coordination, e.g. synchronization (critical sections; monitors) Select ConnectorsTypes of Connector: â€¢ Method/Procedure call â€¢ Data access â€¢ Events â€¢ Stream â€¢ Distributor â€¢ Arbitrator â€¢ Adaptor Selection Determine a systemâ€™s interconnection and interaction needs Determine roles to be fulfilled by the systemâ€™s connectors: Communication, coordination, conversion, facilitation For each connector Determine its appropriate type(s) Determine its dimensions of interest Select appropriate values for each dimension For multi-type, i.e., composite connectors, determine the atomic connector compatibilities Architectural Patterns An architectural patterns is a package of design decisions that is found repeatedly in practice, has known properties that permit reuse, and describes a class of architectures. An architectural pattern comprises: A context that provides the frame for a problem. A problem that is a generalised description of a class of problems often with QA requirements that should be met. A solution that is suitably generalised in the same way as the problem. A solution: Describes the architectural structures that solve the problem, including how to balance the many forces at work. The solution might be static, runtime or deployment oriented. The solution for a pattern is determined and described by: A set of element types (for example, data repositories, processes, and objects) A set of interaction mechanisms or connectors (for example, method calls, events, or message bus) A topological layout of the components A set of semantic constraints covering topology, element behavior, and interaction mechanisms Module PatternsStatic Pattern: Layered Pattern Overview: The layered pattern defines layers (groupings of modules that offer a cohesive set of services) and a unidirectional allowed-to-use relation among the layers. The pattern is usually shown graphically by stacking boxes representing layers on top of each other. Suitable for controlling static aspects of architecture. Elements: Layer, a kind of module. The description of a layer should define what modules the layer contains and a characterization of the cohesive set of services that the layer provides. Relations: Allowed to use, which is a specialization of a more generic depends-on relation. The design should define what the layer usage rules are (e.g., â€œa layer is allowed to use any lower layerâ€ or â€œa layer is allowed to use only the layer immediately below itâ€) and any allowable exceptions. Constraints:â–  Every piece of software is allocated to exactly one layer.â–  There are at least two layers (but usually there are three or more).â–  The allowed-to-use relations should not be circular (i.e., a lower layer cannot use a layer above). Weaknesses:â–  The addition of layers adds up-front cost and complexity to a system.â–  Layers contribute a performance penalty. Component-and-Connector PatternsModel-View-Controller Pattern Context: User interface software is typically the most frequently modifed portion of an interactive application. For this reason it is important to keep modifcations to the user interface software separate from the rest of the system. Problem:â€¢ Isolating the UI functionality from the Application functionality.â€¢ Maintaining multiple views in the presence of change in the underlying data. Solution: Other Component-Connector Patternsâ€¢ Pipe and Filter Patternâ€¢ Broker Patternâ€¢ Client-Server Patternâ€¢ Peer-to-Peer Patternâ€¢ Service-Oriented Architecture Patternâ€¢ Publish-Subscribe Patternâ€¢ Shared Data Pattern Deployment/Allocation PatternsContext:â€“ we are concerned with resource useâ€“ We might consider flexible deployment of resourceâ€“ The QAs we care about are sensitive to the pattern of deployment and the use of resources. Allocation: Map-Reduce PatternContext:â€“ We have large quantities of data we wish to treat as â€œpopulationâ€ data.â€“ This encourages an approach that involves significant amounts of independent processing. Problem: Where for ultra-large data sets doing some individual processing to a portion of the data set and then sorting and analyzing grouped data, map-reduce provides a simple way of doing this processing. Solution: Other Allocation Patternsâ€¢ Multi-tier architecture patternâ€¢ Cloud architectures Relationships between Tactics and PatternsArchitectural patterns and tactics are ways of capturing proven good design structures and making them reusable. Tactics are simpler and more atomic than patternsâ€¢ Tactics capture one step to take for a particular Quality Attribute to change behaviour with respect to that QA.â€¢ use just a single structure or computational mechanism, and they are meant to address a single architectural force.â€¢ Tactics can be seen as the building blocks of patterns; Most patterns consist of (are constructed from) several different tactics. TestabilityTestability illustrate QAs from a static perspective. A system or element of a system is testable if it is possible to test it in the way required by a particular development or maintenance process. Testability Concernsâ€¢ Unlike the other QA (availability, performance and security), testability is concerned with the code structure rather than the connector/component view or deployment view.â€¢ The system elements we consider are code modules and the relationships are dependencies involved in building the code for components. Testability General Scenario ä¸¾ä¾‹ Coverage Concrete Scenarioâ€¢ Source: Regression Testerâ€¢ Stimulus: Completion of maintenance development to repair a critical bugâ€¢ Artifact: Modules for the full systemâ€¢ Environment: Maintenance Developmentâ€¢ Response: Results from path coverage toolâ€¢ Response Measure: Path coverage is better than 95% of non-looping paths inside modules Testability Tactics adding controllability and observability to the system. Specialized Interfaces Record/Playback Localize State Storage Abstract Data Sources Sandbox Executable Assertions limiting complexity in the systemâ€™s designs: If it could be broken into smaller modules with lower complexity that could allow the regression test to achieve higher path coverage. Limit Structural Complexity Limit behavioral complexity - Nondeterminism A Design Checklist for TestabilityAllocation of Responsibilitiesâ–  Determine which system responsibilities are most critical and hence need to be most thoroughly tested.â–  Ensure that additional system responsibilities have been allocated to do the following: Execute test suite and capture results (external test or self-test)â€¢ Capture (log) the activity that resulted in a fault or that resulted in unexpected (perhaps emergent) behavior that was not necessarily a faultâ€¢ Control and observe relevant system state for testing Make sure the allocation of functionality provides high cohesion, low coupling, strong separation of concerns, and low structural complexity. Coordination ModelEnsure the systemâ€™s coordination and communication mechanismsâ–  Support the execution of a test suite and capture the results within a system or between systemsâ–  Support capturing activity that resulted in a fault within a system or between systemsâ–  Support injection and monitoring of state into the communication channels for use in testing, within a system or between systemsâ–  Do not introduce needless nondeterminism Data ModelDetermine the major data abstractions that must be tested to ensure the correct operation of the system.â–  Ensure that it is possible to capture the values of instances of these data abstractionsâ–  Ensure that the values of instances of these data abstractions can be set when state is injected into the system, so that system state leading to a fault may be re-createdâ–  Ensure that the creation, initialization, persistence, manipulation, translation, and destruction of instances of these data abstractions can be exercised and captured Mapping among Architectural Elementsâ–  Determine how to test the possible mappings of architectural elements (especially mappings of processes to processors, threads to processes, and modules to components) so that the desired test response is achieved and potential race conditions identifed.â–  In addition, determine whether it is possible to test for illegal mappings of architectural elements. Resource Managementâ–  Ensure there are suffcient resources available to execute a test suite and capture the results.â–  Ensure that your test environment is representative of (or better yet, identical to) the environment in which the system will run.â–  Ensure that the system provides the means to do the following:â€¢ Test resource limitsâ€¢ Capture detailed resource usage for analysis in the event of a failureâ€¢ Inject new resource limits into the system for the purposes of testingâ€¢ Provide virtualized resources for testing Binding Timeâ–  Ensure that components that are bound later than compile time can be tested in the late-bound context.â–  Ensure that late bindings can be captured in the event of a failure, so that you can re-create the systemâ€™s state leading to the failure.â–  Ensure that the full range of binding possibilities can be tested Choice of Technologyâ–  Determine what technologies are available to help achieve the testability scenarios that apply to your architecture. Are technologies available to help with regression testing, fault injection, recording and playback, and so on?â–  Determine how testable the technologies are that you have chosen (or are considering choosing in the future) and ensure that your chosen technologies support the level of testing appropriate for your system. For example, if your chosen technologies do not make it possible to inject state, it may be diffcult to re-create fault scenarios. ModifiabilityModifiability illustrate QAs from a static perspective. Measure how easy it might be to modify. This is a key area because change incurs cost. Four key questions:â€“ What can change?â€“ How likely is something to change?â€“ When, where, how and by whom will changes be made?â€“ What is the cost of making the change? General Scenario Tactics to control modifiability GPES ExampleVersion 1: General purpose query facility in each GP system.Version 2: Building a specific piece of business logic for each different query.Think about:â€“ What changes can happen?â€“ How likely is a change?â€“ When, where, how and by whom?â€“ How mush will it cost? GPES-relevant Scenarioâ€¢ Source: One of the stakeholders e.g. Medicines and Healthcare Products Regulatory Agencyâ€¢ Stimulus: Wants prescribing data on NSAIDsâ€¢ Artifacts: Code (but depending on the architecture this could be configuration data)â€¢ Environment: Operationâ€¢ Response: Develop the codeâ€¢ Response Measure: Data available 5 weeks after request GPES Version 1â€¢ Design and validate the query with the Medicines agency.â€¢ Code the query.â€¢ Test on some systems to ensure it does not have bad effects.â€¢ Rollout to all systems.â€¢ Make the query available to Medicines agency. GPES Version 2â€¢ Design and validate the query with Medicines agency.â€¢ Negotiate with the GP system providers on the design of the business logic (different in all systems?)â€¢ Are the providers the only vendor of such services? Should it go to a procurement?â€¢ Validate the queries on each systemâ€¢ Integrate the resultsâ€¢ Roll out to all systemsâ€¢ Make the query available to the Medicines Agency It seems likely that the GPES V2 architecture will not pass the modifiability scenario we describe. Are any of the modifiability tactics appropriate to change the architecture to enable it to pass the scenario?â–  Reduce Coupling is the category of tactics we need to consider.â–  Each of the following offer potential routes with slightly different emphases:â€¢ Use an intermediaryâ€¢ Restrict dependenciesâ€¢ Refactorâ€¢ Abstract common servicesâ–  Defer Binding: can we do this later in the process so it is more likely to be done by a computer than a human? Here this is unlikely.â–  More on Binding Timeâ€¢ Compile time/Build Time: component replacement, compile time parameters,â€¦â€¢ Deployment time: configuration scripts that bind at deployment, â€¦â€¢ Initialization time: resource filesâ€¢ Runtime: dynamic lookup, service lookup, name servers, plugins, publish-subscribe, shared repositories, (Maybe just in time compilation fits here too) Design checklist for ModifiabilityAllocation of responsibilitiesWork out how things are likely to change e.g. technical, legal, organisational, social, markets, customers..â–  Work out what responsibilities change.â–  Try to modularise so a change does not affect responsibilities that span many modules. Coordination modelLook at how changes are likely to affect coordination and try to ensure that the most likely changes impact coordination across a small number of modules Data modelSimilar to coordination model â€“ see how a change impacts on data models and try to esnure data model changes span as few modules as possible. Mapping among architectural elementsâ–  Looking at potential changes to the system, assess whether some may best be responded to by changing the mapping to elements.â–  Explore issues such as dependencies between elements, data holdings in elements, assignment of elements to processes, threads or processors. Resource Managementâ–  Determine how a change in responsibility or quality attribute will change resource.â–  Attempt to localise resourcing change resulting from a likely change to a small number of modules.â–  Look at ways of using policies or configuration to manage resource change more effectively Binding Timeâ–  Control choice of binding times so there are not too many combinations to consider.â–  Consider attempting to defer binding to later, balance this against the cost of providing a later binding mechanism. Choice of TechnologyChoose technologies that make the most likely changes easier (e.g. choose a technology that allows runtime alteration of critical parameters rather than one where parameters are chosen at compile time) but balance this agains the cost of the different technologies. Architectural ModellingSoftware Architecture is intended to give us control over Quality Attributes. Ideally weâ€™d like to be able to use Software Architecture to predict Quality Attributes. We should be able to build a predictive model of the Software Architecture and use the model to predict QAs. The current situation is patchyâ€¦ Some quality attributes, most notably performance and availability, have well-understood, time-tested analytic models that can be used to assist in an analysis. Analytic model means one that supports quantitative analysis. Types of Analysisâ€¢ Thought experiment: just a sort of discussion using informed people.â€¢ Back of the envelope: using very approximate techniques with unreliable assumptions.â€¢ Checklist: collated experience.â€¢ Analytic Model: based on sound abstractions â€“ heavily dependent on estimates being correctâ€¢ Simulation: higher level of detail â€“ less analytic, more concrete.â€¢ Prototype: approximate system in an experimental setup.â€¢ Experiment: fielded system, simulated loadâ€¢ Instrumentation: measuring the variable of interest Analyzing PerformanceModels have parameters, which are values you can set to predict values about the entity being modeled. Model can be used to understand the latency characteristics of an architectural design.Data Needed for the Queuing Modelâ–  We need the following information in order to model effectively:â€¢ The distribution for the arrival of service requestsâ€¢ The queuing disciplineâ€¢ The scheduling algorithmâ€¢ The distribution of service times for service requestsâ€¢ Network characteristicsâ–  The theory places restrictions on the distributionsâ€¢ Arrivals are usually expected to be Poisson Distributions specified by arrival rateâ€¢ Service times are usually exponentially distributed on the service rate.â€¢ Some queuing behaviors are excluded such as reneging or jockying Example: MVC, says nothing about its deployment. That is, there is no specifcation of how the model, the view, and the controller are assigned to processes and processors; thatâ€™s not part of the patternâ€™s concern. These and other design decisions have to be made to transform a pattern into an architecture. Until that happens, one cannot say anything with authority about how an MVC-based implementation will perform.Data for MVCâ€¢ Rate of service requests: the View component will service them at some rate.â€¢ Service requests to the Controller are generated by the View component.â€¢ Service requests from the Controller to the View componentâ€¢ Service requests from the Controller to the modelâ€¢ Service requests from the Model to the View Component Modelling MVCWe need estimates of:â–  Distribution of external service demandsâ–  Queuing Disciplines within the queues in front of each component.â–  Network latenciesâ–  Transfer characteristics:â€¢ View â€“ Controllerâ€¢ Controller â€“ Viewâ€¢ Controller â€“ Modelâ€¢ Model â€“ Viewâ–  Scaling to large numbers of components is an issue Analyzing AvailabilityOne key issue is how long it takes to detect that a failure has taken place. Example is a Broker system.Hot Spare çƒ­å¤‡ç”¨ (Active Redundancy)â€¢ Active and redundant both receive identical request stream.â€¢ Synchronous maintenance of broker state.â€¢ Fast failover in the event of failure of the active system. Warm Spare (Passive Redundancy)â€¢ Warm broker is maintained at the most recent checkpoint state.â€¢ In the event of failure the system rolls back to the most recent checkpoint.â€¢ This is slower than the hot spare approach Cold Spareâ€¢ No attempt to synchronise.â€¢ In the event of failure the cold spare is started.â€¢ The system state is recovered via interaction with other systems (so they have to be resilient to failure in the broker) Analysis at Different Stages of the Life Cycle Architecture in the Life Cycleså‰é¢éƒ¨åˆ†å…³æ³¨è½¯ä»¶æž¶æž„çš„ technical contextã€‚è¿™é‡Œå¼€å§‹å…³æ³¨ life cyclesã€‚The role of software architecture is different for different lifecycles. Balancing Agility and Disciplineâ€¢ Lifecycles generally impose some discipline on the development process.â€¢ Software Architectures often feature in Lifecycles as a stage or support for analysis or designâ€¢ Lifecycles exist because they codify useful patterns of activity and save us time and effortâ€¢ Agility focusses on getting adequate solutions to stakeholders with less time and effortâ€¢ We need to balance the discipline of lifecycles against the delivery focus of agility Lifecyclesâ€¢ Lifecycles underpin development processes by ordering stages and activities.â€¢ Any good organisation is always looking to improve its processes so there is usually an ongoing process improvement cycle focussed on making the process better. V-Model approach works well when you understand the concept and requirements. Agile Practiceâ€¢ Test-first programmingâ€¢ Refactoringâ€¢ Continuous integrationâ€¢ Simple Designâ€¢ Pair Programmingâ€¢ Common Codebaseâ€¢ Coding Standardsâ€¢ Open Work Area Agile vs. Plan Driven Early software development methods that emerged in the 1970s - such as the Waterfall method - is plan-driven and inï¬‚exible. But having a strong å…ˆæœŸ up-front plan provides for considerable predictability (as long as the requirements donâ€™t change too much) and makes it easier to coordinate large numbers of teams. Agile methods and practitioners, on the other hand, often è½»è§† scorn planning, preferring teamwork, frequent face-to-face communication, ï¬‚exibility, and adaptation. This enhances invention and creativity. â€¢ Work top-down and bottom-up simultaneously - balance will depend on the size and complexity of the project.â€¢ Top-down does architectural work based on things like patterns, product-line.â€¢ Bottom-up develops implementation and environment-specific constraints and solutions.â€¢ Focus on QAs, scenarios, tactics and processes to è°ƒå’Œ reconcile competing aspects provides a bottomup/top-down linkâ€¢ Balancing commitment and flexibility Analysis Techniques Product Line ArchitectureOne of the early success areas for Software Architecture was the development of Product Line Architectures. Product Line Architecture is an approach to adopt systematic reuse of architectural elements that involves changes in development process supported by specific practices that encourage reuse. A collection of software-intensive systems sharing a common, managed, set of features that satisfy the specific needs of a market segment or mission that are developed from a set of core assets in a prescribed way. Software Product Lines are directed by business goals in a particular application domain.â€¢ The products in a product line share a software product line architectureâ€¢ Products are structured by the product line architecture and are built from services and components.â€¢ Architercture and components are the core assets used to satisfy the business goals.â€¢ Product line leverage commonality and limit variability of the product. Benefits to the organisationâ€¢ Large-scale productivity gainsâ€¢ Improve time to marketâ€¢ Maintian market presence (rapidly evolving variants)â€¢ Sustain growthâ€¢ Improved market agilityâ€¢ Better use of skillsâ€¢ Enable mass customisationâ€¢ Gain control of configurationâ€¢ Improve product qualityâ€¢ Better predictability of cost, schedule and quality Costs of a product lineâ€¢ Architecture: flexible enough to support variation in the productsâ€¢ Software components: general enough to support variabilityâ€¢ Test plans, cases, data: take account of variation in componentsâ€¢ Business cases: must operate at the level of a product familyâ€¢ Project plans: generic and extensible to deal with variationâ€¢ Tools and processes: must support architecture, variation, configuration, ..â€¢ People, skills, training: need to be skilled in architecture and product lines.Product lines spread costs over several products:â€¢ Requirements and requirements analysis â€¢ Domain model â€¢ Architecture and design â€¢ Performance engineering â€¢ Documentation â€¢ Test cases, data, and plans â€¢ Skills â€¢ Processes, methods and tools â€¢ Defect fixing â€¢ Components and services Core Process Activitiesâ€¢ Core asset development: improving the base components in terms of qualities, products they support, and architecture.â€¢ Product development: identifying and building products to meet market need inside the product line.â€¢ Management: monitoring and improving the processes, tools and practices. Introducing Product Linesâ€¢ Proactive: Up-front investment to develop the core assets - need to know the market well (maybe have an already established set of products)â€¢ Reactive: Start with one or two products and use them to generate core assets.â€¢ Incremental: Develop core assets as the business need evolves. Example: Bosch Gasoline SystemsGoalsâ–  Competitiveness:â€¢ Reduced hardware resource consumptionâ€¢ Reduced time to market for new featuresâ–  Development efficiencyâ€¢ Reuse: Applications can be used across different generations of system; â€œcoreâ€ software is highly configurable and is reused via reconfiguration; â€œVehicle functionsâ€ can be used across gasoline and diesel enginesâ€¢ Easy configuration of software productsâ€¢ Increased planning accuracyâ–  Qualityâ€¢ Interface integrityâ€¢ Reuse of core assetsâ–  Customer needsâ€¢ Differentiation by individual software solutionsâ€¢ Clear feature-cost mapping Component Redesignâ–  Focussed on: reuse; simplification of calibration; resource consumption; stabilisation of interfaces (within the architecture)â–  Redesign progressed by:â€¢ Analysing existing software inventory: features, sources of variability; relation to product line; document interdependency.â€¢ Concept development and design of components: simplification; configurability; architecture driven structure; document relations between features and components;â€¢ Baselines for variants of software components: document baselines; implement; maintain up-to-date document and implementation. Phased Introductionâ–  Investigate and customise product line engineering.â–  Design and pilot adequate processes and methods.â–  Roll out and institutionalise in the standard development process. DevOpsThe line between development and operation becomes more blurred and the use of the live environment to test innovations becomes more common. DevOps is a set of practices that span development and operation. Operations have the direct experience of use of the systemâ€“ monitoring that use is a way of empirically verifying qualityâ€“ operations have the data that is used to regulate operations and is essential information for development. Development is responsible for building in the right monitoring to ensure operations can operate effectively. DevOps is a set of practices intended to reduce the time between committing a change to a system and the change being placed into normal operation while ensuring necessary quality. Open Services for Lifecycle Collaboration (OSLC): OSLC is an open and scalable approach to lifecycle integration. It simplifies key integration scenarios across heterogeneous tools. Traditionally we use test as the way of delivering quality change but we can â€œshepherdâ€ committed change into use by controlling quantities of change, users experiencing change, results of monitoring than this may offer a better way. Delivery mechanism needs to be high quality: reliable, repeatable, available. Critical pointsâ€¢ Making the decision to commit the code to be introduced into the system.â€¢ Transitioning from being under consideration into part of the production deployment that will be used by all users.â€¢ Issues is how to have enough confidence to make each of these transitions. Monitoring is critical.â€¢ The question is how to ensure the transitions are as reliable as possible. The extent of the lifecycleâ€¢ Involves all people involved in the delivery of the service/applicationâ€¢ Operations and development people are in continuous interaction.â€¢ We need architecture to achieve this.â€¢ Microservices architectural pattern is often used. Microservices The term â€œMicroservice Architectureâ€ has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services. The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API.â€” https://martinfowler.com/articles/microservices.html Attributes of Microservice Architectureâ€¢ Separately deployed unitsâ€¢ Very small service componentsâ€¢ Single purpose function or an independent portion of functionalityâ€¢ Distributedâ€¢ Loosely coupledâ€¢ Multiple versions are acceptableâ€¢ Asynchronousâ€¢ No Orchestration Architecture EvaluationEvaluation by Designerâ€¢ The consequences of the decision making regulate how much effort to put into the process â€“ more importance means more effort in evaluation.â€¢ Try to use iterative approaches that get deeper in order to eliminate unpromising alternatives early.â€¢ Donâ€™t strive for perfection, good enough for the context is usually enough. Peer Evaluationâ€¢ Fix on the QAs to consider as part of the review â€“ may be determined by the process or the business case.â€¢ The architect presents the architecture to the reviewers â€“ questions are for information.â€¢ The review is driven by the relevant scenarios â€“ the architect talks the review team through a scenario demonstrating the architecture meets the requirements captured in the scenario.â€¢ The outcome is a list of potential issues with actions: fix, mitigate, tolerate, â€¦ External Evaluationâ€¢ Means to bring in additional expertise.â€¢ May represent some stakeholder interests.â€¢ More expensive and difficult to organise so this will often correspond to some major hurdle in the process. The Architecture Tradeoff Analysis Method (ATAM) ATAM is a risk-mitigation process. Its purpose is to help choose a suitable architecture for a software system by discovering trade-offs and sensitivity points, to capture project risks.ATAM is most beneficial when done early in the software development life-cycle, when the cost of changing architectures is minimal. Designed to be usable where:â€“ Evaluators are not expert in the architectureâ€“ Evaluators need not be familiar with the business goals.â€“ The system need not be fully developedâ€“ There may be large numbers of stakeholders Participants in ATMâ€¢ The evaluation team: 3-5 people with designated roles (people may have multiple roles). Team members should be seen to be neutral with respect to the project.â€¢ Project decision takers: manager of the project, funder of the project, main architectâ€¢ Architecture stakeholders: developers, testers, integrators, maintainers, performance engineers, â€¦ ATAM evaluation team roles and responsibilitiesTeam LeaderSets up the evaluation; coordinates with client, making sure clientâ€™s needs are met; establishes evaluation contract; forms evaluation team; sees that final report is produced and delivered (although the writing may be delegated) Evaluation LeaderRuns evaluation; facilitates elicitation of scenarios; administers scenario selection/prioritization process; facilitates evaluation of scenarios against architecture; facilitates onsite analysis Scenario ScribeWrites scenarios on flipchart or whiteboard during scenario elicitation; captures agreed-on wording of each scenario, halting discussion until exact wording is captured Proceedings ScribeCaptures proceedings in electronic form on laptop or workstation, raw scenarios, issue(s) that motivate each scenario (often lost in the wording of the scenario itself), and resolution of each scenario when applied to architecture(s); also generates a printed list of adopted scenarios for handout to all participants TimekeeperHelps evaluation leader stay on schedule; helps control amount of time devoted to each scenario during the evaluation phase Process ObserverKeeps notes on how evaluation process could be improved or deviated from; usually keeps silent but may make discreet process-based suggestions to the evaluation leader during the evaluation; after evaluation, reports on how the process went and lessons learned for future improvement; also responsible for reporting experience to architecture evaluation team at large Process EnforcerHelps evaluation leader remember and carry out the steps of the evaluation method QuestionerRaise issues of architectural interest that stakeholders may not have thought of ATAM Outputsâ€¢ Concise presentation of the architecture â€“ needs to be presentable in around one hour.â€¢ Articulation of the business goals â€“ clearly communicated to all participantsâ€¢ Prioritized QA requirements expressed as scenarios â€“ testable QA requirements.â€¢ Risks and non-risks â€“ architecture decision that carries risks (or not).â€¢ Risk themes â€“ attempt to identify systemic risk by grouping risks into themes.â€¢ Mapping of Architecture Decisions to QA requirements â€“ motivating architecture decisions by QA requirementsâ€¢ Identified sensitivity and tradeoff decisions â€“ critical decisions that have significant impact on QA requirements. Partnership and preparation: Getting the schedule, agendas and list of stakeholders prepared, preparing necessary documents and presentations, and gettting documents to the evaluation team Steps of Evaluation PhaseThe ATAM analysis phases (phase 1 and phase 2) consist of nine steps. Steps 1 through 6 are carried out in phase 1 Presentation of the ATAM approach â€“ remind participants of the approach Business drivers presentation â€“ functions; constraints; business goals; major stakeholders; architectural drivers Architecture presentation: Context for the system Static modular view Component and connector view Deployment view Main QA requirements and how the architecture addresses them: What has been reused Trace of key use cases Trace of key change scenarios Main issues/risks driving architectural change Identify architectural approaches â€“ create a catalogue of patterns and tactics used in the architecture. Generate Quality Attribute Utility Tree this is an approach to identifying architecturally significant requirements (ASR) by looking through the QAs - identifying particular aspects of the QA that are relevant and any requirements related to that aspect of the QA. Each ASR is ranked High, Medium or Low in importance. Analyze architectural approaches â€“ look at the most important QA requirement scenarios as identified at stage 5 and probe how the architecture meets the QA scenario. In phase 2, with all stakeholders present, those steps are summarized Brainstorm prioritization of scenarios â€“ revisit the prioritization for additional scenarios, e.g. a particular stakeholder (performance engineer) might propose a scenario on the response time of the system. Analyze Architectural Approaches â€“ revisit stage 6 but with an expanded and reprioritized set of scenarios Present results â€“ the evaluation group tries to group risks into risk themes to identify systemic issues and results are presented. ATAM Resultsâ€¢ Documentation of architectural approaches taken by the project.â€¢ Prioritized list of scenariosâ€¢ Utility treeâ€¢ Risks discoveredâ€¢ Non-risks identifiedâ€¢ Sensitivity and Tradeoff points identified General Practice Extraction Service (GPES)An IT system designed to allow NHS organizations to extract data from GP practice computer systems in England. This data would be used to monitor quality, plan and pay for health services and help medical research.æ•°æ®çš„è¯·æ±‚å’Œè¿”å›žä¸éœ€è¦å®žæ—¶ï¼Œæ›´å¤šçš„æ˜¯å®šæœŸçš„è¯·æ±‚ï¼Œä¸€å®šæ—¶é—´å†…è¿”å›žæ•°æ®ã€‚ General practitioner (GP), å…¨ç§‘åŒ»ç”Ÿã€‚åœ¨è‹±å›½ï¼Œæ¯ä¸ªäººéƒ½éœ€è¦æ³¨å†Œä¸€ä¸ªå…¨ç§‘åŒ»ç”Ÿçš„è¯Šæ‰€ï¼Œå½“äººä»¬æ„Ÿåˆ°èº«ä½“ä¸é€‚åŽé¦–å…ˆä¼šåŽ»è”ç³»çš„è‡ªå·±çš„å…¨ç§‘åŒ»ç”Ÿã€‚å…¨ç§‘åŒ»ç”Ÿåªè¿›è¡Œæœ‰é™çš„æ²»ç–—ï¼Œå¹¶å»ºè®®æ˜¯å¦æœ‰å¿…è¦åŽ»åŒ»é™¢çœ‹ä¸“ç§‘åŒ»ç”Ÿã€‚æ¯ä¸ª GP éƒ½åƒå°å…¬å¸ä¸€æ ·è¿ä½œï¼Œæœ‰è‡ªå·±çš„ GP ç³»ç»Ÿï¼Œä¸ºæ‚£è€…ä¿ç•™ç—…æ‚£è®°å½•ã€‚åœ¨è‹±å›½ï¼Œå„ç§ä¸åŒçš„æœºæž„ç»„ç»‡å¯èƒ½éœ€è¦äº†è§£GPæ­£åœ¨åšä»€ä¹ˆï¼Œå› æ­¤éœ€è¦ä»Žæ‰€æœ‰è¿™äº›GPç³»ç»Ÿä¸­æå–æ•°æ®ã€‚GPES ç³»ç»Ÿå…è®¸é‚£äº›å·²ç»å¾—åˆ°æŽˆæƒçš„æœºæž„ç»„ç»‡ï¼Œé€šè¿‡ NHSCICï¼ˆå›½å®¶å«ç”Ÿå’Œç¤¾ä¼šä¿å¥ä¿¡æ¯ä¸­å¿ƒï¼‰æå–å„ç§GPæ•°æ®ã€‚å› ä¸ºä¸åŒæœºæž„éœ€è¦çš„ä¿¡æ¯ä¸åŒï¼ŒNHSCIC éœ€è¦ç ”ç©¶åˆ¶å®šå¦‚ä½•æå–æŒ‡å®šçš„æ•°æ®ï¼Œå¹¶è¿è¡Œ GPES ç³»ç»Ÿä»Žè‹±å›½çš„æ‰€æœ‰GPç³»ç»Ÿæå–æ•°æ®ã€‚GP å¯ä»¥ä»Žå››ç§ä¸åŒçš„ GP ç³»ç»Ÿä¸­å››é€‰ä¸€ã€‚è€Œ GPES çš„æŒ‘æˆ˜åœ¨äºŽæ•´åˆæ¥è‡ªå„ä¸ªä¸åŒç³»ç»Ÿçš„GPçš„æ•°æ®ã€‚ é—®é¢˜ The project has been significantly delayed and many customers have yet to receive data. Mistakes in the original é‡‡è´­ procurement and contract management contributed to losses of public funds, through asset write-offs and settlements with suppliers. Only one customer, NHS England has so far received data from GPES. The time needed to design a new type of extract and restrictions in the contracts severely limits HSCICâ€™s ability to provide data to those who request it. It is unlikely that GPES in its current form can provide the NHS-wide service planned. Data Extract Issue NHS did a technical review of GPES in early 2011, which recommended several significant changes to its design. In the original design, each GP system supplier would use a common query language as part of their extraction system. This would allow the NHSIC to design a single extract centrally using the query tool, which all GP clinical systems could understand. The technical review recommended an alternative where each supplier would be free to develop their own query methods. New queries would no longer be designed in the query tool using a common language, but would instead need to be designed as logical â€˜business rulesâ€™ and sent to GP system suppliers to implement. The NHSIC decided to abandon both the GPSOC contract approach and the common query language, as they could not agree either with the Department and GP system suppliers. They then procured the extraction systems by negotiating direct with the GP clinical system suppliers. NHSIC is using a non-competitive procurement approach, plus the changes in design, contributed to the restrictive process for designing new extracts. The HSCIC, has continued to use the GPSOC framework to require data sharing between NHS systems. The new framework, effective from 2014, says that principal clinical system suppliers must provide an interface method for third-party systems to use. This would improve interoperability between systems in GP practices and the health community. The HSCIC cannot do the wide range and scale of data extracts the NHS requests, because of the design of the GPES system and restrictions in supplier contracts. Customers have requested over 100 different data extracts from GPES, but the HSCIC estimate they will be able to design only 24 new extracts in 2015-16. Figure shows a summary of the HSCICâ€™s process to develop a new extract, each of which the supplier designs and programmes from scratch. The HSCIC have limited flexibility to amend extracts once developed, for example to change a time period and the specific organisations it will extract data from. GPES will continue to operate in the short term, as its data is critical for determining payments to GPs. Its coverage of all practices in England cannot currently be replicated by other primary care data extraction systems. However, limited capacity and the difficulty of developing new extracts deters wider use. The HSCIC has acknowledged there is unlikely to be a long-term future for all or part of the GPES. However, they intend to reuse parts for a replacement system if possible. The HSCIC estimate that they will achieve less than two more years of use from the GPES in its current form, in contrast to the five-year minimum lifetime assumed for new IT systems.]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Software Testing]]></title>
    <url>%2FUoE-st%2F</url>
    <content type="text"><![CDATA[çˆ±ä¸å ¡å¤§å­¦ä¿¡æ¯å­¦é™¢è¯¾ç¨‹ç¬”è®° Software Testing, Informatics, University of Edinburgh Reference:http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.htmlPezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007. Why Software Testing?1, è½¯ä»¶çš„æ¼æ´ž, é”™è¯¯å’Œå¤±æ•ˆ Software Faults, Errors &amp; FailuresThe problem start with Faults, Fault(BUG): latent error, mistakes in programming. e.g add(x, y) = x * y.With the Faults in programs, if and only if executing add(x, y) = x * y, the fault being activated, and generate an Errors. Error: An incorrect internal state that is the manifestation of some fault Now we has an effective Error, if and only if we use the values from add(x, y) = x * y to contribute to the program function (such as, assign it to some variables), then we get the Failure. Failure : External, observable incorrect behavior with respect to the requirements or other description of the expected behavior. æ€»ç»“: è½¯ä»¶çš„æ¼æ´žä¸ä¸€å®šä¼šå¯¼è‡´é”™è¯¯, é”™è¯¯ä¸ä¸€å®šä¼šå¯¼è‡´è½¯ä»¶å¤±æ•ˆ. 2, è½¯ä»¶å·¥ç¨‹éœ€è¦éªŒè¯ç¡®è®¤ åœ¨è½¯ä»¶é¡¹ç›®ç®¡ç†ã€è½¯ä»¶å·¥ç¨‹åŠè½¯ä»¶æµ‹è¯•ä¸­ï¼ŒéªŒè¯åŠç¡®è®¤ï¼ˆverification and validationï¼Œç®€ç§°V&amp;Vï¼‰æ˜¯æŒ‡æ£€æŸ¥è½¯ä»¶æ˜¯å¦åŒ¹é…è§„æ ¼åŠå…¶é¢„æœŸç›®çš„çš„ç¨‹åºã€‚éªŒè¯åŠç¡®è®¤ä¹Ÿè¢«è§†ä¸ºä¸€ç§è½¯ä»¶è´¨é‡ç®¡ç†ï¼Œæ˜¯è½¯ä»¶å¼€å‘è¿‡ç¨‹çš„ä¸€éƒ¨åˆ†ï¼Œä¸€èˆ¬å½’ç±»åœ¨è½¯ä»¶æµ‹è¯•ä¸­ã€‚ Validation: æ˜¯å¦ç¬¦åˆé¢„æœŸçš„ç›®çš„ï¼Œæ˜¯å¦æ»¡è¶³ç”¨æˆ·å®žé™…éœ€æ±‚ï¼Ÿ Verification: meets the specification? Verification and Validation ï¼ˆV&amp;Vï¼‰ start at the beginning or even before we decide to build a software product. V&amp;V last far beyond the product delivery as long as the software is in use, to cope with evolution and adaptations to new conditions. The distinction between the two terms is largely to do with the role of specifications. Validation is the process of checking whether the specification captures the customerâ€™s needs, while verification is the process of checking that the software meets the specification. 3, è½¯ä»¶å·¥ç¨‹çš„å¯é æ€§ Dependability In software engineering, dependability is the ability to provide services that can defensibly be trusted within a time-period Assess the readiness of a product. Different measures of dependability:â€¢ Availability measures the quality of service in terms of running versus down timeâ€¢ Mean time between failures (MTBF) measures the quality of the service in terms of time between failuresâ€¢ Reliability indicates the fraction of all attempted operations that complete successfully JUnitsJUnit Terminologyâ€¢ A test runner is software that runs tests and reports results. Many implementations: standalone GUI, command line, integrated into IDEâ€¢ A test suite is a collection of test cases.â€¢ A test case tests the response of a single method to a particular set of inputs.â€¢ A unit test is a test of the smallest element of code you can sensibly test, usually a single class. å¦‚ä½•ä½¿ç”¨è¯·å‚è€ƒJava æµ‹è¯•. Test class@Before public void init(): Creates a test fixture by creating and initialising objects and values. @After public void cleanUp(): Releases any system resources used by the test fixture. Java usually does this for free, but files, network connections etc. might not get tidied up automatically. @Test public void noBadTriangles(), @Test public void scaleneOk(), etc.These methods contain tests for the Triangle constructor and its isScalene() method. Test assertstatic void assertTrue(boolean test),static void assertTrue(String message, boolean test),static void assertFalse(boolean test),static void assertFalse(String message, boolean test) è½¯ä»¶æµ‹è¯•çš„æ ¸å¿ƒé—®é¢˜å’Œè§£å†³æ€è·¯A key problem in software testing is selecting and evaluating test cases. Test case: A test case is a set of inputs, execution conditions, and a pass/fail criterion. Test case specification is a requirement to be satisfied by one or more actual test cases. Test suite: a set of test cases. Adequacy criterion: a predicate that is true (satisfied) or false (not satisfied) of a &lt; program, test suite &gt; pair. Adequacy criterion is a set of test obligations, which can be derived from several sources of information, includingâ€¢ specifications (functional and model-based testing)â€¢ detailed design and source code (structural testing),â€¢ model of systemâ€¢ hypothesized defects (fault-based testing),â€¢ security testing. Test Case Selection and Adequacy CriteriaHow do we know when the test suite is enough?It is impossibal to provide adequate test suite for a system to pass. Instead, design rules to highlight inadequacy of test suites: if outcome break the rule, then there is bugs, if not, then not sureâ€¦ Test case specification: a requirement to be satisfied by one or more test cases. Test obligation: a partial test case specification, requiring some property deemed important to thorough testing. From:â€¢ Functional (black box specification Functional (black box, specification based): from software specificationsâ€¢ Structural (white or glass box): from codeâ€¢ Model-based: from model of system, models used in specification or design, or derived from codeâ€¢ Fault-based: from hypothesized faults (common bugs) Adequacy criterion: set of test obligations, a predicate that is true (satisfied) or false (not satisfied) of a (program, test suite) pair. A test suite satisfies an adequacy criterion if:â€¢ all the tests succeed (pass)â€¢ every test obligation in the criterion is satisfied by at least one of the test cases in the test suite. SatisfiabilitySometimes no test suite can satisfy a criterion for a given program, e.g. defensive programming style includes â€œcanâ€™t happenâ€ sanity checks. Coping with Unsatisfiability:Approach A, exclude any unsatisfiable obligation from the criterion.â€¢ Example: modify statement coverage to require execution only of statements that can be executed - But we canâ€™t know for sure which are executable! Approach B, measure the extent to which a test suite approaches an adequacy criterionâ€¢ Example: if a test suite satisfies 85 of 100 obligations we have reached 85% coverage. An adequacy criterion is satisfied or not, a coverage measure is the fraction of satisfied obligations Subsumption relationTest adequacy criterion A subsumes test adequacy criterion B iff, for every program P, every test suite satisfying A with respect to P also satisfies B with respect to P. e.g. Exercising all program branches (branch coverage) subsumes exercising all program statements Functional TestingDesign functional test case: Generate test cases from specifications. Specification: A functional specification is a description of intended program behavior. Not based on the internals of the code but program specifications, functional testing is also called specification-based or black-box testing é»‘ç®±æ¸¬è©¦. The core of functional test is systematic selection of test cases: partitioning the possible behaviors of the program into a finite number of homogeneous classes, where each such class can reasonably be expected to be consistently correct or incorrect. Test each category and boundaries between (experience suggests failures often lie at the boundaries). Functional test case design is an indispensable base of a good test suite, complemented but never replaced by structural and fault-based testing, because there are classes of faults that only functional testing effectively detects. Omission of a feature, for example, is unlikely to be revealed by techniques that refer only to the code structure. Partition StrategiesFailures are sparse in the whole input space, and dense in some specific regions, justified based on specification. Random (uniform):â€¢ Pick possible inputs uniformlyâ€¢ Avoids designer bias: The test designer can make the same logical mistakes and bad assumptions as the program designer (especially if they are the same person)â€¢ But treats all inputs as equally valuable Systematic (non-uniform, Partition Testing Strategies):â€¢ Try to select inputs that are especially valuableâ€¢ Usually by choosing representatives of classes that are apt to fail often or not at allâ€¢ (Quasi-)Partition: separates the input space into classes whose union is the entire space (classes may overlap), sampling each class in the quasi-partition selects at least one input that leads to a failure, revealing the fault. Steps of systematic approaches to form test cases from specifications:1, Decompose the specification. If the specification is large, break it into independently testable features (ITF) to be considered in testing:â€¢ An ITF is a functionality that can be tested independently of other functionalities of the software under test. It need not correspond to a unit or subsystem of the software.â€¢ ITFs are described by identifying all the inputs that form their execution environments.â€¢ ITFs are applied at different granularity levels, from unit testing through integration and system testing. The granularity of an ITF depends on the exposed interface and whichever granularity(unit or system) is being tested.2, Identify Representative Classes of Values or Derive a Modelâ€¢ Representative values of each inputâ€¢ Representative behaviors of a model: simple input/output transformations donâ€™t describe a system. We use models in program specification, in program design, and in test design3, Generate Test Case Specifications with constraints: The test case specifications represented by the combinations (cartesian product) of all possible inputs or model behaviors, which must be restricted by ruling out illegal combinations and selecting a practical subset of the legal combinations. Given a specification, there may be one or more techniques well suited for deriving functional test case. For example, the presence of several constraints on the input domain may suggest using a partitioning method with constraints, such as the category-partition method. While unconstrained combinations of values may suggest a pairwise combinatorial approach. If transitions among a finite set of system states are identifiable in the specification, a finite state machine approach may be indicated. Combinatorial approaches Combinatorial approaches to functional testing consist of a manual step of structuring the specification statement into a set of properties or attributes that can be systematically varied and an automatizable step of producing combinations of choices. æ€»ä½“æ€è·¯ï¼š1, Identify distinct attributes that can be varied: the data, environment, or configuration2, Systematically generate combinations to be tested Rational: test cases should be varied and include possible â€œcorner casesâ€ Environment describes external factors we need to configure in particular ways in order to specify and execute tests to fully exercise the system. Some common options: System memory, Locale. There are three main techniques that are successfully used in industrial environments and represent modern approaches to systematically derive test cases from natural language specifications:â€¢ category-partition approach to identifying attributes, relevant values, and possible combinations;â€¢ Pairwise (n-way) combination test a large number of potential interactions of attributes with a relatively small number of inputs;â€¢ provision of catalogs to systematize the manual aspects of combinatorial testing. Combinatorial approaches å°†test casesçš„ç²—æš´åˆæˆåˆ†è§£æˆä¸€ä¸ªä¸ªæ­¥éª¤ï¼Œé€šè¿‡è§£æžå’Œç»¼åˆé‚£äº›å¯ä»¥é‡åŒ–å’Œç›‘æŽ§(å¹¶å¾—åˆ°å·¥å…·éƒ¨åˆ†æ”¯æŒ)çš„æ´»åŠ¨æ¥é€æ­¥æ‹†è§£é—®é¢˜. A combinatorial approach may work well for functional units characterized by a large number of relatively independent inputs, but may be less effective for functional units characterized by complex interrelations among inputs. Category-partition å’Œ pairwise partition éƒ½æ˜¯ä½¿ç”¨ä¸Šé¢çš„æ€»ä½“æ€è·¯ï¼Œå·®åˆ«åœ¨äºŽæœ€åŽå¦‚ä½•è‡ªåŠ¨ç”Ÿæˆ test casesã€‚ Category-partitionå°†ç©·ä¸¾æžšä¸¾ä½œä¸ºè‡ªåŠ¨ç”Ÿæˆcombinationsçš„åŸºæœ¬æ–¹æ³•ï¼ŒåŒæ—¶å…è®¸æµ‹è¯•è®¾è®¡è€…æ·»åŠ é™åˆ¶ç»„åˆæ•°é‡å¢žé•¿çš„çº¦æŸæ¡ä»¶ã€‚å½“è¿™äº›çº¦æŸèƒ½å¤Ÿåæ˜ åº”ç”¨åŸŸä¸­çš„çœŸå®žçº¦æŸï¼ˆä¾‹å¦‚ï¼Œcategory-partitionä¸­çš„â€errorâ€æ¡ç›®ï¼‰æ—¶ï¼Œèƒ½å¤Ÿéžå¸¸æœ‰æ•ˆåœ°æ¶ˆé™¤è®¸å¤šå†—ä½™ç»„åˆã€‚ Decompose the specification into independently testable features for each feature: identify parameters, environment elements for each parameter and environment element: identify elementary characteristics (categories) Identify relevant/representative values: for each category identify representative (classes of) values normal values boundary values select extreme values within a class ((e.g., maximum and minimum legal values) select values outside but as close as possible to the class select interior (non-extreme) values of the class special values: 0 and 1, might cause unanticipated behavior alone or in combination with particular values of other parameters. error values: values outside the normal domain of the program Ignore interactions among values for different categories (considered in the next step) Introduce constraints: rule out invalid combinations. For single consgtraints, indicates a value class that test designers choose to test only once to reduce the number of test cases. ä¼˜ç‚¹ï¼šCategory partition testing gave us systematic approach -Identify characteristics and values (the creative step), generate combinations (the mechanical step). ç¼ºç‚¹ï¼štest suite size grows very rapidly with number of categories. ä¸é€‚åˆä½¿ç”¨Category partition testingçš„æƒ…å†µï¼šå½“ç¼ºä¹åº”ç”¨é¢†åŸŸçš„å®žé™…çº¦æŸæ—¶ï¼Œæµ‹è¯•è®¾è®¡è€…ä¸ºäº†å‡å°‘ç»„åˆæ•°é‡è¢«è¿«ä»»æ„æ·»åŠ çš„çº¦æŸï¼ˆä¾‹å¦‚ï¼Œâ€singleâ€æ¡ç›®ï¼‰ï¼Œæ­¤æ—¶ä¸èƒ½å¾ˆæœ‰æ•ˆçš„å‡å°‘ç»„åˆæ•°é‡ã€‚ Pairwise combination testingMost failures are triggered by single values or combinations of a few values. ä¸ºnä¸ªæµ‹è¯•ç±»é€‰æ‹©ç»„åˆæ—¶ï¼Œé™¤äº†ç®€å•åœ°æžšä¸¾æ‰€æœ‰å¯èƒ½çš„ç»„åˆå¤–ï¼Œæ›´å®žé™…çš„ç»„åˆæ–¹æ¡ˆæ˜¯åœ¨é›†åˆnä¸­å–å‡ºk(k&lt;n)é¡¹, ä¸€èˆ¬æ˜¯äºŒå…ƒç»„æˆ–ä¸‰å…ƒç»„ï¼Œæ€»çš„ test cases è¦åŒ…å«æ‰€æœ‰ features çš„ä¸¤ä¸¤ï¼ˆæˆ–ä¸‰ä¸‰ï¼‰ç»„åˆã€‚ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹æ—¶ï¼Œå…ˆæŽ§åˆ¶æŸä¸€ä¸ªå˜é‡é€ä¸€æ”¹å˜ï¼Œè®°å½•é…å¯¹äº†çš„å˜é‡ï¼ŒåŽç»­é‡åˆ°é‡å¤çš„å°±å¯ä»¥å¿½ç•¥ã€‚è¿™æ ·å³ä½¿æ²¡æœ‰åŠ constraintsä¹Ÿå¯ä»¥å¤§å¤§å‡å°‘ç»„åˆæ•°ï¼ˆä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥åŠ constraintsï¼‰ã€‚ ä½¿ç”¨ä½Žé˜¶ç»„åˆæž„å»ºæµ‹è¯•ç”¨ä¾‹æ—¶ï¼Œå¯èƒ½ä¼šé—æ¼æŸäº›é«˜é˜¶ç»„åˆçš„æƒ…å†µã€‚ Befinits of functional testingFunctional testing is the base-line technique for designing test cases:â€¢ Timely: Often useful in refining specifications and assessing testability before code is writtenâ€¢ Effective: finds some classes of fault (e.g.,missing logic) that can elude other approachesâ€¢ Widely applicable: to any description of program behavior serving as spec, at any level of granularity from module to system testing.â€¢ Economical: typically less expensive to design and execute than structural (code-based) test cases Early functional testing design:â€¢ Program code is not necessary: Only a description of intended behavior is neededâ€¢ Often reveals ambiguities and inconsistency in specâ€¢ Useful for assessing testability, and improving test schedule and budget by improving specâ€¢ Useful explanation of specification, or in the extreme case (as in Extreme Programming), test cases are the spec Finite Modelså»ºæ¨¡ä¸»è¦è§£å†³ä¸¤ä¸ªå·¥ç¨‹é—®é¢˜:â€¢ é¦–å…ˆï¼Œä¸èƒ½ç­‰åˆ°å®žé™…çš„äº§å“å‡ºæ¥åŽæ‰åˆ†æžå’Œæµ‹è¯•ã€‚â€¢ å…¶æ¬¡ï¼Œå¯¹å®žé™…äº§å“è¿›è¡Œå½»åº•çš„æµ‹è¯•æ˜¯ä¸åˆ‡å®žé™…çš„ï¼Œæ— è®ºæ˜¯å¦å—åˆ¶äºŽæ‰€æœ‰å¯èƒ½çš„çŠ¶æ€å’Œè¾“å…¥ã€‚ æ¨¡åž‹å…è®¸æˆ‘ä»¬åœ¨å¼€å‘æ—©æœŸå°±ç€æ‰‹åˆ†æžï¼Œå¹¶éšç€è®¾è®¡çš„å‘å±•é‡å¤åˆ†æžï¼Œå¹¶å…è®¸æˆ‘ä»¬åº”ç”¨æ¯”å®žé™…æƒ…å†µæ›´å¹¿æ³›çš„åˆ†æžæ–¹æ³•ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œè¿™äº›åˆ†æžå¾ˆå¤šéƒ½æ˜¯å¯ä»¥è‡ªåŠ¨åŒ–çš„ã€‚ Model program execution, emphasized control. A model is a representation that is simpler than the artifact it represents but preserves (or at least approximates) some important attributes of the actual artifact. A good model is:â€¢ compact: A model must be representable and manipulable in a reasonably compact form.â€¢ Predictive: well enough to distinguish between â€œgoodâ€ and â€œbadâ€ outcomes of analysis.â€¢ Semantically meaningful: interpret analysis results in a way that permits diagnosis of the causes of failure.â€¢ Sufficiently general: Models intended for analysis of some important characteristic must be general enough for practical use in the intended domain of application. æ¨¡åž‹çš„è¡¨è¾¾ï¼šä½¿ç”¨æœ‰å‘å›¾æè¿°ç¨‹åºæ¨¡åž‹ã€‚é€šå¸¸æˆ‘ä»¬å°†å®ƒä»¬ç»˜åˆ¶ä¸ºâ€æ–¹æ¡†å’Œç®­å¤´â€å›¾ï¼Œç”±ä¸€ç»„èŠ‚ç‚¹Nçš„ç»„æˆçš„é›†åˆå’Œå®ƒä»¬é—´çš„å…³ç³»Eï¼ˆå³ordered pairsçš„é›†åˆï¼‰ï¼Œedgesã€‚èŠ‚ç‚¹è¡¨ç¤ºæŸç§ç±»åž‹çš„å®žä½“ï¼Œä¾‹å¦‚æºä»£ç çš„æ­¥éª¤ï¼Œç±»æˆ–åŒºåŸŸã€‚è¾¹è¡¨ç¤ºå®žä½“ä¹‹é—´çš„æŸç§å…³ç³»ã€‚ æ¨¡æ‹Ÿç¨‹åºæ‰§è¡Œçš„æ¨¡åž‹ï¼Œæ˜¯è¯¥ç¨‹åºçŠ¶æ€ç©ºé—´çš„æŠ½è±¡ã€‚é€šè¿‡æŠ½è±¡å‡½æ•°ï¼Œç¨‹åºè¿è¡ŒçŠ¶æ€ç©ºé—´ä¸­çš„çŠ¶æ€ä¸Žç¨‹åºè¿è¡Œçš„finite state æ¨¡åž‹ä¸­çš„çŠ¶æ€ç›¸å…³è”ã€‚ä½†æŠ½è±¡å‡½æ•°æ— æ³•å®Œç¾Žå‘ˆçŽ°ç¨‹åºè¿è¡Œçš„æ‰€æœ‰ç»†èŠ‚ï¼Œå°†å®žé™…çš„æ— é™å¯èƒ½çš„çŠ¶æ€æŠ˜å æˆæœ‰é™å¿…ç„¶éœ€è¦çœç•¥ä¸€äº›ä¿¡æ¯ï¼Œè¿™å°±å¼•å…¥äº†ä¸ç¡®å®šæ€§nondeterminismã€‚ æœ‰ä»€ä¹ˆè½¯ä»¶æ¨¡åž‹çš„åŸºæœ¬æ¦‚å¿µï¼Œåˆæœ‰å“ªäº›å¯ä»¥åº”ç”¨äºŽæµ‹è¯•å’Œåˆ†æžçš„æ¨¡åž‹ï¼Ÿ Controal flow graphç¨‹åºä¸­çš„å•ä¸ªæ­¥éª¤æˆ–æ–¹æ³•çš„ Control flow å¯ä»¥ç”¨ è¿‡ç¨‹å†…æµç¨‹å›¾ intraprocedural control flow graph (CFG) æ¥è¡¨ç¤º. CFG æ¨¡æ‹Ÿé€šè¿‡å•ä¸ªè¿‡ç¨‹æˆ–æ–¹æ³•çš„å¯èƒ½è¿è¡Œè·¯å¾„, æ˜¯ä¸€ä¸ªæœ‰å‘å›¾ï¼Œnodes è¡¨ç¤ºæºä»£ç çš„ä¸€ä¸ªä¸ªåŒºåŸŸï¼Œæœ‰å‘è¾¹ directed edges è¡¨ç¤ºç¨‹åºå¯ä»¥åœ¨å“ªäº›ä»£ç åŒºåŸŸé—´æµè½¬.123456789101112public static String collapseNewlines(String argStr) &#123; char last = argStr.charAt(0); StringBuffer argBuf = new StringBuffer(); for (int cIdx = 0 ; cIdx &lt; argStr.length(); cIdx++) &#123; char ch = argStr.charAt(cIdx); if (ch != '\n' || last != '\n') &#123; argBuf.append(ch); last = ch; &#125; &#125; return argBuf.toString();&#125; å·¦è¾¹æ˜¯ä¸Šé¢ä»£ç å¯¹åº”çš„CFGï¼Œå³è¾¹çš„è¡¨æ ¼æ˜¯Linear Code Sequence and Jump (LCSJ)ï¼Œè¡¨ç¤ºä»Žä¸€ä¸ªåˆ†æ”¯åˆ°å¦ä¸€ä¸ªåˆ†æ”¯çš„æŽ§åˆ¶æµç¨‹å›¾çš„å­è·¯å¾„ Nodes = regions of source code (basic blocks)â€¢ Basic block = maximal program region with a single entry and single exit pointâ€¢ Often statements are grouped in single regions to get a compact modelâ€¢ Sometime single statements are broken into more than one node to model control flow within the statementDirected edges = possibility that program execution proceeds from the end of one region directly to the beginning of another ä¸ºäº†ä¾¿äºŽåˆ†æžï¼ŒæŽ§åˆ¶æµç¨‹å›¾é€šå¸¸ä¼šé€šè¿‡å…¶ä»–ä¿¡æ¯è¿›ä¸€æ­¥åŠ æŒã€‚ä¾‹å¦‚ï¼ŒåŽé¢ä»‹ç»çš„æ•°æ®æµæ¨¡åž‹ data flow models å°±æ˜¯åŸºäºŽåŠ æŒäº†æœ‰å…³å˜é‡è¢«ç¨‹åºå„ä¸ªè¯­å¥è®¿é—®å’Œä¿®æ”¹çš„ä¿¡æ¯çš„CFGæ¨¡åž‹æž„å»ºçš„. Call Graphsè¿‡ç¨‹é—´æµç¨‹ Interprocedural control flow ä¹Ÿå¯ä»¥è¡¨ç¤ºä¸ºæœ‰å‘å›¾ã€‚æœ€åŸºæœ¬çš„æ¨¡åž‹æ˜¯è°ƒç”¨å›¾ call graphs, nodes represent procedures (methods, C functions, etc.) and edges represent the â€œcallsâ€ relation. ç›¸è¾ƒäºŽCFGï¼Œè°ƒç”¨å›¾æ¯”æœ‰æ›´å¤šè®¾è®¡é—®é¢˜å’Œæƒè¡¡å¦¥åï¼Œ å› æ­¤åŸºæœ¬è°ƒç”¨å›¾çš„è¡¨è¾¾æ–¹å¼æ˜¯ä¸å›ºå®šçš„ï¼Œç‰¹åˆ«æ˜¯åœ¨é¢å‘å¯¹è±¡çš„è¯­è¨€ä¸­ï¼Œmethodsè·Ÿå¯¹è±¡åŠ¨æ€ç»‘å®šã€‚è°ƒç”¨å›¾å­˜åœ¨OverapproximationçŽ°è±¡ï¼Œæ¯”å¦‚å°½ç®¡æ–¹æ³•A.check()æ°¸è¿œä¸ä¼šå®žé™…è°ƒç”¨C.foo()ï¼Œä½†æ˜¯ä¸€ä¸ªå…¸åž‹çš„è°ƒç”¨å›¾ä¼šè®¤ä¸ºè¿™ä¸ªè°ƒç”¨æ˜¯å¯èƒ½çš„ã€‚ Context-sensitive call graphï¼šè°ƒç”¨å›¾æ¨¡åž‹æ ¹æ®è¿‡ç¨‹è¢«è°ƒç”¨çš„å…·ä½“ä½ç½®æ¥è¡¨ç¤ºä¸åŒè¡Œä¸ºã€‚123456789101112131415161718192021public class Context &#123; public static void main(String args[]) &#123; Context c = new Context(); c.foo(3); c.bar(17); &#125; void foo(int n) &#123; int[] myArray = new int[ n ]; depends( myArray, 2) ; &#125; void bar(int n) &#123; int[] myArray = new int[ n ]; depends( myArray, 16) ; &#125; void depends( int[] a, int n ) &#123; a[n] = 42; &#125;&#125; Context sensitive analyses can be more precise than Context-insensitive analyses when the model includes some additional information that is shared or passed among procedures. But sensitive call graphs size grows exponentially, not fit for large program. Finite state machineså‰é¢ä»‹ç»çš„æ¨¡åž‹éƒ½æ˜¯éƒ½æ˜¯åŸºäºŽæºä»£ç æŠ½è±¡å‡ºæ¥çš„ã€‚ä¸è¿‡ï¼Œæ¨¡åž‹çš„æž„å»ºä¹Ÿå¸¸å¸¸å…ˆäºŽæˆ–è€…ç‹¬ç«‹äºŽæºä»£ç ï¼Œæœ‰é™çŠ¶æ€æœº finite state machines å°±æ˜¯è¿™ç§æ¨¡åž‹ã€‚ æœ‰é™çŠ¶æ€æœºï¼ˆfinite-state machineï¼ŒFSMï¼‰åˆç§°æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼Œç®€ç§°çŠ¶æ€æœºï¼Œæ˜¯è¡¨ç¤ºæœ‰é™ä¸ªçŠ¶æ€ä»¥åŠåœ¨è¿™äº›çŠ¶æ€ä¹‹é—´çš„è½¬ç§»å’ŒåŠ¨ä½œç­‰è¡Œä¸ºçš„æ•°å­¦æ¨¡åž‹ã€‚ æœ€ç®€å•çš„FSMç”±ä¸€ä¸ªæœ‰é™çš„çŠ¶æ€é›†åˆå’ŒçŠ¶æ€é—´çš„è½¬ç§»åŠ¨ä½œæž„æˆï¼Œå¯ä»¥æœ‰å‘å›¾è¡¨ç¤ºï¼ŒèŠ‚ç‚¹è¡¨ç¤ºçŠ¶æ€ï¼Œedgesè¡¨ç¤ºåœ¨çŠ¶æ€é—´çš„è½¬ç§»éœ€è¦çš„è¿ç®—ã€æ¡ä»¶æˆ–è€…äº‹ä»¶ã€‚å› ä¸ºå¯èƒ½å­˜åœ¨æ— é™å¤šçš„ç¨‹åºçŠ¶æ€ï¼Œæ‰€ä»¥çŠ¶æ€èŠ‚ç‚¹çš„æœ‰é™é›†åˆå¿…é¡»æ˜¯å…·ä½“ç¼–ç¨‹çŠ¶æ€çš„æŠ½è±¡ã€‚ Usually we label the edge to indicate a program operation, condition, or event associated with the transition. We may label transitions with both an external event or a condition and with a program operation that can be thought of as a â€œresponseâ€ to the event. Such a finite state machine with event/response labels on transitions is called a Mealy machine. In the theory of computation, a Mealy machine is a finite-state machine whose output values are determined both by its current state and the current inputs. (This is in contrast to a Moore machine, whose output values are determined solely by its current state.) An alternative representation of finite state machines, including Mealy machines, is the state transition table:There is one row in the transition table for each state node and one column for each event or input. If the FSM is complete and deterministic, there should be exactly one transition in each table entry. Since this table is for a Mealy machine, the transition in each table entry indicates both the next state and the response (e.g., d / emit means â€œemit and then proceed to state dâ€). Structural TestingJudging test suite thoroughness based on the structure of the program itself, it is still testing product functionality against its specification, but the measure of thoroughness has changed to structural criteria. Also known as â€œwhite-boxâ€, â€œglass-boxâ€, or â€œcodebasedâ€ testing. Motivation:1, If part of a program is not executed by any test case in the suite, faults in that part cannot be exposed. The part is a control flow element or combination, statements (or CFG nodes), branches (or CFG edges), fragments and combinations, conditions paths.2, Complements functional testing, another way to recognize cases that are treated differently3, Executing all control flow elements does not guarantee finding all faults: Execution of a faulty statement may not always result in a failureâ€¢ The state may not be corrupted when the statement is executed with some data valuesâ€¢ Corrupt state may not propagate through execution to eventually lead to failure4, Structural coverage: Increases confidence in thoroughness of testing, removes some obvious inadequacies Steps: Create functional test suite first, then measure structural coverage to identify see what is missing Interpret unexecuted elements may be due to natural differences between specification and implementation or may reveal flaws of the software or its development process inadequacy of specifications that do not include cases present in the implementation coding practice that radically diverges from the specification inadequate functional test suites Coverage measurements are convenient progress indicators, sometimes used as a criterion of completion. Control-flow Adequacy (expression coverage)A structural testing strategy that uses the programâ€™s control flow as a model. Control flow elements include statements, branches, conditions, and paths. But a set of correct program executions in which all control flow elements are exercised does not guarantee the absence of faults. Test based on control-flow are concerned with expression coverage. Statement testingAdequacy criterion: each statement (or node in the CFG) must be executed at least once. Because a fault in a statement can only be revealed by executing the faulty statement. Coverage: #(executed statements) / #(statements) Minimizing test suite size is seldom the goal, but small test cases make failure diagnosis easier. Complete statement coverage may not imply executing all branches in a program. Branch testingAdequacy criterion: each branch (edge in the CFG) must be executed at least once. Coverage: #(executed branches) / #(branches)Traversing all edges of a graph causes all nodes to be visited: test suites that satisfy the branch adequacy criterion for a program P also satisfy the statement adequacy criterion for the same program But â€œAll branchesâ€ can still miss conditions.Sample fault: missing operator (negation):digit_high == 1 || digit_low == -1, branch adequacy criterion can be satisfied by varying only part of the condition. Condition testingBasic condition adequacy criterion: each basic condition must be executed at least once. Coverage: #(truth values taken by all basic conditions) / 2 * #(basic conditions) Branch and basic condition are not comparable. Basic condition adequacy criterion can be satisfied without satisfying branch coverage Branch and condition adequacy: cover all conditions and all decisions Compound condition adequacy:â€¢ Cover all possible evaluations of compound conditions - A compound condition is either an atomic condition or some boolean formula of atomic conditions. For example, in the overall condition â€œA || (B &amp;&amp; C)â€œ the set of compound conditions are â€œAâ€, â€œBâ€, â€œC&quot;, &quot;B &amp;&amp; Câ€œ, â€œA || (B &amp;&amp; C)â€œ.â€¢ Cover all branches of a decision tree.â€¢ Number of test cases grows exponentially with the number of basic conditions in a decision ($2^N$). ç»ƒä¹  - Write tests that provide statement, branch, and basic condition coverage over the following code:1234567891011121314int search(string A[], int N, string what)&#123; int index = 0; if ((N == 1) &amp;&amp; (A[0] == what))&#123; return 0; &#125; else if (N == 0)&#123; return -1; &#125; else if (N &gt; 1)&#123; while(index &lt; N)&#123; if (A[index] == what) return index; else index++; &#125; &#125; return -1;&#125; å…ˆç”»å‡º CFG å›¾ï¼Œå†éåŽ†ï¼š Modified condition/decision adequacy criterion (MC/DC)Motivation: Effectively test important combinations of conditions, without exponential blow up in test suite size. (Important combinations: Each basic condition shown to independently affect the outcome of each decision) å‡å¦‚è¿™äº›ç»„åˆè¡¨æ˜Žæ¯ä¸€ä¸ªæ¡ä»¶éƒ½å¯ä»¥ç‹¬ç«‹å½±å“ç»“æžœï¼Œé‚£ä¹ˆå°±ä¸è¦ç©·å°½å„ç§æ¡ä»¶ç»„åˆäº†ï¼Œå¯¹äºŽé‚£äº›ä¸å½±å“ç»“æžœçš„æ¡ä»¶ç»„åˆï¼Œæµ‹äº†ä¹Ÿæ²¡æœ‰æ„ä¹‰ã€‚ Requires:â€¢ For each basic condition $C_i$, two test casesâ€¢ æŽ§åˆ¶å˜é‡ï¼Œåªæ”¹å˜ $C_i$ï¼švalues of all evaluated conditions except $C_i$ are the sameâ€¢ Compound condition as a whole evaluates to True for one and False for the otherï¼Œç»“æžœçš„æ”¹å˜è¡¨æ˜Ž $C_i$ å¯ä»¥ç‹¬ç«‹å½±å“ç»“æžœ MC/DC:â€¢ basic condition coverage (C)â€¢ branch coverage (DC)â€¢ plus one additional condition (M): every condition must independently affect the decisionâ€™s output It is subsumed by compound conditions and subsumes all other criteria discussed so far - stronger than statement and branch coverage. A good balance of thoroughness and test size (and therefore widely used). Path TestingSometimes, a fault is revealed only through exercise of some sequence of decisions (i.e., a particular path through the program). Path coverage requires that all paths through the CFG are covered. In theory, path coverage is the ultimate coverage metric. But in practice, it is impractical if there is loop involed. Adequacy criterion: each path must be executed at least once:Coverage = #(Paths Covered) / #(Total Paths) Practical path coverage criteria:â€¢ The number of paths in a program with loops is unbounded - the simple criterion is usually impossible to satisfyâ€¢ For a feasible criterion: Partition infinite set of paths into a finite number of classesâ€¢ Useful criteria can be obtained by limitingâ€¢â€¢ the number of traversals of loopsâ€¢â€¢ the length of the paths to be traversedâ€¢â€¢ the dependencies among selected paths Boundary Interior CoverageGroups paths that differ only in the subpath they follow when repeating the body of a loop.â€¢ Follow each path in the control flow graph up to the first repeated nodeâ€¢ The set of paths from the root of the tree to each leaf is the required set of subpaths for boundary/interior coverageæŠŠåˆ†æ”¯æ‹†åˆ†ä¸ºæ¯ä¸€æ¡å¯èƒ½çš„ path. Limitations:1, The number of paths through non-loop branches (conditions) can still be exponential ($2^N$).2, Choosing input data to force execution of one particular path may be very difficult, or even impossible if the conditions are not independent. Loop Boundary CoverageSince coverage of non-looping paths is expensive, we can consider a variant of the boundary/interior criterion that treats loop boundaries similarly but is less stringent with respect to other differences among paths. Criterion: A test suite satisfies the loop boundary adequacy criterion iff for every loop:â€¢ In at least one test case, the loop body is iterated zero timesâ€¢ In at least one test case, the loop body is iterated onceâ€¢ In at least one test case, the loop body is iterated more than once For simple loops, write tests that: Skip the loop entirely. Take exactly one pass through the loop. Take two or more passes through the loop. (optional) Choose an upper bound N, and: M passes, where 2 &lt; M &lt; N (N-1), N, and (N+1) passes For Nested Loops: For each level, you should execute similar strategies to simple loops. In addition: Test innermost loop first with outer loops executed minimum number of times. Move one loops out, keep the inner loop at â€œtypicalâ€ iteration numbers, and test this layer as you did the previous layer. Continue until the outermost loop tested. For Concatenated Loops, one loop executes. The next line of code starts a new loop: These are generally independent(Most of the timeâ€¦) If not, follow a similar strategy to nested loops. Start with bottom loop, hold higher loops at minimal iteration numbers. Work up towards the top, holding lower loops at â€œtypicalâ€ iteration numbers. Linear Code Sequences and JumpsThere are additional path-oriented coverage criteria that do not explicitly consider loops. Among these are criteria that consider paths up to a fixed length. The most common such criteria are based on Linear Code Sequence and Jump (LCSAJ) - sequential subpath in the CFG starting and ending in a branch. A single LCSAJ is a set of statements that come one after another (meaning no jumps) followed by a single jump. A LCSAJ starts at either the beginning of the function or at a point that can be jumped to. The LCSAJ coverage is what fraction of all LCSAJs in a unit are followed by your test suite. We can require coverage of all sequences of LCSAJs of length N.Stronger criteria can be defined by requiring N consecutive LCSAJs to be covered - $TER_{N+2}$:1, $TER_1$ is equivalent to statement coverage.2, $TER_2$ is equivalent to branch coverage3, $TER_3$ is LCSAJ coverage4, $TER_4$ is how many pairs of LCSAJ coveredâ€¦ Cyclomatic adequacy (Complexity coverage)There are many options for the set of basis subpaths. When testing, count the number of independent paths that have already been covered, and add any new subpaths covered by the new test. You can identify allpaths with a set of independent subpaths of size = the cyclomatic complexity. Cyclomatic coverage counts the number of independent paths that have been exercised, relative to cyclomatic complexity. â€¢ A path is representable as a bit vector, where each component of the vector represents an edgeâ€¢ â€œDependenceâ€ is ordinary linear dependence between (bit) vectors If e = #(edges), n = #(nodes), c = #(connected components) of a graph, it is $e - n + c$ for an arbitrary graph, $e - n + 2$ for a CFG. Cyclomatic Complexity could be used to guess â€œhow much testing is enoughâ€.â—‹ Upper bound on number of tests for branch coverage.â—‹ Lower bound on number of tests for path coverage. And Used to refactor code.â—‹ Components with a complexity &gt; some threshold should be split into smaller modules.â—‹ Based on the belief that more complex code is more fault-prone. Procedure call coverageThe criteria considered to this point measure coverage of control flow within individual procedures - not well suited to integration or system testing, where connections between procedures(calls and returns) should be covered. Choose a coverage granularity commensurate with the granularity of testing - if unit testing has been effective, then faults thatremain to be found in integration testing will be primarily interface faults, and testing effort should focus on interfaces between units rather than their internal details. Procedure Entry and Exit Testing - A single procedure may have several entry and exit points.â€¢ In languages with goto statements, labels allow multiple entry points.â€¢ Multiple returns mean multiple exit points. Call coverage: The same entry point may be called from many points. Call coverage requires that a test suite executes all possible method calls. Satisfying structural criteriaThe criterion requires execution of statements that cannot be executed as a result of: defensive programming code reuse (reusing code that is more general than strictly required for the application) conditions that cannot be satisfied as a result of interdependent conditions paths that cannot be executed as a result of interdependent decisions Rather than requiring full adequacy, the â€œdegree of adequacyâ€ of a test suite is estimated by coverage measures. Dependence and Data Flow Modelså‰é¢ä»‹ç»çš„ Finite models (Control flow graph, call graph, finite state machines) åªæ˜¯æ•æ‰ç¨‹åºå„éƒ¨åˆ†ä¹‹é—´ä¾èµ–å…³ç³»çš„å…¶ä¸­ä¸€ä¸ªæ–¹é¢ã€‚å®ƒä»¬æ˜Žç¡®åœ°è¡¨çŽ°æŽ§åˆ¶æµç¨‹ï¼Œä½†ä¸é‡è§†ç¨‹åºå˜é‡é—´çš„ä¿¡æ¯ä¼ é€’. Data flow models provide a complementary view, emphasizing and making explicit relations involving transmission of information. Models of data flow and dependence in software were originally developed in the field of compiler construction, where they were (and still are) used to detect opportunities for optimization. Definition-Use Pairs (Def-Use Pairs) The most fundamental class of data flow model associates the point in a program where a value is produced (called a â€œdefinitionâ€) with the points at which the value may be accessed (called a â€œuseâ€). Definitions - Variable declaration (often the special value â€œuninitializedâ€), Variable initialization, Assignment, Values received by a parameter.Use - Expressions, Conditional statements, Parameter passing, Returns. A Definition-Use pair is formed if and only if there is a definition-clear path between the Definition and the Use. A definition-clear path is a path along the CFG path from a definition to a use of the same variable without another definition of the variable in between. &lt;D,U&gt; pairs coverage: #(pairs covered)/ #(total number of pairs)If instead another definition is present on the path, then the latter definition kills the former. Definition-use pairs record direct data dependence, which can be represented in the form of a graph - (Direct) Data Dependence Graph, with a directed edge for each definition-use pair. The notion of dominators in a rooted, directed graph can be used to make this intuitive notion of â€œcontrolling decisionâ€ precise. Node M dominates node N if every path from the root of the graph to N passes through M. Analyses: Reaching definitionDefinition-use pairs can be defined in terms of paths in the program control flow graph.â€¢ There is an association $(d,u)$ between a definition of variable $v$ at $d$ and a use of variable $v$ at $u$ if and only if there is at least one control flow path from $d$ to $u$ with no intervening definition of $v$.â€¢ Definition $v_d$ reaches $u$ ($v_d$ is a reaching definition at $u$).â€¢ If a control flow path passes through another definition $e$ of the same variable $v$, we say that $v_e$ kills $v_d$ at that point. Practical algorithms do not search every individual path. Instead, they summarize the reaching definitions at a node over all the paths reaching that node. An algorithm for computing reaching definitions is based on the way reaching definitions at one node are related to reaching definitions at an adjacent node. Suppose we are calculating the reaching definitions of node n, and there is an edge $(p,n)$ from an immediate predecessor node $p$.We observe:â€¢ If the predecessor node $p$ can assign a value to variable $v$, then the definition $v_p$ reaches $n$. We say the definition $v_p$ is generated at $p$.â€¢ If a definition $v_d$ of variable $v$ reaches a predecessor node $p$, and if $v$ is not redefined at that node, then the definition is propagated on from $p$ to $n$. These observations can be stated in the form of an equation describing sets of reaching definitions.123456789101112/** Euclid's algorithm */public class GCD &#123; public int gcd(int x, int y) &#123; int tmp; // A: def x, y, tmp while (y != 0) &#123; // B: use y tmp = x % y; // C: def tmp; use x, y x = y; // D: def x; use y y = tmp; // E: def y; use tmp &#125; return x; // F: use x &#125;&#125; Reaching definitions at node E are those at node D, except that D adds a definition of x and replaces (kills) an earlier definition of x:$$\begin{equation}\begin{split} Reach(E) &amp;= ReachOut(D) \\ ReachOut(D) &amp;= (Reach(D) \backslash {x_A}) \cup {x_D}\end{split}\end{equation}$$Equations at the head of the while loop - node B, where values may be transmitted both from the beginning of the procedure - node A and through the end of the body of the loop - node E. The beginning of the procedure (node A) is treated as an initial definition of parameters and local variables:$$\begin{equation}\begin{split} Reach(B) &amp;= ReachOut(A) \cup ReachOut(E) \\ ReachOut(A) &amp;= gen(A) = {x_A, y_A, tmp_A } \\ ReachOut(E) &amp;= (Reach(E) \backslash {y_A}) \cup {y_D}\end{split}\end{equation}$$ (If a local variable is declared but not initialized, it is treated as a definition to the special value â€œuninitialized.â€) General equations for Reach analysis:$$\begin{equation} \begin{split}Reach(n) &amp;= \mathop{\cup} \limits_{m \in pred(n)} ReachOut(m) \\ReachOut(n) &amp;=(Reach(n) \backslash kill(n)) \cup gen(n) \\\end{split} \end{equation}$$$gen(n) = v_n$, $v$ is defined or modified at $n$;$kill(n) = v_x$, $v$ is defined or modified at $x, x \ne n$. Reaching definitions calculation: first initializing the reaching definitions at each node in the control flow graph to the empty set, and then applying these equations repeatedly until the results stabilize. Analyses: Live and AvailAvailable expressions is another classical data flow analysis, used in compiler construction to determine when the value of a subexpression can be saved and reused rather than recomputed. An expression is available at a point if, for all paths through the control flow graph from procedure entry to that point, the expression has been computed and not subsequently modified. An expression is generated (becomes available) where it is computed and is killed (ceases to be available) when the value of any part of it changes (e.g., when a new value is assigned to a variable in the expression). The expressions propagation to a node from its predecessors is described by a pair of set equations:$$\begin{equation} \begin{split}Avail(n) &amp;= \mathop{\cap} \limits_{m \in pred(n)} AvailOut(m) \\AvailOut(n) &amp;=(Avail(n) \backslash kill(n)) \cup gen(n) \\\end{split} \end{equation}$$$gen(n)$, available, computed at $n$;$kill(n)$, has variables assigned at $n$. Reaching definitions combines propagated sets using set union, since a definition can reach a use along any execution path. Available expressions combines propagated sets using set intersection, since an expression is considered available at a node only if it reaches that node along all possible execution paths. Reaching definitions is a forward, any-path analysis; Available expressions is a forward, all-paths analysis. Live variables is a backward, any-path analysis that determines whether the value held in a variable may be subsequently used. Backward analyses are useful for determining what happens after an event of interest. A variable is live at a point in the control flow graph if, on some execution path, its current value may be used before it is changed, i.e. there is any possible execution path on which it is used. $$\begin{equation} \begin{split}Live(n) &amp;= \mathop{\cup} \limits_{m \in succ(n)} LiveOut(m) \\LiveOut(n) &amp;=(Live(n) \backslash kill(n)) \cup gen(n) \\end{split} \end{equation}$$$gen(n)$, $v$ is used at $n$;$kill(n)$, $v$ is modified at $n$. One application of live variables analysis is to recognize useless definitions, that is, assigning a value that can never be used. Iterative Solution of Dataflow EquationsInitialize values (first estimate of answer)â€¢ For â€œany pathâ€ problems, first guess is â€œnothingâ€(empty set) at each nodeâ€¢ For â€œall pathsâ€ problems, first guess is â€œeverythingâ€ (set of all possible values = union of all â€œgenâ€ sets) Repeat until nothing changesâ€¢ Pick some node and recalculate (new estimate) From Execution to Conservative Flow AnalysisWe can use the same data flow algorithms to approximate other dynamic propertiesâ€¢ Gen set will be â€œfacts that become true hereâ€â€¢ Kill set will be â€œfacts that are no longer true hereâ€â€¢ Flow equations will describe propagation Example: Taintedness (in web form processing)â€¢ â€œTaintâ€: a user-supplied value (e.g., from web form) that has not been validatedâ€¢ Gen: we get this value from an untrusted source hereâ€¢ Kill: we validated to make sure the value is proper Data flow analysis with arrays and pointersThe models and flow analyses described in the preceding section have been limited to simple scalar variables in individual procedures. Arrays and pointers (dynamic references and the potential for aliasing) introduce uncertainty: Do different expressions access the same storage?â€¢ a[i] same as a[k] when i = kâ€¢ a[i] same as b[i] when a = b (aliasing) The uncertainty is accomodated depending on the kind of analysisâ€¢ Any-path: gen sets should include all potential aliases and kill set should include only what is definitely modifiedâ€¢ All path: vice versa Scope of Data Flow Analysisè¿‡ç¨‹å†… Intraprocedural: Within a single method or procedure, as described so far. è¿‡ç¨‹ä¹‹é—´ Interprocedural: Across several methods (and classes) or procedures Cost/Precision trade-offs for interprocedural analysis are critical, and difficult: context sensitivity, flow-sensitivity. Many interprocedural flow analyses are flow-insensitiveâ€¢ $O(n^3)$ would not be acceptable for all the statements in a program. Though $O(n^3)$ on each individual procedure might be okâ€¢ Often flow-insensitive analysis is good enoughâ€¦ considering type checking as an example Reach, Avail, etc were flow-sensitive sensitive, intraprocedural analyses.â€¢ They considered ordering and control flow decisionsâ€¢ Within a single procedure or method, this is (fairly) cheap - $O(n^3)$ for $n$ CFG nodes. Summary of Data flow models Data flow models detect patterns on CFGs: Nodes initiating the pattern Nodes terminating it Nodes that may interrupt it Often, but not always, about flow of information (dependence) Pros: Can be impy g lemented by efficient iterative algorithms Widely applicable (not just for classic â€œdata flowâ€ properties) Limitations: Unable to distinguish feasible from infeasible paths Analyses spanning whole programs (e.g., alias analysis) must trade off precision against computational cost Data Flow TestingIn structural testing,â€¢ Node and edge coverage donâ€™t test interactionsâ€¢ Path-based criteria require impractical number of test cases: And only a few paths uncover additional faults, anywayâ€¢ Need to distinguish â€œimportantâ€ paths Data flow testing attempts to distinguish â€œimportantâ€ paths: Interactions between statements - Intermediate between simple statement and branch coverage and more expensive path-based structural testing. Intuition: Statements interact through data flowâ€¢ Value computed in one statement used in another Value computed in one statement, used in anotherâ€¢ Bad value computation revealed only when it is used Adequacy criteria:â€¢ All DU pairs: Each DU pair is exercised by at least one test caseâ€¢ All DU paths: Each simple (non looping) DU path is exercised by at least one test caseâ€¢ All definitions: For each definition, there is at least one test case which exercises a DU pair containing it - Every computed value is used somewhere Limits: Aliases, infeasible paths - Worst case is bad (undecidable properties, exponential blowup of paths), so åŠ¡å®žçš„ pragmatic compromises are required Data flow coverage with complex structuresArrays and pointersâ€¢ Under-estimation of aliases may fail to include some DU pairsâ€¢ Over-estimation, may introduce unfeasible test obligations For testing, it may be preferrable to accept under-estimation of alias set rather than over-estimation or expensive analysisâ€¢ æœ‰äº‰è®®çš„ Controversial: In other applications (e.g., compilers), a conservative over-estimation of aliases is usually requiredâ€¢ Alias analysis may rely on external guidance or other globalanalysis to calculate good estimatesâ€¢ Undisciplined use of dynamic storage, pointer arithmetic, etc.may make the whole analysis infeasible Mutation testingFault-based Testing, directed towards â€œtypicalâ€ faults that could occur in a program. Take a program and test suite generated for that program (using other test techniques) Create a number of similar programs (mutants), each differing from the original in one small way, i.e., each possessing a fault The original test data are then run through the mutants Then mutants either: To be dead: test data detect all differences in mutants, the test set is adequate. Remains live if: it is equivalent to the original program (functionally identical although syntactically different - called an equivalent mutant) or, the test set is inadequate to kill the mutant. The test data need to be augmented (by adding one or more new test cases) to kill the live mutant. Numbers of mutants tend to be large (the number of mutation operators is large as they are supposed to capture all possible syntactic variations in a program), hence random sampling, selective mutation operators (Offutt). Coverage - mutation score: #(killed mutants) / #(all non-equivalent mutants) (or random sample). Benifits:â€¢ It provides the tester with a clear target (mutants to kill)â€¢ It does force the programmer to think of the test data that will expose certain kinds of faultsâ€¢ Probably most useful at unit testing level Mutation operators could be built onâ€¢ source code (body),â€¢ module interfaces (aimed at integration testing),â€¢ specifications: Petri-nets, state machines, (aimed at system testing) Tools: MuClipse Model based testingModels used in specification or design have structureâ€¢ Useful information for selecting representative classes of behavior; behaviors that are treated differently with respect to the model should be tried by a thorough test suiteâ€¢ In combinatorial testing, it is difficult to capture that structure clearly and correctly in constraints Devise test cases to check actual behavior against behavior specified by the model - â€œCoverageâ€ similar to structural testing, but applied to specification and design models. Deriving test cases from finite state machines: From an informal specification, to a finite state machine, to a test suite â€œCoveringâ€ finite state machinesâ€¢ State coverage: Every state in the model should be visited by at least one test caseâ€¢ Transition coverage â€¢â€¢ Every transition between states should be traversed by at least one test case. â€¢â€¢ A transition can be thought of as a (precondition, postcondition) pair. Models are useful abstractionsâ€¢ In specification and design, they help us think and communicate about complex artifacts by emphasizing key features and suppressing detailsâ€¢ Models convey structure and help us focus on one thing at a time We can use them in systematic testingâ€¢ If a model divides behavior into classes, we probably want to exercise each of those classes!â€¢ Common model-based testing techniques are based on state machines, decision structures, and grammars, but we can apply the same approach to other models. Testing Object Oriented SoftwareTypical OO software characteristics that impact testingâ€¢ State dependent behaviorâ€¢ Encapsulationâ€¢ Inheritanceâ€¢ å¤šæ€æ€§ Polymorphism and dynamic bindingâ€¢ Abstract and generic classesâ€¢ Exception handling Procedural software, unit = single program, function, or procedure, more often: a unit of work that may correspond to one or more intertwined functions or programs. Object oriented software:â€¢ unit = class or (small) cluster of strongly related classes (e.g., sets of Java classes that correspond to exceptions)â€¢ unit testing = ç±»å†…æµ‹è¯• intra-class testingâ€¢ integration testing = ç±»ä¹‹é—´æµ‹è¯• inter-class testing (cluster of classes)â€¢ dealing with single methods separately is usually too expensive (complex scaffolding), so methods are usually tested in the context of the class they belong to. Basic approach is orthogonal: Techniques for each major issue (e.g., exception handling, generics, inheritance ) can be applied incrementally and independently. Intraclass State Machine TestingBasic idea:â€¢ The state of an object is modified by operationsâ€¢ Methods can be modeled as state transitionsâ€¢ Test cases are sequences of method calls that traverse the state machine model State machine model can be derived from specification (functional testing), code (structural testing), or both. Testing with State Diagrams:â€¢ A statechart (called a â€œstate diagramâ€ in UML) may be produced as part of a specification or design - May also be implied by a set of message sequence charts (interaction diagrams), or other modeling formalisms.â€¢ Two options:1, Convert (â€œflattenâ€) into standard finite-state machine, then derive test cases2, Use state diagram model directly Intraclass data flow testingExercise sequences of methodsâ€¢ From setting or modifying a field valueâ€¢ To using that field value The intraclass control flow graph - control flow through sequences of method calls:â€¢ Control flow for each methodâ€¢ node for classâ€¢ edges: from node class to the start nodes of the methods; from the end nodes of the methods to node class. Interclass TestingThe first level of integration testing for object-oriented software - Focus on interactions between classes Bottom-up integration according to â€œdependsâ€ relation - A depends on B - Build and test B, then A Start from use/include hierarchy - Implementation-level parallel to logical â€œdependsâ€ relationâ€¢ Class A makes method calls on class Bâ€¢ Class A objects include references to class B methods - but only if reference means â€œis part ofâ€ In software engineering, a class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system by showing the systemâ€™s classes, their attributes, operations (or methods), and the relationships among objects. Dependency is a weaker form of bond that indicates that one class depends on another because it uses it at some point in time. One class depends on another if the independent class is a parameter variable or local variable of a method of the dependent class. Interactions in Interclass Tests: Proceed bottom-up Consider all combinations of interactions example: a test case for class Order includes a call to a method of class Model, and the called method calls a method of class Slot, exercise all possible relevant states of the different classes. problem: combinatorial explosion of cases so select a subset of interactions: arbitrary or random selection plus all significant interaction scenarios that have been previously identified in design and analysis: sequence + collaboration diagrams Using Structural Information:â€¢ Start with functional testing: the specification (formal or informal) is the first source of informationâ€¢ Then add information from the code (structural testing) Interclass structural testingWorking â€œbottom upâ€ in dependence hierarchyâ€¢ Dependence is not the same as class hierarchy; not always the same as call or inclusion relation.â€¢ May match bottom-up build order Starting from leaf classes, then classes that use leaf classes,â€¦ Summarize effect of each method: Changing or using object state, or both - Treating a whole object as a variable (not just primitive types) Polymorphism and dynamic bindingOne variable potentially bound to methods of different (sub-)classes. The combinatorial approach: identify a set of combinations that cover all pairwise combinations of dynamic bindings. InheritanceWhen testing a subclass, We would like to re-test only what has not been thoroughly tested in the parent class. But we should test any method whose behavior may have changed. Reusing Tests with the Testing History Approach: Track test suites and test executions determine which new tests are needed determine which old tests must be re-executed New and changed behavior â€¦ new methods must be tested redefined methods must be tested, but we can partially reuse test suites defined for the ancestor other inherited methods do not have to be retested Abstract methods (and classes) - Design test cases when abstract method is introduced (even if it can t be executed yet) Behavior changesâ€¢ Should we consider a method â€œredefinedâ€ if another new or redefined method changes its behavior?â€¢ The standard â€œtesting historyâ€ approach does not do thisâ€¢ It might be reasonable combination of data flow (structural) OO testing with the (functional) testing history approach Testing exception handlingExceptions create implicit control flows and may be handled by different handlers. Impractical to treat exceptions like normal flowâ€¢ too many flows: every array subscript reference, every memory, allocation, every cast, â€¦â€¢ multiplied by matching them to every handler that could appear immediately above them on the call stack.â€¢ many actually impossible So we separate testing exceptions, and ignore program error exceptions (test to prevent them, not to handle them) What we do test: Each exception handler, and each explicit throw or re-throw of an exception. Integration TestingUnit (module) testing is a foundation, unit level has maximum controllability and visibility. Integration testing may serve as a process checkâ€¢ If module faults are revealed in integration testing, they signal inadequate unit testingâ€¢ If integration faults occur in interfaces between correctly implemented modules, the errors can be traced to module breakdown and interface specifications.Integration test plan drives and is driven by the project â€œbuild planâ€ Structural orientation: Modules constructed, integrated and tested based on a hierarchical project structure - Top-down, Bottom-up, Sandwich, Backbone Functional orientation: Modules integrated according to application characteristics or features - Threads, Critical module. A â€œthreadâ€ is a portion of several modules that together provide a user-visible program feature. Component-based software testingWorking Definition of Componentâ€¢ Reusable unit of deployment and compositionâ€¢ Characterized by an interface or contractâ€¢ Often larger grain than objects or packages - A complete database system may be a component Frameworkâ€¢ Skeleton or micro-architecture of an applicationâ€¢ May be packaged and reused as a component, with â€œæŒ‚é’© hooksâ€ or â€œæ’æ§½ slotsâ€ in the interface contract Design patternsâ€¢ Logical design fragmentsâ€¢ Frameworks often implement patterns, but patterns are not frameworks. Frameworks are concrete, patterns are abstract Component-based systemâ€¢ A system composed primarily by assembling components, often â€œCommercial off-the-shelfâ€ (COTS) componentsâ€¢ Usually includes application-specific â€œglue codeâ€ Component Interface Contractsâ€¢ Application programming interface (API) is distinct from implementationâ€¢ Interface includes everything that must be known to use the component: More than just method signatures, exceptions, etc; May include non-functional characteristics like performance, capacity, security; May include dependence on other components. Testing a Component: Producer Viewâ€¢ Thorough unit and subsystem testingâ€¢ Thorough acceptance testing: Includes stress and capacity testing Testing a Component: User Viewâ€¢ Major question: Is the component suitable for this application?â€¢ Reducing risk: Trial integration early System, Acceptance, and Regression Testing System TestingCharacteristics:â€¢ Comprehensive (the whole system, the whole spec)â€¢ Based on specification of observable behavior: Verification against a requirements specification, not validation, and not opinionsâ€¢ Independent of design and implementation Independence: Avoid repeating software design errors in system test design. Maximizing independence:â€¢ Independent V&amp;V: System (and acceptance) test performed by a different organization.â€¢ Independence without changing staff: Develop system test cases early System tests are often used to measure progress. As project progresses, the system passes more and more system tests. Features exposed at top level as they are developed. System testing is the only opportunity to verify Global Properties - Performance, latency, reliability, â€¦ Especially to find unanticipated effects, e.g., an unexpected performance bottleneck. Context-Dependent Properties is beyond system-global: Some properties depend on the system context and use, Example:â€¢ Performance properties depend on environment and configurationâ€¢ Privacy depends both on system and how it is usedâ€¢ Security depends on threat profiles Stress TestingWhen a property (e.g., performance or real-time response) is parameterized by use - requests per second, size of database,â€¦ Extensive stress testing is required - varying parameters within the envelope, near the bounds, and beyond. Often requires extensive simulation of the execution environment, and requires more resources (human and machine) than typical test cases - Separate from regular feature tests, Run less often, with more manual control. Capacity, Security, Performance, Compliance, Documentation Testing. Acceptance testingEstimating dependability, measuring quality, not searching for faults. Requires valid statistical samples from operational profile(model), and a clear, precise definition of what is being measured. Quantitative dependability goals are statistical:â€¢ Reliability: Survival Probability - when function is critical during the mission time.â€¢ Availability: The fraction of time a system meets its specification - Good when continuous service is important but it can be delayed or deniedâ€¢ Failsafe: System fails to a known safe stateâ€¢ Dependability: Generalisation - System does the right thing at right time Usability, Reliability, Availability/Reparability Testing System ReliabilityThe reliability $R_F(t)$ of a system is the probability that no fault of the class $F$ occurs (i.e. system survives) during time $t \sim (t_{init}, t_{failure})$. Failure Probability $Q_F(t) = 1 -R_F(t)$. When the lifetime of a system is exponentially distributed, the reliability of the system is: $R(t) = e^{-\lambda t}$ where the parameter $\lambda$ is called the failure rate. MTTF: Mean Time To (first) Failure, or Expected Life.$ MTTF = E(t_f) = \int_0^\infty R(t)dt = \frac{1}{\lambda}$ Serial System Reliability: Serially Connected Components. Assuming the failure rates of components are statistically independent, The overall system reliability:$$R_{ser}(t) = \prod_{i=1}^n R_i(t) = e^{-t(\lambda_{ser})} = e^{-t(\sum_{i=1}^n \lambda_i)}$$$R_i(t) = e^{-\lambda_i t}$ is reliability of a single component $i$. Parallel System Reliability: Parallel Connected Components.$$R_{par}(t) = 1 - Q_{par}(t) = 1 - \prod_{i=1}^n Q_i(t) = 1 - \prod_{i=1}^n (1 - e^{-\lambda_i t}) = 1 - \prod_{i=1}^n (1 - R_i(t)) $$ For example:Â· if one is to build a serial system with 100 components each of which had a reliability of 0.999, the overall system reliability would be $0.999^{100} = 0.905$.Â· Consider 4 identical modules are connected in parallel, System will operate correctly provided at least one module is operational. If the reliability of each module is 0.95, the overall system reliability is $1-(1-0.95)^4 = 0.99999375$. Statistical testing is necessary for critical systems (safety critical, infrastructure, â€¦), but difficult or impossible when operational profile is unavailable or just a guess, or when reliability requirement is very high. Process-based MeasuresBased on similarity with prior projects, less rigorous than statistical testing. System testing process - Expected history of bugs found and resolved:â€¢ Alpha testing: Real users, controlled environmentâ€¢ Beta testing: Real users, real (uncontrolled) environmentâ€¢ May statistically sample users rather than usesâ€¢ Expected history of bug reports Regression TestingIdeally, software should improve over time. But changes can bothâ€¢ Improve software, adding features and fixing bugsâ€¢ Break software, introducing new bugs - regressions Tests must be re-run after any changes. Make use of different techniques for selecting a subset of all tests to reduce the time and cost for regression testing. Regression Test SelectionFrom the entire test suite, only select subset of test cases whose execution is relevant to changes. Code-based Regression Test Selection: Only execute test cases that execute changed or new code. Control-flow and Data-flow Regression Test Selection: Re-run test cases only if they include changed elements â€“ elements may be modified control flow nodes and edges, or definition-use (DU) pairs in data flow. To automate selection:â€¢ Tools record changed elements touched by each test case - stored in database of regression test casesâ€¢ Tools note changes in programâ€¢ Check test-case database for overlap Specification-based Regression Test Selection:â€¢ Specification-based prioritization: Execute all test cases, but start with those that related to changed and added features. Test Set MinimizationIdentify test cases that are redundant and remove them from the test suite to reduce its size.â€¢ Maximize coverage with minimum number of test cases.â€¢ Stop after a pre-defined number of iterationsâ€¢ Obtain an approximate solution by using a greedy heuristic Test Set Prioritisationâ€¢ Sort test cases in order of increasing cost per additional coverageâ€¢ Select the first test caseâ€¢ Repeat the above two steps until k test cases are selected or max cost is reached (whichever is first). Prioritized Rotating Selection: Execute some sooner than others, eventually execute all test cases. Possible priority schemes:â€¢ Round robin: Priority to least-recently-run test casesâ€¢ Track record: Priority to test cases that have detected faults before - They probably execute code with a high fault densityâ€¢ Structural: Priority for executing elements that have not been recently executed - Can be coarse-grained: Features, methods, files. Test-Driven Development (TDD)Test-Driven Development (or test driven design) is a methodology. â€¢ Short development iterations.â€¢ Based on requirement and pre-written test cases.â€¢ Produces code necessary to pass that iterationâ€™s test.â€¢ Refactor both code and tests.â€¢ The goal is to produce working clean code that fulfills requirements. Principle of TDD - Kent Beck defines:â€¢ Never write a single line of code unless you have a failing automated test.â€¢ Eliminate duplication TDD uses Black-box Unit testï¼š1ï¼Œ æ˜Žç¡®åŠŸèƒ½éœ€æ±‚ã€‚2ï¼Œ ä¸ºåŠŸèƒ½éœ€æ±‚ç¼–å†™ testã€‚3ï¼Œ è¿è¡Œæµ‹è¯•ï¼ŒæŒ‰ç†åº”è¯¥æ— æ³•é€šè¿‡æµ‹è¯•ï¼ˆå› ä¸ºè¿˜æ²¡å†™åŠŸèƒ½ç¨‹åºï¼‰ã€‚4ï¼Œ ç¼–å†™å®žçŽ°è¯¥åŠŸèƒ½çš„ä»£ç ï¼Œé€šè¿‡æµ‹è¯•ã€‚5ï¼Œ å¯é€‰ï¼šé‡æž„ä»£ç ï¼ˆå’Œ test casesï¼‰ï¼Œä½¿å…¶æ›´å¿«ï¼Œæ›´æ•´æ´ç­‰ç­‰ã€‚6ï¼Œ å¯é€‰ï¼šå¾ªçŽ¯æ­¤æ­¥éª¤ Automating Test ExecutionDesigning test cases and test suites is creative, but executing test cases should be automatic. Example Tool Chain for Test Case Generation &amp; Execution:Combine â€¦â€¢ A combinatorial test case generation (genpairs.py) to create test dataâ€¢ DDSteps to convert from spreadsheet data to JUnit test casesâ€¢ JUnit to execute concrete test cases ScaffoldingCode to support development and testing.â€¢ Test driver: A â€œmainâ€ program for running a testâ€¢ Test stubs: Substitute for called functions/methods/objects. Stub is an object that holds predefined data and uses it to answer calls during tests. It is used when we cannot or donâ€™t want to involve objects that would answer with real data or have undesirable side effects. ä»£æŒ‡é‚£äº›åŒ…å«äº†é¢„å®šä¹‰å¥½çš„æ•°æ®å¹¶ä¸”åœ¨æµ‹è¯•æ—¶è¿”å›žç»™è°ƒç”¨è€…çš„å¯¹è±¡ã€‚Stub å¸¸è¢«ç”¨äºŽæˆ‘ä»¬ä¸å¸Œæœ›è¿”å›žçœŸå®žæ•°æ®æˆ–è€…é€ æˆå…¶ä»–å‰¯ä½œç”¨çš„åœºæ™¯ã€‚ â€¢ Test harness: Substitutes for other parts of the deployed environment â€¢ Comparison-based oracle: need predicted output for each input. Fine for a small number of hand-generated test cases, e.g. hand-written JUnit test cases. â€¢ Self-Checking Code as Oracle: oracle written as self-checks, possible to judge correctness without predicting results. Advantages and limits: Usable with large, automaticallygenerated test suites, but often only a partial check. â€¢ Capture and Replay: If human interaction is required, capture the manually run test case, replay it automatically. With a comparison-based test oracle, behavior same as previously accepted behavior. Security Testingâ€œRegularâ€ testing aims to ensure that the program meets customer requirements in terms of features and functionality. Tests â€œnormalâ€ use cases - Test with regards to common expected usage patterns. Security testing aims to ensure that program fulfills security requirements. Often non-functional. More interested in misuse cases. Two common approaches:â€¢ Test for known vulnerability typesâ€¢ Attempt directed or random search of program state space to uncover the â€œweird corner casesâ€ Penetration testingâ€¢ Manually try to â€œbreakâ€ softwareâ€¢ Typically involves looking for known common problems. Fuzz testingSend semi-valid input to a program and observe its behavior.â€¢ Black-box testing - System Under Test (SUT) treated as a â€œblack-boxâ€â€¢ The only feedback is the output and/or externally observablebehavior of SUT. Input generationâ€¢ Mutation based fuzzing: Start with a valid seed input, and â€œmutateâ€ it. Can typically only find the â€œlow-hanging fruitâ€ - shallow bugs that are easy to find.â€¢ Generation based fuzzing: Use a specification of the input format (e.g. a grammar) to automatically generate semi-valid inputs - Very long strings, empty strings, Strings with format specifiers, â€œextremeâ€ format strings, Very large or small values, values close to max or min for data type, Negative values. Almost invariably gives better coverage, but requires much more manual effort. The Dispatcher: running the SUT on each input generated by fuzzer module. The Assessor: automatically assess observed SUT behavior to determine if a fault was triggered. Concolic testingConcolic execution workflow:1, Execute the program for real on some input, and record path taken.2, Encode path as query to SMT solver and negate one branch condition3, Ask the solver to find new satisfying input that will give a different path. White-box testing method.â€¢ Input generated from control-structure of code to systematically explore different paths of the program.â€¢ Generational search (â€œwhitebox fuzzingâ€): Performs concolic testing, but prioritizes paths based on how much they improve coverage. Greybox fuzzingâ–ª Coverage-guided semi-random input generation.â–ª High speed sometimes beats e.g. concolic testing, but shares some limitations with mutation-based fuzzing (e.g. magic constants, checksums). Software Process Models - Software DevelopmentWaterfall model: Sequential, no feedback1, Requirements2, Design3, Implementation4, Testing5, Release and maintenance V-model: modified version of the waterfall modelâ€¢ Tests are created at the point the activity they validate is being carried out. So, for example, the acceptance test is created when the systems analysis is carried out.â€¢ Failure to meet the test requires a further iteration beginning with the activity that has failed the validation Boehmâ€™s Spiral Model: focuse on controlling project risk and attempting formally to address project risk throughout the lifecycle.â€¢ V&amp;V activity is spread through the lifecycle with more explicit validation of the preliminary specification and the early stages of design. The goal here is to subject the early stages of design to V&amp;V activity.â€¢ At the early stages there may be no code available so we are working with models of the system and environment and verifying that the model exhibits the required behaviours. Extreme Programming (XP): one of [Agile Processes]â€¢ Advocates working directly with code almost all the time.â€¢ The 12 principles of XP summarise the approach. 1, Test-driven development; 2, The planning game; 3, On-site customer; 4, Pair programming; 5, Continuous integration; 6, Refactoring; 7, Small releases; 8, Simple design; 9, System metaphor; 10, Collective code ownership; 11, Coding standards; 12, 40-hour work week; â€¢ Development is test-driven.â€¢ Tests play a central role in refactoring activity.â€¢ â€œAgileâ€ development mantra: Embrace Change. Facebookâ€™s Process Model Perpetual development - a continuous development model. In this model, software will never be considered a finished product. Instead features are continuously added and adapted and shipped to users. Fast iteration is considered to support rapid innovation. Planning and Monitoring the ProcessMonitoring: Judging progress against the plan. Quality process: Set of activities and responsibilities. Follows the overall software process in which it is embedded.â€¢ Example: waterfall software process â€“â€“&gt; â€œV modelâ€: unit testing starts with implementation and finishes before integrationâ€¢ Example: XP and agile methods â€“â€“&gt; emphasis on unit testing and rapid iteration for acceptance testing by customers. Strategies vs. PlansTest and Analysis Strategy:â€¢ Lessons of past experience: an organizational asset built and refined over timeâ€¢ Body of explicit knowledge: amenable to improvement, reduces vulnerability to organizational change (e.g., loss of key individuals) Elements of a Strategy:â€¢ Common quality requirements that apply to all or most products - unambiguous definition and measuresâ€¢ Set of documents normally produced during the quality process - contents and relationshipsâ€¢ Activities prescribed by the overall process - standard tools and practicesâ€¢ Guidelines for project staffing and assignment of roles and responsibilities Main Elements of a Plan:â€¢ Items and features to be verified - Scope and target of the planâ€¢ Activities and resources - Constraints imposed by resources on activitiesâ€¢ Approaches to be followed - Methods and toolsâ€¢ Criteria for evaluating results Schedule Riskâ€¢ Critical path = chain of activities that must be completed in sequence and that have maximum overall durationâ€¢ Critical dependence = task on a critical path scheduled immediately after some other task on the critical path Risk Planningâ€¢ Generic management risk: personnel, technology, scheduleâ€¢ Quality risk: development, execution, requirements Contingency Planâ€¢ Derives from risk analysisâ€¢ Defines actions in response to bad news - Plan B at the ready Process Monitoringâ€¢ Identify deviations from the quality plan as early as possible and take corrective action Process ImprovementOrthogonal Defect Classification (ODC)â€¢ Accurate classification schema: for very large projects, to distill an unmanageable amount of detailed informationâ€¢ Two main steps1, Fault classification: when faults are detected, when faults are fixed.2, Fault analysis Root Cause Analysis (RCA)â€¢ Technique for identifying and eliminating process faultsâ€¢ Four main steps1, What are the faults?2, When did faults occur? When, and when were they found?3, Why did faults occur?4, How could faults be prevented?]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Parallel Programming Language and Systems]]></title>
    <url>%2FUoE-ppls%2F</url>
    <content type="text"><![CDATA[çˆ±ä¸å ¡å¤§å­¦ä¿¡æ¯å­¦é™¢è¯¾ç¨‹ç¬”è®° Parallel Programming Language and Systems, Informatics, University of Edinburgh Reference:http://www.inf.ed.ac.uk/teaching/courses/ppls/CMU 15213: Introduction to Computer Systems (ICS)Computer Systems: A Programmerâ€™s PerspectiveA Comprehensive MPI Tutorial ResourceA chapter on MPI from Ian Fosterâ€™s online Book Designing and Building Parallel Programs Introduction to parallel computer architectureCovering some of the nasty issues presented by the shared memory model, including weak consistency models and false sharing in the cache, and some architectural issues for the multicomputer model. Bridging the gap between the parallel applications and algorithms which we can design and describe in abstract terms and the parallel computer architectures (and their lowest level programming interfaces) which it is practical to construct. The ability to express parallelism (a.k.a concurrency) concisely, correctly and efficiently is important in several contexts:â€¢ Performance Computing: parallelism is the means by which the execution time of computationally demanding applications can be reduced. In the era of static (or even falling) clock speeds and increasing core count, this class is entering the computing mainstream.â€¢ Distributed Computing: when concurrency is inherent in the nature of the system and we have no choice but to express and control it.â€¢ Systems Programming: when it is conceptually simpler to think of a system as being composed of concurrent components, even though these will actually be executed by time-sharing a single processor. Parallel ArchitectureTwo types (mainstream): Shared Memory architectures: in which all processors can physically address the whole memory, usually with support for cache coherency (for example, a quad or oct core chip, or more expensive machines with tens or hundreds of cores) Multicomputer architectures: in which processors can only physically address their â€œownâ€ memory (for example, a networked cluster of PCs), which interact with messages across the network. Increasingly, systems will span both classes (e.g. cluster of manycore, or network-onchip manycores like the Intel SCC), and incorporate other specialized, constrained parallel hardware such as GPUs. Real parallel machines are complex, with unforseen semantic and performance traps. We need to provide programming tools which simplify things, but without sacrificing too much performance. Shared Memory ArchitecturesUniform Memory Access (UMA) architectures have all memory â€œequidistantâ€ from all CPUs.For NUMA performance varies with data location. NUMA is also confusingly called Distributed Shared Memory as memory is physically distributed but logically shared. Memory consistency challenge: when, and in what order should one processor public updates to the shared memory? Exactly what and when it is permissible for each processor to see is defined by the Consistency Model, which is effectively a contract between hardware and software, must be respected by application programmers (and compiler/library writers) to ensure program correctness. Different consistency models trade off conceptual simplicity against cost (time/hardware complexity): Sequential consistency: every processor â€œseesâ€ the same sequential interleaving of the basic reads and writes. This is very intuitive, but expensive to implement. Release consistency: writes are only guaranteed to be visible after program specified synchronization points (triggered by special machine instructions). This is less intuitive, but allows faster implementations. Shared memory architectures also raise tricky performance issues: The unit of transfer between memory and cache is a cache-line or block, containing several words. False sharing occurs when two logically unconnected variables share the same cache-line. Updates to one cause remote copies of the line, including the other variable, to be invalidated. Multicomputer architecturesLack of any hardware integration between cache/memory system and the interconnect. Each processor only accesses its own physical address space, so no consistency issues. Information is shared by explicit, co-operative message passingPerformance/correctness issues include the semantics of synchronization and constraints on message ordering. Parallel Applications and AlgorithmsThree well-known parallel patterns: Bag of Tasks, Pipeline and Interacting Peers. Here using the co, &lt; &gt;, await notation. åœ¨co ocå†…çš„ä»£ç , é¡ºåºæ˜¯ä»»æ„çš„.1234# è¿™é‡Œæš‚æ—¶ç”¨ // è¡¨ç¤ºå¹¶è¡Œçš„ä»£ç co a=1; // a=2; // a=3; ## all happen at the same time, What is a in the end?oc To answer the above question, we need to define Atomic Actions: Reads and writes of single variables as being atomic. For more than one statements, if they appear to execute as a single indivisible step with no visible intermediate states, they are atomic, must be enclosed in &lt; &gt;.1234a=0;co a=1; // a=2; // b=a+a; ## what is b?oc The above code has no &lt; &gt;, each value accessed in an expression is a read. Each assignment is a write. Thus, b could be 0, 1, 2, 3, or 4.1234a=0;co a=1; // a=2; // &lt;b=a+a;&gt;oc Now the only outcomes for b are 0, 2 or 4. Sequential memory consistency (SC)To make agreement on such inconsistency, we define the sequential memory consistency (SC), to be consistent with the following rules: ordering of atomic actions (particularly reads and writes to memory) from any one thread have to occur in normal program order atomic actions from different threads are interleaved arbitrarily (ie in an unpredictable sequential order, subject only to rule 1) It doesnâ€™t mean that SC programs have to be executed sequentially!It only means that the results we get must be the same as if the program had been executed in this way. AwaitThe await notation &lt; await (B) S &gt; allows us to indicate that S must appear to be delayed until B is true, and must be executed within the same atomic action as a successful check of B.123456a=0; flag=0;co&#123;a=25; flag=1;&#125;//&lt;await (flag==1) x=a;&gt; ## x = 25oc However, it is not guaranteed that, an await statement is executed right after its condition becomes true. If other atomic actions make the condition false again, before the await executes, it will have to wait for another chance. The Bag-of-TasksExample: Adaptive Quadrature, compute an approximation to the shaded integral by partitioning until the æ¢¯å½¢ trapezoidal approximation is â€œgood enoughâ€, compared with the sum of its two sub-divided trapezoidalsâ€™s area.area = quad (a, b, f(a), f(b), (f(a)+f(b))*(b-a)/2);The recursive calls to quad do not interfere with each other. So we can parallelize the program by changing the calls to12345# ç®€å•åœ°å¹¶è¡Œco larea = quad(left, mid, f(left), f(mid), larea); // rarea = quad(mid, right, f(mid), f(right), rarea);oc In practice, there is very little work directly involved in each call to quad. The work involved in creating and scheduling a process or thread is substantial (much worse than a simple function call), program may be swamped by this overhead. Using the Bag of Tasks pattern: a fixed number of worker processes/threads maintain and process a dynamic collection of homogeneous â€œtasksâ€. Execution of a particular task may lead to the creation of more task instances.12345678# Bag of Tasks patternco [w = 1 to P] &#123; while (all tasks not done) &#123; get a task; execute the task; possibly add new tasks to the bag; &#125;&#125; 1, Shared bag: contains task(a, b, f(a), f(b), area)2, Get a task: remove a record from the bag, either: â€¢ adds its local area approximation to the total â€¢ or creates two more tasks for a better approximation (by adding them to the bag). Advantage:1, It constraints the number of processes/threads to avoid overhead.2, Useful for independent tasks and to implement recursive parallelism3, Naturally load-balanced: each worker will probably complete a different number of tasks, but will do roughly the same amount of work overall. Bag of Tasks Implementation: The challenge is to make accessing the bag much cheaper than creating a new thread. With a shared address space, a simple implementation would make the bag an atomically accessed shared data structure.123456789101112131415161718shared int size = 1, idle = 0;shared double total = 0.0;bag.insert (a, b, f(a), f(b), approxarea);co [w = 1 to P] &#123; while (true) &#123; &lt; idle++; &gt; &lt; await ( size &gt; 0 || idle == P ) ## æ£€æµ‹ termination if (size &gt; 0) &#123; ## get a task bag.remove (left, right ...); size--; idle--; &#125; else break; &gt; ## the work is done mid = (left + right)/2; ..etc.. ## compute larea, etc if (fabs(larea + rarea - lrarea) &gt; EPSILON) &#123; ## create new tasks &lt; bag.insert (left, mid, fleft, fmid, larea); bag.insert (mid, right, fmid, fright, rarea); size = size + 2; &gt; &#125; else &lt; total = total + larea + rarea; &gt; &#125;&#125; Detecting termination:ä¸èƒ½ä»…ä»…å› ä¸º bag ç©ºäº†å°±è®¤ä¸ºå¯ä»¥ç»“æŸäº†, å› ä¸ºè¿˜å¯èƒ½æœ‰è¿˜åœ¨å·¥ä½œçš„ workers æœªæ¥ä¼šäº§ç”Ÿæ–°çš„ä»»åŠ¡. æ‰€ä»¥éœ€è¦è®© workers æœ‰èƒ½åŠ›æŠŠè‡ªå·±çš„å·¥ä½œå®ŒæˆçŠ¶å†µå‘ŠçŸ¥ bag. When bag is empty AND all tasks are done; All tasks are done when all workers are waiting to get a new task. If a bag of tasks algorithm has terminated, there are no tasks left. However, the inverse is not true. I.e. no tasks in a bag could mean that one of the workers is still processing a task which can lead to creation of multiple new tasks.To solve this problem, workers could have the ability to notify the master/bag once they finish the current task. As a result, an implementation of bag of tasks can then contain a count of idle and active works to prevent early termination A more sophisticated implementation (with less contention) might internally have a collection of bags, perhaps one per worker, with task-stealing to distribute the load as necessary. With message passing, a simple scheme might allocate an explicit â€œfarmerâ€ node to maintain the bag. Again, a more sophisticated implementation could distribute the bag and the farmer, with task-stealing and termination checking via messages. Pipeline Patterns.Example: The Sieve of Eratosthenes algorithms for finding all prime numbers. To find all prime numbers in the range 2 to N. The algorithm write down all integers in the range, then repeatedly remove all multiples of the smallest remaining number. Before each removal phase, the new smallest remaining number is guaranteed to be prime. Notice that, it is not necessarily to wait one Sieve completed then start another. As long as one Sieve stage finds out one candidate number could not be divided exactly by the sieve number, it could generate a new stage with this candidate number as Sieve. And different sieve just remove the multiples of its own Sieve number.123456789101112131415161718192021# a message-passing style pipeline pseudocodemain() &#123; # the generator spawn the first sieve process; for (i=2; i&lt;=N; i++) &#123; send i to first sieve; &#125; send -1 to first sieve; # a &quot;stop&quot; signal&#125;sieve() &#123; int myprime, candidate; receive myprime from predecessor and record it; do &#123; receive candidate from predecessor; if (candidate == -1) &#123;send -1 to successor if it exists&#125; else if (myprime doesn&apos;t divide candidate exactly) &#123; if (no successor yet) spawn successor sieve process; send candidate to successor sieve process; &#125; &#125; while (candidate != -1)&#125; æ¯ä¸€ä¸ªæ•°(2-N)éƒ½å¯èƒ½ä½œä¸ºç­›å­, ç­›æŽ‰èƒ½æ•´é™¤è¿™ä¸ªç­›å­çš„å…¶ä»–æ•°ï¼Œè€Œç­›å­ä¹‹é—´æ˜¯äº’ç›¸ç‹¬ç«‹çš„ï¼Œæ‰€ä»¥å¯ä»¥ä»¥æµæ°´çº¿æ¨¡å¼ pipeline patternsæ¥å¹¶è¡Œæ“ä½œï¼ŒåŠ¨æ€ç”Ÿæˆç­›å­ã€‚æœ€å¼€å§‹æœ€å°çš„æ•°å­—2ä¼šæˆä¸ºç­›å­ã€‚ç­›å­å¯ä»¥ç†è§£ä¸ºä¸åŒçš„å·¥åºï¼Œå…¶ä½™æ•°å­—ä»Žå°åˆ°å¤§é€ä¸€é€šè¿‡è¿™äº›å·¥åºåŠ å·¥ï¼ˆåœ¨ Sieve of Eratosthenes é—®é¢˜ä¸­å˜ä¸ºç­›é€‰æŽ’æŸ¥ï¼‰ï¼Œæ— æ³•è¢«ç­›å­æ•´é™¤çš„æ•°å­—ä¼šè¢«ä¼ é€’åˆ°ä¸‹ä¸ªç­›å­ï¼ˆå¦‚æžœæ²¡æœ‰ä¸‹ä¸€ä¸ªç­›å­ï¼Œåˆ™ä»¥è¿™ä¸ªæ•°å­—åˆ›å»ºæ–°çš„ç­›å­ï¼‰ï¼Œè¿™æ ·ä¿è¯ç”Ÿæˆçš„ç­›å­å°±éƒ½æ˜¯ç´ æ•°äº†ã€‚è™½ç„¶å·¥åºæ˜¯æŒ‰é¡ºåºè¿‡çš„ï¼Œä½†æ˜¯æ‰€æœ‰å·¥åºå¯ä»¥åŒæ—¶å¯¹ä¸åŒçš„äº§å“ï¼ˆæ•°å­—ï¼‰å¼€å·¥ï¼Œä»Žè€Œè¾¾åˆ°å¹¶è¡Œç›®çš„ã€‚ For pipeline patterns, the potential concurrency can be exploited by assigning each operation (stage of the pipeline) to a different worker and having them work simultaneously, with the data elements passing from one worker to the next as operations are completed. Despite the dependencies (order constraints) of the processing steps, the pipeline threads can work in parallel by applying their processing step to different data (products). Think of pipeline patterns as the factory assembly line. We need to pick out prime number from a range of numbers N, each number is passed into a sequence of stages, each stages checks a pass in number based on the stagesâ€™s Sieve. The numbers that finally pass all stages without being removed is a prime number. Pipelines are composed of a sequence of threads, in which each threadâ€™s input is the previous threadâ€™s output, (Producer-Consumer relationships). The advantages of pipeline patterns is that construction of pipeline stages is dynamic and data-dependent. To allow production and consumption to be loosely synchronized, we will need some buffering in the system. The programming challenges are to ensure that no producer overwrites a buffer entry before a consumer has used it, and that no consumer tries to consume an entry which doesnâ€™t really exist (or re-use an already consumed entry) Interacting Peers PatternModels of physical phenomena are often expressed as a system of partial differential equations. These can be approximately solved by â€œfinite difference methodsâ€ which involve iteration on a matrix of points, in an interacting peers pattern. The â€œcomputeâ€ step usually involves only a small number of neighbouring points. The termination test looks for convergence. We could use a duplicate grid and barriers to enforce correct synchronization between iterations:12345678910111213141516shared real grid[n+2, n+2], newgrid[n+2, n+2];shared bool converged; local real diff;co [i = 1 to n, j = 1 to n] &#123; initialise grid; do &#123; barrier(); ## before resetting test converged = true; ## provisionally newgrid[i,j] = (grid[i-1,j] + grid[i+1,j] + grid[i,j-1] + grid[i,j+1])/4; ## compute new value diff = abs (newgrid[i,j] - grid[i,j]); ## compute local change barrier(); ## before converged update if (diff &gt; EPSILON) converged = false; ## any one will do grid[i,j] = newgrid[i,j]; ## copy back to real grid barrier(); ## before global check &#125; while (not converged);&#125; A barrier() in ppls makes any thread that arrive here has to wait all the other threads arriving here. ä»¥æ–¹è…”çƒ­å¯¹æµçš„æ¨¡æ‹Ÿè®¡ç®—æ¨¡åž‹ä¸ºä¾‹ï¼Œæ¯ä¸ªç½‘æ ¼èŠ‚ç‚¹$(i,j)_{t+1}$ çš„æ›´æ–°ä¾èµ–äºŽä¸Šä¸€ä¸ªè¿­ä»£æ—¶é—´ç‚¹çš„$(i,j)_t$ä»¥åŠå…¶ä¸´è¿‘å‡ ä¸ªç‚¹çš„å€¼ï¼Œåˆ›å»ºæœ€å¤šè·Ÿç½‘æ ¼ç‚¹æ•°é‡ä¸€æ ·çš„threadsï¼Œç„¶åŽå¹¶è¡Œåœ°è®¡ç®—ç½‘æ ¼ç‚¹çš„æ–°å€¼ï¼Œæ›´æ–°çš„å€¼ç”¨ä¸€ä¸ªbufferå±‚æ¥ç¼“å­˜ï¼Œç”¨barrier()æ¥ä¿è¯æ‰€æœ‰ç½‘æ ¼ç‚¹çš„æ›´æ–°å€¼éƒ½è®¡ç®—å®Œæ¯•ï¼Œå†æ£€æŸ¥æ”¶æ•›æƒ…å†µï¼Œå†ç”¨ä¸€ä¸ªbarrier()ä¿è¯æ‰€æœ‰bufferå±‚çš„å€¼éƒ½æ›´æ–°åˆ°åŽŸç½‘æ ¼ä¸Šï¼Œå†å†³å®šæ˜¯å¦è¿›è¡Œä¸‹ä¸€æ¬¡è®¡ç®—ã€‚ Single Program Multiple Data (SPMD): A programming style, all processes execute more or less the same code, but on distinct partitions of the data. Other PatternsOther candidate patterns include MapReduce (championed by Google), Scan, Divide &amp; Conquer, Farm as well as application domain specific operations. Shared Variable ProgrammingIn the shared-memory programming model, tasks share a common address space, which they read and write asynchronously. An advantage of this model from the programmerâ€™s point is that the notion of data â€œownershipâ€ is lacking, so there is no need to specify explicitly the communication of data between tasks. Program development can often be simplified. There are two fundamentally different synchronization in shared variable programming. Mutual Exclusion and Condition Synchronization. Mutual ExclusionAtomic actions, at most one thread is executing the critical section at a time. Prevent two or more threads from being active concurrently for some period, because their actions may interfere incorrectly. For example, we might require updates to a shared counter (e.g., count++) to execute with mutual exclusion. Critical Sections problemA simple pattern of mutual exclusion occurs in the critical section problem - when n threads execute code of the following form, in which it is essential that at most one thread is executing statements in the critical section at a time (because of potentially unsafe access to shared variables)12345678co [i = 1 to n] &#123; while (something) &#123; lock(l); #entry section critical section; unlock(l); #exit section non-critical section; &#125;&#125; Design code to execute before (entry protocol) and after (exit protocol) the critical section to make the critical section atomic. If one thread lock the critical section, no one(thread) else could lock it or unlock it anymore, until the thread unlock it. Important properties: Mutual exclusion: When a thread is executing in its critical section, no other threads can be executing in their critical sections. Absence of Deadlock (or Livelock): If two or more threads are trying to enter the critical section, at least one succeeds. A deadlock is a state in which each member of a group is waiting for some other member to take action, such as sending a message or more commonly releasing a lock, so that neither of them take action.ç±»ä¼¼ä¸¤ä¸ªäººç›¸é‡äº’ä¸ç›¸è®©, æ²¡äººè‚¯æŒªåŠ¨.Livelock is a condition that takes place when two or more programs change their state continuously, with neither program making progress.ç±»ä¼¼ä¸¤ä¸ªäººç›¸é‡åŒæ—¶å¾€ç›¸åŒæ–¹å‘é¿è®©. Absence of Unnecessary Delay: If a thread is trying to enter its critical section and the other threads are executing their non-critical sections, or have terminated, the first thread is not prevented from entering its critical section. Eventual Entry (No Starvation): A thread that is attempting to enter its critical section will eventually succeed. May not matter in some â€œperformance parallelâ€ programs - as long as we are making progress elsewhere. Simple implementation of each lock with a shared boolean variable: if false, then one locking thread can set it to true and be allowed to proceed. Other attempted locks must be forced to wait.123456789101112# model assumes that the l = false;# write is already atomic# This might fail if the model is more relaxed than SC.lock_t l = false;co [i = 1 to n] &#123; while (something) &#123; &lt; await (!l) l = true; &gt; # guarantee the others waiting critical section; l = false; # unlock the lock, open the critical section non-critical section; &#125;&#125; To implement the &lt; await (!l) l = true; &gt;, we rely on some simpler atomic primitive, implemented with hardware support. There are many possibilities, including â€œFetch-and-Addâ€, â€œTest-and-Setâ€ and the â€œLoad-Linked, Store-Conditionalâ€ pairing. Test-and-Set (TS) instructionBehaving like a call-by-reference function, so that the variable passed in is read from and written to, but in reality it is a single machine instruction. The key feature is that this happens (or at least, appears to happen) atomically.12345678910111213141516# A Test-and-Set (TS) instructionWbool TS (bool v) &#123; &lt; bool initial = v; v = true; return initial; &gt;&#125;lock_t l = false;co [i = 1 to n] &#123; while (something) &#123; while (TS(l)) ; ## spin lock critical section; l = false; non-critical section; &#125;&#125; This is called spin lock, Simple spin locks donâ€™t make good use of the cache (those spinning Test-And-Sets play havoc with contention and coherence performance). A pragmatically better spin locks is known as Test-and-Test-and-Set - mainly spinning on a read rather than a read-write function.1234567... while (something) &#123; while (l || TS(l)); /* only TS() if l was false*/ critical section; ... &#125;... Simply read l until there is a chance that a Test-and-Set might succeed. Spin lock guarantees mutual exclusion, absence of deadlock and absence of delay, but does not guarantee eventual entry. Lamportâ€™s Bakery AlgorithmImplement critical sections using only simple atomic read and simple atomic write instructions (i.e. no need for atomic read-modify-write). é‡‡ç”¨å•†åº—ç»“è´¦æŽ’é˜Ÿæœºåˆ¶ï¼Œé¡¾å®¢å°±æ˜¯ä¸€ä¸ªä¸ªthreadsï¼Œæ ¹æ®æŽ’é˜Ÿç ï¼Œè¶Šå°çš„ä¼˜å…ˆçº§è¶Šé«˜ï¼ˆ0 é™¤å¤–ï¼Œ0 ä»£è¡¨æ²¡æœ‰ç»“è´¦éœ€æ±‚ï¼‰ï¼Œæœ€å°çš„å¯ä»¥è¿›å…¥critical sectionã€‚ The challenge is entry protocal, if a thread intends to access the critical section: æŽ’é˜Ÿå–å·ï¼šIt sets its turn turn[i] = max(turn[:])+1 (Threads not at or intend to access the critical section have a turn of 0) ç­‰å¾…å«å·ï¼šThis thread waits until its turn comes up (until it has the smallest turn). 123456789101112int turn[n] = [0, 0, ... 0];co [i=1 to n] &#123; while (true) &#123; turn[i] = max (turn[1..n]) + 1; for (j = 1 to n except i) &#123; while ((turn[j]!=0 and (turn[i] &gt; (turn[j])) skip; &#125; critical section; turn[i] = 0; noncritical section; &#125;&#125; å› ä¸ºmax (turn[1..n]) + 1ä¸æ˜¯atomicçš„, æ‰€ä»¥ä¼šå‡ºçŽ°é—®é¢˜. é—®é¢˜ä¸€: if turn setting is not atomic then two (or more) threads may claim the same turn. ä¸¤ä¸ªthreadsåœ¨å–å·é˜¶æ®µturn[i] = max(turn[:])+1å‡ºçŽ°å¹¶å‘ï¼Œä¸¤ä¸ªéƒ½å…ˆmax, ä¹‹åŽå†+1. é—®é¢˜äºŒ: there is possibility that a thread can claim a lower turn than another thread which enters the critical section before it! ä¸¤ä¸ªthreadsåœ¨å–å·é˜¶æ®µturn[i] = max(turn[:])+1å‡ºçŽ°å¹¶å‘, å¹¶ä¸”åœ¨ä¸¤ä¸ªthreadsåˆ†åˆ«è¿›è¡Œmaxçš„é—´éš™, åˆšå¥½åœ¨CSä¸­çš„threadå®Œæˆå¹¶é€€å‡ºCSï¼Œå¯¼è‡´ä¸¤ä¸ªthreadçœ‹åˆ°çš„maxå€¼ä¸ä¸€æ ·äº†. å‰è€…æ¯”åŽè€…çœ‹åˆ°çš„å¤§, ä½†å‰è€…å´å› ä¸ºæ›´æ—©è¿›è¡Œ+1æ“ä½œè€Œæå‰è¿›å…¥äº†CS. ä¸¾ä¾‹ï¼šå‡å¦‚åŒæ—¶æœ‰ä¸‰ä¸ªthread A B C, A å·²ç»åœ¨CSä¸­(turn(A)&gt;0)ï¼š B å…ˆè¿è¡Œmaxæ¯”è¾ƒ(max = turn(A)), C åœ¨ A é€€å‡ºåŽ(turn(A) = 0)æ‰è¿›è¡Œæ¯”è¾ƒ(max = 0), B å…ˆè¿›è¡Œ+1æ“ä½œ(turn(B) = turn(A)+1 &gt; 1), B è¿›è¡Œæ¯”è¾ƒåŽå…è®¸è¿›å…¥CS (æ­¤æ—¶turn(C)è¿˜æ˜¯0, 0æ˜¯è¢«å¿½ç•¥çš„); ä¹‹åŽCæ‰ +1(turn(C) = 0 + 1 = 1); è¿™æ ·å¯¼è‡´Bçš„å€¼è™½ç„¶æ¯”Cå¤§, ä½†Bè¿˜æ˜¯æ¯”Cå…ˆè¿›å…¥CS; ä¹‹åŽå› ä¸º C çš„ turn æ¯”è¾ƒå°ï¼Œ æ‰€ä»¥ C ä¹Ÿè·Ÿç€è¿›å…¥ CSã€‚ é—®é¢˜ä¸€è§£å†³æ–¹æ¡ˆ - ä½¿ç”¨çº¿ç¨‹IDï¼ˆç»ä¸ç›¸åŒï¼‰åšäºŒæ¬¡åŒºåˆ†, åœ¨ç›¸åŒ turn çš„æƒ…å†µä¸‹ï¼Œå…·æœ‰è¾ƒä½ŽIDçš„ thread æœ‰é™ã€‚ é—®é¢˜äºŒè§£å†³æ–¹æ¡ˆ - åœ¨max (turn[1..n]) + 1ä¹‹å‰å…ˆturn[i] = 1;.â€¢ è¿™æ ·ï¼Œä»»ä½• threads æƒ³å–å·éƒ½è¦å…ˆæ ‡è®°ä¸º 1â€¢ æ ‡è®°åŽï¼Œæ‰æœ‰èµ„æ ¼è·Ÿå…¶ä»– thread æ¯”è¾ƒâ€¢ ä»¥max+1ä½œä¸ºå·ç è¿›å…¥é˜Ÿåˆ—ï¼Œè¿™æ ·ä»»ä½•çš„å¯èƒ½çš„ turn å€¼éƒ½å¿…å®šå¤§äºŽ 1â€¢ B æ— æ³•æå‰è¿›å…¥CS (æ­¤æ—¶turn(C)ä¸å†æ˜¯è¢«å¿½ç•¥çš„0, è€Œæ˜¯æœ€å°æ­£æ•´æ•°1).12345678# (x, a) &gt; (y,b) means (x&gt;y) || (x==y &amp;&amp; a&gt;b).while (true) &#123; turn[i] = 1; turn[i] = max (turn[1..n]) + 1; for (j = 1 to n except i) &#123; while ((turn[j]!=0 and (turn[i], i) &gt; (turn[j], j)) skip; &#125; ...&#125; Lamportâ€™s algorithm has the strong property of guaranteeing eventual entry (unlike our spin lock versions). The algorithm is too inefficient to be practical if spin-locks are available. Condition SynchronizationDelay an action until some condition (on the shared variables such as in producer-consumer, or with respect to the progress of other threads such as in a Barrier) becomes true. Barrier synchronizationBarrier synchronization is a particular pattern of condition synchronization, a kind of computation-wide waiting:123456co [i = 1 to n] &#123; while (something) &#123; do some work; wait for all n workers to get here; &#125;&#125; A Counter Barriers12&lt;count = count + 1;&gt;&lt;await (count == n);&gt; is fine as a single-use barrier, but things get more complex if (as is more likely) we need the barrier to be reusable. æ”¹è‰¯ä¸º&lt;await (count == n); count = 0;&gt;ä¹Ÿä¸è¡Œ: an inter-iteration race, å‡å¦‚count == n, é‚£ä¹ˆnä¸ªthreadséƒ½å®Œæˆäº†å‰é¢çš„statementså¹¶å‡†å¤‡æ‰§è¡Œawait, ä½†å…¶ä¸­ä»»ä½•ä¸€ä¸ª thread å…ˆæ‰§è¡Œå®Œæ•´ä¸ªä»£ç éƒ½ä½¿count = 0,è¿™æ ·å‰©ä½™çš„threadså°±æ— æ³•é€šè¿‡awaitæ¡ä»¶äº†. Sense Reversing BarrierA shared variable sense is flipped after each use of the barrier to indicate that all threads may proceed. å…³é”®æ¯ä¸ª thread éƒ½æœ‰è‡ªå·±çš„ private variable mySense å’Œ while spin lockã€‚è§£å†³äº†å‰é¢çš„æ­»é”é—®é¢˜ã€‚12345678910111213shared int count = 0; shared boolean sense = false;co [i = 1 to n] &#123; private boolean mySense = !sense; ## one per thread while (something) &#123; do some work; &lt; count = count + 1; if (count == n) &#123; count = 0; sense = mySense; &#125; ## flip sense &gt; while (sense != mySense); ## wait or pass mySense = !mySense; ## flip mySense // æˆ–è€…ä½¿ç”¨ &lt; await (sense==mySense) mySense = !sense;&gt; &#125;&#125; æ‰€æœ‰threadçš„local variable mySenseå¼€å§‹éƒ½è¢«èµ‹å€¼ä¸º!sense(true)ï¼Œå‰é¢n-1ä¸ªthreadéƒ½å¾—åœ¨å†…å¾ªçŽ¯whileé‚£é‡Œç­‰ç€ï¼›ç›´åˆ°æœ€åŽä¸€ä¸ªthreadå®Œæˆå·¥ä½œåŽ, ifæ¡ä»¶æ‰æ»¡è¶³, counté‡ç½®ä¸º0, åè½¬sense(è¢«èµ‹å€¼ä¸ºmySenseä¹Ÿå³æ˜¯true), ä¹‹åŽæ‰€æœ‰threadsæ‰èƒ½ç»“æŸå†…éƒ¨whileå¾ªçŽ¯ï¼ŒæŽ¥ç€å†æ¬¡åè½¬sense(è¢«èµ‹å€¼ä¸º!mySenseä¹Ÿå³æ˜¯false), ç„¶åŽè¿›è¡Œä¸‹ä¸€è½®å¤§å¾ªçŽ¯ï¼Œå€Ÿæ­¤è¾¾åˆ°é‡å¤åˆ©ç”¨barrierçš„ç›®çš„. senseåˆå§‹å€¼æ˜¯ä»€ä¹ˆæ— æ‰€è°“, åè½¬æ‰æ˜¯å…³é”®. ç¼ºç‚¹ï¼š$O(n)$æ•ˆçŽ‡ï¼Œcountæ¬¡æ•°ï¼ˆåŒæ­¥æ¬¡æ•°ï¼‰æ­£æ¯”äºŽthreadæ•°é‡ã€‚ Symmetric BarriersSymmetric barriers are designed to avoid the bottleneck at the counter.é€šè¿‡ pair-threads barriers å¤šè½®åŒæ­¥æ¥æž„å»ºä¸€ä¸ªå®Œæ•´çš„ n-threads barriersï¼Œè®©æ‰€æœ‰threadséƒ½çŸ¥é“å¤§å®¶å·²ç»å®Œæˆä»»åŠ¡ã€‚æ€»å…±æ˜¯$\log_2n$ è½®åŒæ­¥ã€‚æ¯ä¸ªthreadåœ¨å®Œæˆå¿…è¦å·¥ä½œåŽ, å¼€å§‹è¿›å…¥ä¸‹é¢çš„pairwiseåŒæ­¥çŽ¯èŠ‚ï¼Œè‡ªå·±(myid)çš„åˆå§‹arriveçŠ¶æ€ä¸º0:12345678910# arrive[i] == 1 means arrive barrier# there will be log_2 #threads stages,# æ¯ä¸ªstageä»£è¡¨ä¸€æ¬¡pairwiseåŒæ­¥for [s = 0 to stages-1] &#123; &lt;await (arrive[myid] == 0);&gt; # 1 arrive[myid] = 1; # 2 work out who my friend is at stage s; &lt;await (arrive[friend] == 1);&gt; # 3 arrive[friend] = 0; # 4&#125; è¿™æ ·ä¿è¯äº†ï¼Œæ¯ä¸ªthreadéœ€è¦å…ˆæŠŠè‡ªå·±çš„arriveçŠ¶æ€æ ‡è®°ä¸º1(#1ï¼Œ#2)ï¼Œæ‰å¯ä»¥åŽ»çœ‹åŒä¼´çš„çŠ¶æ€ï¼ˆ#3ï¼‰ï¼Œå‡å¦‚åŒä¼´ä¹Ÿæ˜¯1ï¼Œé‚£ä¹ˆè¡¨æ˜Žè‡ªå·±è¿™ä¸€ç»„æ˜¯éƒ½åˆ°è¾¾äº†barrierçŠ¶æ€ï¼ˆå¤§å®¶éƒ½æ˜¯1ï¼‰ï¼Œé‚£ä¹ˆå°±ä¼šæŠŠå¯¹æ–¹çš„çŠ¶æ€åˆå§‹åŒ–ä¸º0 ï¼ˆ#4ï¼‰ï¼Œè¿›å…¥ä¸‹ä¸€é˜¶æ®µï¼Œæ›´æ¢åŒä¼´ï¼Œç»§ç»­åŒæ­¥æ¯”è¾ƒã€‚When used as a step within a multistage symmetric barrier, ä¼šå‡ºçŽ°é—®é¢˜ï¼šå‡å¦‚æœ‰å››ä¸ªthreadï¼Œé‚£ä¹ˆå°±ä¼šæœ‰ä¸¤ä¸ªstagesï¼šç¬¬ä¸€æ¬¡æ˜¯1å’Œ2åŒæ­¥ï¼Œ3å’Œ4åŒæ­¥ã€‚2ä¸€ç›´æ²¡åˆ°barrierï¼Œ1ä¸€ç›´å¡åœ¨#3ã€‚è€Œ3å’Œ4 åŒæ­¥å®ŒåŽå¼€å§‹æ£€æŸ¥1çš„çŠ¶å†µï¼Œå‘çŽ°arrive[1] = 1ï¼Œå°±è¿è¡ŒLines (3) and (4), ç»“æžœ1å°±è¢«åˆå§‹åŒ–äº†ï¼Œè€Œ2è¿˜æ²¡æ˜¯æ²¡åˆ°barrierã€‚ è§£å†³åŠžæ³•æ˜¯ç»™æ¯ä¸ªstageåˆ†é…æ–°çš„arriveå˜é‡ã€‚1234567for [s = 0 to stages-1] &#123; &lt;await (arrive[myid][s] == 0);&gt; arrive[myid][s] = 1; work out who my friend is at this stage; &lt;await (arrive[friend][s] == 1);&gt; arrive[friend][s] = 0;&#125; è¿™æ ·å‡å¦‚å‡ºçŽ°2ä¸€ç›´æ²¡åˆ°barrierçš„æƒ…å†µ, é‚£ä¹ˆ1ä¼šå¡åœ¨å½“å‰stage, 1çš„stage+1çš„arriveçŠ¶æ€å°±æ— æ³•æ›´æ–°ä¸º1. Dissemination BarriersIf n isnâ€™t a power of 2, instead of pairwise synchs, we have two partners at each stage for each thread, one incoming and one outgoing. Structured PrimitivesInstead of implementing directly in the user-address space, a number of more structured primitives have been devised for implementation with the assistance of the operating system, so that threads can be directly suspended and resumed by the OSâ€™s scheduler. â€¢ Machine code, instructions and data directly understandable by a CPU;â€¢ Language primitive, the simplest element provided by a programming language;â€¢ Primitive data type, a datatype provided by a programming language. Semaphores ä¿¡å·ç¯A semaphore is a special shared variable, accessible only through two atomic operations, P(try to decrease) and V(increase), defined by:P(s): &lt;await (s&gt;0) s=s-1;&gt;V(s): &lt;s=s+1;&gt; Property: A thread executing P() on a 0 valued semaphore will be suspended on a queue until after some other thread has executed a V(). Application: A semaphore appears to be a simple integer. A thread waits for permission to proceed a critical section, and then signals that it has proceeded by performing a P() operation on the semaphore. Binary semaphore: A semaphore whose usage is organised to only ever take the value (0, 1) as a mutex äº’æ–¥.Counting(split) semaphore: can take on arbitrary nonnegative values. Semaphores still require careful programming: there is no explicit connection in the program source between â€œmatchingâ€ semaphore operations. It is easy to get things wrong. Similarly, there is no obvious indication of how semaphores are being used - some may be for mutual exclusion, others for condition synchronization. Again confusion is possible. Semaphores for Critical Section (mutual exclusion)123456789sem mutex = 1;co [i = 1 to n] &#123; while (whatever) &#123; P(mutex); critical section; V(mutex); noncritical section; &#125;&#125; Semaphores for Barrier Synchronisationå®žçŽ° symmetric barrier: an array of arrive semaphores for each stage12345for [s = 1 to stages] &#123; V(arrive[myid][s]); work out who my friend is at stage s; P(arrive[friend][s]);&#125; Semaphores for Producer-Consumer Bufferingé’ˆå¯¹å•ä¸ªproducerå’Œconsumerï¼ŒæŽ§åˆ¶å…¶æŽ¥è§¦å•ä¸ªå®¹é‡çš„bufferæƒé™ï¼šä¸€ä¸ªsemaphoresæ ‡è¯†bufferå·²æ»¡fullï¼Œä¸€ä¸ªæ ‡è¯†ç©ºemptyã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œåªèƒ½æœ‰ä¸€ä¸ªsemaphoreæ˜¯1ï¼Œæ•…ç§°ä¹‹ä¸ºsplit binary semaphoreã€‚ P(full) æ‰§è¡Œ wait full &gt; 0 : full -= 1, V(empty)æ‰§è¡Œempty += 1123456789101112131415161718T buf; sem empty = 1, full = 0;co co [i = 1 to M] &#123; while (whatever) &#123; ...produce new data locally P(empty); buf = data; # producer V(full); &#125; &#125;// co [j = 1 to N] &#123; while (whatever) &#123; P(full); result = buf; # consumer V(empty); ... handle result locally &#125; &#125;oc Bounded Buffer: Control access to a multi-space buffer (the producer can run ahead of the consumer up to some limit) Implement the buffer itself with an array (circular), and two integer indices, indicating the current front and rear of the buffer and use arithmetic modulo n (the buffer size), so that the buffer conceptually becomes circular For a single producer and consumer, we protect the buffer with a split â€œcountingâ€ semaphore, initialised according to the buffer size. Think of full as counting how many space in the buffer are full, and empty as counting how many are empty1234567891011121314151617T buf[n]; int front = 0, rear = 0;sem empty = n, full = 0;co ## Producer while (whatever) &#123; ...produce new data locally P(empty); # empty&gt;0, æ‰èƒ½ç”Ÿäº§, empty-=1 buf[rear] = data; rear = (rear + 1) % n; V(full); &#125;// ## Consumer while (whatever) &#123; P(full); # full&gt;0, æ‰èƒ½æ¶ˆè€—, full-=1 result = buf[front]; front = (front + 1) % n; V(empty); ... handle result locally &#125;oc Multiple Producers/Consumers: Because each producer may access the same pointer to overide each other, so as consumer. Thus we need two levels of protection. Use a split counting semaphore to avoid buffer overflow (or underflow), as previously. Use a mutual exclusion semaphores to prevent interference between producers (and another to prevent interference between consumers). This allows up to one consumer and one producer to be actively simultaneously within a non-empty, non-full buffer. 1234567891011121314151617181920212223T buf[n]; int front = 0, rear = 0; 86sem empty = n, full = 0, mutexP = 1, mutexC = 1;co co [i = 1 to M] &#123; while (whatever) &#123; ...produce new data locally P(empty); P(mutexP); # stop the other producers from accessing the buffer buf[rear] = data; rear = (rear + 1) % n; V(mutexP); V(full);&#125; &#125;// co [j = 1 to N] &#123; while (whatever) &#123; P(full); P(mutexC); result = buf[front]; front = (front + 1) % n; V(mutexC); V(empty); ... handle result locally &#125; &#125;oc Extending Multiple Producers/Consumers: If the buffered items are large and take a long time to read/write, we would like to relax this solution to allow several producers and/or consumers to be active within the buffer simultaneously. We need to ensure that these workers accesse distinct buffer locations, which require the index arithmetic to be kept atomic. Make sure that the producer/consumers wait for that element to be empty/full before actually proceeding. The solution is to have extra semaphores pair for each buffer location. MonitorsThe monitor is a more structured mechanism which allows threads to have both mutual exclusion and the ability to wait (block) for a certain condition to become true. It has a mechanism for signaling other threads that their condition has been met. A monitor consists of a mutex (lock) object and condition variables (cv). A condition variable is basically a container of threads that are waiting for a certain condition. For Mutual Exclusion: i.e. a mutex (lock) object, ensures that at most one thread is active within the monitor at each point in time. ä¸åŒçº¿ç¨‹çš„ä¸‹ä¸€æ¡å³å°†æ‰§è¡Œçš„æŒ‡ä»¤ (suspended) å¯èƒ½æ˜¯æ¥è‡ªåŒä¸€ä¸ª monitor (ç”±osè‡ªè¡Œåˆ†é…), ä½†åŒä¸€æ—¶é—´å†…ï¼Œè‡³å¤šåªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œä½†å¯èƒ½ä¸åŒçº¿ç¨‹å„è‡ªæ”¶åˆ°äº†æ¥è‡ªè¿™ä¸ª monitor ä»£ç çš„ä¸åŒæŒ‡ä»¤. It is as if the body of each monitor method is implicitly surrounded with P() and V() operations on a single hidden binary semaphore, shared by all methods. For Condition Synchronization, using a cv with a monitor to control a queue of delayed threads by a kind of Signal and Continue (SC) scheme.For a condition_variables x; wait(x): Release lock; wait for the condition to become true; reacquire lock upon return (Java wait()) Signal(x): Wake up a waiter, if any (Java notify()) signal-all(x)orBroadcast(x): Wake up all the waiters (Java notifyAll()) For the thread active inside a monitor method - executing in monitor state If the thread could not proceed, it may call the wait(cv) operation to give up the (implicit) lock it holds on the monitor, and being suspended (push to the end of CV queue). Each CV has its unique block queue. Or the thread could calls the operation signal(cv) to release the lock. This allow one previously blocked thread (normally chosen by a FIFO discipline) to become ready for scheduling again (only one will be allowed to enter the monitor entry queue at a time). The signalling thread continues uninterrupted. Or return(). If no threads are waiting, then a signal() is â€œlostâ€ or â€œforgottenâ€, whereas a V() in Semaphores allows a subsequent P() to proceed. Monitor semantics mean that when a thread which was previously blocked on a condition is actually awakened again in the monitor. The point to remember is that when the signal happened, the signalled thread was allowed to try to acquire the monitor lock again). It could be that some other thread acquires the lock first, and does something which negates the condition again (for example, it consumes the â€œnew itemâ€ from a monitor protected buffer). Thus it is often necessary, in all but the most tightly constrained situations, to wrap each conditional variable wait() call in a loop which rechecks the condition it was waiting for is still true. Single producer, single consumer bounder buffer12345678910111213141516171819monitor Bounded_Buffer &#123; typeT buf[n]; # an array of some type T int front = 0, # index of first full slot rear = 0; # index of first empty slot count = 0; # number of full slots ## rear == (front + count) % n condition_variables not_full, # signaled when count &lt; n not_empty; # signaled when count &gt; 0 procedure deposit(typeT data) &#123; # å­˜ while (count == n) wait(not_full); buf[rear] = data; rear = (rear+1) % n; count++; signal(not_empty); &#125; procedure fetch(typeT &amp;result) &#123; # å– while (count == 0) wait(not_empty); result = buf[front]; front = (front+1) % n; count--; signal(not_full); &#125;&#125; Why the while loop is necessary as a safety check on the wait calls (why not use if)? - å› ä¸ºnotify()åªä¼šè®©æ­£åœ¨ wait queue çš„ thread è¿›å…¥å‡†å¤‡çŠ¶æ€, ä½†ä¸ä¼šç›´æŽ¥æŽ§åˆ¶å…¶æ¢å¤å·¥ä½œï¼ˆæ˜¯å¦é©¬ä¸Šå¼€å§‹ï¼Œè°å…ˆå¼€å§‹ï¼Œéƒ½æ˜¯ç”±oså†…éƒ¨æŽ§åˆ¶çš„ï¼‰, æ‰€ä»¥å¯¼è‡´ä¸åŒ thread è¿›åº¦ä¸åŒ; è€Œwhileå¯ä»¥ä¿è¯å½“å³ä½¿ thread å› ä¸ºå—åˆ°notify()è€Œç»“æŸwait()å¼€å§‹è¿›å…¥å‡†å¤‡çŠ¶æ€(entry queue)åŽ, ç»§ç»­æ£€æŸ¥ buffer çŠ¶æ€, è¿™æ ·å‡å¦‚å‘çŽ°è‡ªå·±æ˜¯æœ€ä¼˜å…ˆå®‰æŽ’çš„é‚£ä¸ª, å°±å¯ä»¥è·³å‡ºwhileå¾ªçŽ¯è¿›å…¥å·¥ä½œçŠ¶æ€; å‡å¦‚å‘çŽ°è‡ªå·±ä¼˜å…ˆåº¦ä¸æ˜¯æœ€é«˜çš„(whileå¾ªçŽ¯æ¡ä»¶ç»§ç»­æ»¡è¶³), åˆ™ç»§ç»­wait(). The key difference to semaphores: signal() on a condition variable is not â€œrememberedâ€ in the way that V() on a semaphore is. If no threads are waiting, then a signal() is â€œlostâ€ or â€œforgottenâ€, whereas a V() will allow a subsequent P() to proceed. Real Shared Variable Programming SystemsVarious concepts for shared variable programming have been embedded in real programming systems. In particular Câ€™s Posix threads (Pthreads) library and Javaâ€™s threads and monitors. POSIX Threads (Pthread)Create a new thread: Threads (type pthread_t) begin by executing a given function, and terminate when that function exits (or when killed off by another thread).12int pthread_create (pthread_t *thread, p_thread_attr_t *attr, void *(*function) (void *), void *arguments); Wait for thread termination: int pthread_join (pthread_t t, void ** result); 12345678910111213141516//ä¸€ä¸ªç®€å•ä½†æ˜¯æœ‰é”™è¯¯çš„ä¾‹å­ï¼Œint target;void *adderthread (void *arg) &#123; int i; for (i=0; i&lt;N; i++) &#123; target = target+1; &#125;&#125;int main (int argc, char *argv[]) &#123; int i; pthread_t thread[P]; target = 0; for (i=0; i&lt;P; i++) &#123; pthread_create(&amp;thread[i], NULL, adderthread, NULL); &#125; .....&#125; Variable target is accessible to all threads (shared memory). Its increment is not atomic, so we may get unpredictable results. POSIX provides mechanisms to coordinate accesses including semaphores and building blocks for monitors. Pthreads semaphores12345678910111213141516//ç”¨ pthread semaphores æ”¹å†™å‰é¢çš„ä»£ç sem_t lock;void *adderthread (void *arg) &#123; int i; for (i=0; i&lt;N; i++) &#123; sem_wait(&amp;lock); target = target+1; sem_post(&amp;lock); &#125;&#125;int main (int argc, char *argv[]) &#123; target = 0; sem_init(&amp;lock, 0, 1); .....&#125; sem_init(&amp;sem, share, init), where init is the initial value and share is a â€œbooleanâ€ (in the C sense) indicating whether the semaphore will be shared between processes (true) or just threads within a process (false). sem_wait(s), which is the Posix name for P(s) sem_post(s), which is the Posix name for V(s) A Producers &amp; Consumers:1234567891011121314151617181920212223242526272829303132sem_t empty, full; // the global semaphoresint data; // shared bufferint main (int argc, char *argv[]) &#123; pthread_t pid, cid; .... sem_init(&amp;empty, 0, 1); // sem empty = 1 sem_init(&amp;full, 0, 0); // sem full = 0 pthread_create(&amp;pid, &amp;attr, Producer, NULL); pthread_create(&amp;cid, &amp;attr, Consumer, NULL); pthread_join(pid, NULL); pthread_join(cid, NULL);&#125;void *Producer (void *arg) &#123; int produced; for (produced = 0; produced &lt; numIters; produced++) &#123; sem_wait(&amp;empty); data = produced; sem_post(&amp;full); &#125;&#125;void *Consumer (void *arg) &#123; int total = 0, consumed; for (consumed = 0; consumed &lt; numIters; consumed++) &#123; sem_wait(&amp;full); total = total+data; sem_post(&amp;empty); &#125; printf("after %d iterations, the total is %d (should be %d)\n", numIters, total, numIters*(numIters+1)/2);&#125; Pthreads MonitorsPthreads provides locks, of type pthread_mutex_t m;. These can be Initialized with pthread_mutex_init(&amp;m, attr), where attr are attributes concerning scope (as with semaphore creation). If attr is NULL, the default mutex attributes (NONRECURSIVE) are used; Locked with pthread_mutex_lock(&amp;m), which blocks the locking thread if m is already locked. There is also a non-blocking version pthread_mutex_trylock(&amp;m). Unlocked with pthread_mutex_unlock(&amp;m). Only a thread which holds a given lock, should unlock it! Pthreads provides condition variables pthread_cond_t. As well as the usual initialization, these can be: Waited on with pthread_cond_wait(&amp;cv, &amp;mut) where cv is a condition variable, and mut must be a lock already held by this thread, and which is implictly released. Signalled with pthread_cond_signal(&amp;cv) by a thread which should (but doesnâ€™t strictly have to) hold the associated mutex. The semantics are â€œSignal-and-Continueâ€ as previously discussed. Signalled all with pthread_cond_broadcast(&amp;cv). This is â€œsignal-allâ€ A simple Jacobi grid-iteration program with a re-usable Counter Barrier. To avoid copying between â€œnewâ€ and â€œoldâ€ grids, each iteration performs two Jacobi steps. Convergence testing could be added as before.123456789101112131415161718192021222324252627282930313233343536373839404142434445pthread_mutex_t barrier; // mutex semaphore for the barrierpthread_cond_t go; // condition variable for leavingint numArrived = 0;void Barrier() &#123; pthread_mutex_lock(&amp;barrier); numArrived++; if (numArrived == numWorkers) &#123; numArrived = 0; pthread_cond_broadcast(&amp;go); &#125; else &#123; pthread_cond_wait(&amp;go, &amp;barrier); &#125; pthread_mutex_unlock(&amp;barrier);&#125;int main(int argc, char *argv[]) &#123; pthread_t workerid[MAXWORKERS]; pthread_mutex_init(&amp;barrier, NULL); pthread_cond_init(&amp;go, NULL); InitializeGrids(); for (i = 0; i &lt; numWorkers; i++) pthread_create(&amp;workerid[i], &amp;attr, Worker, (void *) i); for (i = 0; i &lt; numWorkers; i++) pthread_join(workerid[i], NULL);&#125;void *Worker(void *arg) &#123; int myid = (int) arg, rowA = myid*rowshare+1, rowB = rowA+rowshare-1; for (iters = 1; iters &lt;= numIters; iters++) &#123; for (i = rowA; i &lt;= rowB; i++) &#123; for (j = 1; j &lt;= gridSize; j++) &#123; grid2[i][j] = (grid1[i-1][j] + grid1[i+1][j] + grid1[i][j-1] + grid1[i][j+1]) * 0.25; &#125; &#125; Barrier(); for (i = rowA; i &lt;= rowB; i++) &#123; for (j = 1; j &lt;= gridSize; j++) &#123; grid1[i][j] = (grid2[i-1][j] + grid2[i+1][j] + grid2[i][j-1] + grid2[i][j+1]) * 0.25; &#125; &#125; Barrier(); &#125;&#125; Memory Consistency in PthreadsWeak consistency models can wreck naive DIY synchronization attempts! To enable portability, Pthreads mutex, semaphore and condition variable operations implicitly act as memory fences, executing architecture specific instructions. In effect, the C + Pthreads combination guarantees a weak consistency memory model, with the only certainties provided at uses of Pthreads primitives. For example, all writes by a thread which has released some mutex, are guaranteed to be seen by any thread which then acquires it. Nothing can be assumed about the visibility of writes which cannot be seen to be ordered by their relationship to uses of Pthread primitives. The programmer must also be careful to use only thread-safe code, which works irrespective of how many threads are active. Thread-safe code only manipulates shared data structures in a manner that ensures that all threads behave properly and fulfill their design specification without unintended interaction. Implementation is guaranteed to be free of race conditions when accessed by multiple threads simultaneously. Typical problems involve the use of non-local data. For example, imagine a non-thread safe malloc. Unluckily interleaved calls might break the underlying free space data structure. Some libraries will provide thread-safe versions (but of course, which pay an unnecessary performance penalty when used in a single threaded program). Java ConcurrencyJavaæ˜¯ä¸€ç§å¤šçº¿ç¨‹ multi-threaded ç¼–ç¨‹è¯­è¨€ï¼Œå…¶åŒæ­¥æ¨¡åž‹æ˜¯åŸºäºŽ monitor æ¦‚å¿µï¼Œå¯ç”¨äºŽå¼€å‘å¤šçº¿ç¨‹ç¨‹åºã€‚å¤šä»»åŠ¡ multtasking å°±æ˜¯å¤šä¸ªè¿›ç¨‹å…±äº«å…¬å…±å¤„ç†èµ„æºï¼ˆå¦‚CPUï¼‰çš„æ—¶å€™ã€‚å¤šçº¿ç¨‹å°†å¤šä»»åŠ¡çš„æ€æƒ³æ‰©å±•åˆ°å¯ä»¥å°†å•ä¸ªåº”ç”¨ç¨‹åºä¸­çš„ç‰¹å®šæ“ä½œç»†åˆ†ä¸ºå•ç‹¬çº¿ç¨‹çš„åº”ç”¨ç¨‹åºã€‚æ¯ä¸ªçº¿ç¨‹éƒ½å¯ä»¥å¹¶è¡Œè¿è¡Œã€‚æ“ä½œç³»ç»Ÿä¸ä»…åœ¨ä¸åŒçš„åº”ç”¨ç¨‹åºä¹‹é—´åˆ†é…å¤„ç†æ—¶é—´ï¼Œè€Œä¸”åœ¨åº”ç”¨ç¨‹åºå†…çš„æ¯ä¸ªçº¿ç¨‹ä¹‹é—´åˆ†é…å¤„ç†æ—¶é—´ã€‚ Java ThreadsThreads can be created from classes which extend java.lang.Thread123456class Simple extends Thread &#123; public void run() &#123; System.out.println("this is a thread"); &#125;&#125;new Simple().start(); // implicitly calls the run() method Or implement java.lang.Runnable (so we can extend some other class too).1234class Bigger extends Whatever implements Runnable &#123; public void run() &#123; .... &#125;&#125;new Thread( new Bigger (...) ).start(); Wait to join with another thread123456789101112131415161718192021222324class Friend extends Thread &#123; private int me; public Friend (int i) &#123; me = i; &#125; public void run() &#123; System.out.println("Hello from thread " + me); &#125;&#125;class Hello throws java.lang.InterruptedException &#123; private static final int n = 5; public static void main(String[] args) &#123; int i; Friend t[] = new Friend[n]; System.out.println ("Hello from the main thread"); for (i=0; i&lt;n; i++) &#123; t[i] = new Friend(i); t[i].start(); &#125; for (i=0; i&lt;n; i++) &#123; t[i].join(); // might throw java.lang.InterruptedException &#125; System.out.println ("Goodbye from the main thread"); &#125;&#125; Java â€œMonitorsâ€Java provides an implementation of the monitor concept (but doesnâ€™t actually have monitor as a keyword). Any object in a Java program can, in effect, become a monitor, simply by declaring one or more of its methods to be synchronized, or by including a synchronized block of code. Each such object is associated with one, implicit lock. A thread executing any synchronized code must first acquire this lock. This happens implicitly (i.e. there is no source syntax). Similarly, upon leaving the synchronized block the lock is implicitly released. Javaâ€™s condition variable mechanism uses Signal-and-Continue semantics (The signalling thread continues uninterrupted). Each synchronizable object is associated with a single implicit condition variable. Manipulated with methods wait(), notify() and notifyAll(). We can only have one conditional variable queue per monitor (hence the absence of any explicit syntax for the condition variable itself). wait(): has three variance, one which waits indefinitely for any other thread to call notify or notifyAll method on the object to wake up the current thread. Other two variances puts the current thread in wait for specific amount of time before they wake up. notify(): wakes up only one thread waiting on the object and that thread starts execution. notifyAll(): wakes up all the threads waiting on the object, although which one will process first depends on the OS implementation. These methods can be used to implement producer consumer problem where consumer threads are waiting for the objects in Queue and producer threads put object in queue and notify the waiting threads. Readers &amp; Writers problem requires control access to some shared resource, such that there may be many concurrent readers, but only one writer (with exclusive access) at a time.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 2 readers and 2 writers making 5 accesses eachwith concurrent read or exclusive write. */class ReadWrite &#123; // driver program -- two readers and two writers static Database RW = new Database(); // the monitor public static void main(String[] arg) &#123; int rounds = Integer.parseInt(arg[0],10); new Reader(rounds, RW).start(); new Reader(rounds, RW).start(); new Writer(rounds, RW).start(); new Writer(rounds, RW).start(); &#125;&#125;class Reader extends Thread &#123; int rounds; Database RW; private Random generator = new Random(); public Reader(int rounds, Database RW) &#123; this.rounds = rounds; this.RW = RW; &#125; public void run() &#123; for (int i = 0; i&lt;rounds; i++) &#123; try &#123; Thread.sleep(generator.nextInt(500)); &#125; catch (java.lang.InterruptedException e) &#123;&#125; System.out.println("read: " + RW.read()); &#125; &#125;&#125;class Writer extends Thread &#123; int rounds; Database RW; private Random generator = new Random(); public Writer(int rounds, Database RW) &#123; this.rounds = rounds; this.RW = RW; &#125; public void run() &#123; for (int i = 0; i&lt;rounds; i++) &#123; try &#123; Thread.sleep(generator.nextInt(500)); &#125; catch (java.lang.InterruptedException e) &#123;&#125; RW.write(); &#125; &#125;&#125; Implement the â€œdatabaseâ€. Allowing several readers to be actively concurrently. The last reader to leave will signal a waiting writer. Thus we need to count readers, which implies atomic update of the count. A reader needs two protected sections to achieve this. Notice that while readers are actually reading the data they do not hold the lock.1234567891011121314151617181920212223242526272829303132class Database &#123; private int data = 0; // the data int nr = 0; // synchronized means no more than one thread could do that private synchronized void startRead() &#123; nr++; &#125; private synchronized void endRead() &#123; nr--; if (nr==0) notify(); &#125;// awaken a waiting writer public int read() &#123; int snapshot; startRead(); snapshot = data; // read data endRead(); return snapshot; &#125; public synchronized void write() &#123; int temp; while (nr&gt;0) try &#123; wait(); &#125; catch (InterruptedException ex) &#123;return;&#125; temp = data; // next six lines are the â€˜â€˜databaseâ€™â€™ update! data = 99999; // to simulate an inconsistent temporary state try &#123; Thread.sleep(generator.nextInt(500)); // wait a bit, for demo purposes only &#125; catch (java.lang.InterruptedException e) &#123;&#125; data = temp+1; // back to a safe state System.out.println("wrote: " + data); notify(); // awaken another waiting writer &#125;&#125; We could express the same effect with synchronized blocks12345678910public int read() &#123; int snapshot; synchronized(this) &#123; nr++; &#125; // this - the database object snapshot = data; synchronized(this) &#123; nr--; if (nr==0) notify(); // awaken a waiting writer &#125; return snapshot;&#125; Would it be OK to use notifyAll() in read()? - Yes, but with extra transmission cost. Buffer for One Producer - One Consumer1234567891011121314/** (borrowed from Skansholm, Java from the Beginning) */public class Buffer extends Vector &#123; public synchronized void putLast (Object obj) &#123; addElement(obj); // Vectors grow implicitly notify(); &#125; public synchronized Object getFirst () &#123; while (isEmpty()) try &#123;wait();&#125; catch (InterruptedException e) &#123;return null;&#125; Object obj = elementAt(0); removeElementAt(0); return obj; &#125;&#125; The java.util.concurrent packageIncluding a re-usable barrier and semaphores (with P() and V() called acquire() and release()). It also has some thread-safe concurrent data structures (queues, hash tables). The java.util.concurrent.atomic package provides implementations of atomically accessible integers, booleans and so on, with atomic operations like addAndGet, compareAndSet. The java.util.concurrent.locks package provides implementations of locks and condition variables, to allow a finer grained, more explicit control than that provided by the built-in synchronized monitors. Message Passing ProgrammingWhen the underyling archictecture doesnâ€™t support physically shared memory (for example, by distributing the OS and virtual memory system, i.e. Multicomputer architectures), we can make the disjoint nature of the address spaces apparent to the programmer, who must make decisions about data distribution and invoke explicit operations to allow interaction across these. Message passing, which is a approache to abstract and implement such a model, dominates the performance-oriented parallel computing world. Message passing is characterized as requiring the explicit participation of both interacting processes, since each address space can only be directly manipulated by its owner. The basic requirement is thus for send and receive primitives for transferring data out of and into local address spaces. The resulting programs can seem quite fragmented: we express algorithms as a collection of local perspectives. These are often captured in a single program source using Single Program Multiple Data (SPMD) style, with different processes following different paths through the same code, branching with respect to local data values and/or to some process identifier.12345678910111213141516// SPMD Compare-Exchangeco [me = 0 to P-1] &#123; // assumes P is even int a, temp; // these are private to each process now ...... // typical one step within a parallel sorting algorithm if (me%2 == 0) &#123; send (me+1, a); // send from a to process me+1 recv (me+1, temp); // receive into temp from process me+1 a = (a&lt;=temp) ? a : temp; // å–è¾ƒå°å€¼ &#125; else &#123; send (me-1, a); recv (me-1, temp); a = (a&gt;temp) ? a : temp; // å–è¾ƒå¤§å€¼ &#125; ......&#125; 1, Synchronization: Must a sending process pause until a matching receive has been executed (synchronous), or not (asynchronous)? Asynchronous semantics require the implementation to buffer messages which havenâ€™t yet been, and indeed may never be, received. If we use synchronous semantics, the compare-exchange code above will deadlock. Can you fix it? One way s to make the send be a non-blocking one (MPI_Isend)Another way is to reverse the order of one of the send/receive pairs:12345&#125; else &#123; recv (me-1, temp); send (me-1, a); a = (a&gt;temp) ? a : temp; // å–è¾ƒå¤§å€¼&#125; ...... 2, Addressing: When we invoke a send (or receive) do we have to specify a unique destination (or source) process or can we use wild-cards? Do we require program-wide process naming, or can we create process groups and aliases?3, Collective Operations: Do we restrict the programmer to single-source, single-destination, point-to-point messages, or do we provide abstractions of more complex data exchanges involving several partners?â€¢ Broadcast: Everyone gets a copy of the same value.â€¢ Scatter: Data is partitioned and spread across the group.â€¢ Gather: Data is gathered from across the group.â€¢ Reduction: Combine the gathered values with an associative operation.â€¢ Scan (Prefix): Reduce and also compute all the ordered partial reductions. Message Passing Interface (MPI) Message Passing Interface (MPI) is a standardized and portable message-passing standard. The standard defines the syntax and semantics of a core of library routines useful to a wide range of users writing portable message-passing programs in C, C++, and Fortran. Processes can be created statically when the program is invoked (e.g. using the mpirun command) or spawned dynamically. All communications take place within the context of â€œcommunication spacesâ€ called communicators, which denote sets of processes, allows the MPI programmer to define modules that encapsulate internal communication structures. A process can belong to many communicators simultaneously. New communicators can be defined dynamically. Simple send/receives operate with respect to other processes in a communicator. Send must specify a target but receive can wild card on matching sender. Messages can be tagged with an extra value to aid disambiguation. Message-passing programming models are by default nondeterministic: the arrival order of messages sent from two processes A and B, to a third process C, is not defined. (However, MPI does guarantee that two messages sent from one process A, to another process B, will arrive in the order sent.) There are many synchronization modes and a range of collective operations. MPI Primitives (6 basics functions)1, int MPI_Init(int *argc, char ***argv): Initiate an MPI computation.2, int MPI_Finalize(): Terminate a computation.These must be called once by every participating process, before/after any other MPI calls. They return MPI_SUCCESS if successful, or an error code. Each process has a unique identifier in each communicator of which it is a member (range 0â€¦members-1). MPI_COMM_WORLD is the built-in global communicator, to which all processes belong by default. A process can find the size of a communicator, and its own rank within it:3, int MPI_Comm_Size (MPI_Comm comm, int *np): Determine number of processes (comm - communicator). The processes in a process group are identified with unique, contiguous integers numbered from 0 to np-1.4, int MPI_Comm_rank (MPI_Comm comm, int *me): Determine my process identifier. 5, MPI_SEND: Send a message.6, MPI_RECV: Receive a message. MPI Task FarmA task farm is bag-of-tasks in which all the tasks are known from the beginning. The challenge is to assign them dynamically to worker processes, to allow for the possibility that some tasks may take much longer to compute than others. To simplify the code, we assume that there are at least as many tasks as processors and that tasks and results are just integers. In a real application these would be more complex data structures. Notice the handling of the characteristic non-determinism in the order of task completion, with tags used to identify tasks and results. We also use a special tag to indicate an â€œend of tasksâ€ message.1234567891011121314151617181920212223242526272829303132333435363738394041424344/** SPMD styleå†œåœºä¸»åˆ†é…ä»»åŠ¡ç»™å·¥äºº */#define MAX_TASKS 100#define NO_MORE_TASKS MAX_TASKS+1#define FARMER 0 // ç¬¬ä¸€ä¸ª process æ˜¯farmer,å…¶ä½™æ˜¯workerint main(int argc, char *argv[]) &#123; int np, rank; MPI_Init(&amp;argc, &amp;argv); MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); MPI_Comm_size(MPI_COMM_WORLD, &amp;np); if (rank == FARMER) &#123; farmer(np-1); &#125; else &#123; worker(); &#125; MPI_Finalize();&#125;void farmer (int workers) &#123; int i, task[MAX_TASKS], result[MAX_TASKS], temp, tag, who; MPI_Status status; // 1, ç»™æ¯ä¸ªäººå‘é€ä»»åŠ¡ for (i=0; i&lt;workers; i++) &#123; MPI_Send(&amp;task[i], 1, MPI_INT, i+1, i, MPI_COMM_WORLD); &#125; // 2, æ”¶å–ä»»åŠ¡ç»“æžœ, ç»§ç»­å‘æ”¾å‰©ä½™ä»»åŠ¡ while (i&lt;MAX_TASKS) &#123; MPI_Recv(&amp;temp, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status); who = status.MPI_SOURCE; tag = status.MPI_TAG; result[tag] = temp; MPI_Send(&amp;task[i], 1, MPI_INT, who, i, MPI_COMM_WORLD); i++; &#125; // 3, æ‰€æœ‰ä»»åŠ¡å·²ç»å®Œæˆ, æ”¶é›†æœ€åŽä¸€ä¸ªä»»åŠ¡ç»“æžœ, å¹¶ä¸”å‘å‡ºç»“æŸä»»åŠ¡ä¿¡å· for (i=0; i&lt;workers; i++) &#123; MPI_Recv(&amp;temp, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status); who = status.MPI_SOURCE; tag = status.MPI_TAG; result[tag] = temp; MPI_Send(&amp;task[i], 1, MPI_INT, who, NO_MORE_TASKS, MPI_COMM_WORLD); &#125;&#125; Notice that the final loop, which gathers the last computed tasks, has a predetermined bound. We know that this loop begins after dispatch of the last uncomputed task, so there must be exactly as many results left to gather as there are workers.12345678910111213void worker() &#123; int task, result, tag; MPI_Status status; MPI_Recv(&amp;task, 1, MPI_INT, FARMER, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status); tag = status.MPI_TAG; while (tag != NO_MORE_TASKS) &#123; result = somefunction(task); MPI_Send(&amp;result, 1, MPI_INT, FARMER, tag, MPI_COMM_WORLD); MPI_Recv(&amp;task, 1, MPI_INT, FARMER, MPI_ANY_TAG, MPI_COMM_WORLD, &amp;status); tag = status.MPI_TAG; &#125;&#125; A worker is only concerned with its interaction with the farmer. è¿™æ ·é€Ÿåº¦è¾ƒå¿«çš„workerå¯ä»¥è‡ªåŠ¨æŽ¥æ›´å¤šçš„ä»»åŠ¡ï¼Œæœ€ç»ˆæ•´ä½“ä¸Šè¾¾æˆ load balanceã€‚ Send in standard mode12int MPI_Send(void *buf, int count, MPI_Datatype datatype, int dest, int tag, MPI_Comm comm) Send count items of given type starting in position buf to process dest in communicator comm, tagging the message with tag (which must be non-negative). There are corresponding datatypes for each basic C type, MPI_INT, MPI_FLOAT etc, and also facilities for constructing derived types which group these together. Are MPI_Send and MPI_Recv synchronous or asynchronous? Receive in standard mode12int MPI_Recv(void *buf, int count, MPI_Datatype datatype, int source, int tag, MPI_Comm comm, MPI_Status *status) Receive count items of given type starting in position buf, from process source in communicator comm, tagged by tag. It attempts to receive a message that has an envelope corresponding to the specified tag, source, and comm, blocking until such a message is available. When the message arrives, elements of the specified datatype are placed into the buffer at address buf. This buffer is guaranteed to be large enough to contain at least count elements. Non-determinism (within a communicator) is achieved with â€œwild cardsâ€, by naming MPI_ANY_SOURCE and/or MPI_ANY_TAG as the source or tag respectively. A receive can match any available message sent to the receiver which has the specified communicator, tag and source, subject to the constraint that messages sent between any particular pair of processes are guaranteed to appear to be non-overtaking. In other words, a receive cannot match message B in preference to message A if A was sent before B by the same process, the receive will receive the first one which was sent, not the first one to arrive. The status variable can be used subsequently to inquire about the size, tag, and source of the received message. Status information is returned in a structure with status.MPI_SOURCE and status.MPI_TAG fields. This is useful in conjunction with wild card receives, allowing the receiver to determine the actual source and tag associated with the received message. Prime Sieve Generator12345678910111213int main(int argc, char *argv[]) &#123; MPI_Comm nextComm; int candidate = 2, N = atoi(argv[1]); MPI_Init(&amp;argc, &amp;argv); MPI_Comm_spawn("sieve", argv, 1, MPI_INFO_NULL, 0, MPI_COMM_WORLD, &amp;nextComm, MPI_ERRCODES_IGNORE); while (candidate&lt;N) &#123; MPI_Send(&amp;candidate, 1, MPI_INT, 0, 0, nextComm); candidate++; &#125; candidate = -1; MPI_Send(&amp;candidate, 1, MPI_INT, 0, 0, nextComm); MPI_Finalize();&#125; We use MPI_Comm_spawn to dynamically create new sieve processes as we need them, and MPI_Comm_get_parent to find an inter-communicator to the process group which created us.12345678910111213141516171819202122int main(int argc, char *argv[]) &#123; MPI_Comm predComm, succComm; MPI_Status status; int myprime, candidate; int firstoutput = 1; // a C style boolean MPI_Init (&amp;argc, &amp;argv); MPI_Comm_get_parent (&amp;predComm); MPI_Recv(&amp;myprime, 1, MPI_INT, 0, 0, predComm, &amp;status); printf ("%d is a prime\n", myprime); MPI_Recv(&amp;candidate, 1, MPI_INT, 0, 0, predComm, &amp;status); while (candidate!=-1) &#123; if (candidate%myprime != 0) &#123; // not sieved out if (firstoutput) &#123; // create my successor if necessary MPI_Comm_spawn("sieve", argv, 1, MPI_INFO_NULL, 0, MPI_COMM_WORLD, &amp;succComm, MPI_ERRCODES_IGNORE); firstoutput = 0; &#125; MPI_Send(&amp;candidate, 1, MPI_INT, 0, 0, succComm) // pass on the candidate &#125; MPI_Recv(&amp;candidate, 1, MPI_INT, 0, 0, predComm, &amp;status); // next candidate &#125; if (!firstoutput) MPI_Send(&amp;candidate, 1, MPI_INT, 0, 0, succComm); // candidate=-1, shut down MPI_Finalize();&#125; The message flow is insured by the method in which new processes are spawned/created. Every time a new â€œsieveâ€ process is spawned, MPI creates it in a new group/communicator. succComm is a handle to this new group which always contains only one process. Therefore, when a candidate is sent to the process, there is only one process in the succComm group and it has id 0. The Recv function works in the same way predComm is a handle of the parent group (i.e. group of the process that created this sieve). And because the parent was the only process in this group/communicator, it can be identified by id 0. In conclusion, a process creates at most one successor. This successor is the only process in its group/communicator. The succCom and predComm are handles to the children and parent groups respectively, both of which contain a single process with id 0 which is unique in its own group/communicator. Spawning New MPI Processes12int MPI_Comm_spawn (char *command, char *argv[], int p, MPI_Info info, int root, MPI_Comm comm, MPI_Comm *intercomm, int errcodes[]) This spawns p new processes, each executing a copy of program command, in a new communicator returned as intercomm. To the new processes, intercomm appears as MPI_COMM_WORLD. It must becalled by all processes in comm (it is â€œcollectiveâ€), with process root computing the parameters. info and errcodes are used in system dependent ways to control/monitor process placement, errors etc. MPI_Comm_get_parent gives the new processes a reference to the communicator which created them. Synchronization in MPIMPI uses the term blocking in a slightly unconventional way, to refer to the relationship between the caller of a communication operation and the implementation of that operation (i.e. nothing to do with any matching operation).Thus, a blocking send complete only when it is safe to reuse the specified output buffer (because the data has been copied somewhere safe by the system). æ³¨æ„è¿™é‡Œè·Ÿå‰é¢æåˆ°çš„synchronousæ¦‚å¿µä¸ä¸€æ ·ï¼Œsynchronous å¼ºè°ƒæŽ¥æ”¶æˆåŠŸæ‰æ˜¯åˆ¤æ–­å‘é€æˆåŠŸä¸Žå¦çš„æ ‡è¯†ï¼Œè€Œ blocking åªéœ€è¦ä¿è¯ç¼“å­˜å¯ä»¥è¢«å®‰å…¨æ”¹å†™å³å¯ã€‚ In contrast, a process calling a non-blocking send continues immediately with unpredictable effects on the value actually sent. Similarly, there is a non-blocking receive operation which allows the calling process to continue immediately, with similar issues concerning the values which appear in the buffer. æ„ä¹‰åœ¨äºŽï¼Œå½“éœ€è¦å‘é€çš„ä¿¡æ¯å­—èŠ‚éžå¸¸å·¨å¤§æ—¶ï¼Œå‘é€å’ŒæŽ¥æ”¶è€—æ—¶éƒ½éžå¸¸ä¹…ï¼Œè¿™æ—¶å€™å¦‚æžœå¯ä»¥ä¸éœ€è¦ç­‰å¾…è¿™äº›å·¨é‡ä¿¡æ¯çš„ä¼ è¾“è€Œç›´æŽ¥ç»§ç»­ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼Œåˆ™èƒ½æé«˜æ•ˆçŽ‡ã€‚ To manage these effects, there are MPI operations for monitoring the progress of non-blocking communications (effectively, to ask, â€œis it OK to use this variable now?â€). - The idea is that with careful use these can allow the process to get on with other useful work even before the user-space buffer has been safely stored. Blocking Communication Semantics in MPIMPI provides different blocking send operations, vary in the level of synchronization they provide. Each makes different demands on the underlying communication protocol (i.e. the implementation). 1, Synchronous mode send (MPI_Ssend) is blocking and synchronous, only complete when a matching receive has been found. 2, Standard mode send (MPI_Send) is blocking. Its synchronicity depends upon the state of the implementation buffers, in that it will be asynchronous unless the relevant buffers are full, in which case it will wait for buffer space (and so may appear to behave in a â€œsemiâ€ synchronous fashion). 3, Buffered mode send (MPI_Bsend) is blocking and asynchronous, but the programmer must previously have made enough buffer space available (otherwise an error is reported). There are associated operations for allocating the buffer space. Receiving with MPI_Recv blocks until a matching message has been completely received into the buffer (so it is blocking and synchronous). MPI also provides non-blocking sends and receives which return immediately (i.e. possibly before it is safe to use/reuse the buffer). There are immediate versions of all the blocking operations (with an extra â€œIâ€ in the name). For example, MPI_Isend is the standard mode immediate send, and MPI_Irecv is the immediate receive. Non-blocking operations have an extra parameter, called a â€˜requestâ€™ which is a handle on the communication, used with MPI_Wait and MPI_Test to wait or check for completion of the communication (in the sense of the corresponding blocking version of the operation). Probing for MessagesA receiving process may want to check for a potential receive without actually receiving it. For example, we may not know the incoming message size, and want to create a suitable receiving buffer. int MPI_Probe(int src, int tag, MPI_Comm comm, MPI_Status *status) behaves like MPI_Recv , filling in *status, without actually receiving the message. There is also a version which tests whether a message is available immediately int MPI_Iprobe(int src, int tag, MPI_Comm comm, int *flag, MPI_Status *status) leaving a (C-style) boolean result in *flag (i.e. message/no message). We can then determine the size of the incoming message by inspecting its status information. int MPI_Get_count(MPI_Status *status, MPI_Datatype t, int *count) sets *count to the number of items of type t in message with status *status. We could use these functions to receive (for example) a message containing an unknown number of integers from an unknown source, but with tag 75, in a given communicator comm.12345MPI_Probe(MPI_ANY_SOURCE, 75, comm, &amp;status);MPI_Get_count(&amp;status, MPI_INT, &amp;count);buf = (int *) malloc(count*sizeof(int));source = status.MPI_SOURCE;MPI_Recv(buf, count, MPI_INT, source, 75, comm, &amp;status); Collective OperationsMPI offers a range of more complex operations which would otherwise require complex sequences of sends, receives and computations. These are called collective operations, because they must be called by all processes in a communicator. 1, MPI_Bcast broadcasts count items of type t from buf in root to buf in all other processes in comm:12int MPI_Bcast (void *buf, int count, MPI_Datatype t, int root, MPI_Comm comm) 2, MPI_Scatter is used to divide the contents of a buffer across all processes.12int MPI_Scatter (void *sendbuf, int sendcount, MPI_Datatype sendt, void *recvbuf, int recvcount, MPI_Datatype recvt, int root, MPI_Comm comm) $i^{th}$ chunk (size sendcount) of rootâ€˜s sendbuf is sent to recvbuf on process $i$ (including the root process itself). The first three parameters are only significant at the root. Counts, types, root and communicator parameters must match between root and all receivers. 3, MPI_Gather is the inverse of MPI_Scatter. Instead of spreading elements from one process to many processes, MPI_Gather takes elements from many processes and gathers them to one single process. MPI_Gather takes elements from each process and gathers them to the root process. The elements are ordered by the rank of the process from which they were received. Only the root process needs to have a valid receive buffer. The recv_count parameter is the count of elements received per process, not the total summation of counts from all processes.123MPI_Gather( void* send_data, int send_count, MPI_Datatype send_datatype, void* recv_data, int recv_count, MPI_Datatype recv_datatype, int root, MPI_Comm communicator) 4, MPI_Allreduce computes a reduction, such as adding a collectionof values together. No root, all Processes receive the reduced result.12int MPI_Allreduce (void *sendbuf, void *recvbuf, int count, MPI_Datatype sendt, MPI_Op op, MPI_Comm comm) Reduces elements from all send buffers, point-wise, to count single values, using op, storing result(s) in all receive buffers. The op is chosen from a predefined set (MPI_SUM, MPI_MAX etc) or constructed with user code and MPI_Op_create. MPI_Allreduce is the equivalent of doing MPI_Reduce followed by an MPI_Bcast. Jacobi (1-dimensional wrapped), each neighour is owned by distinct process, thus could not read each otherâ€™s data - introduce a layer of message passing, introduce halo as buffer.123456789101112131415161718192021222324252627282930// here for convenience MPI_Sendrecv combines a send and a receive.int main(int argc, char *argv[]) &#123; MPI_Comm_size(MPI_COMM_WORLD, &amp;p); MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); if (rank == 0) read_problem(&amp;n, work); // æ•°æ®å­˜åœ¨ root - 0å·è¿›ç¨‹ MPI_Bcast(&amp;n, 1, MPI_INT, 0, MPI_COMM_WORLD); // å¹¿æ’­æ•°æ® mysize = n/p; // assume p divides n, for simplicity local = (float *) malloc(sizeof(float) * (mysize+2)); //include fringe/halo MPI_Scatter(work, mysize, MPI_FLOAT, &amp;local[1], mysize, MPI_FLOAT, 0, MPI_COMM_WORLD); // scatter åˆ†å‘æ•°æ®åˆ°å„processä¸»ä½ç½® left = (rank+p-1)%p; // who is my left neighour? right = (rank+1)%p; // who is my right neighour? do &#123; //[0]å’Œ[mysize+1]halo MPI_Sendrecv(&amp;local[1], 1, MPI_FLOAT, left, 0, // send this &amp;local[mysize+1], 1, MPI_FLOAT, right, 0, // receive this MPI_COMM_WORLD, &amp;status); // anti-clockwise MPI_Sendrecv(&amp;local[mysize], 1, MPI_FLOAT, right, 0, &amp;local[0], 1, MPI_FLOAT, left, 0, MPI_COMM_WORLD, &amp;status); // clockwise do_one_step(local, &amp;local_error); MPI_Allreduce(&amp;local_error, &amp;global_error, 1, MPI_FLOAT, MPI_MAX, MPI_COMM_WORLD); &#125; while (global_error &gt; acceptable_error); MPI_Gather (&amp;local[1], mysize, MPI_FLOAT, work, mysize, MPI_FLOAT, 0, MPI_COMM_WORLD); if (rank == 0) print_results(n, work);&#125; 12345int MPI_Sendrecv(const void *sendbuf, int sendcount, MPI_Datatype sendtype, int dest, int sendtag, void *recvbuf, int recvcount, MPI_Datatype recvtype, int source, int recvtag, MPI_Comm comm, MPI_Status *status) CommunicatorsCommunicators define contexts within which groups of processes interact. All processes belong to MPI_COMM_WORLD from the MPI initialisation call onwards. Create new communicators from old ones by collectively callingMPI_Comm_split(MPI_Comm old, int colour, int key, MPI_Comm *newcomm) to create new communicators based on colors and keys:color - control of subset assignment (nonnegative integer). Processes with the same color are in the same new communicator.key - control of rank assignment (integer). Within each new communicator, processes are assigned a new rank in the range $0â€¦p^{\prime} âˆ’ 1$, where $p^{\prime}$ is the size of the new communicator. Ranks are ordered by (but not necessarily equal to) the value passed in as the key parameter, with ties broken by considering process rank in the parent communicator. This can be helpful in expressing algorithms which contain nested structure. For example, many divide-and-conquer algorithms split the data and machine in half, process recursively within the halves, then unwind to process the recursive results back at the upper level.1234567891011//Divide &amp; Conquer Communicatorsvoid some_DC_algorithm ( ..., MPI_Comm comm) &#123; MPI_Comm_size(comm, &amp;p); MPI_Comm_rank(comm, &amp;myrank); ... pre-recursion work ... if (p&gt;1) &#123; MPI_Comm_split (comm, myrank&lt;(p/2), 0, &amp;subcomm); // two sub-machines some_DC_algorithm (..., subcomm); // recursive step // in both sub-machines &#125; else do_base_case_solution_locally(); ... post-recursion work ...&#125; Task and Pattern Based ModelsProgramming explicitly with threads (or processes) has some drawbacks:â€¢ Natural expression of many highly parallel algorithms involves creation of far more threads than there are cores. Thread creation and scheduling have higher overheads than simpler activities like function calls (by a factor of 50-100).â€¢ The OS has control over the scheduling of threads to processor cores, but it does not have the application specific knowledge required to make intelligent assignments (for example to optimize cache re-use). Traditional OS concerns for fairness may be irrelevant or even counter-productive. To avoid this, programmers resort to complex scheduling and synchronization of a smaller number of coarser grained threads. How to avoid this? A number of languages and libraries have emerged whichâ€¢ separate the responsibility for identifying potential parallelism, which remains the application programmerâ€™s job, from detailed scheduling of this work to threads and cores, which becomes the language/library run-timeâ€™s job.â€¢ provide abstractions of common patterns of parallelism, which can be specialized with application specific operations, leaving implementation of the pattern and its inherent synchronization to the system. These are sometimes called task based approaches, in contrast to traditional threaded models. Examples include OpenMP, which is a compiler/language based model, and Intelâ€™s Threading Building Blocks library. Threading Building BlocksThreading Building Blocks (TBB) is a shared variable model, C++ template-based library. It uses generic programming techniques to provide a collection of parallel algorithms, each of which is an abstraction of a parallel pattern. It also provides a direct mechanism for specifying task graphs and a collection of concurrent data structures and synchronization primitives. æ³›åž‹ç¨‹åºè®¾è®¡ï¼ˆgeneric programmingï¼‰æ˜¯ç¨‹åºè®¾è®¡è¯­è¨€çš„ä¸€ç§é£Žæ ¼æˆ–èŒƒå¼ï¼Œå…è®¸ç¨‹åºå‘˜åœ¨å¼ºç±»åž‹ç¨‹åºè®¾è®¡è¯­è¨€ä¸­ç¼–å†™ä»£ç æ—¶ä½¿ç”¨ä¸€äº›ä»¥åŽæ‰æŒ‡å®šçš„ç±»åž‹ï¼Œåœ¨å®žä¾‹åŒ–æ—¶ä½œä¸ºå‚æ•°æŒ‡æ˜Žè¿™äº›ç±»åž‹ã€‚ It handles scheduling of tasks, whether explicit programmed or inferred from pattern calls, to a fixed number of threads internally. In effect, this is a hidden Bag-of-Tasks, leaving the OS with almost nothing to do. Game of Life (cs106b ä½œä¸š1) Original Code for a Step123456789101112enum State &#123;DEAD,ALIVE&#125; ; // cell statustypedef State **Grid;void NextGen(Grid oldMap, Grid newMap) &#123; int row, col, ncount; State current; for (row = 1; row &lt;= MAXROW; row++) &#123; for (col = 1; col &lt;= MAXCOL; col++) &#123; current = oldMap[row][col]; ncount = NeighborCount(oldMap, row, col); newMap[row][col] = CellStatus(current, ncount);&#125; &#125; &#125; TBB parallel_forå‡è®¾æˆ‘ä»¬æƒ³å°†ä¸Šé¢çš„å‡½æ•°NextGenåº”ç”¨åˆ°æ•°ç»„(ç½‘æ ¼)çš„æ¯ä¸ªå…ƒç´ ï¼Œè¿™ä¸ªä¾‹å­æ˜¯å¯ä»¥æ”¾å¿ƒä½¿ç”¨å¹¶è¡Œå¤„ç†æ¨¡å¼çš„ã€‚å‡½æ•°æ¨¡æ¿tbb::parallel_for å°†æ­¤è¿­ä»£ç©ºé—´(Range)åˆ†è§£ä¸ºä¸€ä¸ªä¸ªå—ï¼Œå¹¶æŠŠæ¯ä¸ªå—è¿è¡Œåœ¨ä¸åŒçš„çº¿ç¨‹ä¸Šã€‚è¦å¹¶è¡ŒåŒ–è¿™ä¸ªå¾ªçŽ¯ï¼Œç¬¬ä¸€æ­¥æ˜¯å°†å¾ªçŽ¯ä½“è½¬æ¢ä¸ºå¯ä»¥åœ¨ä¸€ä¸ªå—ä¸Šè¿è¡Œçš„å½¢å¼ - ä¸€ä¸ªSTLé£Žæ ¼çš„å‡½æ•°å¯¹è±¡ï¼Œç§°ä¸ºbodyå¯¹è±¡ï¼Œå…¶ä¸­ç”±operator()ä¸­å¤„ç†ã€‚Game of Life Step Using parallel_for12345void NextGen(Grid oldMap, Grid newMap) &#123; parallel_for (blocked_range&lt;int&gt;(1, maxrow+1), // Range CompNextGen(oldMap, newMap), // Body affinity_partitioner()); // Partitioner&#125; Range defines a task(iteration) space, and its sub-division (partition) technique;Body defines the code which processes a range;Partitioner (optional parameter) influencing partitioning and scheduling strategy. The parallel_for Template:12template &lt;typename Range, typename Body&gt;void parallel_for(const Range&amp; range, const Body &amp;body); Requires definition of: A range space to iterate over Must define a copy constructor and a destructor a destructor to destroy these copies Defines is_empty() Defines is_divisible() Defines a splitting constructor, R(R &amp;r, split) A body type that operates on the range (or a subrange) Must define a copy constructor, which is invoked to create a separate copy (or copies) for each worker thread. Defines operator() In the C++ programming language, a copy constructor is a special constructor for creating a new object as a copy of an existing object.123456789101112131415161718//é€šç”¨å½¢å¼classname (const classname &amp;obj) &#123; // body of constructor&#125;//å®žä¾‹#include &lt;iostream&gt;using namespace std;class Line &#123; public: int getLength( void ); Line( int len ); // simple constructor Line( const Line &amp;obj); // copy constructor ~Line(); // destructor private: int *ptr;&#125;; Range ClassA blocked_range&lt;T&gt; is a template class provided by the library. It describes a one-dimensional iteration space over type T. and be queried for the beginning (r.begin()) and end (r.end()) of the range. The TBB runtime can break a blocked_range into two smaller ranges, each (roughly) half the size. Note that a blocked_range carries no problem data. The values in the range can be used as we choose, for example to index into arrays.Range is Generic:12345R::R (const R&amp;) // Copy constructorR::~R() // Destructorbool R::is_empty() const // True if range is emptybool R::is_divisible() const // True if range can be partitionedR::R (R&amp; r, split) // Splitting constructor; splits r into two subranges Besides the provided blocked_range and blocked_range2d, users can define their own ranges. TBB DIY Range Example: Compute Fibonacci numbers.12345678910class FibRange &#123; public: int n_ ; // represents the range corresponding to fib(n) FibRange(int n) : n_(n) &#123; &#125; FibRange(FibRange&amp; other, split) // split constructor : n_(other.n_ - 2) // initialize the new object &#123; other.n_ = other.n_ - 1;&#125; // reuse the other range object bool is_divisible() const &#123; return (n_ &gt; 10); &#125; // sequential threshold bool is_empty() const &#123; return n_ &lt; 0; &#125;;&#125;; Body Class123456789101112131415class CompNextGen &#123; Grid oldMap, newMap; public: CompNextGen (Grid omap, Grid nmap) : oldMap(omap), newMap(nmap) &#123;&#125; // åˆ†å‰²è¿­ä»£ç©ºé—´çš„æ–¹å¼å¤šç§å¤šæ · void operator()( const blocked_range&lt;int&gt;&amp; r ) const &#123; for (int row = r.begin(); row &lt; r.end(); row++)&#123; // è¿™é‡ŒæŒ‰è¡Œåˆ†å‰² for (int col = 1; col &lt;= maxcol; col++) &#123; nState current = oldMap[row][col]; int ncount = NeighborCount(oldMap, row, col); newMap[row][col] = CellStatus(current, ncount); &#125; &#125; &#125;&#125; Body is Generic123Body::Body(const Body&amp;) \\ Copy constructorBody::~Body() \\ Destructorvoid Body::operator() (Range&amp; subrange) const \\ Apply the body to subrange. Because the body object might be copied, its operator() should not modify the body hence should be declared const. Otherwise the modification might or might not become visible to the thread that invoked parallel_for, depending upon whether operator() is acting on the original or a copy.Credit from www.threadingbuildingblocks.org parallel_for partitions original range into subranges, and deals out subranges to worker threads in a way that: Balances load, Uses cache efficiently, and Scales. Game of Life 1D with C++11 Lambda Function, an alternative interface to parallel_for allows us to use a C++ lambda expression to avoid writing a body class.123456789void NextGen(Grid oldMap, Grid newMap) &#123; parallel_for (blocked_range&lt;int&gt;(1, maxrow+1), [&amp;](const blocked_range&lt;int&gt;&amp; r)&#123; for (int row = r.begin(); row &lt; r.end(); row++)&#123; for (int col = 1; col &lt;= MAXCOL; col++) &#123; State current = oldMap[row][col]; int ncount = NeighborCount(oldMap, row, col); newMap[row][col] = CellStatus(current, ncount); &#125; &#125; &#125; );&#125; [&amp;]å¼•å…¥ lambda è¡¨è¾¾å¼. è¯¥è¡¨è¾¾å¼åˆ›å»ºä¸€ä¸ªç±»ä¼¼äºŽCompNextGençš„å‡½æ•°å¯¹è±¡. å½“å±€éƒ¨å˜é‡åœ¨ lambda expression ä¹‹å¤–å£°æ˜Žï¼Œä½†åˆåœ¨lambdaè¡¨è¾¾å¼å†…ä½¿ç”¨æ—¶, å®ƒä»¬è¢«â€æ•èŽ·â€ä¸ºå‡½æ•°å¯¹è±¡å†…çš„å­—æ®µ. [&amp;]æŒ‡å®šå¼•ç”¨ï¼Œ[=]æŒ‡å®šæŒ‰å€¼æ•èŽ·. TBB PartitionersTBB supports different partitioning strategy:1, tbb::parallel_for( range, body, tbb::simple_partitioner() ); forces all ranges to be fully partitioned (i.e. until is_divisible() fails).2, tbb::parallel_for( range, body, tbb::auto_partitioner() ); allows the TBB runtime to decide whether to partition the range (to improve granularity).3, tbb::parallel_for( range, body, tbb::affinity_partitioner ); is like auto_partitioner() but also, when the parallel_for is inside a loop, tries to allocate the same range to the same processor core across iterations to improve cache behaviour. Game of Life Using a 2D decomposition123456789101112131415161718void NextGen(Grid oldMap, Grid newMap) &#123; parallel_for (blocked_range2d&lt;int, int&gt; (1, maxrow+1, 1, maxcol+1), // Range CompNextGen(oldMap, newMap)); // Body auto_partitioner()); // Partitioner&#125;class CompNextGen &#123; Grid oldMap, Grid newMap; public: CompNextGen (Grid omap, Grid nmap) : oldMap(omap), newMap(nmap) &#123;&#125; // äºŒç»´åˆ†å‰² void operator()( const blocked_range2d&lt;int, int&gt;&amp; r ) const &#123; for (int row = r.rows().begin(); row &lt; r.rows().end(); row++)&#123; for (int col = r.cols().begin(); col &lt; r.cols().end(); col++) &#123; State current = oldMap[row][col]; int ncount = NeighborCount(oldMap, row, col); newMap[row][col] = CellStatus(current, ncount); &#125; &#125; &#125;;&#125; blocked_range2d is partitioned in alternating dimensions, level by level. TBB parallel_reduce TemplateTBB parallel_reduce has similar structure to parallel_for but additionally allows bodies to gather results internally as they go along. We could parallelize a loop reduction (iterations are independent), as in a Numerical Integration example, with a parallel_for, but we would need a critical section of some kind to accumulate the partial results. parallel_reduce structures and hides this, with one further generic operation, called join.12template &lt;typename Range, typename Body&gt;void parallel_reduce (const Range&amp; range, Body &amp;body); 1234Body::Body( const Body&amp;, split ) //Splitting constructorBody::~Body() // Destructorvoid Body::operator() (Range&amp; subrange) const // Accumulate results from subrangevoid Body::join( Body&amp; rhs ); // Merge result of rhs into the result of this. When a worker thread is available, as decided by the task scheduler, parallel_reduce invokes the splitting constructor to create a subtask for the worker. When the subtask completes, parallel_reduce uses method join to accumulate the result of the subtask. It reuses Range concept from parallel_for.The Fib Body Class (with operator()), using the DIY range example - FibRange from above123456789101112131415161718class Fib &#123; public: int fsum_ ; Fib() : fsum_(0) &#123; &#125; Fib(Fib&amp; other, split) : fsum_(0) &#123; &#125; // use += since each body may accumulate more than one range void operator() (FibRange&amp; range) &#123; fsum_ += fib(range.n_ ); &#125; int fib(int n) &#123;if (n &lt; 2) return 1; else return fib(n-1)+fib(n-2);&#125; void join(Fib&amp; rhs) &#123; fsum_ += rhs.fsum_; &#125;;&#125;;int main( int argc, char* argv[] ) &#123; task_scheduler_init init(2); Fib f; parallel_reduce(FibRange(FIBSEED), f, simple_partitioner()); cout &lt;&lt; "Fib " &lt;&lt; FIBSEED &lt;&lt; " is " &lt;&lt; f.fsum_ &lt;&lt; "\n"; return 0;&#125; Using a simple_partitioner forces full splitting of the ranges. We could use auto_partitioner to let the TBB run-time system control this. The Task Schedulerå¦‚æžœä¸€ä¸ªç®—æ³•ä¸èƒ½è‡ªç„¶åœ°æ˜ å°„åˆ°å‰é¢æåˆ°çš„ä»»ä½•å…¶ä¸­ä¸€ç§ high-level loop templatesï¼Œå¯ä»¥ä½¿ç”¨ task scheduler ç›´æŽ¥æ“ä½œä»»åŠ¡, å¯ä»¥æž„å»ºæ–°çš„é«˜çº§æ¨¡æ¿ã€‚ All of TBBâ€™s parallel pattern constructs are implemented via the same underlying task scheduler, which executes a task graph representing the pattern. TBB also allows the programmer to (carefully!) create task graphs directly. This allows expression of unstructured task graphs, or the implementation and abstraction of further patterns. There are functions to create new tasks as children of existing tasks and to specify the control dependencies between them. How to code Fibonacci using tasks directly? The key method is task::execute, which we override with our application specific behaviour. Recursion is typically used to calculate Fibonacci number but leads to unbalanced task graph. Fibonacci - Task Spawning Solution - Use TBB tasks to thread creation and execution of task graph: Allocate space for the task by a special â€œoverloaded newâ€ and method task::allocate_root - Create root of a task tree. Tasks must be allocated by special methods so that the space can be efficiently recycled when the task completes. Construct task with the constructor FibTask(n, &amp;sum) invoked by new. When the task is run in step 3, it computes the nth Fibonacci number and stores it into *sum. Run the task and wait for completion with task::spawn_root_and_wait. 123456789101112131415161718192021222324252627282930#include "tbb/task.h"...long ParallelFib( long n ) &#123; long sum; FibTask&amp; a = *new(task::allocate_root()) FibTask(n, &amp;sum); task::spawn_root_and_wait(a); return sum;&#125;class FibTask: public task &#123; public: const long n; long* const sum; FibTask( long n_, long* sum_ ) : n(n_), sum(sum_) &#123;&#125; task* execute() &#123; // Overrides virtual function task::execute if( n &lt; CutOff ) &#123; *sum = SerialFib(n); &#125; else &#123; long x, y; FibTask&amp; a = *new( allocate_child() ) FibTask(n-1,&amp;x); FibTask&amp; b = *new( allocate_child() ) FibTask(n-2,&amp;y); set_ref_count(3); // Set to 3 = 2 children + 1 for wait spawn( b ); // Start b running. // Start a running and wait for all children (a and b). spawn_and_wait_for_all(a); *sum = x+y; // Do the sum &#125; return NULL; &#125;&#125;; The TBB scheduler runs tasks in a way that tends to minimize both memory demands and cross-thread communication. The intuition is that a balance must be reached between depth-first and breadth-first execution. At any point in execution, the collection of known tasks is maintained as a shared graph. Each thread maintains its own double-ended queue of tasks (roughly, as pointers into the shared graph). Newly spawned tasks are added to the front of the local queue. å½“ä¸€æ¡çº¿ç¨‹å‚ä¸Ž task graph æ—¶ï¼Œå®ƒä¼šä¸æ–­æŒ‰ç…§ä¼˜å…ˆåŽŸåˆ™æ‰§è¡Œä¸‹é¢çš„è§„åˆ™æ¥èŽ·å–ä»»åŠ¡: looks at the front of its local queue, which encourages locality within one threadâ€™s work; å¦‚æžœ deque ä¸ºç©ºï¼Œåˆ™æ­¤è§„åˆ™ä¸é€‚ç”¨ï¼› å‡å¦‚å¤±è´¥, steal a task from the back of one other (randomly chosen) threadâ€™s queue, which encourages stealing of big tasks, and discourages locality across threads. LindaLinda presents an alternative conceptual model for parallelism, based around a small library of operations. The Linda model saw something of a revival in distributed java systems programming, under the name JavaSpaces. The key concept is that processes interact through tuple space, a global, content addressable memory, which is thread safe, with no race conditions, therefore does not require explicit locks. Each tuple is an ordered collection of typed data fields. Duplicate tuples are allowed. The tuple space itself acts like a monitor. If a process tries to access a tuplen, it is blocked until a matching tuple becomes available. Semaphore - Linda have tuple (or a set of tuples for a counting semaphore) that represent the locks. If someone needs to enter the lock, it waits until a tuple is available in the bag, pull it out of the bag and inserts it back into the tuple space. Processes run asynchronously and can operate on tuple space with six operations. 1, Add new tuple to tuple space: out(exp1, exp2, ...., expN); - evaluates the expressions in the parameter list before atomically placing a copy of the results as a new tuple in tuple space. It could be considered as an asynchronous send with a wild-card destination in message-passing. out(&quot;sum&quot;, 2, 3), out(&quot;Green&quot;, x*y, square(2)); 2, To take a tuple from tuple space: in(tuple-template); - atomically removes from tuple space a tuple which matches the template. template contains actual values and formal parameters (indicated by ?) to be assigned during the match. åŒ¹é…åŒ…å«ä¸Žå®žé™…å€¼çš„åŒ¹é…ï¼Œä»¥åŠä¸Žå½¢å¼å‚æ•°ç±»åž‹ types ç›¸åŒ¹é…. in is blocking, in the sense that the caller is suspended until a matching tuple becomes available. For example: in(&quot;sum&quot;,?i,?j) matches &quot;sum&quot;, assigns 2 to i and 3 to j and the tuple is removed from the tuple space. in(&quot;Green&quot;, ?y, ?r, FALSE);. We could think of in as a blocking, asynchronous receive, with wild-card source, but with additional constraints implied by the pattern matching. 3, Atomically read a tuple from tuple space with rd(tuple-template); 4, Tuples may also be created with eval(expr, expr, ...) which is like out, but dynamically creates new processes to evaluate each field of the tuple which has been expressed as a function call. The calling process continues immediately, and the resulting tuple enters tuple space atomically when all the newly sparked processes have terminated 5, Finally, there are non-blocking forms inp, rdp (p for â€œpredicateâ€) which complete â€œimmediatelyâ€, returning a boolean indicating whether or not a match occurred. This allow a process to carry on with a different task and then try again later. Bag of Tasks Implementation:åŒæ ·ä»¥å‰é¢çš„ Adaptive Quadrature ä¸ºä¾‹. Use a (&quot;counts&quot;, x, y) tuple, in effect as a shared variable, to count the number of tasks and number of idle workers. The final field in a task tuple indicates whether this is a real task or a â€œno more tasksâ€ signal.123456789101112131415161718192021222324252627int main () &#123; out("total", 0.0); out("counts", 1, P); // set initial #task and #idle out("task", a, b, f(a), f(b), approxarea, FALSE); // make initial task for (i = 0; i&lt;P; i++) eval(worker()); // create P workers in ("counts", 0, P); // no tasks left, and P workers idle in ("total", ?total); // get the result out ("task", 0.0, 0.0, 0.0, 0.0, 0.0, TRUE); // indicate no more tasks ... //use total&#125;int worker() &#123; while (true) &#123; in("task", ?left, ?right, ?fleft, ?fright, ?lrarea, ?gameOver); if (gameOver) &#123; // if gameOver == TRUE out ("task", 0.0, 0.0, 0.0, 0.0, 0.0, TRUE); // for others to see break; &#125; in("counts", ?size, ?idle); out("counts", size-1, idle-1); ... usual task calculations ... if (abs (larea + rarea - lrarea) &gt; EPSILON) &#123; // create new tasks out("task", left, mid, fleft, fmid, larea, FALSE); out("task", mid, right, fmid, fright, rarea, FALSE); in("counts", ?size, ?idle); out("counts", size+2, idle+1); &#125; else &#123; in ("total", ?total); out ("total", total+larea+rarea); in("counts", ?size, ?idle); out("counts", size, idle+1); &#125; &#125; &#125; Pipeline Implementation:Use eval() to create the sieve processes dynamically as we need them. The sieve processes eventually turn into part of an â€œarrayâ€ of primes in tuple space. We ensure pipelined message flow by tagging tuples with their destination and position in the sequence.12345678910111213141516171819202122232425void main (int argc, char *argv[]) &#123; int i; eval("prime", 1, sieve(1)); // the 1st prime number, the 1st worker for (i=2; i&lt;LIMIT; i++) &#123; out("number", 1, i-1, i); // send number to sieve &#125;&#125;int sieve (int me) &#123; int n, p, in_seq=1, out_seq=1, stop=FALSE; in("number", me, in_seq, ?p); // in_seq = 1, first arrival is prime while (!stop) &#123; in_seq++; in("number", me, in_seq, ?n); // get the next candidate if (n==LIMIT) &#123; stop = TRUE; out("number", me+1, out_seq, n); // pass on the signal &#125; else if (n%p !=0) &#123; // if never created a successor before if (out_seq == 1) eval("prime", me+1, sieve(me+1)); // new sieve out("number", me+1, out_seq, n); // and its first input out_seq++; &#125; &#125; return p;&#125; Tuple SpaceLindaâ€™s powerful matching model sets a demanding implementation challenge, way beyond the associative memory hardware used in on-chip caches. Indexing and hashing techniques adapted from relational database technology can help (e.g. Linda rd and SQL select). Advanced Linda implementations perform considerable compile-time analysis of program specific tuple usage. For example, possible tuples (in a given program) can be categorised into a set of classes by type signature, and stored separately.]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Natural Language Understanding]]></title>
    <url>%2FUoE-nlu%2F</url>
    <content type="text"><![CDATA[çˆ±ä¸å ¡å¤§å­¦ä¿¡æ¯å­¦é™¢è¯¾ç¨‹ç¬”è®° Natural Language Understanding, Informatics, University of Edinburgh References:Natural language understandingCS224n: Natural Language Processing with Deep LearningLecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning Meaning representationsæ„æ€çš„è¡¨è¾¾æœ‰å¾ˆå¤šæ–¹æ³•ã€‚ä¸€ç§æœ‰æ•ˆçš„è¡¨ç¤ºå•è¯çš„å«ä¹‰çš„æ–¹æ³•æ˜¯ distributional semantic. Semantics (from Ancient Greek: ÏƒÎ·Î¼Î±Î½Ï„Î¹ÎºÏŒÏ‚ sÄ“mantikos, â€œsignificantâ€) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics. è¯­ä¹‰å­¦ Semantics åœ¨è¯­è¨€å­¦ä¸­çš„ç ”ç©¶ç›®çš„åœ¨äºŽæ‰¾å‡ºè¯­ä¹‰è¡¨è¾¾çš„è§„å¾‹æ€§ã€å†…åœ¨è§£é‡Šã€ä¸åŒè¯­è¨€åœ¨è¯­ä¹‰è¡¨è¾¾æ–¹é¢çš„ä¸ªæ€§ä»¥åŠå…±æ€§ï¼›ä¸Žè®¡ç®—æœºç§‘å­¦ç›¸å…³çš„è¯­ä¹‰å­¦ç ”ç©¶åœ¨äºŽæœºå™¨å¯¹è‡ªç„¶è¯­è¨€çš„ç†è§£ã€‚ Tradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms. To convert natural language into values that computer understands, represent words as discrete symbols: Words can be represented by one-hot vectors, Vector dimension is the vocabulary. But there is no natural notion of similarity for one-hot vectors! So learn to encode similarity in the vectors themselves. The core idea is representing words by their context, building a dense vector for each word, chosen so that it is similar to vectors of words that appear in similar contexts. Distributional models of meaning = vector-Â­space models of meaning = vector semantics.word vectors = word embeddings = word representations. Four kinds of vector modelsSparse vector representations:1, Mutual-Â­information weighted word co-Â­occurrence matrices Dense vector representations:2, Singular value decomposition (SVD): A special case of this is called LSA - Latent Semantic Analysis3, NeuralÂ­â€networkÂ­â€inspired models (skipÂ­â€grams, CBOW)4, Brown clusters Prediction-Â­based models learn embeddings as part of the process of word prediction. Train a neural network to predict neighboring words. The advantages:Â· Fast, easy to train (much faster than SVD)Â· Available online in the word2vec packageÂ· Including sets of pretrained embeddings Word representation and Word2vecWord2vec is a framework for learning word vectors representation.Idea:1, We have a large corpus of text2, Every word in a fixed vocabulary is represented by a vector3, Go through each position t in the text, which has a center word c and context (â€œoutsideâ€) words o4, Use the similarity of the word vectors for c and o to calculate the probability of o given c (or vice versa)5, Keep adjusting the word vectors to maximize this probability åœ¨ä¸Šé¢ç¬¬å››ç‚¹, å¦‚æžœæ˜¯ç»™å®šä¸­å¿ƒè¯ï¼Œè®¡ç®—ä¸Šä¸‹æ–‡è¯, é‚£ä¹ˆå°±æ˜¯ Skip-grams model, æ¯”å¦‚ Given word $w_t$, in a context window of 2C words, predict 4 context words [wt-2, wt-1, wt+1, wt+2]Skip-grams ç»™äºˆæ¨¡åž‹è·³è¯èƒ½åŠ›ï¼Œæ¯”å¦‚ â€œI hit the tennis ballâ€ æœ‰ä¸‰ä¸ªtrigrams: â€œI hit theâ€, â€œhit the tennisâ€, â€œthe tennis ballâ€. ä½†æ˜¯ï¼Œè¿™ä¸ªå¥å­ä¹ŸåŒæ ·åŒ…å«ä¸€ä¸ªåŒæ ·é‡è¦ä½†æ˜¯N-Gramæ— æ³•æå–çš„trigram:â€hit the ballâ€. è€Œä½¿ç”¨ skip-grams å…è®¸æˆ‘ä»¬è·³è¿‡ â€œtennisâ€ ç”Ÿæˆè¿™ä¸ªtrigram. åä¹‹ï¼Œç»™å®š bag-of-words context, predict target word, é‚£å°±æ˜¯ Continuous Bag of Words, CBOW model. ç¼ºç‚¹ï¼šå› ä¸ºoutput size ç­‰äºŽ vocabularyï¼Œè€Œ softmax åˆ†æ¯ä¸­éœ€è¦æ±‚å’Œæ¯ä¸€ä¸ªè¯çš„ output size Ã— hidden units çš„å†…ç§¯ï¼Œ è®¡ç®—ä¼šéžå¸¸æ˜‚è´µã€‚è§£å†³åŠžæ³•æ˜¯ä½¿ç”¨è´Ÿé‡‡æ · negative samplingã€‚ Word2vecçš„æœ¬è´¨æ˜¯éåŽ†è¯­æ–™åº“çš„æ¯ä¸€ä¸ªè¯$w_i$ï¼Œæ•æ‰$w_i$ä¸Žå…¶ä¸Šä¸‹æ–‡ä½ç½®ç›®æ ‡è¯çš„åŒæ—¶å‡ºçŽ°çš„æ¦‚çŽ‡ã€‚ ç›®æ ‡å‡½æ•°Obejective funtion (cost or loss function) J(Î¸):For each position $t = 1, â€¦ , T$, predict context words within a window of fixed size m, given center word, use chain rule to multiply all the probability to get the likelihood $L(Î¸)$:The Î¸ is the vectors representations, which is the only parameters we needs to optimize(å…¶å®žè¿˜æœ‰å…¶ä»–hyperparametersï¼Œè¿™é‡Œæš‚æ—¶å¿½ç•¥). The loss function is the (average) negative log likelihood: Minimizing objective function âŸº Maximizing predictive accuracy. The problem is how to calculate $P(w_{t+j} \mid w_t; Î¸)$: æ¯ä¸ªè¯ç”±ä¸¤ä¸ªå‘é‡è¡¨ç¤ºï¼ˆEasier optimization. Average both at the endï¼‰ï¼š$v_w$ when w is a center word, $u_w$ when w is a context word. Then for a center word c and a â€œoutsideâ€ word o:The numerator contains dot product, compares similarity of o and c, larger dot product = larger probability. The denominator works as a normalization over entire vocabulary. é«˜é¢‘è¯äºŒæ¬¡é‡‡æ ·subsamplingäºŒæ¬¡é‡‡æ ·æ˜¯æŒ‡å½“å†³å®šæ˜¯å¦é€‰å–ä¸€ä¸ªè¯ä½œä¸ºæ ·æœ¬æ—¶ï¼Œå®ƒè¢«é€‰æ‹©çš„æ¦‚çŽ‡åæ¯”äºŽå®ƒå‡ºçŽ°çš„æ¦‚çŽ‡ï¼Œè¿™æ ·ä¸ä»…å¯ä»¥é™ä½Žæ— æ„ä¹‰ä½†é«˜é¢‘çš„è¯(â€œtheâ€, â€œaâ€ç­‰)çš„é‡è¦æ€§ï¼Œä¹Ÿå¯ä»¥åŠ å¿«é‡‡æ ·é€Ÿåº¦ã€‚$$P(w_i) = (\sqrt{\frac{z(w_i)}{0.001}} + 1) \cdot \frac{0.001}{z(w_i)}$$ $z(w_i)$ æ˜¯è¯$w_i$åœ¨è¯­æ–™åº“ä¸­çš„å æ¯”ï¼Œå¦‚æžœâ€peanutâ€åœ¨10äº¿è¯­æ–™åº“ä¸­å‡ºçŽ°äº†1,000æ¬¡, é‚£ä¹ˆz(â€œpeanutâ€) = 1e-6. Negative samplingè´Ÿé‡‡æ ·æ˜¯æŒ‡æ¯ä¸ªè®­ç»ƒæ ·æœ¬ä»…æ›´æ–°æ¨¡åž‹æƒé‡çš„ä¸€å°éƒ¨åˆ†ï¼šonly the output that represents the positive class(1) + other few randomly selected classes(0) are evaluated.è¯¥è®ºæ–‡æŒ‡å‡º è´Ÿé‡‡æ ·5-20ä¸ªå•è¯é€‚ç”¨äºŽè¾ƒå°çš„æ•°æ®é›†ï¼Œå¯¹äºŽå¤§åž‹æ•°æ®é›†åªéœ€è¦2-5ä¸ªå•è¯ã€‚ ä¿®æ”¹ç›®æ ‡å‡½æ•°ï¼Œé€‰æ‹©kä¸ªè´Ÿæ ·æœ¬ï¼ˆå³é™¤äº†æ¦‚çŽ‡æœ€é«˜çš„é‚£ä¸ªç›®æ ‡è¯ä¹‹å¤–çš„å…¶ä»–è¯ï¼‰ï¼š è¿™æ ·å¯ä»¥æœ€å¤§åŒ–çœŸæ­£çš„å¤–éƒ¨è¯å‡ºçŽ°çš„æ¦‚çŽ‡ï¼Œæœ€å°åŒ–éšæœºè´Ÿé‡‡æ ·çš„è¯æ¦‚çŽ‡ã€‚ è´Ÿé¢æ ·æœ¬çš„é€‰æ‹©æ˜¯åŸºäºŽ unigram åˆ†å¸ƒ $f(w_i)$: ä¸€ä¸ªè¯ä½œä¸ºè´Ÿé¢æ ·æœ¬è¢«é€‰æ‹©çš„æ¦‚çŽ‡ä¸Žå…¶å‡ºçŽ°çš„é¢‘çŽ‡æœ‰å…³ï¼Œæ›´é¢‘ç¹çš„è¯æ›´å¯èƒ½è¢«é€‰ä½œè´Ÿé¢æ ·æœ¬ã€‚$$P(w_i) = \frac{ {f(w_i)}^{3/4} }{\sum_{j=0}^{n}\left( {f(w_j)}^{3/4} \right) }$$è´Ÿé‡‡æ ·çš„ä¼˜ç‚¹æ˜¯ï¼šÂ· Training speed is independent of the vocabulary sizeÂ· Allowing parallelism.Â· æ¨¡åž‹çš„è¡¨çŽ°æ›´å¥½ã€‚å› ä¸ºè´Ÿé‡‡æ ·å¥‘åˆNLPçš„ç¨€ç–æ€§è´¨ï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œè™½ç„¶è¯­æ–™åº“å¾ˆå¤§ï¼Œä½†æ˜¯æ¯ä¸€ä¸ªè¯åªè·Ÿå¾ˆå°éƒ¨åˆ†è¯ç”±å…³è”ï¼Œå¤§éƒ¨åˆ†è¯ä¹‹é—´æ˜¯æ¯«æ— å…³è”çš„ï¼Œä»Žæ— å…³è”çš„ä¸¤ä¸ªè¯ä¹‹é—´ä¹Ÿåˆ«æŒ‡æœ›èƒ½å­¦åˆ°ä»€ä¹ˆæœ‰ç”¨çš„ä¿¡æ¯ï¼Œä¸å¦‚ç›´æŽ¥å¿½ç•¥ã€‚ ä¸Žä¼ ç»Ÿçš„NLPæ–¹æ³•æ¯”è¾ƒåœ¨word2vecå‡ºçŽ°ä¹‹å‰ï¼ŒNLPä½¿ç”¨ç»å…¸ä¸”ç›´è§‚çš„å…±ç”ŸçŸ©é˜µï¼ˆco-occurrence matrixï¼‰æ¥ç»Ÿè®¡è¯è¯­ä¸¤ä¸¤åŒæ—¶å‡ºçŽ°çš„é¢‘çŽ‡ï¼Œå‚è€ƒANLP - Distributional semantic modelsã€‚ç¼ºç‚¹ä¹Ÿæ˜Žæ˜¾ï¼Œè¯æ±‡é‡çš„å¢žåŠ å¯¼è‡´çŸ©é˜µå¢žå¤§ï¼Œéœ€è¦å¤§é‡å†…å­˜ï¼Œéšä¹‹è€Œæ¥çš„åˆ†ç±»æ¨¡åž‹å‡ºçŽ°ç¨€ç–æ€§é—®é¢˜ï¼Œæ¨¡åž‹ä¸ç¨³å®šã€‚è™½ç„¶å¯ä»¥ä½¿ç”¨SVDæ¥é™ç»´ï¼Œä½†æ˜¯ä¸€ä¸ªnÃ—mçŸ©é˜µçš„è®¡ç®—æˆæœ¬æ˜¯O(mn2)æµ®ç‚¹æ•°ï¼ˆå½“n&lt;mï¼‰ï¼Œè¿˜æ˜¯éžå¸¸å¤§çš„ã€‚è€Œä¸”å¾ˆéš¾å¹¶å…¥æ–°è¯æˆ–æ–°æ–‡æ¡£ã€‚ ç›®å‰èžåˆäº†ä¸¤ç§æ–¹æ³•çš„ä¼˜ç‚¹çš„Gloveæ˜¯æœ€å¸¸ç”¨çš„ã€‚ TODO(Glove)Morphological Recursive Neural Network (morphoRNN)Limitation of word2vec:â€¢ Closed vocabulary assumptionâ€¢ Cannot exploit functional relationships in learning: å¦‚è‹±è¯­çš„dogã€dogså’Œdog-catcheræœ‰ç›¸å½“çš„å…³ç³»ï¼Œè‹±è¯­ä½¿ç”¨è€…èƒ½å¤Ÿåˆ©ç”¨ä»–ä»¬çš„èƒŒæ™¯çŸ¥è¯†æ¥åˆ¤æ–­æ­¤å…³ç³»ï¼Œå¯¹ä»–ä»¬æ¥è¯´ï¼Œdogå’Œdogsçš„å…³ç³»å°±å¦‚åŒcatå’Œcatsï¼Œdogå’Œdog-catcherå°±å¦‚åŒdishå’Œdishwasher To walk closer to open vocabulary, use compositional representations based on morphemes. Instead of word embedding, embed morphemes - the smallest meaningful unit of language. Compute representation recursively from morphemes, word embedding ç”± morphemes embedding æ‹¼æŽ¥è€Œæ¥. ä¸ŽåŸºç¡€ç‰ˆçš„morphoRNNç»“æž„ç›¸åŒï¼ŒContext-insensitive Morphological RNN model (cimRNN) è€ƒå¯Ÿ morphoRNN åœ¨ä¸å‚è€ƒä»»ä½•ä¸Šä¸‹æ–‡ä¿¡æ¯æƒ…å†µä¸‹ï¼Œ ä»…ä»…ç”¨ morphemic representation æž„é€ è¯å‘é‡çš„èƒ½åŠ›ã€‚è®­ç»ƒæ—¶ï¼Œç»™æ¯ä¸ªè¯xiå®šä¹‰æŸå¤±å‡½æ•°s(xi)ä¸ºæ–°æž„é€ çš„è¯å‘é‡pc(xi)å’Œå‚è€ƒè¯å‘é‡pr(xi)ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»å¹³æ–¹ è¯¥cimRNNæ¨¡åž‹æ²¡æœ‰æœºä¼šæ”¹è¿›å¯èƒ½è¢«ä¼°è®¡ä¸è¶³çš„ç½•è§è¯çš„è¡¨è¾¾. Context-sensitive Morphological RNN (csmRNN) åœ¨å­¦ä¹ è¯­ç´ ç»„æˆæ—¶åŒæ—¶å‚è€ƒè¯­å¢ƒä¿¡æ¯ï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œç¥žç»ç½‘ç»œé¡¶å±‚çš„æ›´æ–°å°†ä¸€ç›´åå‘ä¼ æ’­ç›´è‡³åº•å±‚çš„è¯­ç´ å±‚ã€‚ Compositional character representationsåœ¨è‡ªç„¶è¯­è¨€å¤„ç†ä¸­ä½¿ç”¨ word ä½œä¸ºåŸºæœ¬å•ä½çš„é—®é¢˜åœ¨äºŽè¯æ±‡é‡å¤ªå¤§äº†ï¼Œæ‰€ä»¥å‡ ä¹Žæ‰€æœ‰ä¸»æµæ¨¡åž‹éƒ½ä¼šçœç•¥å¾ˆå¤šè¯ï¼Œæ¯”å¦‚Bengioçš„RNNsè¯­è¨€æ¨¡åž‹å°±æŠŠæ‰€æœ‰å‡ºçŽ°é¢‘çŽ‡&lt;3çš„å•è¯ç»Ÿä¸€æ ‡è®°ä¸ºä¸€ä¸ªç‰¹æ®Šè¯ã€‚ä½†è¿™æ ·çš„æ“ä½œä¹Ÿåªæ˜¯æŠŠè¯æ±‡é‡é™åˆ°äº†16,383ã€‚åˆæ¯”å¦‚word2vecæ¨¡åž‹åªè€ƒè™‘å‡ºçŽ°é¢‘çŽ‡æœ€é«˜çš„30,000ä¸ªè¯ã€‚ æ‰€ä»¥å¯»æ‰¾å…¶ä»–æœ‰é™é›†åˆçš„è¯­è¨€å•ä½æˆä¸ºæ›¿ä»£é€‰æ‹©ï¼Œæ¯”å¦‚å­—æ¯ characterï¼ˆæ›´ç¡®åˆ‡åœ°è¯´æ˜¯ unicode code pointsï¼‰ï¼Œæ¯”å¦‚å‰é¢æåˆ°çš„ Morphemesï¼Œè¿˜æœ‰å…¶ä»–æ¯”å¦‚ Character n-gramsï¼ŒMorphological analysisç­‰ï¼Œè¿™äº›å¯ä»¥ç»Ÿç§°ä¸º subwords unitsã€‚ ç„¶åŽå†é€šè¿‡ subwords æ¥é‡æž„ word representationï¼Œè¿›è€Œæž„å»ºæ•´ä¸ªæ–‡æœ¬çš„meaning representation. æž„å»º word representation æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯æŠŠ subwords vectors ç›¸åŠ ã€å¹³å‡æˆ–è€…æ‹¼æŽ¥ç­‰ï¼Œä½†æ›´å¥½çš„æ˜¯ä½¿ç”¨éžçº¿æ€§çš„æ–¹æ³•ï¼Œæ¯”å¦‚ Bidirectional LSTMs, Convolutional NNs ç­‰ã€‚ å“ªç§æ–¹å¼æž„å»º subword representations æ¯”è¾ƒå¥½ï¼Ÿåœ¨ word representation çš„é‡æž„ä¸­ï¼Œæ¶‰åŠäº†å‡ ä¸ªå˜é‡:1, Subword Unit 2, Composition Functionâ€¢ Linear Vector operationâ€¢ Bi-LSTMsâ€¢ Convolutional NNs 3, Language Typology Type example Morphology analysis Fusional (English) â€œreadsâ€ read-s read-3SG.SG Agglutinative (Turkish) â€œIf I read â€¦â€ oku-r-sa-m read-AOR.COND.1SG Root&amp;Pattern (Arabic) â€œhe wroteâ€ k(a)t(a)b(a) write-PST.3SG.M Reduplication (Indonesian) â€œchildrenâ€ anak~anak child-PL é™¤äº†è¯­è¨€æ¨¡åž‹å¤–, å…¶ä»–NLPä»»åŠ¡å¦‚SQuAdé—®ç­”æ•°æ®é›†ä¸Šçš„å¾ˆå¤šä¼˜ç§€æ¨¡åž‹ï¼Œä¹Ÿä¼šåŠ å…¥character embedding. ä½†ç›®å‰ Character-level models å¹¶ä¸å…·æœ‰è§¦åŠå®žé™… morphology çš„æ¨¡åž‹é¢„æµ‹èƒ½åŠ›ã€‚ Multi-word language representationsNeural bag-of-words models:Â· Simply average (or just sum) word vectors,Â· Can improve effectiveness by putting output through 1+ fully connected layers (DANs)Â· Recurrent neural networks(LSTM/GRU): cannot capture phrases without prefix context, and empirically, representations capture too much of last words in final vector â€“ focus is LM next word predictionÂ· Convolutional Neural Network: compute vectors for every h-word phrase, often for several values of h. Example: â€œthe country of my birthâ€ computes vectors for: the country, country of, of my, my birth, the country of, country of my, of my birth, the country of my, country of my birth. Not very linguistic, but you get everything! Data-dependent composition:Recursion is natural for describing language, Phrases correspond to semantic units of language. How to map longer phrases into the same vector space?åˆ©ç”¨å¤åˆæ€§åŽŸç† principle of compositionality: åœ¨æ•°å­¦ã€è¯­ä¹‰å­¦å’Œè¯­è¨€å“²å­¦ä¸­ï¼Œå¤åˆæ€§åŽŸç†æ˜¯æŒ‡ï¼Œä¸€ä¸ªå¤æ‚è¡¨è¾¾å¼çš„æ„ä¹‰æ˜¯ç”±å…¶å„ç»„æˆéƒ¨åˆ†çš„æ„ä¹‰ä»¥åŠç”¨ä»¥ç»“åˆå®ƒä»¬çš„è§„åˆ™æ¥å†³å®šçš„ã€‚ Recursive neural nets, a tree structure.For Structure Prediction:Inputs: two candidate childrenâ€™s representationsOutputs:1, The semantic representation if the two nodes are merged.2, Score of how plausible the new node would be. ç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹å¦‚ä½•æž„å»ºä¸€ä¸ªç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹?è¯­è¨€æ¨¡åž‹çš„ç›®çš„æ˜¯è¾“å…¥ä¸€ä¸²å­—ç¬¦, è¾“å‡ºä¸‹ä¸€ä¸ªå­—ç¬¦çš„æ¦‚çŽ‡åˆ†å¸ƒ, å¯ä»¥ä½¿ç”¨ fixed-window neural Language Model, ç±»ä¼¼äºŽN-Gram, ä»…è€ƒè™‘å‰(n-1)ä¸ªçª—å£é•¿åº¦åºåˆ—, â€œas the proctor started the clock the students opened their _â€œ å¾—åˆ°å®šé•¿çš„è¾“å…¥åºåˆ—, è€Œ Feedforward neural networks çš„è¾“å…¥å°±æ˜¯è¦æ±‚å›ºå®šé•¿åº¦çš„å‘é‡. ç”¨å‰é¦ˆç¥žç»ç½‘ç»œåšè¯­è¨€æ¨¡åž‹çš„ä¼˜ç‚¹ï¼ˆç›¸å¯¹äºŽN-Gramï¼‰å°±æ˜¯æ²¡æœ‰äº†ç¨€ç–æ€§é—®é¢˜ï¼Œè€Œä¸”æ¨¡åž‹çš„å¤§å°ä¹ŸæŽ§åˆ¶åœ¨ O(n)ï¼ˆN-Gramæ˜¯O(exp(n))ï¼‰ å›ºå®šé•¿åº¦çš„å‰é¦ˆç¥žç»ç½‘ç»œçš„å›ºæœ‰ç¼ºé™·å°±æ˜¯å®ƒè¦æ±‚è¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯å›ºå®šé•¿åº¦çš„, ä»…è€ƒè™‘å‰çš„(n-1)é•¿åº¦çš„åºåˆ—, å¾ˆå¤šæ—¶å€™ä¼šä¸¢å¤±NLPä¸­çš„é•¿è·ç¦»ä¾èµ–ä¿¡æ¯, è·ŸN-Gramçš„æœ‰ä¸€æ ·çš„ç¼ºé™·ã€‚è€Œä¸”å®žé™…çš„åº”ç”¨ä¸­è¯­å¥çš„é•¿åº¦æ˜¯ä¸å›ºå®šçš„ï¼Œæœ€å¥½æœ‰ä¸€ä¸ªç¥žç»ç½‘ç»œå¯ä»¥æŽ¥å—ä»»æ„é•¿åº¦çš„è¾“å…¥åºåˆ—, è¾“å‡ºä»»æ„é•¿åº¦çš„åºåˆ—ã€‚å¾ªçŽ¯ç¥žç»ç½‘ç»œ (Recurrent neural networks, aka RNNs) å°±å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜. å¾ªçŽ¯ç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹ä¸åŒäºŽå‰é¦ˆç¥žç»ç½‘ç»œä½¿ç”¨è¾“å…¥åºåˆ—çš„æ¯ä¸€ä¸ªè¯å•ç‹¬è®­ç»ƒä¸€è¡Œ(æˆ–ä¸€åˆ—, å–å†³äºŽçŸ©é˜µçš„è®¾è®¡)å‚æ•°çŸ©é˜µ, RNNsçš„è®¾è®¡æ ¸å¿ƒæ˜¯ç”¨è¾“å…¥åºåˆ—çš„æ¯ä¸€ä¸ªè¯, åå¤åœ°è®­ç»ƒåŒä¸€ä¸ªå‚æ•°, å³â€å…±äº«å‚æ•°â€. å› ä¸ºå‚æ•°å…±äº«:1, æ¨¡åž‹å¤§å°ä¸ä¼šéšç€è¾“å…¥åºåˆ—é•¿åº¦å¢žåŠ è€Œå¢žåŠ ã€‚2, æ¯ä¸€æ­¥çš„è®¡ç®—ï¼Œç†è®ºä¸Šéƒ½ä½¿ç”¨åˆ°äº†ä¹‹å‰çš„åŽ†å²ä¿¡æ¯ï¼Œæ‰€ä»¥ç†è®ºä¸Šå¯ä»¥æ›´å¥½çš„æ•æ‰é•¿è·ç¦»ä¾èµ–ï¼ˆä½†å®žé™…ä¸Šè¡¨çŽ°å¹¶ä¸å¥½ï¼Œçœ‹åŽé¢çš„æ¢¯åº¦æ¶ˆå¤±ä¸Žçˆ†ç‚¸ï¼‰.3, æ¨¡åž‹æœ‰æ›´å¥½çš„æ³›åŒ–èƒ½åŠ› ä½¿ç”¨åŸºäºŽSoftmaxçš„RNNsè¯­è¨€æ¨¡åž‹ç­‰åŒäºŽè§£å†³çŸ©é˜µåˆ†è§£é—®é¢˜, å‚è€ƒBreaking the Softmax Bottleneck: A High-Rank RNN Language Modelã€‚ å¾ªçŽ¯ç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹ä½¿ç”¨æŸå¤±å‡½æ•°è¯„ä¼°æ¨¡åž‹è¡¨çŽ°: æŸå¤±å‡½æ•° loss function on step t is usual äº¤å‰ç†µ cross-entropy between predicted probability distribution and the true next word. ä¼ ç»Ÿçš„ç»Ÿè®¡è¯­è¨€æ¨¡åž‹ä½¿ç”¨å›°æƒ‘åº¦(perplexity)æ¥è¯„ä¼°æ¨¡åž‹è¡¨çŽ°ï¼Œä½†å…¶å®žé™ä½Žå›°æƒ‘åº¦ç­‰ä»·äºŽå‡å°æŸå¤±å‡½æ•°. ç¥žç»ç½‘ç»œè¯­è¨€æ¨¡åž‹çš„å­¦ä¹ èƒ½åŠ›Character models are good at reduplication (no oracle, though), works well on language with reduplication patterns like Indonesian, Malay. Character NLMs learn word boundaries, memorize POS tags. What do NLMs learn about morphology?1, Character-level NLMs work across typologies, but especially well for agglutinative morphology.2, predictive accuracy is not as good as model with explicit knowledge of morphology (or POS).3, They actually learn orthographic similarity of affixes, and forget meaning of root morphemes accordong to qualitative analyses.4, More generally, they appear to memorize frequent subpatterns æ€»çš„æ¥è¯´ï¼Œç¥žç»ç½‘ç»œå¤„ç†è‡ªç„¶è¯­è¨€çš„èƒ½åŠ›å¹¶ä¸ç‰¹æ®Šï¼Œè¡¨çŽ°çš„æ€§èƒ½ï¼Œè·Ÿç¥žç»ç½‘ç»œæœ¬èº«çš„é•¿å¤„ç›¸åŒ¹é…ï¼Œå¦‚æ³›åŒ–ã€æ¨¡å¼åŒ¹é…ã€ç«¯åˆ°ç«¯åº”ç”¨çš„èƒ½åŠ›ç­‰ã€‚ Dependency parsingè¯­è¨€å­¦é‡Œæœ‰ä¸¤ç§è§’åº¦çœ‹å¾…è¯­æ³•ç»“æž„ - Constituency and Dependencyï¼š Constituency: phrase structure grammar, ä»Žå¥å­æˆåˆ†æž„é€ çš„è§’åº¦çœ‹ï¼Œcapture the configurational patterns of sentencesï¼Œå³æŠŠå¥å­çš„è¯­æ³•ç†è§£ä¸ºè¯ç»„æˆåˆ†çš„é€’å½’åµŒå¥—. å¯ä»¥ç”¨ context-free grammars (CFGs) æ¥è¡¨è¾¾è¯­æ³•è§„åˆ™ï¼Œå°±æ˜¯è¯­æ³•æ ‘ã€‚ Dependency syntax: ä¸»è¦æ˜¯ä»Žè¯­ä¹‰çš„è§’åº¦æ¥çœ‹ï¼Œæ˜¾ç¤ºå“ªäº›å•è¯ä¾èµ–äºŽï¼ˆä¸€èˆ¬æŒ‡ä¿®æ”¹æˆ–ä½œä¸ºå‚æ•°å…¶å‚æ•°ï¼‰å“ªäº›å•è¯ã€‚ç‰¹åˆ«ç”¨äºŽåŒºåˆ†åŠ¨è¯çš„ä¸»æ ¼ï¼ˆsubject position or with nominative inflectionï¼‰å®¾æ ¼ï¼ˆobject position or with accusative inflectionï¼‰. Dependencies can be identified even in non-configurational languages. A sentence dependency structure explains the dependency relation between its words: represented as a graph with the words as its nodes, linked by directed, labeled edges, with the following properties:â€¢ connected: every node is related to at least one other node, and (through transitivity) to ROOT;â€¢ single headed: every node (except ROOT) has exactly one incoming edge (from its head);â€¢ acyclic: the graph cannot contain cycles of directed edges. Dependency trees æœ‰ä¸¤ç§ï¼Œå¦‚æžœdependency graphä¸­æœ‰edgesäº¤å‰åˆ™æ˜¯non-projective, åä¹‹åˆ™æ˜¯ projectiveã€‚æ›´ç¡®åˆ‡çš„å®šä¹‰æ˜¯ï¼šA dependency tree is projective wrt. a particular linear order of its nodes if, for all edges h â†’ d and nodes w, w occurs between h and d in linear order only if w is dominated by h. A non-projective dependency grammar is not context-free. Motivation for Dependency parsing:â€¢ context-free parsing algorithms base their decisions on adjacency;â€¢ in a dependency structure, a dependent need not be adjacent to its head (even if the structure is projective);â€¢ we need new parsing algorithms to deal with non-adjacency (and with non-projectivity if present). Evaluation: accuracy (# correct dependencies with or ignore label)). Graph-based dependency parsingBased on maximum spanning trees (MST parser), views syntactic structure as a set of constraints Intuition as tagging problem: since each word has exactly one parent, the possible tags are the other words in the sentence (or a dummy node called root). If we edge factorize the score of a tree so that it is simply the product of its edge scores, then we can simply select the best incoming edge for each word. The tartget function is to find the highest scoring dependency tree in the space of all possible trees for a sentence. The score of dependency tree y for sentence x is:$$s(x,y) = \sum_{(i,j)\in y} s(i,j)$$$x = x_1â€¦x_n, y$ is a set of dependency edges, with $(i, j) âˆˆ y$ if there is an edge from $x_i$ to $x_j$. Scoring edges with a neural networkThe function g(aj, ai) computes an association score telling us how much word wi prefers word wj as its head. Association scores are a useful way to select from a dynamic group of candidates, è·Ÿæ³¨æ„åŠ›æœºåˆ¶çš„similarity score å¼‚æ›²åŒå·¥ï¼Œæ–¹ç¨‹çš„å½¢å¼ä¹Ÿå¾ˆç›¸ä¼¼ã€‚ Parsing ç®—æ³•ï¼š start with a totally connected graph G, i.e., assume a directed edge between every pair of words; find the maximum spanning tree (MST) of G, i.e., the directed tree with the highest overall score that includes all nodes of G; this is possible in O(n2) time using the Chu-Liu-Edmonds algorithm; it finds a MST which is not guaranteed to be projective; 1, Each node j in the graph greedily selects the incoming edge with the highest score s(i,j) 2, If result were a tree, it would have to be the maximum spanning tree; If not, there must be a cycle. 3, Break the cycle by replacing a single incoming edge to one of the nodes in the cycle. To choose the node, decide recursively by identifying the cycle and contract it into a single node and recalculate scores of incoming and outgoing edges. Now call CLE recursively on the contracted graph. MST on the contracted graph is equivalent to MST on the original graph. è¿™é‡Œæ˜¯æŒ‡å…ˆè¯†åˆ«å‡ºå¾ªçŽ¯ä½“saw â‡„ johnâ‘¡ï¼Œç„¶åŽåœ¨è¿™ä¸ªå¾ªçŽ¯ä½“èŒƒå›´å†…ï¼Œä½¿ç”¨CLEæ‰¾å‡º root è¿›å‡ºè¿™ä¸ªå¾ªçŽ¯ä½“çš„æœ€å¤§æ¦‚çŽ‡è·¯çº¿(root â†’ saw â†’ john = 40) &gt; (root â†’ john â†’ saw = 29)â‘¢ï¼› 4, Greedily collect incoming edges to all nodes, find out to be a tree and thus the MST of the graph. æŠŠå¾ªçŽ¯ä½“ä»¥åŠå…¶åŒ…å«çš„nodesåˆå¹¶ä¸ºä¸€ä¸ªnode wjsï¼Œå¹¶ä¸”å·²ç»æœ‰äº†è¿›å‡ºwjsçš„æœ€å¤§æ¦‚çŽ‡è·¯å¾„ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨æ•´ä¸ªå›¾ä¸Šç»§ç»­è¿è¡ŒCLEç®—æ³•æ‰¾å‡ºæœ€å¤§æ¦‚çŽ‡è·¯çº¿(root â†’ wjs â†’ mary = 70) &gt; (root â†’ mary â†’ wjs = 40)â‘£. Chu-Liu-Edmonds (CLE) Algorithm: In graph theory, Edmondsâ€™ algorithm or Chuâ€“Liu/Edmondsâ€™ algorithm is an algorithm for finding a spanning arborescence of minimum weight (sometimes called an optimum branching). It is the directed analog of the minimum spanning tree problem Transition-based dependency parsingAn extension of shift-reduce parsing (MALT parser), views syntactic structure as the actions of an automaton:â€¢ for a given parse state, the transition system defines a set of actions T which the parser can take;â€¢ if more than one action is applicable, a machine learning classifier is used to decide which action to take;â€¢ just like in the MST model, this requires a mechanism to compute scores over a set of (possibly dynamic) candidates.if si is the ith top element on stack, and bi the ith element on buffer, then we have the following transitions:â€¢ LEFT-ARC(l): adds arc s1 â†’ s2 with label l and removes s2 from stack (|s| â‰¥ 2);â€¢ RIGHT-ARC(l): adds arc s2 â†’ s1 with label l and removes s1 from stack (|s| â‰¥ 2);â€¢ SHIFT: moves b1 from buffer to stack; recondition: |b| â‰¥ 1.æ€»çš„æ¥è¯´å°±æ˜¯ï¼šçˆ¶èŠ‚ç‚¹ä¿ç•™åœ¨stackä¸­; ä»Žå§‹è‡³ç»ˆ root ä¸€ç›´éƒ½æ˜¯çˆ¶èŠ‚ç‚¹ï¼›ä»Ž buffer ä¸­æŠŠå€™é€‰è¯ä¸€ä¸ªä¸€ä¸ª push åˆ°stackä¸­ï¼Œæ ¹æ® classifier é¢„æµ‹çš„ç»“æžœï¼Œåˆ†è¾¨å‡ºå“ªä¸ªå€™é€‰è¯æ˜¯å­èŠ‚ç‚¹ï¼Œå¹¶æŠŠå­èŠ‚ç‚¹ pop å‡º stackï¼›ç›´åˆ°æ¸…ç©º bufferï¼Œstack ä¸­åªå‰©ä¸‹ rootã€‚ Comparing MST and transition-based parsers:Both require dynamic classifiers, and these can be implemented using neural networks, conditioned on bidirectional RNN encodings of the sentence. The MST parser selects the globally optimal tree, given a set of edges with scores;â€¢ it can naturally handle projective and non-projective trees; A transition-based parser makes a sequence of local decisions about the best parse action;â€¢ it can be extended to projective dependency trees by changing the transition set; Accuracies are similar, but transition-based is faster; Recurrent neural network grammars (RNNGs)Widespread phenomenon: Polarity items can only appear in certain contexts, e.g. â€œanybodyâ€. In linguistics, a polarity item is a lexical item that can appear only in environments associated with a particular grammatical polarity â€“ affirmative or negative. A polarity item that appears in affirmative (positive) contexts is called a positive polarity item (PPI), and one that appears in negative contexts is a negative polarity item (NPI). The environment in which a polarity item is permitted to appear is called a â€œlicensing contextâ€œ. The lecture that I gave did not appeal to anybody;The lecture that I gave appealed to anybody. ä¹Ÿè®¸â€anybodyâ€å‡ºçŽ°çš„æ¡ä»¶æ˜¯å‰é¢å‡ºçŽ°è¿‡â€notâ€ï¼Œé‚£ä¹ˆåº”è¯¥å¯ä»¥ä½¿ç”¨ RNNs æ¨¡åž‹æ¥è§£ç è¿™ç‚¹ä¿¡æ¯ã€‚ç„¶è€Œ:The lecture that I did not give appealed to anybody. è¿™è¯´æ˜Ž Language is hierarchical: The licensing context depends on recursive structure (syntax)ã€‚ä¸èƒ½ç®€å•æ ¹æ®â€notâ€æ˜¯å¦å‡ºçŽ°æ¥åˆ¤æ–­ï¼Œè€Œæ˜¯éœ€è¦çœ‹â€notâ€ä¿®é¥°çš„æˆåˆ†ï¼Œä¹Ÿå°±æ˜¯è¯´è¦è€ƒè™‘è¯­æ³•çš„åˆç†ã€‚è¿™å°±ç»™æ–‡æœ¬ç”Ÿæˆä»»åŠ¡ï¼ˆæˆ–è€…è¯´æž„å»ºè¯­è¨€æ¨¡åž‹ï¼‰å¸¦æ¥æŒ‘æˆ˜ã€‚ Recurrent neural network grammars (Dyer et al. 2016)æå‡ºäº†ä¸€ç§å…·æœ‰æ˜Žç¡®çŸ­è¯­ç»“æž„çš„è¯­è¨€æ¨¡åž‹ RNNGsã€‚ RNNGs operate via a recursive syntactic process reminiscent of probabilistic context-free grammar generation, but decisions are parameterized using RNNs that condition on the entire syntactic derivation history, greatly relaxing context-free independence assumptions. å°±æ˜¯åœ¨ä½¿ç”¨ RNNs æž„å»ºè¯­è¨€æ¨¡åž‹ï¼Œé™¤äº†è€ƒè™‘åŽ†å²è¯ä¿¡æ¯, è¿˜ä¼šç”ŸæˆåŽ†å²çš„è¯­æ³•ç»“æž„, å¹¶ä»¥æ­¤ä¸ºå‚è€ƒé¢„æµ‹è¯­æ³•ç»“æž„å’Œè¯è¯­,ä»¥ä¿è¯ç”Ÿæˆçš„è¯­è¨€ç¬¦åˆè¯­æ³•ç»“æž„ã€‚è¿™é‡Œçš„è¯­æ³•æ˜¯é’ˆå¯¹ phrase structure (constituency) grammarsï¼Œæ‰€ä»¥ RNNGs ä¹Ÿæ˜¯ä¸€ç§ constituency parsingï¼š Generate symbols sequentially using an RNN Add some â€œcontrol symbolsâ€ to rewrite the history periodically Periodically â€œcompressâ€ a sequence into a single â€œconstituentâ€ Augment RNN with an operation to compress recent history into a single vector (-&gt; â€œreduceâ€) RNN predicts next symbol based on the history of compressed elements and non-compressed terminals (â€œshiftâ€ or â€œgenerateâ€) RNN must also predict â€œcontrol symbolsâ€ that decide how big constituents are é¦–å…ˆæ³¨æ„åˆ°ï¼Œå¦‚æžœæœ‰åºåœ°åŽ»éåŽ†è¯­æ³•æ ‘ï¼Œå¾—å‡ºçš„å°±æ˜¯ä¸€ä¸ªåºåˆ—ï¼š What information can we use to predict the next action, and how can we encode it with an RNN? Use an RNN for each of: Previous terminal symbols Previous actions Current stack contentsæœ€åŽå¾—å‡ºçš„ stack å°±æ˜¯å®Œæ•´çš„è¯­æ³•æ ‘ï¼ˆä»¥åºåˆ—çš„å½¢å¼ï¼‰ã€‚ Syntactic Compositionäººä»¬é€šè¿‡è¾ƒå°å…ƒç´ çš„è¯­ä¹‰ç»„åˆæ¥è§£é‡Šè¾ƒå¤§æ–‡æœ¬å•å…ƒçš„å«ä¹‰ - å®žä½“ï¼Œæè¿°æ€§è¯è¯­ï¼Œäº‹å®žï¼Œè®ºæ®ï¼Œæ•…äº‹.When compressing â€œThe hungry catâ€ into a single composite symbol, use Bi-LSTM to encode (NP The hungry cat). åŸºäºŽæ­¤å¯ä»¥é€’å½’åœ°è§£ç æ›´å¤æ‚çš„çŸ­è¯­ï¼Œæ¯”å¦‚(NP The (ADJP very hungry) cat), åªéœ€è¦æŠŠåŽŸæ¥çš„hungryæ›¿æ¢ä¸º(ADJP very hungry)å³å¯ã€‚ è¿™ç§é€’å½’åœ°å †æ ˆç¬¦å·çš„æž„å»ºè¡Œä¸ºæ˜ å°„äº†ç¬¦å·å¯¹åº”çš„æ ‘ç»“æž„ é™¤æ­¤äº†ä½¿ç”¨ Bi-LSTM è§£ç ï¼Œè¿˜å¯ä»¥ä½¿ç”¨ Attentionï¼šReplace composition with one that computes attention over objects in the composed sequence, using embedding of NT for similarity. Implement RNNGsStack RNNs Augment a sequential RNN with a stack pointer Two constant-time operations push - read input, add to top of stack, connect to current location of the stack pointer pop - move stack pointer to its parent A summary of stack contents is obtained by accessing the output of the RNN at location of the stack pointer Training RNNs: Each word is conditioned on history represented by a trio of RNNs backpropagate through these three RNNs, and recursively through the phrase structure S â†’ NP VP. å®Œæ•´çš„RNNGsæ¨¡åž‹ï¼Œç”¨ softmax è®¡ç®—ä¸‹ä¸€ä¸ª action çš„æ¦‚çŽ‡åˆ†å¸ƒï¼š Parameter EstimationRNNGs jointly model sequences of words together with a â€œtree structureâ€. Any parse tree can be converted to a sequence of actions (depth first traversal) and vice versa (subject to wellformedness constraints). Inference problems of RNNGsAn RNNG is a joint distribution p(x,y) over strings (x) and parse trees (y), i.e. it jointly predicts the word, and the parse context together. So the model will still generate the syntactic information and the next word but we can discard the additional outputs if all we want is the language model. Two inference questions:â€¢ What is $p(x)$ for a given x? - language modelingâ€¢ What is $argmax_yp(y | x)$ for a given x? - parsing The model predicts the next action (NT() GEN() or REDUCE in generative mode, NT() SHIFT or REDUCE in discriminative mode). The set of actions completely determines the string and tree structure, so we can get their joint probability by multiplying over the probabilities of all actions. In discriminative mode, the input is a string of words, and the model cannot generate words, but instead â€œconsumesâ€ the words in the input buffer. The model can be used as a parser (find the maximum prob. tree, i.e., $argmax_yP(y \mid x)$). In generative mode, there is a respective GEN() action for every word, so the word is predicted with the action. To be a language model (find the maximum prob. sentence/assign probabilities to a sentence, i.e., $p(x)$), we must marginalize over trees to get the probability of the sentence. This is intractable so is approximated with importance sampling by sampling from a discriminatively trained model. importance samplingAssume weâ€ve got a conditional distribution $q(y | x)$s.t. (i) $p(x, y) &gt; 0 \Rightarrow q(y | x) &gt; 0$(ii) $y \sim q(y | x)$ is tractable and(iii) $q(y | x)$ is tractable The importance weights $w(x,y) = \frac{p(x, y)}{q(y | x)}$ ä»Žå¥å­åˆ°è¯­æ³•æ ‘çš„seq2seqæ¨¡åž‹å…¶å®žä»Žå¥å­åˆ°è¯­æ³•çš„æ˜ å°„ç±»ä¼¼äºŽä¸€ä¸ªseq2seqæ¨¡åž‹ã€‚è€Œç›´æŽ¥çš„æŠŠè¯­æ³•æ ‘ä»¥å­—ç¬¦åºåˆ—çš„å½¢å¼è¡¨è¾¾ï¼Œä½¿ç”¨ç®€å•çš„ RNNs ç›´æŽ¥æž„å»ºå¥å­åˆ°è¯­æ³•åºåˆ—çš„ seq2seq æ¨¡åž‹æ•ˆæžœä¹Ÿä¸é”™ï¼Œæ¯”å¦‚ï¼šinput: The hungry cat meows .output: S( NP( _ _ _ ) VP( _ ) _ )Vanilla RNNs åœ¨æ¨¡å¼åŒ¹é…å’Œè®¡æ•°æ–¹é¢éžå¸¸å‡ºè‰²ï¼Œç»éªŒè¯æ˜Žï¼Œè®­ç»ƒæœ‰ç´ çš„ seq2seq æ¨¡åž‹é€šå¸¸ä¼šè¾“å‡ºæ ¼å¼è‰¯å¥½çš„å­—ç¬¦ä¸²ï¼Œè§è¿™ç¯‡æ–‡ç«  section 3.2 ä½†æ½œåœ¨çš„é—®é¢˜æ˜¯ï¼Œseq2seq æ¨¡åž‹å¹¶ä¸è¦æ±‚è¾“å‡ºæ˜¯æœ‰æ­£ç¡®æ‹¬å·å­—ç¬¦ï¼ˆæ•°é‡å¯¹é½ï¼Œä½ç½®æ­£ç¡®ï¼‰ã€‚å¦å¤–ï¼Œç†è®ºä¸Šå•ä¸ªRNNä¹Ÿåªèƒ½è®°å¿†æ‹¬å·ç»“æž„ä¸€å®šçš„æœ‰é™æ·±åº¦ï¼Œå› ä¸º RNNs åªæœ‰å›ºå®šçš„æœ‰é™æ•°é‡çš„éšè—å•å…ƒã€‚ä¾‹å¦‚ï¼Œå®ƒå°†ä¸ºè¿™äº›è¾“å‡ºåˆ†é…éžé›¶æ¦‚çŽ‡ï¼šS( NP( _ _ ) VP ( _ ) _ )S( NP( _ _ _ ) VP ( _ ) _ ) ) ) ç†æƒ³æƒ…å†µä¸‹ï¼Œæ¨¡åž‹åº”è¯¥ç»™ä»»ä½•ä¸å®Œæ•´çš„è¾“å‡ºåˆ†é…é›¶æ¦‚çŽ‡ã€‚ä½¿ç”¨ RNNGs æ˜¯å› ä¸ºå®ƒæœ¬èº«èƒ½å¤Ÿå±¥è¡Œè¿™äº›é™åˆ¶ï¼Œ ä¿è¯ç”Ÿæˆå®Œæ•´æ­£ç¡®çš„è¯­æ³•æ ‘ã€‚ ä»Žä¸­å¯ä»¥çœ‹å‡ºï¼Œseq2seqæ¨¡åž‹å¯ä»¥ç”¨äºŽå¿«é€ŸåŽŸåž‹å’Œ baseline æ­å»ºï¼Œä½†å¦‚æžœé‡åˆ°è¦æ±‚è¾“å‡ºéµå®ˆæŸäº›çº¦æŸæ¡ä»¶çš„é—®é¢˜ï¼Œåˆ™éœ€è¦ç›´æŽ¥æ‰§è¡Œè¿™äº›çº¦æŸæ¡ä»¶ã€‚ ParsingParsing is a fundamental task in NLP. But what is parsing actually good for? Parsing breaks up sentences into meaningful parts or finds meaningful relationships, which can then feed into downstream semantic tasks:â€¢ semantic role labeling (figure out who did what do whom);â€¢ semantic parsing (turn a sentence into a logical form);â€¢ word sense disambiguation (figure out what the words in a sentence mean);â€¢ compositional semantics (compute the meaning of a sentence based on the meaning of its parts). Semantic role labeling (SRL)è™½ç„¶å¯ä»¥ä½¿ç”¨ Distributional semantics è¡¨è¾¾å«ä¹‰ï¼Œåªæ˜¯ Distributional semantics æ¯”è¾ƒæ“…é•¿å¤„ç†ç›¸ä¼¼åº¦ï¼Œä¸”æ— æ³•å¾ˆæ˜Žç¡®åœ°å¤„ç†å¤åˆæ€§ Compositionalityã€‚ åœ¨æ•°å­¦ã€è¯­ä¹‰å­¦å’Œè¯­è¨€å“²å­¦ä¸­ï¼Œå¤åˆæ€§åŽŸç†æ˜¯æŒ‡ï¼Œä¸€ä¸ªå¤æ‚è¡¨è¾¾å¼çš„æ„ä¹‰æ˜¯ç”±å…¶å„ç»„æˆéƒ¨åˆ†çš„æ„ä¹‰ä»¥åŠç”¨ä»¥ç»“åˆå®ƒä»¬çš„è§„åˆ™æ¥å†³å®šçš„ã€‚ ä¸ºäº†èƒ½å¤Ÿå¤„ç†å¤åˆæ€§å’ŒæŽ¨ç†ï¼Œæˆ‘ä»¬éœ€è¦è±¡å¾æ€§å’Œç»“æž„åŒ–çš„æ„ä¹‰è¡¨ç¤ºã€‚ è™½ç„¶è¯­è¨€æ˜¯æ— ç©·æ— å°½çš„ï¼Œå¥å­æ˜¯æ— é™çš„é›†åˆï¼Œè€Œäººè„‘çš„èƒ½åŠ›å´æ˜¯æœ‰é™çš„ï¼Œä½†äººä»¬æ€»èƒ½å¤Ÿç†è§£ä¸€ä¸ªå¥å­çš„å«ä¹‰ï¼ˆå‡å¦‚äººä»¬ç†ŸçŸ¥è¡¨è¾¾å¥å­çš„è¯­è¨€ï¼‰. å› æ­¤, å¯¹äºŽ semantics, è¯­ä¹‰è‚¯å®šæ˜¯æœ‰é™çš„é›†åˆ, è¿™æ ·æ‰èƒ½ç¡®å®šå¥å­çš„ç¡®åˆ‡æ„ä¹‰. In generative grammar, a central principle of formal semantics is that the relation between syntax and semantics is compositional. The principle of compositionality (Fregean Principle): The meaning of a complex expression is determined by the meanings of its parts and the way they are syntactically combined. Semantic role labeling means identifying the arguments (frame elements) that participate in a prototypical situation (frame) and labeling them with their roles; SRL task is typically broken down into a sequence of sub-tasks: parse the training corpus; match frame elements to constituents; extract features from the parse tree; train a probabilistic model on the features. æ‰€è°“ frame elements æ˜¯é’ˆå¯¹ Frame Semantics è€Œè¨€çš„ã€‚ SRL provides a shallow semantic analysis that can benefit various NLP applications; no parsing needed, no handcrafted features. Frame Semanticsè¡¨è¾¾è¯ä¹‰ï¼Œé™¤äº† Firth, J.R. (1957) çš„ â€œa word is characterized by the company it keepsâ€ï¼ˆä¹Ÿå³æ˜¯ Distributional semanticsï¼‰ä¹‹å¤–, è¿˜æœ‰ Charles J. Fillmore çš„ Frame Semantics. The basic idea is that one cannot understand the meaning of a single word without access to all the essential knowledge that relates to that word. A semantic frame is a collection of facts that specify â€œcharacteristic features, attributes, and functions of a denotatum, and its characteristic interactions with things necessarily or typically associated with it.â€ A semantic frame can also be defined as a coherent structure of related concepts that are related such that without knowledge of all of them, one does not have complete knowledge of any one; they are in that sense types of gestalt. Proposition Bankå®Œæ•´çš„å¥å­è¡¨è¾¾äº†å‘½é¢˜ propositions, ä¹Ÿå³ä¸€ä¸ªä¸»å¼ . æ¯”å¦‚â€John smokesâ€è¿™ä¸ªå¥å­çš„å‘½é¢˜å¦‚æžœæ˜¯çœŸçš„,é‚£ä¹ˆâ€Johnâ€åœ¨è¿™é‡Œä¸€å®šæ˜¯æŸä¸ªâ€smokesâ€çš„äºº, ä¹Ÿå°±æ˜¯å¿…é¡»æ˜¯NP. åœ¨çŽ°ä»£å“²å­¦ã€é€»è¾‘å­¦ã€è¯­è¨€å­¦ä¸­ï¼Œå‘½é¢˜æ˜¯æŒ‡ä¸€ä¸ªåˆ¤æ–­ï¼ˆé™ˆè¿°ï¼‰çš„è¯­ä¹‰ï¼ˆå®žé™…è¡¨è¾¾çš„æ¦‚å¿µï¼‰ï¼Œè¿™ä¸ªæ¦‚å¿µæ˜¯å¯ä»¥è¢«å®šä¹‰å¹¶è§‚å¯Ÿçš„çŽ°è±¡ã€‚å‘½é¢˜ä¸æ˜¯æŒ‡åˆ¤æ–­ï¼ˆé™ˆè¿°ï¼‰æœ¬èº«ã€‚å½“ç›¸å¼‚åˆ¤æ–­ï¼ˆé™ˆè¿°ï¼‰å…·æœ‰ç›¸åŒè¯­ä¹‰çš„æ—¶å€™ï¼Œä»–ä»¬è¡¨è¾¾ç›¸åŒçš„å‘½é¢˜ã€‚ä¾‹å¦‚ï¼Œé›ªæ˜¯ç™½çš„ï¼ˆæ±‰è¯­ï¼‰å’ŒSnow is whiteï¼ˆè‹±è¯­ï¼‰æ˜¯ç›¸å¼‚çš„åˆ¤æ–­ï¼ˆé™ˆè¿°ï¼‰ï¼Œä½†å®ƒä»¬è¡¨è¾¾çš„å‘½é¢˜æ˜¯ç›¸åŒçš„ã€‚åœ¨åŒä¸€ç§è¯­è¨€ä¸­ï¼Œä¸¤ä¸ªç›¸å¼‚åˆ¤æ–­ï¼ˆé™ˆè¿°ï¼‰ä¹Ÿå¯èƒ½è¡¨è¾¾ç›¸åŒå‘½é¢˜ã€‚ä¾‹å¦‚ï¼Œåˆšæ‰çš„å‘½é¢˜ä¹Ÿå¯ä»¥è¯´æˆå†°çš„å°ç»“æ™¶æ˜¯ç™½çš„ï¼Œä¸è¿‡ï¼Œä¹‹æ‰€ä»¥æ˜¯ç›¸åŒå‘½é¢˜ï¼Œå–å†³äºŽå†°çš„å°ç»“æ™¶å¯è§†ä¸ºé›ªçš„æœ‰æ•ˆå®šä¹‰ã€‚ PropBank is a version of the Penn Treebank annotated with semantic roles. More coarse-grained than Frame Semantics: End-to-end SRL systemåŸºæœ¬çš„ç»“æž„å•å…ƒæ˜¯Bi-LSTMï¼Œç”¨æ³•æ˜¯ï¼šÂ· a standard LSTM layer processes the input in forward direction;Â· the output of this LSTM layer is the input to another LSTM layer, but in reverse direction;è¿™äº›Bi-LSTMå•å…ƒå¯ä»¥å åŠ èµ·æ¥æž„é€ æ›´æ·±å±‚çš„ç¥žç»ç½‘ç»œ. The input (processed word by word) features are:â€¢ argument and predicate: the argument is the word being processed, the predicate is the word it depends on;â€¢ predicate context (ctx-p): the words around the predicate; also used to distinguish multiple instances of the same predicate;â€¢ region mark (mr): indicates if the argument is in the predicate context region or not;â€¢ if a sequence has np predicates it is processed np times. Output: semantic role label for the predicate/argument pair using IOB tags (inside, outside, beginning). Training:â€¢ Word embeddings are used as input, not raw words;â€¢ the embeddings for arguments, predicate, and ctx-p, as well as mr are concatenated and used as input for the Bi-LSTM;â€¢ the output is passed through a conditional random field (CRF); allows to model dependencies between output labels;â€¢ Viterbi decoding is used to compute the best output sequence Model learns â€œsyntaxâ€(Maybe): it associates argument and predicate words using the forget gate: Semantic ParsingSemantic Parsing æŒ‡è¯­ä¹‰åˆ†æžï¼ŒæŠŠæ–‡æœ¬è§£æžä¸ºä»»æ„çš„é€»è¾‘å½¢å¼(ä¸€ç§ meaning representation)ï¼Œæ¯”å¦‚ first-order logic(FOL).Sam likes Casey - likes(Sam, Casey);Anna&#39;s dog Mr. PeanutButter misses her - misses(MrPB, Anna) âˆ§ dog(MrPB);Kim likes everyone - âˆ€x.likes(x, Kim).Predicate-argument structure is a good match for FOL, as well as structures with argument-like elements (e.g. NPs).Determiners, quantifiers (e.g. â€œeveryoneâ€, â€œanyoneâ€), and negation can be expressed in FOL. However, much of natural language is unverifiable, ambiguous, non-canonical. That makes it hard to represent the wide-coverage meaning of arbitrary NL. Closed domains are easier, and can sometimes be harvested automatically, e.g. GEOQUERY dataset. This leads to a proliferation of domain-specific MRs.Â· Pairs of NL sentences with structured MR can be collected, e.g. IFTTT dataset (Quirk et al. 2015).Â· WikiTableQuestionsÂ· Googleâ€™s knowledge graph Viewing MR as a string, semantic parsing is just conditional language modeling. Trainable alternative to compositional approaches: encoder-decoder neural models. The encoder and decoder can be mixed and matched: RNN, top-down tree RNN. Works well on small, closed domains if we have training data, but there are many unsolved phenomena/ problems in semantics. Abstract meaning representation (AMR)â€¢ The edges (ARG0 and ARG1) are relationsâ€¢ Each node in the graph has a variableâ€¢ They are labeled with conceptsâ€¢ d / dog means â€œd is an instance of dogâ€œThe dog is eating a bone(e / eat-01&nbsp;&nbsp;&nbsp;&nbsp;:ARG0 (d / dog)&nbsp;&nbsp;&nbsp;&nbsp;:ARG1 (b / bone)) The dog wants to eat the bone(want-01&nbsp;&nbsp;&nbsp;&nbsp;:ARG0 (d / dog)&nbsp;&nbsp;&nbsp;&nbsp;:ARG1 (e / eat-01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ARG0 d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:ARG1 (b / bone))) CoreferenceCharles just graduated, and now Bob wants Anna to give him a job.Q: who does him refer to? MetonymyWestminster decided to distribute funds throughout England, Wales, Northern Island, and Scotlanddecided(Parliament, â€¦) ImplicatureThat cake looks delicious - I would like a piece of that cake. Even more phenomenaâ€¦â€¢ Abbreviations (e.g. National Health Service=NHS)â€¢ Nicknames (JLaw=Jennifer Lawrence)â€¢ Metaphor (crime is a virus infecting the city)â€¢ Time expressions and change of stateâ€¢ Many others TODO(æŒ‡ä»£æ¶ˆè§£ Coreference Resolution)Unsupervised Part-of-Speech TaggingParts-of-speech(POS), word classes, or syntactic categories, ä¸€èˆ¬æŒ‡å…«ä¸ªè¯æ€§ï¼šnoun, verb, adjective, adverb, pronoun, preposition, conjunction, interjection, æœ‰æ—¶å€™æ˜¯ numeral, article or determiner.1, noun åè©ž ( n. )2, pronoun ä»£åè©ž ( pron. )3, verb å‹•è©ž ( v. )4, adjective å½¢å®¹è©ž ( adj. )5, adverb å‰¯è©ž ( adv. )6, preposition ä»‹ç³»è©ž ( prep. )7, conjunction é€£æŽ¥è©ž ( conj. )8, interjection æ„Ÿæ­Žè©ž ( int. ) Tagging is a task that take a sentence, assign each word a label indicating its syntactic category (part of speech). One common standard label is Penn Treebank PoS tagset. DT - Determiner å®šè¯­IN - Preposition or subord. conjunctionNN - Noun, singular or massNNS - Noun, pluralNNP - Proper noun, singularRB - AdverbTO - toVB - Verb, base formVBZ - Verb, 3rd person singular present In supervised POS tagging, the input is the text and a set of allowed POS labels. The training data contains input and output examples. The output is a guess, for each word in the test data, which POS label it should have. A common approach is to use an HMM. To train it, choose parameters Î¸ that maximize $P(x,y \mid Î¸)$, the probability of the training data given the parameters. This is maximum likelihood estimation and it was covered in ANLP. You can use the model to predict y for each x in the test data by solving $P(y \mid x,Î¸)$ using the Viterbi algorithm. A consequence of supervised training with MLE is that the model will only learn non-zero probability for tag-word pairs that actually appear in the data. Hence, if â€œtheâ€ is only ever tagged with DT in the training data, then the model will learn that the probability of producing â€œtheâ€ from any other tag is zero. This means that many word tokens will be (empirically) unambiguous, which is one of the things that makes supervised POS tagging easy. RNNs è™½ç„¶ä¹Ÿå¯ä»¥å¤„ç†åºåˆ—æ¨¡åž‹, ä½†æ˜¯ç¥žç»ç½‘ç»œéœ€è¦ç›®æ ‡å‡½æ•°, æ²¡æœ‰ç›®æ ‡æ— æ³•è®¡ç®—æŸå¤±, å°±æ— æ³•è°ƒæ•´å‚æ•°, ä¹Ÿå°±æ˜¯â€ç›‘ç£å­¦ä¹ â€. Current PoS taggers are highly accurate (97% accuracy on Penn Treebank). But they require manually labelled training data, which for many major language is not available. Hence motivated for unsupervised PoS tagging. In unsupervised POS tagging, the input is the text and the number of clusters. The training data contains only input examples. The output is a guess, for each word in the text, which cluster the word belongs to. For example:123Number of clusters: 50Input x: The hungry cat meowsOutput y: 23 45 7 18 What we hope is that the cluster labels will correlate with true POS labels; that is, that tokens labeled 23 will tend to be determiners, that clusters label 45 will tend to be adjectives, and so on. è¿™ä¸ªæ—¶å€™å¯ä»¥ä½¿ç”¨éšé©¬å°”ç§‘å¤«æ¨¡åž‹, è¿™ä¸ªâ€éšâ€å°±æ˜¯é’ˆå¯¹æ²¡æœ‰ç›®æ ‡å¯ä»¥å‚è€ƒè¿™ç§æƒ…å†µ. Hidden Markov ModelsThe unsupervised tagging models here are based on Hidden Markov Models (HMMs).To train it, choose parameters Î¸ that maximize $P(x \mid Î¸)$, the probability of the training data given the parameters. The parameters Î¸ = (Ï„, Ï‰) define:â€¢ Ï„ : the probability distribution over tag-tag transitions;â€¢ Ï‰: the probability distribution over word-tag outputs.The parameters are sets of multinomial distributions:â€¢ $Ï‰ = Ï‰^{(1)} . . . Ï‰^{(T)}$: the output distributions for each tag;â€¢ $Ï„ = Ï„^{(1)} . . . Ï„^{(T)}$: the transition distributions for each tag;â€¢ $Ï‰^{(t)} = Ï‰_1^{(t)}. . . Ï‰_W^{(t)}$: the output distribution from tag $t$;â€¢ $Ï„^{(t)} = Ï„_1^{(t)}. . . Ï„_T^{(t)}$: the transition distribution from tag $t$. Another way to write the model, often used in statistics and machine learning: $w_i | t_i = t âˆ¼ Multinomial(Ï‰^{(t)})$ So as tag, given that $t_{iâˆ’1} = t$, the value of $t_i$ is drawn from a multinomial distribution with parameters $Ï„^{(t)}$. How to estimate Ï‰ and Ï„ without supervision. This is still maximum likelihood estimation, but notice that itâ€™s more difficult because the tags y are unobserved, so you must marginalize them out. For estimation (i.e., training the model, determining its parameters), we need a procedure to set Î¸ based on data. Rely on Bayes Rule:\begin{equation}\begin{split} P(Î¸|w)&amp;=\frac{P(w|Î¸)P(Î¸)}{P(w)}\\ &amp;âˆP(w|Î¸)P(Î¸)\\\end{split}\end{equation}Choose the Î¸ that maximize the likelihood $P(w|Î¸)$. Basically, we ignore the prior. In most cases, this is equivalent to assuming a uniform prior. To do this, you can use expectation maximization (EM), a variant of MLE that can cope with unobserved data, which was also covered in ANLP. For examples, forward-backward algorithm for HMMs, inside-outside algorithm for PCFGs, k-means clustering. For inference (i.e., decoding, applying the model at test time), we need to know Î¸ and then we can compute $P(t, w)$: E-step: use current estimate of Î¸ to compute expected counts of hidden events ($n(t,t^{\prime})$, $n(t,w)$).M-step: recompute Î¸ using expected counts. You can then use the trained model to predict y for each x in the test data by solving $P(y \mid x,Î¸)$ using the Viterbi algorithm. But EM often fails, even very small amounts of training data have been show to work better than EM. One consequence of unsupervised training with EM is that every word can be assigned to any cluster label. This makes things really difficult, because it means every word is ambiguous. The basic assumptions of EM (that any tag-word or tag-tag distribution is equally likely) make this even more difficult. Instead, use Bayesian HMM with Gibbs sampling. Bayesian HMMWhen training HMM model, we are not actually interested in the value of Î¸, we could simply integrate it out. This approach is called Bayesian integration. Integrating over Î¸ gives us an average over all possible parameters values. The Bayesian HMM is simply an alternative way to solve the unsupervised POS tagging problem. The input and output is the same. But instead of learning Î¸, we directly solve $P(y \mid x)$. Note that we donâ€™t need to learn Î¸ (though we could) - in this setting, we integrate it out, after first supplying some information about the tag-tag and word-tag distributions encoded in Î¸. Specifically, we tell the model that a sparse distribution is much more likely than a uniform distribution. We do this by defining a distribution $P(Î¸)$, and this gives us a new model, $P(y,x \mid Î¸)Ã—P(Î¸)$. By integrating out Î¸ we can solve the unsupervised tagging problem directly. Example: we want to predict a spinner result will be â€œaâ€ or not?â€¢ Parameter Î¸ indicates spinner result: $P(Î¸ = a) = .45$, $P(Î¸ = b) = .35$, $P(Î¸ = c) = .2$;â€¢ define t = 1: result is â€œaâ€, t = 0: result is not â€œaâ€;â€¢ make a prediction about one random variable (t) based on the value of another random variable (Î¸). Maximum likelihood approach: choose most probable Î¸, $\hat{Î¸} = a$, and $P(t = 1|\hat{Î¸}) = 1$, so we predict $t = 1$. Bayesian approach:average over Î¸,$P(t = 1) = \sum_Î¸ P(t = 1|Î¸)P(Î¸) = 1(.45) + 0(.35) + 0(0.2) = .45$, predict t = 0. Advantages of Bayesian integration:â€¢ accounts for uncertainty as to the exact value of Î¸;â€¢ models the shape of the distribution over Î¸;â€¢ increases robustness: there may be a range of good values of Î¸;â€¢ we can use priors favoring sparse solutions (more on this later). Dirichlet distributionChoosing the right prior can make integration easier. A $K$-dimensional Dirichlet with parameters $Î± = Î±_1 . . . Î±_K$ is defined as: $$ P(Î¸) = \frac{1}{Z} \prod_{j=1}^K Î¸_j^{Î±_jâˆ’1} $$ We usually only use symmetric Dirichlets, where $Î±_1 . . . Î±_K$ are all equal to Î². We write Dirichlet(Î²) to mean $Dirichlet(Î², . . . , Î²)$. æ³¨æ„åˆ°è¿™æ˜¯ä¸€ä¸ªäºŒç»´çš„æ¦‚çŽ‡å¯†åº¦å›¾. $Î²&gt;1$æ„å‘³ç€æ›´å–œæ¬¢å‡å€¼åˆ†å¸ƒ, æ­¤æ—¶$Î¸$å¤§æ¦‚çŽ‡è½åœ¨$0.5$é™„è¿‘,å› ä¸º$Î¸_1+Î¸_2=1$, æ‰€ä»¥æ­¤æ—¶$Î¸_1, Î¸_2$æ¦‚çŽ‡å‡ç­‰. å¦‚æžœ$Î²=1$, $Î¸_1$çš„ä»»ä½•å–å€¼æ˜¯ç­‰æ¦‚çŽ‡çš„, ç­‰äºŽè¯´ä»»ä½•$Î¸_1,Î¸_2$çš„ç»„åˆæ¦‚çŽ‡éƒ½æ˜¯å‡ç­‰çš„. To Bayesianize the HMM, we augment with it with symmetric Dirichlet priors: To simplify things, use a bigram version of the Bayesian HMM; If we integrate out the parameters Î¸ = (Ï„, Ï‰), we get: Use these distributions to find $P(t|w)$ using an estimation method called Gibbs sampling. Results: Integrating over parameters is useful in itself, even with uninformative priors $(Î± = Î² = 1)$; æ€»ç»“ï¼šÂ· Bayesian HMM improves performance by averaging out uncertainty;Â· allows us to use priors that favor sparse solutions as they occur in language data.Â· Using a tag dictionary is also really helpful. We still have no labeled training data, but if we only allow each word to be tagged with one of the labels that appears in the dictionary, then most word-tag pairs will have probability zero. So this is a very different way of supplying information to the unsupervised model that is very effective. Bias in NLPThe social impact of NLPOutcome of an NLP experiment can have a direct effect on peopleâ€™s lives, e.g. é¢‘ç¹å‡ºçŽ°äºšé©¬é€Š Alexa çªç„¶å‘å‡ºè¯¡å¼‚ç¬‘å£°ï¼Œç»™å¤šåç”¨æˆ·é€ æˆå›°æƒ‘å’Œææ…Œ, å› ä¸ºäººä»¬è°ˆè¯ä¸­å¶ç„¶åŒ…å« trigger è¯ï¼šâ€Alexa, laughâ€ è€Œå‘å‡º - äºšé©¬é€Šçš„è§£å†³æ–¹æ¡ˆæ˜¯æŠŠ trigger æ”¹ä¸ºæ›´éš¾è§¦å‘çš„ â€œAlexa, can you laughâ€ Chatbot å¯¹äºŽäººä»¬æ•æ„Ÿé—®é¢˜çš„ä¸æ°å½“å›žç­”, æ¯”å¦‚ â€œShould I kill myself?â€ - â€œYes.â€ï¼Œè¿™äº›å›žç­”å¯¹æ‚£æœ‰å¿ƒç†éšœç¢çš„äººç¾¤æˆ–è€…é’å°‘å¹´å„¿ç«¥å¸¦æ¥éžå¸¸å¤§çš„å±å®³ã€‚ Microsoft çš„ AI chatbot ä¸Šçº¿ä»…ä¸€å¤©, å°±é€šè¿‡ twitter å’Œäººäº¤è°ˆå¹¶å­¦ä¼šæ¶‰åŠç§æ—, æ€§åˆ«æ­§è§†ç­‰çš„è¯è¯­, å…¸åž‹çš„ â€œgarbage in, garbage outâ€ çŽ°è±¡. å…¶ä»–æ¶‰åŠæ•°æ®éšç§ç­‰é—®é¢˜ è¯­è¨€çš„ç‰¹æ€§ï¼Œå¯¼è‡´NLPæ¶‰åŠçš„ç¤¾ä¼šä¼¦ç†é—®é¢˜éžå¸¸å¤š, è€Œä¸”å½±å“éžå¸¸å¤§ï¼šÂ· è¯­è¨€ä¼ é€’ç€ä¿¡æ¯ã€åè§ï¼Œæ˜¯æ”¿æ²»æ€§çš„ã€æƒåŠ›çš„å·¥å…·, åŒæ—¶æ¯”å…¶ä»–æŠ€æœ¯å¸¦æœ‰æ›´æ˜Žæ˜¾çš„æ‹ŸäººåŒ–ã€äººæ ¼åŒ–å€¾å‘ï¼Œè¿™å¯èƒ½ç»™ä¸ªäººç”Ÿæ´»å¸¦æ¥ä¸ä¾¿æˆ–å±å®³ï¼Œç»™æ•´ä¸ªç¤¾ä¼šå¸¦æ¥èˆ†è®ºå½±å“ã€‚Â· Any dataset carries demographic bias: latent information about the demographics of the people that produced it. That excludes people from other demographics. åŒæ—¶äººç±»æœ¬èº«çš„è®¤çŸ¥å®¹æ˜“åŠ æ·±åè§:The availability heuristic: the more knowledge people have about a specific topic, the more important they think it must be. Topic overexposure creates biases that can lead to discrimination and reinforcement of existing biases. E.g. NLP focused on English may be self-reinforcing. NLP å®žéªŒæœ¬èº«å®¹æ˜“åŠ æ·±åè§ï¼šâ€¢ Advanced grammar analysis can improve search and educational NLP, but also reinforce prescriptive linguistic norms.â€¢ Stylometric analysis can help discover provenance of historical documents, but also unmask anonymous political dissenters. NLP æŠ€æœ¯å¯èƒ½è¢«ä¸æ°å½“åœ°ä½¿ç”¨ï¼šâ€¢ Text classification and IR can help identify information of interest, but also aid censors.â€¢ NLP can be used to discriminate fake reviews and news, and also to generate them. Word embeddings contain human-like biasesword2vec learns semantic/ syntactic relationships, also keep company with unsavoury stereotypes and biases?â€¢ Man:Woman - King:Queenâ€¢ Man:Doctor - Woman:Nurseâ€¢ Man:Computer Programmer - Woman:Homemaker Measure bias using implicit association tests:1, Compute similarity of group1 and stereotype1 word embeddings. Cosine similarity is use to measure association (in place of reaction time).2, Compute similarity of group1 and stereotype 2 word embeddings.3, Null hypothesis: if group1 is not more strongly associated to one of the stereotypes, there will be no difference in the means.4, Effect size measured using Cohenâ€™s d.5, Repeat for group 2. Experimentsâ€¢ Uses GloVe trained on Common Crawlâ€”a large-scale crawl of the web.â€¢ Removed low frequency names.â€¢ Removed names that were least â€œname-likeâ€ (e.g. Will) algorithmically.â€¢ Each concept is represented using a small set of words, designed for previous experiments in the psychology literature. Result:Â· flowers associate with pleasant, insects associate with unpleasant. $p &lt; 10^{âˆ’7}$Â· Menâ€™s names associate with career, womenâ€™s names associate with family. $p &lt; 10^{âˆ’3}$Â· European American names associate with pleasant, African American names associate with unpleasant. $p &lt; 10^{âˆ’8}$ è¿™äº›ç»“æžœçš„ç¡®çœŸå®žåœ°åæ˜ äººç±»ç¤¾ä¼šçš„çŽ°çŠ¶ã€‚ä½†å¤§éƒ¨åˆ†æ€§åˆ«æ–¹é¢çš„åè§å…¶å®žæ˜¯åæ˜ äº†ç›®å‰çš„ç¤¾ä¼šåˆ†å·¥ï¼Œæ— æ‰€è°“é«˜ä½Žè´µè´±ï¼›äººç§çš„åè§å€’æ˜¯åæ˜ äº†åŽ†å²é—®é¢˜å¯¹çŽ°åœ¨çš„å½±å“ï¼Œè¿™ç§åè§æ˜¯ä¸ç¬¦åˆé“å¾·çš„ã€‚äººå¯¹äºŽå…¶ä»–ç”Ÿç‰©çš„åè§ï¼Œè™½ç„¶æ˜¯æ²¡å¿…è¦çš„ï¼Œä½†äººç±»çš„ç¡®å€¾å‘äºŽå–œçˆ±è¡Œä¸ºâ€å¯çˆ±â€ï¼Œå¤–å½¢â€ç¾Žå¥½â€çš„ç”Ÿç‰©ï¼Œæ¯”å¦‚å¤§ç†ŠçŒ«å°±æ˜¯æ¯”é³„é±¼å—æ¬¢è¿Žã€‚ åè§çš„å­˜åœ¨ä¸ä¸€å®šåˆç†ã€‚å“ªäº›åè§æ˜¯ä¸åˆç†çš„ï¼Œæ‰æ˜¯äººä»¬æ›´åº”è¯¥åŽ»æ€è€ƒå’Œè®¨è®ºçš„åœ°æ–¹ã€‚ Debiasing word embeddingsBolukbasi. et. al., 2016. Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddingsæä¾›äº†ä¸€ä¸ªæ€è·¯: ç¡®è®¤åè§çš„æ–¹å‘ ä¸­å’ŒæŠµæ¶ˆåè§: å¯¹äºŽéžå®šæ€§çš„è¯ï¼ˆå¦‚â€åŒ»ç”Ÿâ€ï¼‰ï¼Œé€šè¿‡æŠ•å°„æ¥æ¶ˆé™¤åè§ ç­‰ä»·ï¼šè®©father - motherå’Œboy - girlç­‰è·ï¼Œè®©å®šæ€§è¯é—´çš„è·ç¦»åªæœ‰æ€§åˆ«çš„è·ç¦»ï¼›æˆ–è€…è®©doctor - womanå’Œdoctor - manç­‰è·ï¼Œæ¶ˆé™¤éžå®šæ€§è¯çš„æ€§åˆ«åè§ã€‚ ä»€ä¹ˆè¯éœ€è¦æŠµæ¶ˆåè§: è®­ç»ƒä¸€ä¸ªçº¿æ€§åˆ†ç±»å™¨æ¥ç¡®å®šè¯æ˜¯éžå®šæ€§è¿˜æ˜¯éžå®šæ€§çš„, ç»“æžœå½“ç„¶æ˜¯å¤§éƒ¨åˆ†è‹±è¯­è¯éƒ½æ˜¯éžå®šæ€§çš„. If analogies reveal a gender dimension, use analogies on specific seed pairs to find it.y è½´ä¸‹é¢çš„è¯å±žäºŽå®šæ€§è¯, ä¸éœ€è¦ä¸­æ€§åŒ–, è€Œyè½´ä¹‹ä¸Šçš„è¯åˆ™éœ€è¦è¿›è¡Œä¸­æ€§åŒ–å¤„ç†. ä¸åŒçš„åè§, éœ€è¦ä¸åŒçš„ seed words; ä¸€ç§åè§, å¯ä»¥æœ‰å¤šç§ seed words é€‰æ‹©: é™¤äº†ç”¨â€She-Heâ€ä½œä¸ºæ€§åˆ«åè§çš„åŸºå‡†, è¿˜æœ‰å…¶ä»–é€‰æ‹©. ç¼–ç å™¨â€”è§£ç å™¨ Sequence-to-sequence å’Œæ³¨æ„åŠ›æœºåˆ¶å½“è¾“å…¥è¾“å‡ºéƒ½æ˜¯ä¸å®šé•¿åºåˆ—æ—¶, æ¯”å¦‚æœºå™¨ç¿»è¯‘è¿™ç§ä»»åŠ¡ï¼Œéœ€è¦ä½¿ç”¨ Sequence-to-sequenceï¼ˆseq2seqï¼‰æˆ–è€… encoder-decoder ç¥žç»ç½‘ç»œç»“æž„ã€‚è¿™ç§ç»“æž„å¯ä»¥é€šè¿‡ä¸€ç§æ–¹æ³•å«æ³¨æ„åŠ›æœºåˆ¶æ¥æ˜¾è‘—æé«˜æ€§èƒ½ã€‚ ç¼–ç å™¨â€”è§£ç å™¨ Sequence-to-sequenceï¼ˆseq2seqï¼‰ç¼–ç å™¨ï¼šæ‰€è°“ç¼–ç ï¼Œå°±æ˜¯æŠŠä¸å®šé•¿çš„è¾“å…¥åºåˆ—è¾“å…¥RNNï¼Œä»¥å¾—å‡ºæŸç§å®šé•¿çš„ç¼–ç ä¿¡æ¯ã€‚è§£ç å™¨ï¼šæ‰€è°“è§£ç ï¼Œå°±æ˜¯æŠŠç¼–ç å™¨ç¼–ç åŽçš„ä¿¡æ¯ï¼ˆä¸€èˆ¬å–ç¼–ç å™¨çš„RNNæœ€ç»ˆæ—¶åˆ»çš„éšå«å±‚å˜é‡ï¼‰è¾“å…¥åˆ°è§£ç å™¨çš„RNNä¸­ï¼Œæ¯ä¸ªtæ—¶åˆ»çš„è¾“å‡ºæ—¢å–å†³äºŽä¹‹å‰æ—¶åˆ»ï¼ˆt-1ï¼‰çš„è¾“å‡ºåˆå–å†³äºŽç¼–ç ä¿¡æ¯ã€‚ç­‰åŒäºŽä¸€ä¸ªä»¥è§£ç ä¿¡æ¯ä½œä¸ºæ¡ä»¶æ¦‚çŽ‡ç”Ÿæˆç›®æ ‡è¯­è¨€å¥å­çš„è¯­è¨€æ¨¡åž‹ã€‚ æ‰€ä»¥ seq2seq æœ¬è´¨æ˜¯ä¸€ä¸ªæ¡ä»¶æ¦‚çŽ‡è¯­è¨€æ¨¡åž‹ï¼šè¯­è¨€æ¨¡åž‹æ˜¯æŒ‡è§£ç å™¨æ¯æ¬¡ä¼šé¢„æµ‹ä¸‹ä¸€ä¸ªå‡ºçŽ°çš„å•è¯ï¼Œæ¡ä»¶æ¦‚çŽ‡æ˜¯æŒ‡é¢„æµ‹æ˜¯åŸºäºŽç¼–ç åŽçš„æºå¥å­ã€‚ æ³¨æ„åŠ›åœ¨ä¼ ç»Ÿçš„seq2seqæ¨¡åž‹ä¸­ï¼Œè§£ç å™¨å„ä¸ªæ—¶åˆ»éƒ½ä½¿ç”¨ç›¸åŒçš„ç¼–ç ä¿¡æ¯ï¼Œè¿™å°±è¦æ±‚è§£ç å™¨æŠŠæºè¾“å…¥åºåˆ—çš„æ‰€æœ‰ä¿¡æ¯éƒ½è§£ç å¹¶æ•´åˆåˆ°æœ€åŽæ—¶åˆ»çš„éšå«çŠ¶æ€ä¸­ï¼Œè¿™ä¸ªæ˜¯å¾ˆå¤§çš„ä¿¡æ¯ç“¶é¢ˆã€‚è€Œäººä»¬çŸ¥é“ï¼Œåœ¨å®žé™…ä»»åŠ¡ä¸­ï¼Œæ¯”å¦‚æœºå™¨ç¿»è¯‘ï¼Œç›®æ ‡å¥å­çš„ä¸åŒå•è¯ï¼Œä¸€èˆ¬åªå¯¹åº”æºå¥å­çš„æŸä¸€éƒ¨åˆ†è€Œå·²ã€‚å¦‚æžœèƒ½å¤Ÿè®©è§£ç å™¨åœ¨è§£ç æ—¶ï¼Œåœ¨ä¸åŒæ—¶åˆ»ä¸“æ³¨äºŽæºè¾“å…¥åºåˆ—çš„ä¸åŒéƒ¨åˆ†ï¼Œé‚£ä¹ˆå°±å¯ä»¥çªç ´è¿™ä¸ªç“¶é¢ˆã€‚ å¯¹äºŽè§£ç å™¨çš„æ¯ä¸€æ—¶é—´æ­¥çš„éšå«çŠ¶æ€stï¼Œå¯ä»¥è¡¡é‡å…¶ä¸Žç¼–ç å™¨çš„æ‰€æœ‰æ—¶é—´æ­¥éšå«çŠ¶æ€h0â€¦â€¦etçš„ç›¸ä¼¼æ€§(æˆ–scoreè¯„åˆ†) e = Î±(s, h)ï¼Œç®€å•çš„è¯„åˆ†æ–¹å¼æ˜¯å…ƒç´ é—´ç›¸ä¹˜, e = s*hï¼ˆBahanauçš„è®ºæ–‡æä¾›äº†æ›´å¤æ‚çš„å½¢å¼), ä¹Ÿå¯ä»¥å‚è€ƒè®ºæ–‡Effective Approaches to Attention-based Neural Machine TranslationæŽ¢è®¨çš„é›†ä¸­è¯„åˆ†æ–¹å¼, è¿™ç¯‡è®ºæ–‡æä¾›äº†ä¸€ç§ Bilinear å½¢å¼çš„ç›¸ä¼¼æ€§è¯„åˆ†æ³•, å°±æ˜¯åœ¨så’Œhä¹‹é—´ä»¥ç‚¹ä¹˜çš„å½¢å¼æ’å…¥ä¸€ä¸ªäº¤äº’çŸ©é˜µ interaction matrix. å¯¹å¾—å‡ºçš„è¯„åˆ†æ±‚åŠ æƒå¹³å‡a = softmax(e), å¾—å‡ºçš„æƒå€¼åˆ†å¸ƒä¹Ÿç§°æ³¨æ„åŠ›æƒé‡ é€šè¿‡æ³¨æ„åŠ›æƒé‡æŠŠç¼–ç å™¨éšå«çŠ¶æ€åŠ æƒæ±‚å’Œï¼Œå¾—åˆ°æ³¨æ„åŠ›è¾“å‡º A = Î£ah æœ€åŽæŠŠæ³¨æ„åŠ›è¾“å‡ºå’Œå¯¹åº”æ—¶é—´æ­¥çš„è§£ç å™¨éšå«çŠ¶æ€stæ‹¼æŽ¥åœ¨ä¸€èµ· [A;st]ï¼Œä½œä¸ºè§£ç å™¨rnnçš„éšå«å±‚.]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Accelerated Natural Language Processing]]></title>
    <url>%2FUoE-anlp%2F</url>
    <content type="text"><![CDATA[çˆ±ä¸å ¡å¤§å­¦ä¿¡æ¯å­¦é™¢è¯¾ç¨‹ç¬”è®° Accelerated Natural Language Processing, Informatics, University of Edinburgh References:Accelerated natural language processingANLP revision guideLecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning æ¦‚çŽ‡æ¨¡åž‹ Probability Modelæ¦‚çŽ‡æ¨¡åž‹æ˜¯éšæœºçŽ°è±¡çš„æ•°å­¦è¡¨ç¤ºï¼Œç”±æ ·æœ¬ç©ºé—´ï¼Œæ ·æœ¬ç©ºé—´å†…çš„äº‹ä»¶ä»¥åŠä¸Žæ¯ä¸ªäº‹ä»¶ç›¸å…³çš„æ¦‚çŽ‡å®šä¹‰ã€‚ç›®æ ‡æ˜¯æ¨¡æ‹Ÿç»™ä¸€ä¸ªäº‹ä»¶å‘ç”Ÿçš„æ¦‚çŽ‡ ä¼°ç®—æ¦‚çŽ‡ï¼ˆProbability Estimationï¼‰ä¸€èˆ¬ä½¿ç”¨æœ€å¤§ä¼¼ç„¶ä¼°è®¡ï¼ˆMLEï¼Œç›¸å…³é¢‘çŽ‡ï¼‰ï¼š$$p(x_i) = \frac{Count(x_i)}{\sum_{i=0}^nCount(x_i)}$$ å¹³æ»‘Smoothingä¸€èˆ¬ç”¨äºŽå¤„ç†0æ¦‚çŽ‡çš„é—®é¢˜ï¼Œæ¯”å¦‚åœ¨è®­ç»ƒé›†ä¸­çœ‹ä¸åˆ°, ä½†å‡ºçŽ°åœ¨æµ‹è¯•é›†ä¸­çš„è¯ã€‚ Language modelingTo compute the probability of sentence /sequence of words $P(w_1, w_2, w_3â€¦)$, or to predict upcomming words $P(w|w_1, w_2, w_3â€¦)$â€¦ a language model is also a probability model. Probability computation makes use of chain rule of probability, the products of a sequence of conditional probability.$$P(w_{1:n}) = P(w_1)P(w_2|w_1)P(w_3|w_{1:2})P(w_4|w_{1:3})â€¦P(w_n|w_{1:n-1})$$ But the last term based on the entire sentence is very difficult to compute. So it is simplified by Markov Assumption: approximate the conditional probability by only accounting several prefixes, a one-order Markov assumption simplifies as P(the| water is so transparent that) â‰ˆ P(the| that)$$\begin{align}P(w_{1:n}) &amp;= \prod_{i=1}^n P(w_i | w_1, â€¦, w_{i-1}) \\&amp;\propto \prod_{i=1}^n P(w_i | w_{i-k}, â€¦, w_{i-1}) \end{align}$$Evaluation: Perplexity PerplexityIntuition based on Shannon game: The best language model is one that best predicts an unseen test set(e.g. next word), gives the highest $P(sentence)$ to the word that actually occurs. Definition: Perplexity is the inverse probability of the test set, normalized by the number of words(lie between 0-1). Normalize the log probability of all the test sentences:$$\frac{1}{M} \log_2 \prod_{i=1}^m p(x^{(i)}) = \frac{1}{M} \sum_{i=1}^m \log_2 p(x^{(i)})$$Then transform to perplexity:$$Perplexity = 2^{-\frac{1}{M} \sum_{i=1}^m \log_2 p(x^{(i)})}$$So minimizing perplexity is the same as maximizing probability Bad approximation: unless the test data looks just like the training data, so generally only useful in pilot experiments. N-Gram Language ModelN-Gramè¯­è¨€æ¨¡åž‹æ˜¯åŸºäºŽN-1é˜¶é©¬å°”å¯å¤«å‡è®¾ä¸”ç”±MLEä¼°ç®—å‡ºçš„LMã€‚N-GramLM é¢„æµ‹ä¸‹ä¸€ä¸ªå•è¯å‡ºçŽ°æ¦‚çŽ‡ä»…æ¡ä»¶äºŽå‰é¢çš„(N-1)ä¸ªå•è¯, ä»¥The students opened their booksä¸ºä¾‹: Bi-gram: ç»Ÿè®¡$P(w_{i}=m|w_{i-1})$, P(students | the), P(opened | students), â€¦, å±žäºŽé©¬å°”å¯å¤«ä¸€é˜¶æ¨¡åž‹, å³å½“å‰tæ—¶é—´æ­¥çš„çŠ¶æ€ä»…è·Ÿt-1ç›¸å…³. Tri-gram: P(students | &lt;/s&gt; The), P(opened | The students), é©¬å°”å¯å¤«äºŒé˜¶æ¨¡åž‹ Four-gram: ä¾æ­¤ç±»æŽ¨ ç‰¹æ®Šçš„Uni-gram: ç»Ÿè®¡$P(w_i)$, P(the), P(students), â€¦, æ­¤æ—¶æ•´ä¸ªæ¨¡åž‹é€€åŒ–ä¸ºè¯è¢‹æ¨¡åž‹, ä¸å†å±žäºŽé©¬å°”å¯å¤«æ¨¡åž‹, è€Œæ˜¯åŸºäºŽè´å¶æ–¯å‡è®¾, å³å„ä¸ªå•è¯æ˜¯æ¡ä»¶ç‹¬ç«‹çš„. æ‰€ä»¥ä¸€èˆ¬N-gramæ˜¯æŒ‡N&gt;1çš„. How to estimate theparameter?Maximum likelyhood estimateï¼š$$P(w_{i}=m|w_{i-n:i-1}) = \frac{Count(w_{i-n:i})}{Count(w_{i-n:i-1})}$$ In practice, use log space to avoid underflow, and adding is faster than multiplying. Insufficient: To catch long-distance dependencies, the n has to be very large, that asks for very large memory requirement N-grams only work well for word prediction if the test corpus looks like the training corpus. Sparsity: Zero count of gram, means zero probability? No. To deal with 0 probability, commonly use Kneser-Ney smoothing, for very large N-grams like web, use stupid backoff. Add Alpha Smoothing Assign equal probability to all unseen events. Applied in text classification, or domains where zeros probability is not common. Backoff Smoothing Use information from lower order N-grams (shorter histories) Back off to a lower-order N-gram if we have zero evidence for a higher-order interpolation N-gram. Discount: In order for a backoff model to give a correct probability distribution, we have to discount the higher-order N-grams to save some probability mass for the lower order N-grams. Interpolation Smoothing Interpolation: mix the probability estimates from all the N-gram estimators, weighing and combining the trigram, bigram, and unigram counts Simple interpolation: $P(w_3|w_1, w_2) = \lambda_1 P(w_3|w_1, w_2) + \lambda_2 P(w_3|w_2) + \lambda_3 P(w_3), \sum \lambda = 1$. Î» could be trianed/conditioned on training set/contest, choose Î» that maximie the probability of held-out data Kneser-Ney Smoothing Combine absolute discounting and interpolation: Extending interpolatation with an absolute discounting 0.75 for high order grams. Use a better estimate for probabilities of lower-order unigrams, the continuation probability, $P_{continuatin}(w)$ is how likely is w to appear as a novel continutaion. For each word w, count the number of bigram types it completes. Or count the number of word types seen to precede w. Every bigram type was a novel continuation the first time it was seen. normalized by the total number of word bigram types. To lower the probability of some fix bigram like â€œSan Franscioâ€ For general N-gram, Naive Bayes Classifier Application: Text classification, to classify a text, we calculate each class probability given the test sequence, and choose the biggest one. Evaluation: precision, recall, F-measure Strength and Weakness: é«˜æ•ˆ, å¿«é€Ÿ, ä½†å¯¹äºŽç»„åˆæ€§çš„çŸ­è¯­è¯ç»„, å½“è¿™äº›çŸ­è¯­ä¸Žå…¶ç»„æˆæˆåˆ†çš„å­—çš„æ„æ€ä¸åŒæ—¶, NBçš„æ•ˆæžœå°±ä¸å¥½äº† Text ClassificationOr text categorization, method is not limited to NB, see lab7.Spam email, gender/authorship/language identification, sentiments analysis,(opinion extraction, subjectivity analysis)â€¦ Sentiments Analysis For sentiment(or other text classification), word occurrence may matter more than word frequency. Thus it often improves performance to clip the word counts in each document at 1. This variant binary NB is called binary multinominal naive Bayes or binary NB. Remove duplicates in each data sample - bag of words representation, boolean features. Binarized seems to work better than full word counts. Deal with negation: like, not like, A very simple baseline that is commonly used in sentiment to deal with negation is during text normalization to prepend the prefix NOT_ to every word after a token of logical negation Sentiment lexicons: lists of words that are preannotated with positive or negative sentiment. To deal with insufficient labeled training data. A common way to use lexicons in the classifier is to use as one feature the totalcount of occurrences of any words in the positive lexicon, and as a second feature the total count of occurrences of words in the negative lexicon. Using just two features results in classifiers that are much less sparse to small amounts of training data, and may generalize better. See lab8. Naive Bayes Assumptions Bags of words: a set of unordered words/features with its frequency in the documents, their order was ignored. Conditional independence: the probabilities $P(w|C)$ are independence given the class, thus a sequence of words(w1,w2,w3â€¦) probability coculd be estimate via prducts of each $P(w_i|C)$ by walking through every pisition of the sequence, noted that the orders in the sequence does not matter. Naive Bayes Training Each classesâ€™ prior probability P(C) is the percentage of the classes in the training set. For the test set, its probability as a class j, is the products of its sequence probability $P(w_1, w_2, w_3â€¦|C_j)$ and $P(C_j)$, normalized by the sequence probability $P(w_1, w_2, w_3â€¦)$, which could be calculated by summing all $P(w_1, w_2, w_3â€¦|C_j)*P(C_j)$. The joint features probability $P(w_1, w_2, w_3â€¦|C)$ of each class is calculated by naively multiplying each wordâ€™s MLE given that class. In practice, to deal with 0 probability, we dun use MLE, instead we use add alpha smoothing. Why 0 probability matters? Because it makes the whole sequence probability $P(w_1, w_2, w_3â€¦|C)$ 0, then all the other features as evidence for the class are eliminated too. How: first extract all the vocabulary V in the training set. Then, for each feature/word k, its add alpha smoothing probability estimation within a class j is $(Njk + \alpha)/(N_j+V*\alpha)$. This is not the actual probability, but just the numerator. Naive Bayes Relationship to Language Modelling When using all of the words as features for naive bayes, then each class in naive bayes is a unigram languange model. For each word, assign probability $P(word|C)$, For each sentence, assign probability $P(S|C) = P(w_1, w_2, w_3â€¦|C)$ Running multiple languange models(classes) to assign probabilities, and pick out the highest language model. Hidden Markov ModelThe HMM is a probabilistic sequence model: given a sequence of units (words, letters, morphemes, sentences, whatever), they compute a probability distribution over possible sequences of labels and choose the best label sequence. HMMå‚æ•°$Î»= (Y, X, Ï€, A, B)$ : Yæ˜¯éšçŠ¶æ€ï¼ˆè¾“å‡ºå˜é‡ï¼‰çš„é›†åˆ Xæ˜¯è§‚å¯Ÿå€¼ï¼ˆè¾“å…¥ï¼‰é›†åˆ Initial probability Ï€ Transition probability matrix A, $P(Tag_{i+1} | Tag_{i})$ Emission probability B, $P(Word | Tag)$ Application: part-of-speech tagging, name entity recognition(NEr), parse tree, speech recognition Hidden?: these tags, trees or words is not observed(hidden). bæ¯”å¦‚åœ¨POSä»»åŠ¡ä¸­, Xå°±æ˜¯è§‚å¯Ÿåˆ°çš„å¥å­, Yå°±æ˜¯å¾…æŽ¨å¯¼çš„æ ‡æ³¨åºåˆ—, å› ä¸ºè¯æ€§å¾…æ±‚çš„, æ‰€ä»¥äººä»¬ç§°ä¹‹ä¸ºéšå«çŠ¶æ€. The three fundamental problems of HMM: decoding: discover the best hidden state sequence via Viterbi algorithm. Probability of the observation: Given an HMM with know parameters Î» and an observation sequence O, determine the likelihood $P(O| \lambda)$ (a language model regardless of tags) via Forward algorithm Learning (training): Given only the observed sequence, learn the best(MLE) HMM parameters Î» via forward-backward algorithm, thus training a HMM is an unsupervised learning task. ç®—æ³•: å‰å‘ç®—æ³•å’ŒåŽå‘ç®—æ³•è§£å†³å¦‚ä½•è®¡ç®—ä¼¼ç„¶$P(O| \lambda)$çš„é—®é¢˜ Viterbiç®—æ³•è§£å†³HMM è§£ç é—®é¢˜. è¿™äº›ç®—æ³•éƒ½æ˜¯åŠ¨æ€è§„åˆ’ç®—æ³• HMMçš„ç¼ºé™·æ˜¯å…¶åŸºäºŽè§‚å¯Ÿåºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ç›¸äº’æ¡ä»¶ç‹¬ç«‹çš„å‡è®¾ã€‚å³åœ¨ä»»ä½•æ—¶åˆ»è§‚å¯Ÿå€¼ä»…ä»…ä¸ŽçŠ¶æ€ï¼ˆå³è¦æ ‡æ³¨çš„æ ‡ç­¾ï¼‰æœ‰å…³ã€‚å¯¹äºŽç®€å•çš„æ•°æ®é›†ï¼Œè¿™ä¸ªå‡è®¾å€’æ˜¯åˆç†ã€‚ä½†å¤§å¤šæ•°çŽ°å®žä¸–ç•Œä¸­çš„çœŸå®žè§‚å¯Ÿåºåˆ—æ˜¯ç”±å¤šä¸ªç›¸äº’ä½œç”¨çš„ç‰¹å¾å’Œè§‚å¯Ÿåºåˆ—ä¸­è¾ƒé•¿èŒƒå›´å†…çš„å…ƒç´ ä¹‹é—´çš„ä¾èµ–è€Œå½¢æˆçš„ã€‚è€Œæ¡ä»¶éšæœºåœº(conditional random fiel, CRF)æ°æ°å°±å¼¥è¡¥äº†è¿™ä¸ªç¼ºé™·. åŒæ—¶, ç”±äºŽç”Ÿæˆæ¨¡åž‹å®šä¹‰çš„æ˜¯è”åˆæ¦‚çŽ‡ï¼Œå¿…é¡»åˆ—ä¸¾æ‰€æœ‰è§‚å¯Ÿåºåˆ—çš„å¯èƒ½å€¼ï¼Œè¿™å¯¹å¤šæ•°é¢†åŸŸæ¥è¯´æ˜¯æ¯”è¾ƒå›°éš¾çš„ã€‚ Part-of-speech Tagging Part-of-speech(POS), word classes, or syntactic categories, a description of eight parts-of-speech: noun, verb, adjective, adverb, pronoun, preposition, conjunction, interjection, and sometimes numeral, article or determiner. noun åè©ž (ä»£è™Ÿ n. ) pronoun ä»£åè©ž (ä»£è™Ÿ pron. ) verb å‹•è©ž (ä»£è™Ÿ v. ) adjective å½¢å®¹è©ž (ä»£è™Ÿ adj. ) adverb å‰¯è©ž (ä»£è™Ÿ adv. ) preposition ä»‹ç³»è©ž (ä»£è™Ÿ prep. ) conjunction é€£æŽ¥è©ž (ä»£è™Ÿ conj. ) interjection æ„Ÿæ­Žè©ž (ä»£è™Ÿ int. ) Motivation: Use model to find the best tag sequence T for an untagged sentence S: argmax $P(T|S)$ -&gt; argmax $P(S|T)*P(T)$, where P(T) is the transition (prior) probabilities, $P(S|T)$ is the emission (likelihood) probabilities. Parts-of-speech can be divided into two broad supercategories: closed class types and open class types Search for the best tag sequence: Viterbi algorithm evaluation: tag accuracy ä½¿ç”¨HMMå¤„ç†POSä»£ç  Transition Probability Matrix Tags or states Each (i,j) represent the probability of moving from state i to j When estimated from sequences, should include beginning &lt;s&gt; and end &lt;/s&gt; markers. Tag transition probability matrix: the probability of tag i followed by j Emission Probability Also called observation likelihoods, each expressing the probability of an observation j being generated from a states i. Word/symbol Penn Treebank Forward Algorithm Compute the likelihood of a particular observation sequence. Implementation is almost the same as Viterbi. Yet Viterbi takes the max over the previous path probabilities whereas the forward algorithm takes the sum. Viterbi AlgorithmDecoding task: the task of determining which sequence of variables is the underlying source of some sequence of observations. Viterbiçš„å®žçŽ°å‚è€ƒHMM POS Tagging Intuition: The probability of words $w_1$ followed by $w_2$ with tag/state i and j (i,j is index of all Tags), is the chain rule of the probability of i followed by j and the probability of i output $w_i$ $P(w_1 | i)$ and $P(w_2 |j)$, then choose the maximum from all the possible i j. Then using chain rule to multiply the whole sequence of words. The value of each cell $Vt(j)$ is computed by recursively taking the most probable path that could lead us to this cell from left columns to right. See exampls in tutorial 2 Since HMM based on Markov Assumptions, so the present column $V_t$ is only related with the nearby left column $V_{t-1}$. HMM Trainingç»™å®šè§‚å¯Ÿåºåˆ—$X = x_1, x_2, â€¦, x_t$ ï¼Œè®­ç»ƒè°ƒæ•´æ¨¡åž‹å‚æ•°Î», ä½¿$p(X | \lambda)$æœ€å¤§: Baum-Welchç®—æ³• (Forward-backward algorithm) inputs: just the observed sequence output: the converged Î»(A,B). For each interation k until Î» converged: Compute expected counts using Î»(k-1) Set Î»(k) using MLE on the expected counts. ç»å¸¸ä¼šå¾—åˆ°å±€éƒ¨æœ€ä¼˜è§£. Context-free GrammarCFG(phrase-structure grammar) consists of a set of rules or productions, each of which expresses the ways that symbols of the language can be grouped and ordered toLexicon gether, and a lexicon of words and symbols. ConstituencyPhrase structure, organizes words into nested constituents. Groups of words behaving as a single units, or constituents. Noun phrase(NP), a sequence of words surrounding at least one noun. While the whole noun phrase can occur before a verb, this is not true of each of the individual words that make up a noun phrase Preposed or Postposed constructions. While the entire phrase can be placed differently, the individual words making up the phrase cannot be. Fallback: In languages with free word order, phrase structure(constituency) grammars donâ€™t make as much sense. Headed phrase structure: many phrase has head, VP-&gt;VB, NP-&gt;NN, the other symbols excepct the head is modifyer. Probabilistic Context-free GrammarPCFG(Stochastic Context-Free Grammar SCFG (SCFG)), a probabilistic augmentation of context-free grammars in which each rule is associated with a probability. G = (T,N,S,R,P) T, N: Terminal and Non-terminal S: starts symbol R: Derive rule/grammar, N -&gt; N/C P: a probability function, for a given N, Î£P(N-&gt;Ni/Ci)=1. Normally P(S-&gt;NP VP)=1, because this is the only rule for S. PCFG could generates a sentence/tree, thus it is a language model, assigns a probability to the string of words constituting a sentence The probability of a tree t is the product of the probabilities of the rules used to generate it. The probability of the string s is the sum of the probabilities of the trees/parses which have that string as their yield. The probability of an ambiguous sentence is the sum of the probabilities of all the parse trees for the sentence. Application: Probabilistic parsing Shortage: lack the lexicalization of a trigram model, i.e only a small fraction of the rules contains information about words. To solve this problem, use lexicalized PCFGs Lexicalization of PCFGs The head word of phrase gives a good representation of the phraseâ€™s structure and meaning Puts the properties of words back into a PCFG Word to word affinities are useful for certain ambiguities, because we know the probability of rule with words and words now, e.g. PP attachment ambiguity Recursive Descent ParsingIt is a top-down, depth-first parser: Blindly expand nonterminals until reaching a terminal (word). If multiple options available, choose one but store current stateas a backtrack point (in a stack to ensure depth-first.) If terminal matches next input word, continue; else, backtrack Can be massively inefficient (exponential in sentence length) if faced with local ambiguity Can fall into infinite loop CKY ParsingWell-formed substring table: For parsing, subproblems are analyses of substrings, memoized in well-formed substring table(WFST, chart). Chart entries are indexed by start and end positions in the sentence, and correspond to: either a complete constituent (sub-tree) spanning those positions (if working bottom-up), or a prediction about what complete constituent might be found (if working top-down). The chart is a matrix where cell [i, j] holds information about the word span from position i to position j: The root node of any constituent(s) spanning those words Pointers to its sub-constituents (Depending on parsing method,) predictions about whatconstituents might follow the substring. Probability CKY parsing: Dependency Parsing Motivation: context-free parsing algorithms base their decisions on adjacency; in a dependency structure, a dependent need not be adjacent to its head (even if the structure is projective); we need new parsing algorithms to deal with non-adjacency (and with non-projectivity if present). Approach: Transition-based dependency parsing Dependency SyntaxDependency structure shows which words depend on (modify or are arguments of) which other words. A fully lexicalized formalism without phrasal constituents and phrase-structure rules: binary, asymmetric grammatical relations between words. More specific, head-dependent relations, with edges point from heads to their dependents. Motivation: In languages with free word order, phrase structure (constituency) grammars donâ€™t make as much sense. E.g. we may need both S â†’ NP VP and S â†’ VP NP, but could not tell too much information simply looking at the rule. Dependencies: Identifies syntactic relations directly. The syntactic structure of a sentence is described solely in terms of the words (or lemmas) in a sentence and an associated set of directed binary grammatical relations that hold among the words. Relation between phrase structure and dependency structure Convert phrase structure annotations to dependencies via head rules. (Convenient if we already have a phrase structure treebank.): For a given lexicalized constituency parse(CFG tree), remove the phrasal categories, remove the (duplicated) terminals, and collapse chains of duplicates. The closure of dependencies give constituency from a dependency tree Transition-based Dependency Parsingtransition-based systems use supervised machine learning methods to train classifiers that play the role of the oracle. Given appropriate training data, these methods learn a function that maps from configurations to transition operators(actions). Bottom up Like shift-reduce parsing, but the â€˜reduceâ€™ actions are specialized to create dependencies with head on left or right. configurationï¼šconsists of a stack, an input buffer of words or tokens, and a set of relations/arcs, a set of actions. How to choose the next action: each action is predicted by a discriminative classifier(often SVM, could be maxent) over each legal move. features: a sequence of the correct (configuration, action) pairs f(c ; x). Evaluation: accuracy (# correct dependencies with or ignore label)). Dependency Tree Dependencies from a CFG tree using heads, must be projective: There must not be any crossing dependency arcs when the words are laid out in their linear order, with all arcs above the words. But dependency theory normally does allow non-projective structures to account for displaced constituents. Bounded and Unbounded DependenciesUnbounded dependency could be considered as long distance dependency Long-distance dependencies: contained in wh-non-subject-question, â€œWhat flights do you have from Burbank to Tacoma Washington?â€, the Wh-NP what flights is far away from the predicate that it is semantically related to, the main verb have in the VP. Noisy Channel Model: The intuition of the noisy channel model is to treat the misspelled word as if a correctly spelled word had been â€œdistortedâ€ by being passed through a noisy communication channel. a probability model using Bayesian inference, input -&gt; noisy/errorful encoding -&gt; output, see an observation x (a misspelled word) and our job is to find the word w that generated this misspelled word. $P(w|x) = P(x|w)*P(w)/P(x)$ Noisy channel model of spelling using naive bayes The noisy channel model is to maximize the product of likelihood(probability estimation) P(s|w) and the prior probability of correct words P(w). Intuitively it is modleing the noisy channel that turn a correct word â€˜wâ€™ to the misspelling. The likelihood(probability estimation) P(s|w) is called the the channel/error model, telling if it was the word â€˜wâ€™, how likely it was to generate this exact error. The P(w) is called the language model Generative vs. Discriminative Models Generative(joint) models palce probabilities $p(c, d)$ over both observed data d and the hidden variables c (generate the obersved data from hidden stuff). Discriminative(conditional) models take the data as given, and put a probability over hidden structure given the data, $p(c | d)$. åœ¨æœ´ç´ è´å¶æ–¯ä¸ŽLogistic Regression, ä»¥åŠHMMå’ŒCRFä¹‹é—´, æœ‰ç”Ÿæˆå¼å’Œåˆ¤åˆ«å¼çš„åŒºåˆ«. ç”Ÿæˆå¼æ¨¡åž‹æè¿°æ ‡ç­¾å‘é‡yå¦‚ä½•æœ‰æ¦‚çŽ‡åœ°ç”Ÿæˆç‰¹å¾å‘é‡x, å³å°è¯•æž„å»ºxå’Œyçš„è”åˆåˆ†å¸ƒ$p(y, x)$, å…¸åž‹çš„æ¨¡åž‹æœ‰N-Gramè¯­è¨€æ¨¡åž‹, æœ´ç´ è´å¶æ–¯æ¨¡åž‹ï¼ˆNaive Bayesï¼‰ï¼Œ éšé©¬å°”ç§‘å¤«æ¨¡åž‹ï¼ˆHMMï¼‰, MRFã€‚ è€Œåˆ¤åˆ«æ¨¡åž‹ç›´æŽ¥æè¿°å¦‚ä½•æ ¹æ®ç‰¹å¾å‘é‡xåˆ¤æ–­å…¶æ ‡ç­¾y, å³å°è¯•æž„å»º$p(y | x)$çš„æ¡ä»¶æ¦‚çŽ‡åˆ†å¸ƒ, å…¸åž‹æ¨¡åž‹å¦‚å¦‚LR, SVMï¼ŒCRFï¼ŒMEMMç­‰. Exponential ModelsIt is a family, includes Log-linear, MaxEnt, Logistic Regression models. Make probability model from the linear combination of weights Î» and features f as votes, normalized by the total votes. It is a probabilistic distribution: it estimates a probability for each class/label, aka Softmax. It is a classifier, choose the highest probability label. Application: dependency parsing actions prediction, text classification, Word sense disambiguation Training Discriminative Model Features in NLP are more general, they specify indicator function(a yes/no[0,1] boolean matching function) of properties of the input and each class. Weights: low possibility features will associate with low/negative weight, vise versa. Define features: Pick sets of data points d which are distinctive enough to deserve model parameters: related words, words contians #, words end with ing, etc. Regularization in Discriminative ModelThe issue of scale: Lots of features sparsity: easily overfitting: need smoothing Many features seen in training never occur again in test Optimization problem: feature weights can be infinite, and iterative solvers can take a long time to get to those infinities. See tutorial 4. Solution: Early stopping Smooth the parameter via L2 regularization. Smooth the data, like the add alpha smoothing, but hard to know what artificial data to create Morphology æž„è¯å­¦ï¼ˆè‹±è¯­è¨€å­¦åˆ†ç§‘å­¦åï¼šmorphologyï¼Œâ€œç»„ç»‡ä¸Žå½¢æ€â€)ï¼Œåˆç§°å½¢æ€å­¦ï¼Œæ˜¯è¯­è¨€å­¦çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œç ”ç©¶å•è¯ï¼ˆwordï¼‰çš„å†…éƒ¨ç»“æž„å’Œå…¶å½¢æˆæ–¹å¼ã€‚å¦‚è‹±è¯­çš„dogã€dogså’Œdog-catcheræœ‰ç›¸å½“çš„å…³ç³»ï¼Œè‹±è¯­ä½¿ç”¨è€…èƒ½å¤Ÿåˆ©ç”¨ä»–ä»¬çš„èƒŒæ™¯çŸ¥è¯†æ¥åˆ¤æ–­æ­¤å…³ç³»ï¼Œå¯¹ä»–ä»¬æ¥è¯´ï¼Œdogå’Œdogsçš„å…³ç³»å°±å¦‚åŒcatå’Œcatsï¼Œdogå’Œdog-catcherå°±å¦‚åŒdishå’Œdishwasherã€‚æž„è¯å­¦æ­£æ˜¯ç ”ç©¶è¿™ç§å•å­—é—´ç»„æˆçš„å…³ç³»ï¼Œå¹¶è¯•ç€æ•´ç†å‡ºå…¶ç»„æˆçš„è§„åˆ™ã€‚ Morphemes: The way words are built up from smaller meaning-bearing units. Lemma: Lexeme, refers to the set of all the forms that have the same meaning, lemma: refers to the particular form that is chosen by convention to represent the lexeme. E.g: run, runs, ran, running are forms of the same lexeme, with run as the lemma. Affixes: Adding additional meanings of various kinds. â€œ+ed, un+â€ suffix : follow the stem Plural of nouns â€˜cat+sâ€™ Comparative and superlative of adjectives â€˜small+erâ€™ Formation of adverbs â€˜great+lyâ€™ Verb tenses â€˜walk+edâ€™ All inflectional morphology in English uses suffixes Prefix: precede the stem In English: these typically change the meaning Adjectives â€˜un+friendlyâ€™, â€˜dis+interestedâ€™ Verbs â€˜re+considerâ€™ Some language use prefixing much more widely Infix: inserted inside the stem Circumfix: do both(follow, precede) Root, stem and base are all terms used in the literature to designate that part of a word that remains when all affixes have been removed. The root word is the primary lexical unit of a word, and of a word family (this root is then called the base word), which carries the most significant aspects of semantic content and cannot be reduced into smaller constituents. E.g: In the form â€˜untouchablesâ€™ the root is â€˜touchâ€™, to which first the suffix â€˜-ableâ€™, then the prefix â€˜un-â€˜ and finally the suffix â€˜-sâ€™ have been added. In a compound word like â€˜wheelchairâ€™ there are two roots, â€˜wheelâ€™ and â€˜chairâ€™. Stem is of concern only when dealing with inflectional morphology Stemming: reduce terms to their stems in info retrieval, E.g: In the form â€˜untouchablesâ€™ the stem is â€˜untouchableâ€™, â€˜touchedâ€™ -&gt; â€˜touchâ€™; â€˜wheelchairsâ€™ -&gt; â€˜wheelchairâ€™. Morphological ParsingUse Finite-state transducers, FST, a transducer maps between one representation and another; It is a kind of FSA which maps between two sets of symbols. Inflectional vs. Derivational MorphologyInflectionalÂ· nouns for count (plural: +s) and for possessive case (+â€™s)Â· verbs for tense (+ed, +ing) and a special 3rd person singular present form (+s)Â· adjectives in comparative (+er) and superlative (+est) forms. DerivationalÂ· Changing the part of speech, e.g. noun to verb: â€˜word â†’ wordifyâ€™Â· Changing the verb back to a nounÂ· Nominalization: formation of new nouns, often verbs or adjectives Inflectional Derivational does not change basic meaning or part of speech may change the part of speech or meaning of a word expresses grammatical features or relations between words not driven by syntactic relations outside the word applies to all words of the same part of speech, inflection occurs at word edges: govern+ment+s, centr+al+ize+d applies closer to the stem Challenge of Rich MorphologyFor a morphologically rich language, many issues would arise because of the morphological complexity. These productive word-formation processes result in a large vocabulary for these languages Large vocabularies mean many unknown words, and these unknown words cause significant performance degradations in a wide variety of languages For POS, augmentations become necessary when dealing with highly inflected or agglutinative languages with rich morphology like Czech, Hungarian and Turkish., part-of-speech taggers for morphologically rich languages need to label words with case and gender information. Tagsets for morphologically rich languages are therefore sequences of morphological tags rather than asingle primitive tag. Dependency grammar is better than constituency in dealing with languages that are morphologically richã€‚ Linguistic and Representational ConceptsParsing Parsing is a combination of recognizing an input string and assigning a correct linguistic structure/tree to it based on a grammar. The Syntactic, Statistical parsing are constituent-based representations(context-free grammars). The Dependency Parsing are based on dependency structure(dependency grammars). Syntactic ParsingSyntactic parsing, is the task of recognizing a sentence and assigning a correct syntactic structure to it. Syntactic parsing can be viewed as a search search space: all possible trees generated by the grammar search guided by the structure of the space and the input. search direction top-down: start with root category (S), choose expansions, build down to words. bottom-up: build subtrees over words, build up to S. Search algorithm/strategy: DFS, BFS, Recursive descent parsing, CKY Parsing Challenge: Structual Ambiguity Statistical ParsingOr probabilistic parsing, Build probabilistic models of syntactic knowledge and use some of this probabilistic knowledge to build efficient probabilistic parsers. motivation: to solve the problem of disambiguation algorithm: probability CKY parsing evaluation: Compare the output constituency parser with golden standard tree, a constituent(part of the output parser) marked as correct if it spans the same sentence positions with the corresponding constituent in golder standard tree. Then we get the precision, recall and F1 measure. constituency: S-(0:10), NP-(0:2), VP-(0:9)â€¦ Precission = (# correct constituents)/(# in parser output), recall = (# correct constituents)/(# in gold standard) Not a good evaluation, because it higher order constituent is marked wrong simply it contains a lower level wrong constituent. Dependency ParsingConstituencyDependencyMorphologyAmbiguity Structural ambiguity: Occurs when the grammar can assign more than one parse to a sentence. Attachment ambiguity: A sentence has an attachment ambiguity if a particular constituent can be attached to the parse tree at more than one place. Coordination ambiguity: different sets of phrases can be conjoined by a conjunction like and. E.g green egg and bread. Coordination: The major phrase types discussed here can be conjoined with conjunctions like and, or, and but to form larger constructions of the same type. Global and local ambiguity global ambiguity: multiple analyses for a full sentence, like I saw the man with the telescope local ambiguity: multiple analyses for parts of sentence. the dog bit the child: first three words could be NP (but arenâ€™t). Building useless partial structures wastes time. Open-class Closed-classClosed classes are those with relatively fixed membership prepositions: on, under, over, near, by, at, from, to, with determiners: a, an, the pronouns: she, who, I, others conjunctions: and, but, or, as, if, when auxiliary verbs: can, may, should, are particles: up, down, on, off, in, out, at, by numerals: one, two, three, first, second, third Open-class Nouns, verbs, adjectives, adverbs Word SenseA discrete representation of an aspect of a wordâ€™s meaning.How: Distributional semantic models Collocation: A sequence of words or terms that co-occur more often than would be expected by chance. Synonym: ä»£åè¯, When two senses of two different words (lemmas) are identical, or nearly identical, the two senses are synonyms. E.g. couch/sofa vomit/throw up filbert/hazelnut car/automobile Similarity: Or distance, a looser metric than synonymy.Two ways to measure similarity: Thesaurusè¯åº“-based: are words nearby in hypernym hierarchy? Do words have similar definitions? Distributional: do words have similar distributional contexts Hyponym: ä¸‹ä¹‰è¯, One sense is a hyponym of another sense if the first sense is more specific, denoting a subclass of the other. E.g. car is a hyponym of vehicle; dog is a hyponym of animal, and mango is a hyponym of fruit. Hypernym: Superordinate, ä¸Šä½è¯, vehicle is a hypernym of car, and animal is a hypernym of dog. Word Sense DisambiguationWSD, The task of selecting the correct sense for a word, formulated as a classification task. Chose features: Directly neighboring words, content words, syntactically related words, topic of the text, part-of-speech tag, surrounding part-of-speech tags, etc â€¦ Distributional Semantic ModelsVector semantics(embeddings): The meaning of a word is represented as a vector. Two words are similar if they have similar word contexts vector. Term-context matrix(Co-occurrence Matrices): a word/term is defined by a vector over counts of context words. The row represent words, columns contexts. Problem: simple frequency isnâ€™t the best measure of association between words. One problem is that raw frequency is very skewed and not very discriminative. â€œtheâ€ and â€œofâ€ are very frequent, but maybe not the most discriminative. Sulution: use Pointwise mutual information. Then the Co-occurrence Matrices is filled with PPMI, instead of raw counts. Measuring vectors similarity based on PPMI: Dot product(inner product): More frequent words will have higher dot products, which cause similarity sensitive to word frequency. Cosine: normalized dot product , Raw frequency or PPMI is non-negative, so cosine range [0,1]. Evaluation of similarity Intrinsic: correlation between algorithm and human word similarity ratings. Check if there is correlation between similarity measures and word frequency. Application: sentiment analysis, see lab8 Pointwise Mutual InformationPMI: do events x and y co-occur more than if they were independent? PMI between two words: $$PMI(w, c) = \log_2 \frac{P(w,c)}{P(W)P(c)}$$ Compute PMI on a term-context matrix(using counts): $$PMI(x, y) = log_2 \frac{N \times count(x, y)}{Count(x) Count(y)}$$1234p(w=information, c=data) = 6/19p(w=information) = 11/19p(c=data) = 7/19PMI(information,data) = log2(6*19/(11*7)) PMI is biased towards infrequent events, solution: Add-one smoothing PPMI: Positive PMI, could better handle low frequenciesPPMI = max(PMI,0) T-testThe t-test statistic, like PMI, can be used to measure how muchmore frequent the association is than chance. The t-test statistic computes the difference between observed and expected means, normalized by the variance. The higher the value of t, the greater the likelihood that we can reject the null hypothesis. Null hypothesis: the two words are independent, and hence P(a,b) = P(a)P(b) correctly models the relationship between the two words.$$t\textrm{-}test(a,b) = \frac{P(a,b) - P(a)P(b)}{\sqrt{P(a)P(b)}}$$ Minimum Edit Distancethe minimum number of editing operations (operations like insertion, deletion, substitution) needed to transform one string into another.Algorithm: searching the shortest path, use Dynamic programming to avoid repeating, (use BFS to search the shortest path?) WordNetA hierarchically organizesd lexical database, resource for English sense relations Synset: The set of near-synonyms for a WordNet sense (for synonym set) Word2VecSentence Meaning Representationæˆ‘ä»¬å‡è®¾è¯­è¨€è¡¨è¾¾å…·æœ‰æ„ä¹‰è¡¨å¾ï¼Œè¿™äº›è¡¨å¾ç”±ç”¨äºŽè¡¨ç¤ºå¸¸è¯†çš„ç±»åž‹ç›¸åŒçš„ä¸œè¥¿ç»„æˆã€‚è€Œåˆ›å»ºè¿™ç§è¡¨å¾å¹¶å°†å…¶åˆ†é…ç»™è¾“å…¥çš„è¯­è¨€çš„ä»»åŠ¡ï¼Œç§°ä¸ºè¯­ä¹‰åˆ†æžï¼ˆSemantic Analysisï¼‰ã€‚The symbols in our meaning representations language (MRL) correspond to objects, properties, and relations in the world. ä¸Šå›¾å±•ç¤ºäº†ä½¿ç”¨å››ç§å¸¸ç”¨çš„MRLè¡¨è¾¾â€œI have a carâ€ï¼Œç¬¬ä¸€è¡Œæ˜¯First order logicï¼Œæœ‰å‘å›¾å’Œå…¶æ–‡å­—ä¿¡æ¯æ˜¯ Abstract Meaning Representation (AMR)ï¼Œå…¶ä½™ä¸¤ç§æ˜¯Frame-Based å’Œ Slot-Fillerã€‚ Qualifications of MRL: Canonical form: sentences with the same (literal) meaning should have the same MR. Compositional: The meaning of a complex expression is a function of the meaning of its parts and of the rules by which they are combined. Verifiable: Can use the MR of a sentence to determine the truth of the sentence with respect to some given model(knowledge base) of the world. Unambiguous: an MR should have exactly one interpretation. Inference and Variables: we should be able to verify sentences not only directly, but also by drawing conclusions based on the input MR and facts in the knowledge base. Expressiveness: the MRL should allow us to handle a wide range of meanings and express appropriate relationships between the words in a sentence. Lexical semantics: the meaning of individual words. Lexical semantic relationships: Relations between word senses æ¨¡åž‹è®ºä»Žä»…æ˜¯æ­£å¼çš„é™ˆè¿°åˆ°èƒ½å¤Ÿå‘Šè¯‰æˆ‘ä»¬ä¸–ç•ŒæŸäº›äº‹æ€çš„é™ˆè¿°ï¼Œæˆ‘ä»¬æœŸæœ› meaning representations å¼¥åˆè¿™ç§å·®è·ã€‚è€Œæä¾›è¿™ç§ä¿è¯çš„ä¾æ®å°±æ˜¯æ¨¡åž‹ã€‚æ¨¡åž‹æ˜¯ä¸€ç§æ­£å¼çš„ç»“æž„ï¼Œå¯ä»¥ä»£è¡¨çœŸæ˜¯ä¸–ç•Œçš„ç‰¹å®šäº‹æ€ã€‚ æ„ä¹‰è¡¨è¾¾çš„è¯æ±‡è¡¨åŒ…å«ä¸¤éƒ¨åˆ†ï¼š éžé€»è¾‘è¯æ±‡è¡¨ï¼Œç”±æž„æˆæˆ‘ä»¬è¯•å›¾è¡¨è¾¾çš„ä¸–ç•Œçš„å¯¹è±¡ï¼Œå±žæ€§å’Œå…³ç³»çš„å¼€æ”¾å¼åç§°ç»„æˆã€‚å¦‚ è°“è¯­predicates, nodes, labels on links, or labels in slots in framesã€‚ é€»è¾‘è¯æ±‡è¡¨ï¼Œç”±ä¸€ç»„å°é—­çš„ç¬¦å·ï¼Œè¿ç®—ç¬¦ï¼Œé‡è¯ï¼Œé“¾æŽ¥ç­‰ç»„æˆï¼Œå®ƒä»¬æä¾›äº†ç”¨ç»™å®šæ„ä¹‰è¡¨ç¤ºè¯­è¨€ç¼–å†™è¡¨è¾¾å¼çš„å½¢å¼åŒ–æ–¹æ³•ã€‚ æ‰€æœ‰éžé€»è¾‘è¯æ±‡çš„å…ƒç´ éƒ½éœ€è¦åœ¨æ¨¡åž‹ä¸­æœ‰ä¸€ä¸ªè¡¨ç¤ºï¼ˆå±žäºŽæ¨¡åž‹çš„å›ºå®šçš„ä¸”å®šä¹‰æ˜Žç¡®çš„ä¸€éƒ¨åˆ†ï¼‰ã€‚â€¢ å¯¹è±¡ Objects denote elements of the domainâ€¢ å±žæ€§ Properties denote sets of elements of the domainâ€¢ å…³ç³» Relations denote sets of **tuples of elements of the domain First-order LogicFOL, Predicate logic, meets all of the MRL qualifications except compositionality. Term: represent objects. Expressions are constructed from terms in three ways: Constants in FOL refer to specific objects in the world being described. FOL constants refer to exactly one object. Objects can, however, have multiple constants that refer to them. Functions in FOL correspond to concepts that are often expressed in English as genitives(æ‰€æœ‰æ ¼) å¦‚ â€œFrascaâ€™s locationâ€, ä¸€èˆ¬è¡¨è¾¾ä¸ºLocationOf(Frasca). Functions provide a convenient way to refer to specific objects without having to associate a named constant with them. Variables, å…è®¸æˆ‘ä»¬å¯¹å¯¹è±¡åšå‡ºæ–­è¨€å’ŒæŽ¨ç†ï¼Œè€Œä¸å¿…å¼•ç”¨ä»»ä½•ç‰¹å®šçš„å‘½åå¯¹è±¡ã€‚Make statements about anonymous objects: making statements about a particular unknown object and making statements about all the objects in some arbitrary world of objects. Predicate(è°“è¯­, è°“è¯, å®¾è¯, è¿°è¯­): symbols that represent properties of entities and relations between entities. Terms can be combined into predicate-argument structures. Restaurant(Maharani) æŒ‡æ˜ŽMaharaniçš„å±žæ€§æ˜¯Restaurant. Predicates with multiple arguments represent relations between entities: member-of(UK, EU) /N to indicate that a predicate takes N arguments: member-of/2 Logical connectives: create larger representations by conjoining logical formulas using one of three operators. âˆ¨(or), âˆ§(and), Â¬(not), â‡’(implies). â€œI only have five dollars and I donâ€™t have a lot of time.â€, Have(Speaker,FiveDollars) âˆ§ Â¬Have(Speaker,LotOfTime) Variables and Quantifiers: Existential Quantifiers: (â€œthere existsâ€), â€œa restaurant that serves Mexican food near ICSIâ€ - âˆƒxRestaurant(x) âˆ§ Serves(x, MexicanFood) âˆ§ Near((LocationOf(x), LocationOf(ICSI)), å¤´éƒ¨çš„âˆƒå‘Šè¯‰æˆ‘ä»¬å¦‚ä½•è§£è¯»å¥ä¸­çš„å˜é‡x: è¦è®©å¥å­ä¸ºçœŸ, é‚£ä¹ˆå¯¹äºŽå˜é‡xè‡³å°‘å­˜åœ¨ä¸€ä¸ªå¯¹è±¡ã€‚ Universal Quantifier:âˆ€(â€œfor allâ€). â€œAll vegetarian restaurants serve vegetarian food.â€ - âˆ€xVegetarianRestaurant(x) â‡’ Serves(x,VegetarianFood). A predicate with a variable among its arguments only has a truth value if it is bound by a quantifier: âˆ€x.likes(x, Gim) has an interpretation as either true or false. Lambda NotationExtend FOL, to work with â€˜partially constructedâ€™ formula, with this form Î»x.P(x). Î»-reduction: åº”ç”¨äºŽé€»è¾‘ term ä»¥äº§ç”Ÿæ–°çš„FOLè¡¨è¾¾å¼, å…¶ä¸­å½¢å‚å˜é‡ç»‘å®šåˆ°æŒ‡å®šçš„term, å½¢å¼ä¸ºÎ»x.P(x)(A) -&gt; P(A). E.g.ï¼šÎ»x.sleep(x)(Marie) -&gt; sleep(Marie) åµŒå¥—ä½¿ç”¨, Verbal (event) MRsï¼šÎ»x.Î»y.Near(x,y)(Bacaro) -&gt; Î»y.Near(Bacaro,y), Î»z. Î»y. Î»x. Giving1(x,y,z) (book)(Mary)(John) -&gt; Giving1(John, Mary, book) -&gt; John gave Mary a book Problem: fixed arguments Requires separate Giving predicate for each syntactic subcategorisation frame(number/type/position of arguments). Separate predicates have no logical relation: if Giving3(a, b, c, d, e) is true, what about Giving2(a, b, c, d) and Giving1(a, b, c). Solution: Reification of events äº‹ä»¶å…·è±¡åŒ– InferenceæŽ¨æ–­çš„ä¸¤ç§æ€è·¯, forward chaining å’Œ backward chaining. forward chaining systems:Modus ponens(if - then) states that if the left-hand side(antecedent) of an implication rule is true, then the right-hand side(consequent) of the rule can be inferred.VegetarianRestaurant(Leaf)âˆ€xVegetarianRestaurant(x) â‡’ Serves(x,VegetarianFood)thenServes(Leaf ,VegetarianFood)éšç€å•ä¸ªäº‹å®žè¢«æ·»åŠ åˆ°çŸ¥è¯†åº“ä¸­ï¼Œmodus ponensç”¨äºŽè§¦å‘æ‰€æœ‰é€‚ç”¨çš„implication rulesã€‚ä¼˜ç‚¹æ˜¯äº‹å®žå¯ä»¥åœ¨è¢«åœ¨éœ€è¦æ—¶æ‰åœ¨çŸ¥è¯†åº“ä¸­å‘ˆçŽ°ï¼Œå› ä¸ºåœ¨æŸç§æ„ä¹‰ä¸Šæ¥è¯´æ‰€æœ‰æŽ¨æ–­éƒ½æ˜¯é¢„å…ˆæ‰§è¡Œçš„ã€‚è¿™å¯ä»¥å¤§å¤§å‡å°‘åŽç»­çš„queriesæ‰€éœ€çš„æ—¶é—´ï¼Œå› ä¸ºéƒ½åº”è¯¥æ˜¯ç®€å•çš„æŸ¥æ‰¾ã€‚ä½†ç¼ºç‚¹æ˜¯é‚£äº›æ°¸è¿œç”¨ä¸åˆ°çš„äº‹å®žä¹Ÿå¯èƒ½è¢«æŽ¨æ–­å’Œå­˜å‚¨ã€‚ backward chaining: ç¬¬ä¸€æ­¥æ˜¯é€šè¿‡æŸ¥çœ‹queryå…¬å¼æ˜¯å¦å­˜åœ¨çŸ¥è¯†åº“ä¸­, æ¥ç¡®è®¤queryæ˜¯å¦ä¸ºçœŸã€‚æ¯”å¦‚æŸ¥è¯¢Serves(Leaf ,VegetarianFood). å¦‚æžœæ²¡æœ‰ï¼Œåˆ™æœç´¢çŸ¥è¯†åº“ä¸­å­˜åœ¨çš„é€‚ç”¨implication rulesã€‚å¯¹æ¶‰åŠåˆ°çš„antecedenté€’å½’è¿è¡Œbackward chaining. æ¯”å¦‚å‘åŠ¨æœç´¢é€‚ç”¨è§„åˆ™ï¼Œä»Žè€Œæ‰¾åˆ°è§„åˆ™âˆ€xVegetarianRestaurant(x) â‡’ Serves(x,VegetarianFood), å¯¹äºŽterm Leafè€Œè¨€, å¯¹åº”çš„antecedentæ˜¯VegetarianRestaurant(Leaf), å­˜åœ¨äºŽçŸ¥è¯†åº“ä¸­. Prolog å°±æ˜¯é‡‡ç”¨backward chaining æŽ¨æ–­ç­–ç•¥çš„ç¼–ç¨‹è¯­è¨€. è™½ç„¶forwardå’ŒbackwardæŽ¨ç†æ˜¯åˆç†çš„ï¼Œä½†ä¸¤è€…éƒ½ä¸å®Œå¤‡ã€‚è¿™æ„å‘³ç€å•ç‹¬ä½¿ç”¨è¿™äº›æ–¹æ³•çš„ç³»ç»Ÿæ— æ³•æ‰¾åˆ°æœ‰æ•ˆçš„æŽ¨è®ºã€‚å®Œå¤‡çš„æŽ¨ç†æ˜¯è§£æž resolution, ä½†è®¡ç®—æˆæœ¬å¾ˆé«˜. åœ¨å®žè·µä¸­ï¼Œå¤§å¤šæ•°ç³»ç»Ÿä½¿ç”¨æŸç§å½¢å¼çš„chainingå¹¶æŠŠè´Ÿæ‹…åŽ‹åˆ°çŸ¥è¯†åº“å¼€å‘äººå‘˜åŽ»è§£ç çŸ¥è¯†ï¼Œä»¥æ”¯æŒå¿…è¦inferenceå¯ä»¥æŽ¨è®º. Reification of EventsJohn gave Mary a book -&gt; âˆƒe, z. Giving(e) âˆ§ Giver(e, John) âˆ§ Givee(e, Mary) âˆ§ Given(e,z) âˆ§ Book(z) Reify: to â€œmake realâ€ or concrete, i.e., give events the same status asentities. In practice, introduce variables for events, which we can quantify over Entailment relations: automatically gives us logical entailment relations between events1234[John gave Mary a book on Tuesday] -&gt; [John gave Mary a book]âˆƒ e, z. Giving(e) âˆ§ Giver(e, John) âˆ§ Givee(e, Mary) âˆ§ Given(e,z) âˆ§ Book(z) âˆ§ Time(e, Tuesday)-&gt;âˆƒ e, z. Giving(e) âˆ§ Giver(e, John) âˆ§ Givee(e, Mary) âˆ§ Given(e,z) âˆ§ Book(z) Semantic ParsingAka semantic analysis. Systems for mapping from a text string to any logical form. Motivation: deriving a meaning representation from a sentence. Application: question answering Method: Syntax driven semantic analysis with semantic attachments Syntax Driven Semantic Analysis Principle of compositionality: the construction of constituent meaning is derived from/composed of the meaning of the constituents/words within that constituent, guided by word order and syntactic relations. Build up the MR by augmenting CFG rules with semantic composition rules. Add semantic attachments to CFG rules. Problem: encounter invalide FOL for some (base-form) MR, need type-raise. Training Semantic AttachmentsE.g123456VP â†’ Verb NP : &#123;Verb.sem(NP.sem)&#125;Verb.sem = Î»y. Î»x. âˆƒe. Serving(e) âˆ§ Server(e, x) âˆ§ Served(e, y)NP.sem = Meat-&gt;VP.sem = Î»y. Î»x. âˆƒe. Serving(e) âˆ§ Server(e, x) âˆ§ Served(e, y) (Meat)= Î»x. âˆƒe. Serving(e) âˆ§ Server(e, x) âˆ§ Served(e, Meat) The MR for VP, is computed by applying the MR function to VPâ€™s children. Complete the rule:123456S â†’ NP VP : &#123;VP.sem(NP.sem)&#125;VP.sem = Î»x. âˆƒe. Serving(e) âˆ§ Server(e, x) âˆ§ Served(e, Meat)NP.sem = AyCaramba-&gt;S.sem = Î»x. âˆƒe. Serving(e) âˆ§ Server(e, x) âˆ§ Served(e, Meat) (AyCa.)= âˆƒe. Serving(e) âˆ§ Server(e, AyCaramba) âˆ§ Served(e, Meat) Abstract Meaning RepresentationAMR Frame-BasedSlot-FillerTopic Modellingä¸»é¢˜åˆ†ç±»ä»»åŠ¡ä¸­ï¼ŒåŠ å…¥çŸ¥é“æœ‰ä»€ä¹ˆä¸»é¢˜ï¼Œæˆ–è€…å¯¹ä¸»é¢˜çš„æ•°é‡å’Œåˆ†å¸ƒåšå‡ºå…ˆéªŒå‡è®¾ï¼Œæ­¤æ—¶å¯ä»¥ä½¿ç”¨ç›‘ç£å­¦ä¹ , å¦‚æœ´ç´ è´å¶æ–¯åˆ†ç±», æŠŠæ–‡ç« å¤„ç†æˆè¯è¢‹(bag of words) ä½†å‡å¦‚æ²¡æœ‰è¿™äº›å…ˆéªŒï¼Œå°±è¦ä¾é æ— ç›‘ç£å­¦ä¹ ï¼šInstead of using supervised topic classification â€“ rather not fix topics in advance nor do manual annotation, Use clustering to teases out the topics. Only the number of topics is specified in advance. Latent Dirichlet allocation(LDA): each document may be viewed as a mixture of various topics where each document is generated by LDA. A topic is a distribution over words generate document: Randomly choose a distribution over topics For each word in the document randomly choose a topic from the distribution over topics randomly choose a word from the corresponding topic (distribution over the vocabulary) training: repeat until converge assign each word in each document to one of T topics. For each document d, go through each word w in d and for each topic t, compute: p(t|d), P(w|t) Reassign w to a new topic, where we choose topic t with probability P(w|t)xP(t|d) LDAæ¨¡åž‹ä»£ç  EvaluationExtrinsic EvaluationUse something external to measure the model. End-to-end evaluation, the best way to evaluate the performance of a language model is to embed it in an application and measure how much the application improves. Put each model in a task: spelling corrector, speech recognizer, MT system Run the task, get an accuracy for A and for B How many misspelled words corrected properly How many words translated correctly Compare accuracy for A and B Unfortunately, running big NLP systems end-to-end is often very expensive. Intrinsic EvaluationMeasures independenly to any application. Train the parameters of both models on the training set, and then compare how well the two trained models fit the test set. Which means whichever model assigns a higher probability to the test set Human EvaluationE.g to know whether the email is actually spam or not, i.e. the human-defined labels for each document that we are trying togold labels match. We will refer to these human labels as the gold labels. Precision, Recall, F-measure To deal with unbalanced lables Application: text classification, parsing. Evaluation in text classification: the 2 by 2 contingency table, golden lable is true or false, the classifier output is positive or negative. Precision: Percentage of positive items that are golden correct, from the view of classifier Recall: Percentage of golden correct items that are positive, from the view of test set. F-measure Motivation: there is tradeoff between precision and recall, so we need a combined meeasure that assesses the P/R tradeoff. The b parameter differentially weights the importance of recall and precision, based perhaps on the needs of an application. Values of b &gt; 1 favor recall, while values of b &lt; 1 favor precision. Balanced F1 measure with beta =1, F = 2PR/(P+R) Confusion MatrixRecalled that confusion matrixâ€™s row represent golden label, column represent the classifierâ€™s output, to anwser the quesionï¼šfor any pair of classes(c1,c2), how many test sample from c1 were incorrectly assigned to c2 Recall: Fraction of samples in $c_1$ classified correctly, $\frac{CM(c_1, c_1)}{\sum_jCM(c_1, j)}$ Precision: fraction of samples assigned $c_1$ that are actually $c_1$, $\frac{CM(c_1, c_1)}{\sum_iCM(i, c_1)}$ Accuracy: $\frac{\sum diagnal}{all}$ CorrelationWhen two sets of data are strongly linked together we say they have a High Correlation.Correlation is Positive when the values increase together, and Correlation is Negative when one value decreases as the other increases. Pearson correlation: covariance of the two variables divided by the product of their standard deviations.$$r = \frac{\sum_{i=1}^n(x_i - \overrightarrow{x})(y_i - \overrightarrow{y})}{\sqrt{\sum_{i=1}^n(x_i - \overrightarrow{x})^2} \sqrt{\sum_{i=1}^n(y_i - \overrightarrow{y})^2}}$$ Spearman correlation: the Pearson correlation between the rank values of the two variables Basic Text ProcessingRegular ExpressionsNLPå·¥ä½œå¿…å¤‡æŠ€èƒ½(è€ƒè¯•ä¸éœ€è¦). ä¸€äº›ç»ƒä¹ Regular Expressionsçš„æœ‰è¶£ç½‘ç«™:https://alf.nu/RegexGolfhttps://regexr.com/ Word TokenizationNLP task needs to do text normalization: Segmenting/tokenizing words in running text Normalizing word formats Segmenting sentences in running text they lay back on the San Francisco grass and looked at the stars and their Type: an element of the vocabulary. Token: an instance of that type in the actual text. è‹±æ–‡æ¯”è¾ƒç®€å•.ä¸­æ–‡æœ‰ä¸€ä¸ªéš¾ç‚¹, éœ€è¦åˆ†è¯.]]></content>
      <categories>
        <category>AI</category>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NLP</tag>
        <tag>UoE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stanford CS106A/B Programming Intro æ–¯å¦ç¦å¤§å­¦ç¼–ç¨‹å…¥é—¨è¯¾]]></title>
    <url>%2Fstanford-cs106ab%2F</url>
    <content type="text"><![CDATA[Stanford CS106B Programming Abstractions å’Œ CS106A çš„å­¦ä¹ ç¬”è®°. è¯¾ç¨‹ä½œä¸š(cs106b spring 2017)å®žçŽ°ä»£ç è§ https://github.com/ShootingSpace/cs106b-programming-abstraction Topics:A: Intro (by Java)B: Recursion, algorithms analysis (sort/search/hash), dynamic data structures (lists, trees, heaps), data abstraction (stacks, queues, maps), implementation strategies/tradeoffs Purposes become acquainted with the C++ programming language learn more advanced programming techniques explore classic data structures and algorithms and apply these tools to solving complex problems Reference Text Book: Data Structures &amp; Algorithm Analysis in C++, 4th ed, by Mark A. Weiss Text Book: Programming Abstractions in C++ 1st Edition by Eric Roberts Text Book: Algorithms, 4th Edition Blog: Red Blob Games, Amitâ€™s A* Pages Coding styleWhy writing clean, well-structured code The messy code trap harder to build and debug harder to clean up Decomposition Decompose the problem, not the programs, program is written from the already decomposed framework. Logical and readable Methods should be short and to the point, Strive to design methods that are general enough for a variety of situations and achieve specifics trough use of parameters. Avoid redundants methods. Avoid repeated lines or methods. Readable code: Writing readable code not only help future readers but also help avoid your own bugs: Because bugs are codes that fail to expresses idea in mind. Reader can see the algorithmic idea when sweeping the code. Works correctly in all situations: Using a listing of specific test cases to exercise the program on. The overall approach is straight-forward, data structure is cleanly organized, tasks are nicely decomposed, algorithms are clear and easy to follow, comments are helpful, layout is consistent. How to write clean, well-structured code? Choosing good names for variables Name reflect what it stores, normally nouns; In Java, conventionly, begin variables with the first word lowercase, and upper case later words bestScore Widely used idiomatic one-letter names: i, j, k for int loop counters; x, y, z for coordinates. Choosing good names for methods Name reflect the action they perform, verbs normally; The prefixes get and set have a typical role: A get method gets a piece of information from an object; set methods are used to pass a value in to an object Returning a boolean are ofter named starting with is or has. Using whitespace to separate logical parts: Put in blank lines to separate the code into its natural sub sections that accomplis logical sub-parts of the whole algoriithm. Each little section might have a comment to describe what it accomplishes. Use Indentation to show hierarchy structure Comments Attributions: consider as an important tennet of academic integrity. CommentsExamples of information you might include in comments: General overview. What are the goals and requirements of this program? this function? The overview comment should also contain author and version information: who worked on this file and when. Data structures. How is the data stored? How is it ordered, searched, accessed? Design decisions. Why was a particular data structure or algorithm chosen? What other strategies were tried and rejected? Error handling. How are error conditions handled? What assumptions are made? What happens if those assumptions are violated? Nitty-gritty code details. Comments are invaluable for explaining the inner workings of particularly complicated (often labeled â€œcleverâ€) paths of the code. Planning for the future. How might one make modifications or extensions later? And moreâ€¦ (This list is by no means exhaustive) ADTAn abstract data type is a set of objects together with a set of operations. Abstract data types are mathematical abstractions; nowhere in an ADTâ€™s definition is there any mention of how the set of operations is implemented.Objects such as lists, sets, and graphs, along with their operations, can be viewed as ADTs.Also there are search tree, set, hash table, priority queue. Client uses class as abstraction Invokes public operations only Internal implementation not relevant! Client canâ€™t and shouldnâ€™t muck with internals: Class data should private Imagine a â€œwallâ€ between client and implementor Wall prevents either from getting involved in otherâ€™s business Interface is the â€œchinkâ€ in the wall Conduit allows controlled access between the two Consider Lexicon Abstraction is a word list, operations to verify word/prefix How does it store list? using array? vector? set? does it matter to client? Why ADTs? Abstraction: Client insulated from details, works at higher-level Encapsulation: Internals private to ADT, not accessible by client Independence: Separate tasks for each side (once agreed on interface) Flexibility: ADT implementation can be changed without affecting client The C++ language includes, in its library, an implementation of common data structures. This part of the language is popularly known as the Standard Template Library (STL). In general, these data structures are called collections or containers. IteratorsIn the STL, a position is represented by a nested type, iterator. Getting an Iterator iterator begin( ) returns an appropriate iterator representing the first item in the container. iterator end( ) returns an appropriate iterator representing the endmarker in the container (i.e., the position after the last item in the container). Iterator Methods * `itr++` and `++itr` advances the iterator itr to the next location. Both the prefix and postfix forms are allowable. * `itr` returns a reference to the object stored at iterator itrâ€™s location. The reference returned may or may not be modifiable (we discuss these details shortly). * `itr1==itr2` / `itr1!=itr2`, returns true if iterators itr1 and itr2 refer to the same / different location and false otherwise. Container Operations that require Iterators. The three most popular methods that require iterators are those that add or remove from the list (either a vector or list) at a specified position: iterator insert( iterator pos, const Object &amp; x ): adds x into the list, prior to the position given by the iterator pos. This is a constant-time operation for list, but not for vector. The return value is an iterator representing the position of the inserted item. iterator erase( iterator pos ): removes the object at the position given by the iterator. This is a constant-time operation for list, but not for vector. The return value is the position of the element that followed pos prior to the call. This operation invalidates pos, which is now stale, since the container item it was viewing has been removed. iterator erase( iterator start, iterator end ): removes all items beginning at position start, up to, but not including end. Observe that the entire list can be erased by the call c.erase( c.begin( ), c.end( ) ) Range for loop: C++11 also allows the use of the reserved word auto to signify that the compiler will automatically infer the appropriate type, for simple data type: 12for( auto x : squares ) cout&lt;&lt; x; for complicate data type like map: Each element of the container is a map&lt;K, V&gt;::value_type, which is a typedef for std::pair&lt;const K, V&gt;. Consequently, youâ€™d write this as 123for (auto&amp; kv : myMap) &#123; std::cout &lt;&lt; kv.first &lt;&lt; " has value " &lt;&lt; kv.second &lt;&lt; std::endl;&#125; RecursionHelper Function No clear definition of helper function How to utilize helper function to help constructing recursion algarithm: construct a same-name recursive function with extra parameters to pass in. In some other cases, decomposition with several step into a function is itself a helper function, which help to make the main function simple and clean. Exhaustive recursionPermutations/subsets are about choice Both have deep/wide tree of recursive calls Depth represents total number of decisions made Width of branching represents number of available options per decision Explores every possible option at every decision point, typically very expensive, N! permutations, 2N subsets Recursive BacktrackingPartial exploration of exhaustive space. In the case that if we are interested in finding any solution, whichever one that works out first is fine. If we eventually reach our goal from here, we have no need to consider the paths not taken. However, if this choice didnâ€™t work out and eventually leads to nothing but dead ends; when we backtrack to this decision point, we try one of the other alternatives. The back track based on the stacks of recursion, if a stack return false (or fail result), we back to previous stack and try another way(un-making choice). Need something return(normally bool) to step out of the entire recursion once any one solution found. One great tip for writing a backtracking function is to abstract away the details of managing the configuration (what choices are available, making a choice, checking for success, etc.) into other helper functions so that the body of the recursion itself is as clean as can be. This helps to make sure you have the heart of the algorithm correct and allows the other pieces to be developed, test, and debugged independently. Pointerlvalue: In C++, any expression that refers to an internal memory location capable of storing data is called an lvalue (pronounced â€œell-valueâ€). x = 1.0; Declaring pointer variables123456789101112131415161718192021222324252627282930313233int main() &#123; -------------------------------------------------- // Declaration, in the stack // Not yet initialized! int num; int *p, *q; // If cout &lt;&lt; num &lt;&lt; p &lt;&lt; q &lt;&lt; endl; // There will be junk number, junk address. // If now *p=10, it may blow up, because what *p point to is an address points to somewhere around that could be invalid. --------------------------------------------------- // new operator allocate memory from the heap, returns address p = new int; // P -----&gt; [ int ] ï¼ˆheep 1000ï¼‰ *p = 10; // P -----&gt; [ 10 ] ï¼ˆheep 1000ï¼‰ q = new int; // P -----&gt; [ int ] ï¼ˆheep 1004ï¼‰ *q = *p; // q -----&gt; [ 10 ] ï¼ˆheep 1004ï¼‰ q = p; // q -----&gt; [ 10 ] ï¼ˆheep 1000ï¼‰ // [ 10 ] ï¼ˆheep 1004ï¼‰ became orphan, and could not be reclaim back --------------------------------------------------- delete p; // [ 10 ] ï¼ˆheep 1000ï¼‰memory was reclaimed and free, // and available for others as [ ]ï¼ˆheep 1000ï¼‰, // but p still hold the address delete q; // bad idea, [ 10 ]ï¼ˆheep 1000ï¼‰ already been reclaimed! q = NULL; // NULL is zero pointer, means the pointer does not hold any address, // used as sentinel value, sometimes better than delete. // Accessing &quot;deleted&quot; memory has unpredictable consequences --------------------------------------------------- // int *p declaration reserves only a single word, which is large enough to hold a machine address. // â‰  // int *p = NULL declare pointer p as nullptr --------------------------------------------------- (*newOne).name = name // &quot;.&quot; &gt; &quot;*&quot; newOne-&gt;name = name Use of pointerBig program that contains a certain amout of classes and objects that are share some relationship. Instead of copying data from each other, using pointer to point to specific data is better: Saves space by not repeating the same information. If some objects gets new information to update, change in one place only! Dynamic allocationRequest memory: To acquire new memory when you need it and to free it explicitly when it is no longer needed. Acquiring new storage when the program is running. While the program is running, you can reserve part of the unallocated memory, leaving the rest for subsequent allocations.The pool of unallocated memory available to a program is called the heap.int *p = new int; //new operator to allocate memory from the heapIn its simplest form, the new operator takes a type and allocates space for a variable of that type located in the heap.The call to new operator will return the address of a storage location in the heap that has been set aside to hold an integer. Free occupied memory: Delete which takes a pointer previously allocated by new and returns the memory associated with that pointer to the heap. Tree Node, tree, subtree, parent, child, root, edge, leaf For any node ni, the depth of ni is the length of the unique path from the root to ni. The height of ni is the length of the longest path from ni to a leaf Rules for all trees Recursive branching structure Single root node Every node reachable from root by unique path Binary treeEach node has at most 2 children. Binary search tree All nodes in left subtree are less than root, all nodes in right subtree are greater. Arranged for efficient search/insert. It is the basis for the implementation of two library collections classes, set and map. Most operationsâ€™ average running time is O(log N). Operating on treesMany tree algorithms are recursive Handle current node, recur on subtrees Base case is empty tree (NULL) Tree traversals to visit all nodes, order of traversal: Pre: cur, left, right In: left, cur, right Post: left, right, cur Others: level-by-level, reverse orders, etc Balanced Search TreesBinary search tree have poor worst-case performance. To make costs are guaranteed to be logarithmic, no matter what sequence of keys is used to construct them, the ideal is to keep binary search trees perfectly balanced. Unfortunately, maintaining perfect balance for dynamic insertions is too expensive. So consider data structure that slightly relaxes the perfect balance requirement to provide guaranteed logarithmic performance not just for the insert and search operations, but also for all of the ordered operations (except range search). AVL treeAdelson-Velskii and Landis tree is a binary search tree with a balance condition. Track balance factor for each node: Height of right subtree - height of left subtree information is kept for each node (in the node structure) For every node in the tree, the height of the left and right subtrees can differ by at most 1 (Balance factor = 0 or 1). When balance factor hits 2, restructure Rotation moves nodes from heavy to light side Local rearrangement around specific node When finished, node has 0 balance factor Single rotation: one time rotation between new insert node and its parent node Double rotation: two single rotation of the new insert node 2-3 treesAllow the nodes in the tree to hold more than one key: 3-nodes, which hold three links and two keys. A 2-3 search tree is a tree that is either empty or A 2-node, with one key (and associated value) and two links, a left link to a 2-3 search tree with smaller keys, and a right link to a 2-3 search tree with larger keys A 3-node, with two keys (and associated values) and three links, a left link to a 2-3 search tree with smaller keys, a middle link to a 2-3 search tree with keys between the nodeâ€™s keys, and a right link to a 2-3 search tree with larger keys A perfectly balanced 2-3 search tree is one whose null links are all the same distance from the root. The concept guarantee that search and insert operations in a 2-3 tree with N keys are to visit at most lg N nodes. But its dicrect implementation is inconvenient: Not only is there a substantial amount of code involved, but the overhead incurred could make the algorithms slower than standard BST search and insert. Consider a simple representation known as a red-black BST that leads to a natural implementation. Binary HeapA heap is a binary tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Such a tree is known as a complete binary tree. A heap data structure consist of an array (of Comparable objects) and an integer representing the current heap size. For any element in array position i, the left child is in position 2i, the right child is in the cell after the left child [2i + 1], and the parent is in position [i/2]. Heap-Order Property: For every node X, the key in the parent of X is smaller than (or equal to) the key in X. So to make find minimum operation quick. Basic Heap Operation insert: To insert an element X into the heap, create a hole in the next available location. Then Percolate up - swap X with its parent index (i/2) so long as X has a higher priority than its parent. Continue this process until X has no more lower priority parent. 1234567//Percolate upint hole = ++size;binaryQueue[0]=std::move(*newOne);for ( ; (priority &lt; binaryQueue[hole/2].priority || (priority == binaryQueue[hole/2].priority &amp;&amp; name &lt; binaryQueue[hole/2].name) ); hole/=2) &#123; binaryQueue[hole] = std::move(binaryQueue[hole/2]);&#125;binaryQueue[hole] = std::move(binaryQueue[0]); deleteMin: When the minimum is removed, a hole is created at the root. Move the last element X in the heap to place in the root hole. Then Percolate down - swapp X with its more urgent-priority child [index (i2 or i2+1)] so long as it has a lower priority than its child. Repeat this step until X has no more higher priority child. 12345678910//Percolate downint child;for (; hole*2&lt;=size;hole=child) &#123; child = hole*2; if ( child!=size &amp;&amp; (binaryQueue[child+1].priority&lt;binaryQueue[child].priority || (binaryQueue[child+1].priority==binaryQueue[child].priority &amp;&amp; binaryQueue[child+1].name&lt;binaryQueue[child].name)) ) ++child; if ( binaryQueue[child].priority&lt;priority_tobePerD || (binaryQueue[child].priority==priority_tobePerD &amp;&amp; binaryQueue[child].name&lt;name_tobePerD) ) &#123; binaryQueue[hole] = std::move(binaryQueue[child]); &#125; else break;&#125; Use integer division to avoid even odd index. Priority QueuesA priority queue is a data structure that allows at least the following two operations: insert, and deleteMin, which finds, returns, and removes the minimum element in the priority queue. Algorithm AnalysisSpace/time, big-O, scalability Big-O Computational complexity: The relationship between N and the performance of an algorithm as N becomes large Big-O notation: to denote the computational complexity of algorithms. Standard simplifications of big-O Eliminate any term whose contribution to the total ceases to be significant as N becomes large. Eliminate any constant factors. Worst-case versus average-case complexityAverage-case performance often reflects typical behavior, while worst-case performance represents a guarantee for performance on any possible input. Predicting computational complexity from code structure Constant time: Code whose execution time does not depend on the problem size is said to run in constant time, which is expressed in big-O notation as O(1). Linear time: function that are executed exactly n times, once for each cycle of the for loop, O(N) Quadratic time: Algorithms like selection sort that exhibit O(N2) performance are said to run in quadratic tim For many programs, you can determine the computational complexity simply by finding the piece of the code that is executed most often and determining how many times it runs as a function of N Space/time In general, the most important measure of performance is execution time. It also possible to apply complexity analysis to the amount of memory space required. Nowadays the memory is cheap, but it still matters when designing extreamly big programs, or APPs on small memory device, such as phones and wearable devices. SortingThere are lots of different sorting algoritms, from the simple to very complex. Some optimized for certain situations (lots of duplicates, almost sorted, etc.). So why do we need multiple algorithms? Selection sortSelect smallest and swap to front/backend1234567891011void SelectionSort(Vector&lt;int&gt; &amp;arr)&#123; for (int i = 0; i &lt; arr.size()-1; i++) &#123; int minIndex = i; for (int j = i+1; j &lt; arr.size(); j++) &#123; if (arr[j] &lt; arr[minIndex]) minIndex = j; &#125; Swap(arr[i], arr[minIndex]); &#125;&#125; Count work inside loops: First iteration does N-1 compares, second does N-2, and so on. One swap per iteration O(N2) Insertion sortAs sorting hand of just-dealt cards, each subsequent element inserted into proper place Start with first element (already sorted) Insert next element relative to first Repeat for third, fourth, etc. Slide elements over to make space during insert 123456789void InsertionSort(Vector&lt;int&gt; &amp;v)&#123; for (int i = 1; i &lt; v.size(); i++) &#123; int cur = v[i]; // slide cur down into position to left for (int j=i-1; j &gt;= 0 &amp;&amp; v[j] &gt; cur; j--) v[j+1] = v[j]; v[j+1] = cur; &#125;&#125; Because of the nested loops, each of which can take N iterations, insertion sort is O(N2). HeapsortPriority queues can be used to sort in O(N log N) time. The algorithm based on this idea is known as heapsort. The building of the heap, uses less than 2N comparisons. In the second phase, the ith deleteMax uses at most less than 2\*log (N âˆ’ i + 1) comparisons, for a total of at most 2N log N âˆ’ O(N) comparisons (assuming N â‰¥ 2). Consequently, in the worst case, at most 2N log N âˆ’ O(N) comparisons are used by heapsort. Merge sortInspiration: Algorithm like selection sort is quadratic growth (O(N2)). Double input -&gt; 4X time, halve input -&gt; 1/4 time. Can recursion save the day? If there are two sorted halves, how to produce sorted full result? Divide and conquer algorithm Divide input in half Recursively sort each half Merge two halves together â€œEasy-split hard-joinâ€ No complex decision about which goes where, just divide in middle Merge step preserves ordering from each half Merge depends on the fact that the first element in the complete ordering must be either the first element in v1 or the first element in v2, whichever is smaller.12345678910111213141516171819202122232425void MergeSort(Vector&lt;int&gt; &amp;v)&#123; if (v.size() &gt; 1) &#123; int n1 = v.size()/2; int n2 = v.size() - n1; Vector&lt;int&gt; left = Copy(v, 0, n1); Vector&lt;int&gt; right = Copy(v, n1, n2); MergeSort(left); MergeSort(right); v.clear(); Merge(v, left, right); &#125;&#125;void Merge(Vector&lt;int&gt; &amp;v,Vector&lt;int&gt; &amp;left,Vector&lt;int&gt; &amp;right) &#123; int l=0, r=0; while(l&lt;left.size() &amp;&amp; r&lt;right.size()) &#123; if (left[l]&lt;right[r]) v.add(left[l++]); else v.add(right[r++]); &#125; while(l&lt;left.size()) v.add(left[l++]); while(r&lt;right.size()) v.add(right[r++]);&#125; The time to mergesort N numbers is equal to the time to do two recursive mergesorts of size N/2, plus the time to merge, which is linear. T(N) = N + 2T(N/2). log N levels * N per level= O(NlogN). Mergesort uses the lowest number of comparisons of all the popular sorting algorithms. Theoretical result show that no general sort algorithm could be better than NlogN. But there is still better in practice: The running time of mergesort, when compared with other O(N log N) alternatives, depends heavily on the relative costs of comparing elements and moving elements in the array (and the temporary array). These costs are language dependent. In Java, when performing a generic sort (using a Comparator), an element comparison can be expensive, but moving elements is cheap (because they are reference assignments, rather than copies of large objects). In C++, in a generic sort, copying objects can be expensive if the objects are large, while comparing objects often is relatively cheap because of the ability of the compiler to aggressively perform inline optimization. QuicksortMost sorting programs in use today are based on an algorithm called Quicksort, which employs a Divide and conquer strategy as merge sort, but instead take a different approach to divide up input vector into low half and high half. Quicksort uses a few more comparisons, in exchange for significantly fewer data movements. The reason that quicksort is faster is that the partitioning step can actually be performed in place and very efficiently. â€œHard-split easy-joinâ€, Each element examined and placed in correct half, so that join step become trivial. Choose an element (pivot) to serve as the boundary between the small and large elements. Partitioning: Rearrange the elements in the vector so that all elements to the left of the boundary are less than the pivot and all elements to the right are greater than or possibly equal to the pivot. Sort the elements in each of the partial vectors. 12345678void Quicksort(Vector&lt;int&gt; &amp;v, int start, int stop)&#123; if (stop &gt; start) &#123; int pivot = Partition(v, start, stop); Quicksort(v, start, pivot-1); Quicksort(v, pivot+1, stop); &#125;&#125; The running time of quicksort is equal to the running time of the two recursive calls plus the linear time spent in the partition (the pivot selection takes only constant time). T(N) = T(i) + T(N âˆ’ i âˆ’ 1) + cN, where i = |S1| is the number of elements in S1. There are thre cases Ideal 50/50 split: The pivot is in the middle, T(N) = cN + 2T(N/2) =&gt; O(NlogN) Average bad 90/10 split: N per level, but more levels, solve N*(9/10)k = 1, still k = O(NlogN) Worst N-1/1 split: The pivot is the smallest element, all the time. Then i = 0, T(N) = T(N âˆ’ 1) + cN, N &gt; 1. With N levels! O(N2) In a vector with randomly chosen elements, Quicksort tends to perform well, with an average-case complexity of O(N log N). In the worst case â€” which paradoxically consists of a vector that is already sorted â€” the performance degenerates to O(N2). Despite this inferior behavior in the worst case, Quicksort is so much faster in practice than most other algorithms that it has become the standard. Quicksort strategyPicking the pivotPicking a good pivot improves performance, but also costs some time. If the algorithm spends more time choosing the pivot than it gets back from making a good choice, you will end up slowing down the implementation rather than speeding it up. The popular, uninformed choice is to use the first element as the pivot. This is acceptable if the input is random, but if the input is presorted or in reverse order, then the pivot provides a poor partition. A safe approach is to choose the pivot element randomly. On the other hand, random number generation is generally an expensive commodity and does not reduce the average running time of the rest of the algorithm at all. A good estimate can be obtained by picking three elements randomly and using the median of these three as pivot. The randomness turns out not to help much, so the common course is to use as pivot the median of the left, right, and center elements. Quicksort partitioning strategyA known method that is very easy to do it wrong or inefficiently. General process: The first step is to get the pivot element out of the way by swapping it with the last element. Two pointers, i point to the first element and j to the next-to-last element. What our partitioning stage wants to do is to move all the small elements to the left part of the array and all the large elements to the right part. â€œSmallâ€ and â€œlargeâ€ are relative to the pivot. While i is to the left of j, we move i right, skipping over elements that are smaller than the pivot. We move j left, skipping over elements that are larger than the pivot. When i and j have stopped, i is pointing at a large element and j is pointing at a small element. If i is to the left of j (not yet cross), those elements are swapped. Repeat the process until i and j cross The final is to swap the pivot element with present i element One important detail we must consider is how to handle elements that are equal to the pivot? Suppose there are 10,000,000 elements, of which 500,000 are identical (or, more likely, complex elements whose sort keys are identical). To get an idea of what might be good, we consider the case where all the elements in the array are identical. If neither i nor j stops, and code is present to prevent them from running off the end of the array, no swaps will be performed. Although this seems good, a correct implementation would then swap the pivot into the last spot that i touched, which would be the next-to last position (or last, depending on the exact implementation). This would create very uneven subarrays. If all the elements are identical, the running time is O(N2). If both i and j stop, there will be many swaps between identical elements. The partition creates two nearly equal subarrays. The total running time would then be O(N log N). Thus it is better to do the unnecessary swaps and create even subarrays than to risk wildly uneven subarrays. Small arrays For very small arrays (N â‰¤ 20), quicksort does not perform as well as insertion sort. Furthermore, because quicksort is recursive, these cases will occur frequently. A common solution is not to use quicksort recursively for small arrays, but instead use a sorting algorithm that is efficient for small arrays, such as insertion sort. A good cutoff range is N = 10, although any cutoff between 5 and 20 is likely to produce similar results. This also saves nasty degenerate cases, such as taking the median of three elements when there are only one or two. Design StrategyWhen an algorithm is given, the actual data structures need not be specified. It is up to the programmer to choose the appropriate data structure in order to make the running time as small as possible. There are many to be considered: algorithms, data structure, space-time tradeoff, code complexity. Dynamic ProgrammingTo solve optimization problems in which we make a set of choices in order to arrive at an optimal solution. As we make each choice, subproblems of the same form often arise. Dynamic programming is effective when a given subproblem may arise from more than one partial set of choices; the key technique is to store the solution to each such subproblem in case it should reappear. Unlike divide-and-conquer algorithms which partition the problem into disjoint subproblems, dynamic programming applies when the subproblems overlap. â€œProgrammingâ€ in this context refers to a tabular method. When should look for a dynamic-programming solution to a problem? Optimal substructure: a problem exhibits optimal substructure if an optimal solution to the problem contains within it optimal solutions to subproblems. Overlapping subproblems: When a recursive algorithm revisits the same problem repeatedly, we say that the optimization problemhas overlapping subproblems. In contrast, a problem for which a divide-andconquer approach is suitable usually generates brand-new problems at each step of the recursion. General setps of Dynamic Programming Characterize the structure of an optimal solution. Recursively define the value of an optimal solution. Compute the value of an optimal solution, typically in a bottom-up fashion. Construct an optimal solution from computed information. Greedy AlgorithmsGreedy algorithms work in phases. In each phase, a decision is made in a locally optimal manner, without regard for future consequences. When the algorithm terminates, we hope that the local optimum is equal to the global optimum. If this is the case, then the algorithm is correct; otherwise, the algorithm has produced a suboptimal solution. Huffman Codes A Huffman code is a particular type of optimal prefix code that is commonly used for lossless data compression. The reason that this is a greedy algorithm is that at each stage we perform a merge without regard to global considerations. We merely select the two smallest trees. If we maintain the trees in a priority queue, ordered by weight, then the running time is O(C logC), since there will be one buildHeap, 2C âˆ’ 2 deleteMins, and C âˆ’ 2 inserts. A simple implementation of the priority queue, using a list, would give an O(C2) algorithm. The choice of priority queue implementation depends on how large C is. In the typical case of an ASCII character set, C is small enough that the quadratic running time is acceptable. Divide and ConquerTraditionally, routines in which the text contains at least two recursive calls and subproblems be disjoint (that is, essentially nonoverlapping) are called divide-and-conquer algorithms. Divide: Smaller problems are solved recursively (except, of course, base cases). Conquer: The solution to the original problem is then formed from the solutions to the subproblems.We have already seen several divide-and-conquer algorithms: mergesort and quicksort, which have O(N log N) worst-case and averagecase bounds, respectively. Backtracking AlgorithmsSee Recursive BacktrackingIn some cases, the savings over a brute-force exhaustive search can be significant.The elimination of a large group of possibilities in one step is known as pruning. How to evaluate/compare alternatives Often interested in execution performance: Time spent and memory used Should also consider ease of developing, verifying, maintaining code Text editor case study Buffer requirements Sequence of characters + cursor position Operations to match commands above What to consider? Implementation choices performance implications Buffer class interface 1234567891011121314class Buffer &#123; public: Buffer(); ~Buffer(); void moveCursorForward(); void moveCursorBackward(); void moveCursorToStart(); void moveCursorToEnd(); void insertCharacter(char ch); void deleteCharacter(); void display(); private: // TBD!&#125;; Buffer layered on Vector Need character data + cursor Chars in Vector&lt;char&gt; Represent cursor as integer index Minor detail â€“ is index before/after cursor? Buffer contains: AB|CDE 1234// for Buffer classprivate: Vector&lt;char&gt; chars;int cursor; Performance insertCharacter() and deleteCharacter() is linear, other operation is just O(1) Space used ~1 byte per char Buffer layered on Stack Inspiration: add/remove at end of vector is fast If chars next to cursor were at endâ€¦ Build on top of stack? Another layered abstraction! How is cursor represented? Buffer contains:AB|CDEThere is no explicit cursor representation, instead using two stack to represent a whole data structure being seperated by the implicit cursor. 123// for Buffer classprivate: Stack&lt;char&gt; before, after; Performance moveCursorToStart(), moveCursorToEnd() operation is linear, other operation is just O(1) Space used ~2 byte per char Buffer as double linked list Inspiration: contiguous memory is constraining Connect chars without locality Add tail pointer to get direct access to last cell Add prev link to speed up moving backwards Buffer contains:AB|CDE 1234567// for Buffer classprivate: struct cellT &#123; char ch; cellT *prev, *next; &#125;; cellT *head, *tail, *cursor; Cursor design To cell before or after? 5 letters, 6 cursor positionsâ€¦ Add â€œdummy cellâ€ to front of list Performance destruction is linear, other operation is just O(1) Space used ~9 byte per char Compare implementations table th:nth-of-type(1) { width: 200px; } table th:nth-of-type(2) { width: 80px; } table th:nth-of-type(3) { width: 80px; } Operation Vector Stack Single linked list Double linked list Buffer() O(1) O(1) O(1) O(1) ~Buffer() O(1) O(1) O(N) O(N) moveCursorForward() O(1) O(1) O(1) O(1) moveCursorBackward() O(1) O(1) O(N) O(1) moveCursorToStart() O(1) O(N) O(1) O(1) moveCursorToEnd() O(1) O(N) O(N) O(1) insertCharacter() O(N) O(1) O(1) O(1) deleteCharacter() O(N) O(1) O(1) O(1) Space used 1N 2N 5N 9N Space-time tradeoff Doubly-linked list is O(1) on all six operations But, each char uses 1 byte + 8 bytes of pointers =&gt; 89% overhead! Compromise: chunklist Array and linked list hybrid Shares overhead cost among several chars Chunksize can be tuned as appropriate Cost shows up in code complexity Cursor must traverse both within and across chunks Splitting/merging chunks on insert/deletes MapMap is super-useful, support any kind of dictionary, lookup table, index, database, etc.Map stores key-value pairs, support fast access via key, operations to optimize: add, getValueHow to make it work efficiently? Implement Map as Vector Layer on Vector, provides convenience with low overhead Define pair struct, to olds key and value together, Vector&lt;pair&gt; Vector sorted or unsorted? If sorted, sorted by what? Sorting: Provides fast lookup, but still slow to insert (because of shuffling) How to implement getValue, add? Does a linked list help? Easy to insert, once at a position But hard to find position to insertâ€¦ Implementing Map as tree Implementatation Each Map entry adds node to tree, node contains: string key, client-type value, pointers to left/right subtrees Tree organized for binary search, Key is used as search field getValue: Searches tree, comparing keys, find existing match or error add: Searches tree, comparing keys, overwrites existing or adds new node Private members for Map 1234567891011121314151617template &lt;typename ValType&gt; class Map &#123; public: // as before private: struct node &#123; string key; ValType value; node *left, *right; &#125;; node *root; node *treeSearch(node * t, string key); void treeEnter(node *&amp;t, string key, ValType val); DISALLOW_COPYING(Map)&#125;; Evaluate Map as tree Space used: Overhead of two pointers per entry (typically 8 bytes total) Runtime performance: Add/getValue take time proportional to tree height(expected to be O(logN)) Degenerate trees The insert order is â€œsortedâ€: 2 8 14 15 18 20 21, totally unbalanced with height = 7 The insert order is â€œalternately sortedâ€: 21 2 20 8 14 15 18 or 2 8 21 20 18 14 15 Association: What is the relationship between worst-case inputs for tree insertion and Quicksort? What to do about it: AVL tree Compare Map implementations Operation Vector BST Sorted Vector getValue O(N) O(lgN) O(lgN) add O(N) O(lgN) O(N) Space used N 9N N Hashing Hash table ADT Hash table data structure: A list of keys and TableSize Hash function: A mapping that map each key into some number in the range 0 to TableSize-1 and distributes the keys evenly among the appropriate cell HashingThe major problems are choosing a function, deciding what to do when two keys hash to the same value (this is known as acollision), and deciding on the table size RehashingIf the table gets too full, the running time for the operations will start taking too long, and insertions might fail for open addressing hashing with quadratic resolution. A solution is to build another table that is about twice as big (with an associated new hash function) and scan down the entire original hash table, computing the new hash value for each (nondeleted) element and inserting it in the new table. The Big-FiveIn C++11, classes come with five special functions that are already written for you. These are the destructor, copy constructor, move constructor, copy assignment operator, and move assignment operator. Collectively these are the big-five. DestructorThe destructor is called whenever an object goes out of scope or is subjected to a delete. Typically, the only responsibility of the destructor is to free up any resources that were acquired during the use of the object. This includes calling delete for any corresponding news, closing any files that were opened, and so on. The default simply applies the destructor on each data member. ConstructorA constructor is a method that describes how an instance of the class is constructed. If no constructor is explicitly defined, one that initializes the data members using language defaults is automatically generated. Copy Constructor and Move Constructor Copy Assignment and Move Assignment (operator=)By Defaults, if a class consists of data members that are exclusively primitive types and objects for which the defaults make sense, the class defaults will usually make sense.The main problem occurs in a class that contains a data member that is a pointer. The default destructor does nothing to data members that are pointers (for good reasonâ€”recall that we must delete ourselves). Furthermore, the copy constructor and copy assignment operator both copy the value of the pointer rather than the objects being pointed at. Thus, we will have two class instances that contain pointers that point to the same object. This is a so-called shallow copy (contrast to deep copy). To avoid shallow copy, ban the copy funtionality by calling DISALLOW_COPYING(ClassType). As a result, when a class contains pointers as data members, and deep semantics are important, we typically must implement the destructor, copy assignment, and copy constructors ourselves. Explicit constructor:All one-parameter constructors should be made explicit to avoid behind-the-scenes type conversions. Otherwise, there are somewhat lenient rules that will allow type conversions without explicit casting operations. Usually, this is unwanted behavior that destroys strong typing and can lead to hard-to-find bugs.The use of explicit means that a one-parameter constructor cannot be used to generate an implicit temporary 1234567891011class IntCell &#123;public: explicit IntCell( int initialValue = 0 ) : storedValue&#123; initialValue &#125; &#123; &#125; int read( ) const &#123; return storedValue; &#125;private: int storedValue; &#125;;IntCell obj; // obj is an IntCellobj = 37; // Should not compile: type mismatch Since IntCell constructor is declared explicit, the compiler will correctly complain that there is a type mismatch TemplateType-independentWhen we write C++ code for a type-independent algorithm or data structure, we would prefer to write the code once rather than recode it for each different type Function template A function template is not an actual function, but instead is a pattern for what could become a function. An expansion for each new type generates additional code; this is known as code bloat when it occurs in large projects. Class template12345678template &lt;typename Object&gt;class MemoryCell &#123; public: explicit MemoryCell( const Object &amp; initialValue = Object&#123; &#125; ) : storedValue&#123; initialValue &#125; &#123; &#125; private: Object storedValue;&#125;; MemoryCell is not a class, it is only a class template. It will be a class if specify the Object type. MemoryCell&lt;int&gt; and MemoryCell&lt;string&gt; are the actual classes. Graph AlgorithmsDefinitions: vertices, edges, arcs, directed arcs = digraphs, weight/cost, path, length, acyclic(no cycles) Topological Sort A topological sort is an ordering of vertices in a directed acyclic graph, such that if there is a path from vi to vj, then vj appears after vi in the ordering. A topological ordering is not possible if the graph has a cycle To find a topological ordering, define the indegree of a vertex v as the number of edges (u, v), then use a queue or stack to keep the present 0 indegree vertexes. At each stage, as long as the queue is not empty, dequeue a 0 indegree vertexes in the queue, enqueue each new generated 0 indegree vertexes into the queue. Shortest-Path Algorithms Breadth-first search Explores equally in all directions To find unweighted shortest paths Operates by processing vertices in layers: The vertices closest to the start are evaluated first, and the most distant vertices are evaluated last. Dijkstraâ€™s Algorithm Also called Uniform Cost Search, cost matters Instead of exploring all possible paths equally, it favors lower cost paths. Dijkstraâ€™s algorithm proceeds in stages. At each stage, while there are still vertices waiting to be known: Selects a vertex v, which has the smallest dv among all the unknown vertices, and declares v as known stage. For each of vâ€™s neighbors, w, if the new pathâ€™s cost from v to w is better than previous dw, dw will be updated. But w will not be marked as known, unless at next while-loop stage, dw happens to be the smalles. The above steps could be implemented via a priority queue. A proof by contradiction will show that this algorithm always works as long as no edge has a negative cost. If the graph is sparse, with |E| =Î¸(|V|), this algorithm is too slow. In this case, the distances would need to be kept in a priority queue. Selection of the vertex v is a deleteMin operation. The update of wâ€™s distance can be implemented two ways. One way treats the update as a decreaseKey operation. An alternate method is to insert w and the new value dw into the priority queue every time wâ€™s distance changes. Greedy Best First Search(Heuristic search) With Breadth First Search and Dijkstraâ€™s Algorithm, the frontier expands in all directions. This is a reasonable choice if youâ€™re trying to find a path to all locations or to many locations. However, a common case is to find a path to only one location. A modification of Dijkstraâ€™s Algorithm, optimized for a single destination. It prioritizes paths that seem to be leading closer to the goal. To make the frontier expand towards the goal more than it expands in other directions. First, define a heuristic function that tells us how close we are to the goal, design a heuristic for each type of graph 123def heuristic(a, b): # Manhattan distance on a square grid return abs(a.x - b.x) + abs(a.y - b.y) Use the estimated distance to the goal for the priority queue ordering. The location closest to the goal will be explored first. This algorithm runs faster when there arenâ€™t a lot of obstacles, but the paths arenâ€™t as good(not always the shortest). A* Algorithm Dijkstraâ€™s Algorithm works well to find the shortest path, but it wastes time exploring in directions that arenâ€™t promising. Greedy Best First Search explores in promising directions but it may not find the shortest path. The A* algorithm uses both the actual distance from the start and the estimated distance to the goal. Compare the algorithms: Dijkstraâ€™s Algorithm calculates the distance from the start point. Greedy Best-First Search estimates the distance to the goal point. A* is using the sum of those two distances. So A* is the best of both worlds. As long as the heuristic does not overestimate distances, A* does not use the heuristic to come up with an approximate answer. It finds an optimal path, like Dijkstraâ€™s Algorithm does. A* uses the heuristic to reorder the nodes so that itâ€™s more likely that the goal node will be encountered sooner. Conclusion: Which algorithm should you use for finding paths on a map? If you want to find paths from or to all all locations, use Breadth First Search or Dijkstraâ€™s Algorithm. Use Breadth First Search if movement costs are all the same; use Dijkstraâ€™s Algorithm if movement costs vary. If you want to find paths to one location, use Greedy Best First Search or A*. Prefer A in most cases. When youâ€™re tempted to use Greedy Best First Search, consider using A with an â€œinadmissibleâ€ heuristic. If you want the optimal paths, Breadth First Search and Dijkstraâ€™s Algorithm are guaranteed to find the shortest path given the input graph. Greedy Best First Search is not. A* is guaranteed to find the shortest path if the heuristic is never larger than the true distance. (As the heuristic becomes smaller, A turns into Dijkstraâ€™s Algorithm. As the heuristic becomes larger, A turns into Greedy Best First Search.) Advanced Data StructuresRed-Black TreesRed-black tree leads to a natural implementation of the insertion algorithm for 2-3 trees RBT definition Red-black tree means encoding 2-3 trees in this way: red links, which bind together two 2-nodes to represent 3-nodes, and black links, which bind together the 2-3 tree. An equivalent definition is to define red-black BSTs as BSTs having red and black links and satisfying the following three restrictions: Red links lean left. No node has two red links connected to it. The tree has perfect black balance : every path from the root to a null link has the same number of black links. A 1-1 correspondence: If we draw the red links horizontally in a red-black BST, all of the null links are the same distance from the root, and if we then collapse together the nodes connected by red links, the result is a 2-3 tree. RBT implementaion Color representation: Each node is pointed to by precisely one link from its parent, Encode the color of links in nodes, by adding a boolean instance variable color to our Node data type, which is true if the link from the parent is red and false if it is black. By convention, null links are black. For clarity, define constants RED and BLACK for use in setting and testing this variable. Rotation To correct right-leaning red links or two red links in a row conditions. takes a link to a red-black BST as argument and, assuming that link to be to a Node h whose right link is red, makes the necessary adjustments and returns a link to a node that is the root of a red-black BST for the same set of keys whose left link is red. Actually it is switching from having the smaller of the two keys at the root to having the larger of the two keys at the root. Flipping colors to split a 4-node In addition to flipping the colors of the children from red to black, we also flip the color of the parent from black to red. Keeping the root black. Insertion Maintain the 1-1 correspondence between 2-3 trees and red-black BSTs during insertion by judicious use of three simple operations: left rotate, right rotate, and color flip. If the right child is red and the left child is black, rotate left. If both the left child and its left child are red, rotate right. If both children are red, flip colors. Deletion Assignments Name Hash Game of Life Serafini Recursion Boggle! Patient Queue Huffman Encoding Trailblazer]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>ç¼–ç¨‹</tag>
        <tag>Java</tag>
        <tag>Software Engineer</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn AI Step by Step]]></title>
    <url>%2Fai%2F</url>
    <content type="text"><![CDATA[è®°å½•å­¦ä¹ AIçš„å­¦ä¹ ç¬”è®°ï¼Œå†…å®¹åŒ…å«åŸºç¡€çŸ¥è¯†çš„æ€»ç»“ä»¥åŠç¼–ç¨‹å®žçŽ°çš„æ•´ç†ã€‚ English template è‹±æ–‡æ¨¡æ¿ æœºå™¨å­¦ä¹  Coursera Machine Learningï¼Œ å´æ©è¾¾çš„ç®€åŒ–ç‰ˆæœºå™¨å­¦ä¹  Machine Learning, å´æ©è¾¾çš„æœºå™¨å­¦ä¹ è¯¾ç¨‹ è¿™ä¸ªæ¯”è¾ƒæ·±å…¥ Deep Learning, å´æ©è¾¾çš„æ·±åº¦å­¦ä¹ è¯¾ç¨‹ Neural Networks for Machine Learning, Hintonçš„ç¥žç»ç½‘ç»œè¯¾ç¨‹ æ·±åº¦å­¦ä¹  Deep learning, Coursera Machine Learning Practical: DNN, CNN, RNN æ¯ä¸ªlabçš„ç­”æ¡ˆåœ¨ä¸‹ä¸€ä¸ªlab åˆ†æ”¯ï¼Œå³lab1çš„ç­”æ¡ˆå¯ä»¥åœ¨lab2 branché‡Œé¢çœ‹åˆ°ã€‚è¿™ä¸ªä»£ç å…¨éƒ¨ç”¨Python classï¼Œæ¯”courseraçš„éš¾åº¦é«˜ç‚¹ã€‚ è‡ªç„¶è¯­è¨€å¤„ç† è‡ªç„¶è¯­è¨€å¤„ç†, æ–¯å¦ç¦ åŠ é€Ÿè‡ªç„¶è¯­è¨€å¤„ç†, çˆ±ä¸å ¡å¤§å­¦ æ·±åº¦å­¦ä¹ å¤„ç†è‡ªç„¶è¯­è¨€ï¼Œæ–¯å¦ç¦ è®¡ç®—æœºè§†è§‰ å›¾åƒè¯†åˆ«ï¼šå·ç§¯ç¥žç»ç½‘ç»œï¼ŒæŽé£žé£žï¼Œæ–¯å¦ç¦ æœºå™¨äºº æœºå™¨äººå…¥é—¨ï¼Œæ–¯å¦ç¦]]></content>
      <categories>
        <category>AI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Computer Science Step by Step]]></title>
    <url>%2Fcs%2F</url>
    <content type="text"><![CDATA[æˆ‘å­¦ä¹ CSåŽ†ç¨‹ï¼Œä¹ŸåŒ…å«åŸºç¡€çŸ¥è¯†çš„æ€»ç»“ä»¥åŠç¼–ç¨‹å®žçŽ°çš„æ•´ç†ã€‚ æ¯ä¸€é˜¶æ®µé‡Œé¢, éƒ½æœ‰å¾ˆå¤šä¸ªæ€§åŒ–é€‰é¡¹, ä»…ä¾›å‚è€ƒ å…¥é—¨ CSå…¥é—¨ å­¦ä¹ ç¼–å†™(è‡³å°‘)ä¸€ç§é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€(C ++ï¼ŒJavaÂ®ï¼ŒPythonÂ®) æµ‹è¯•ä½ çš„ä»£ç  å¤¯å®žåŸºç¡€ä½ å¯ä»¥è·³è¿‡è¿™äº›è€Œç›´æŽ¥è¿›å…¥ä¸‹é¢çš„è¿›é˜¶å®žè·µçŽ¯èŠ‚ï¼Œå¹¶æ ¹æ®è‡ªå·±éœ€è¦æŸ¥æ¼è¡¥ç¼ºã€‚ä½†æ˜¯è¿™äº›éƒ½æ˜¯éžå¸¸é‡è¦çš„åŸºç¡€ï¼Œä»»ä½•æ—¶å€™ï¼Œåªè¦æœ‰æ—¶é—´ï¼Œå°±å¯ä»¥åŽ»å­¦ä¹ äº†è§£ã€‚ é€»è¾‘æŽ¨ç†å’Œç¦»æ•£æ•°å­¦ ç†Ÿæ‚‰è®¡ç®—æœºæ“ä½œç³»ç»Ÿ å­¦ä¹ è®¡ç®—æœºç½‘ç»œ æŽŒæ¡æ•°æ®åº“ äº†è§£ç¼–è¯‘å™¨å’Œä¼˜åŒ– äº†è§£è®¡ç®—ç†è®º å­¦ä¹ å…¶ä»–ç¼–ç¨‹è¯­è¨€ è¿›é˜¶ä¸Žå®žè·µ æ·±å…¥äº†è§£ç®—æ³•å’Œæ•°æ®ç»“æž„ åˆ†å¸ƒå¼ï¼Œå¹¶è¡Œå’Œå¤§æ•°æ® å®‰å“å¼€å‘ iOSå¼€å‘ ç½‘é¡µå¼€å‘ åŠ å¯†ä¸ŽåŒºå—é“¾ å‚ä¸Žé¡¹ç›® English template è‹±æ–‡æ¨¡æ¿ CSå…¥é—¨çŽ°åœ¨çš„å…¥é—¨è¯¾åŸºæœ¬éƒ½æ˜¯ç”¨Pythonè¯­è¨€ã€‚ è®¡ç®—æœºç§‘å­¦å¯¼è®ºï¼Œä¼˜è¾¾å­¦åŸŽ CS50x å“ˆä½›ï¼Œè¯­è¨€åŒ…æ‹¬Cï¼ŒPythonï¼ŒSQLå’ŒJavaScriptåŠ CSSå’ŒHTML CMU 15213: Introduction to Computer Systems (ICS) é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€ä¸€èˆ¬è€Œè¨€ï¼Œå»ºè®®å…ˆå­¦Java æˆ– Pythonï¼Œå†å­¦C++ã€‚ è¿™ä¸‰ç§è¯­è¨€éƒ½åŸºæœ¬æŽŒæ¡åŽï¼Œå†æ ¹æ®è‡ªèº«çš„èŒä¸šéœ€æ±‚ï¼Œé€‰æ‹©å…¶ä¸­ä¸€ä¸ªè¯­è¨€ï¼ˆæˆ–è€…å…¶ä»–è¯­è¨€ï¼‰è¿›ä¸€æ­¥æ·±å…¥ç»ƒä¹ ã€‚ é¢å‘åˆå­¦è€…ç¨‹åºå‘˜çš„åœ¨çº¿èµ„æºï¼š ç¼–ç¨‹æ–¹æ³•å­¦ï¼Œæ–¯å¦ç¦CS106Aï¼ŒJava ä¼¯å…‹åˆ©å¤§å­¦CS 61Aè®¡ç®—æœºç¨‹åºçš„ç»“æž„ä¸Žè§£è¯»ï¼ŒPython Javaç¼–ç¨‹ç®€ä»‹ï¼ŒMIT Google Python Class é¢å‘æœ‰ç»éªŒçš„ç¨‹åºå‘˜çš„åœ¨çº¿èµ„æºï¼š æ•°æ®ç»“æž„ï¼Œä¼¯å…‹åˆ©å¤§å­¦ CS 61Bï¼ŒJava è®¡ç®—æœºç¨‹åºè®¾è®¡ï¼ŒUdacityï¼ŒPython æŠ½è±¡ç¼–ç¨‹ï¼Œæ–¯å¦ç¦ CS106Bï¼ŒC ++, æœ€æ–°ä½œä¸š http://web.stanford.edu/class/cs106b/ ã€Šæ•°æ®ç»“æž„ä¸Žç®—æ³•åˆ†æž:C++æè¿°ã€‹, Mark A. Weiss æµ‹è¯•ä½ çš„ä»£ç äº†è§£å¦‚ä½•æ•èŽ·é”™è¯¯ï¼Œåˆ›å»ºæµ‹è¯•å’Œç ´è§£è½¯ä»¶. è½¯ä»¶æµ‹è¯•ï¼ŒUdacity è½¯ä»¶è°ƒè¯•ï¼ŒUdacity æ“ä½œç³»ç»Ÿ CMU 15213: Introduction to Computer Systems (ICS) CS162 UC Berkeley: Operating Systems and Systems Programming é€»è¾‘æŽ¨ç†å’Œç¦»æ•£æ•°å­¦ æ•°å­¦è®¡ç®—æœºç§‘å­¦ï¼Œéº»çœç†å·¥å­¦é™¢ æ•°å­¦æ€è€ƒå¯¼è®ºï¼Œæ–¯å¦ç¦å¤§å­¦ï¼ŒCoursera æ¦‚çŽ‡å›¾å½¢æ¨¡åž‹ï¼Œæ–¯å¦ç¦å¤§å­¦ï¼ŒCoursera åšå¼ˆè®ºï¼ŒCoursera è®¡ç®—ç†è®º Introduction to the theory of computation, Michael Sipser è®¡ç®—æœºç½‘ç»œ Computer Networking A Top-Down Approach, James F. Kurose, Keith W. Ross æ•°æ®åº“ SQL A First Course in Database Systems, Jeffrey D. Ullman, Jennifer Widom ç¼–è¯‘å™¨ç®—æ³•å’Œæ•°æ®ç»“æž„äº†è§£åŸºæœ¬æ•°æ®ç±»åž‹(å †æ ˆï¼Œé˜Ÿåˆ—å’Œè¢‹å­)ï¼ŒæŽ’åºç®—æ³•(å¿«é€ŸæŽ’åºï¼Œåˆå¹¶ï¼Œå †æ ˆ)ï¼Œæ•°æ®ç»“æž„(äºŒå‰æœç´¢æ ‘ï¼Œçº¢é»‘æ ‘ï¼Œå“ˆå¸Œè¡¨)å’ŒBig O. ç®—æ³•ç®€ä»‹ï¼Œéº»çœç†å·¥å­¦é™¢ï¼Œ2011ç§‹å­£ ç®—æ³•ï¼Œæ™®æž—æ–¯é¡¿å¤§å­¦ï¼ŒPart1 ç®—æ³•ï¼Œæ™®æž—æ–¯é¡¿å¤§å­¦ï¼ŒPart2 ç®—æ³•ï¼šè®¾è®¡å’Œåˆ†æžï¼Œæ–¯å¦ç¦å¤§å­¦ ç®—æ³•ï¼Œç¬¬4ç‰ˆï¼Œby Robert Sedgewick and Kevin Wayne åˆ†å¸ƒå¼ï¼Œå¹¶è¡Œå’Œå¤§æ•°æ® Hadoop å’Œ MapReduce å…¥é—¨ï¼Œä¼˜è¾¾å­¦åŸŽ å¹¶è¡Œè®¡ç®—å…¥é—¨ï¼šMPI, openMP, and CUDA, æ–¯å¦ç¦ MapReduce æžé™è®¡ç®—ï¼Œçˆ±ä¸å ¡å¤§å­¦ åŠ å¯†ä¸ŽåŒºå—é“¾ Cryptography, Stanford, Coursera Applied Cryptography, Udacity å®‰å“å¼€å‘ Google Developer Training for Android, on Udacity iOSå¼€å‘ç½‘é¡µå¼€å‘å‚ä¸Žé¡¹ç›® å°è¯•è¯¾å ‚ä»¥å¤–çš„é¡¹ç›®ï¼šåˆ›å»ºå’Œç»´æŠ¤ç½‘ç«™ï¼Œæž„å»ºè‡ªå·±çš„æœåŠ¡å™¨æˆ–æž„å»ºæœºå™¨äººã€‚ Capstone project: Analyzing (Social) Network Data - scroll down to bottom of page,UCSD, Coursera Capstone project: Java Programming: A DIY Version of Netflix and Amazon Recommendation Engines, Duke University, Coursera Project Directory, Apache Google Summer of Code Project Archive å‚ä¸Žå¤§åž‹ç³»ç»Ÿï¼ˆä»£ç åº“ï¼‰çš„ä¸€å°éƒ¨åˆ†ï¼Œé˜…è¯»å¹¶ç†è§£çŽ°æœ‰ä»£ç ï¼Œè·Ÿè¸ªæ–‡æ¡£å’Œè°ƒè¯• Version control with Git GitHubÂ®ï¼šå…³æ³¨githubçƒ­é—¨å¼€æºé¡¹ç›®çš„issue ä¸Žå…¶ä»–ç¨‹åºå‘˜ä¸€èµ·å·¥ä½œ å‚ä¸Žå¼€æºé¡¹ç›®ï¼š å°è¯•æå‡ºä¸€ä¸ªissue é’ˆå¯¹ä¸€ä¸ªissueï¼Œå°è¯•ç»™å‡ºè§£å†³æ–¹æ¡ˆï¼Œå¹¶æäº¤ pull request å‚ä¸Žå…¬å¸å®žä¹  å…¶ä»–ç¼–ç¨‹è¯­è¨€æ ¹æ®å®žé™…éœ€è¦è‡ªè¡Œé€‰æ‹©ä¸€ç§æˆ–å¤šç§å­¦ä¹ , ä¸€äº›åœ¨çº¿èµ„æºï¼š CS50x å“ˆä½›ï¼Œè¯­è¨€åŒ…æ‹¬Cï¼ŒPythonï¼ŒSQLå’ŒJavaScriptåŠ CSSå’ŒHTML Codecademy JavaScript Bento JavaScript Learning Track(Bento) Egghead.io å­¦ä¹ å¦‚ä½•ç¼–ç¨‹ï¼šJavaScript - Epicodus Inc. å­¦ä¹ ï¼šæŸ¥è¯¢ CSS ï¼† HTML Bento CSS Learning Track(Bento) Bento HTML Learning Track(Bento) ç”¨ç ´æŠ˜å·å»ºç«‹ä¸ªäººç½‘ç«™ ä½¿ç”¨Webflowæž„å»ºå“åº”å¼ç½‘ç«™ ä½¿ç”¨éª¨æž¶æž„å»ºSaaSç€é™†é¡µ å»ºç«‹åŠ¨æ€ç½‘ç«™ åœ¨1å°æ—¶å†…ç¼–å†™ä¸ªäººå¯åŠ¨é¡µé¢ï¼šå®žç”¨HTMLå’ŒCSSç®€ä»‹ å­¦ä¹ å¦‚ä½•ç¼–ç¨‹ï¼šCSS - Epicodus Inc. ä»Žå¤´å¼€å§‹å­¦ä¹ HTML5ç¼–ç¨‹ Ruby å­¦ä¹ å¦‚ä½•ç¼–ç¨‹ï¼šRuby - Epicodus Inc. RubyMonk - äº¤äº’å¼Rubyæ•™ç¨‹ Haskell C9ï¼šåŠŸèƒ½ç¼–ç¨‹åŸºç¡€çŸ¥è¯† - Erik Meijer CIS 194ï¼šHaskellç®€ä»‹ - Brent Yorgey CS240hï¼šHaskellçš„åŠŸèƒ½ç³»ç»Ÿ - Bryan Oâ€™Sullivan edXï¼šåŠŸèƒ½ç¼–ç¨‹ç®€ä»‹ - Erik Meijer äºšç›å¤§å­¦ï¼šåŠŸèƒ½ç¼–ç¨‹ - JÃ¼rgenGiesl Lua Lua Interactive Crash Course Lua Tutorial PHP å­¦ä¹ å¦‚ä½•ç¼–ç¨‹ï¼šPHP - Epicodus Inc. GO Go Tutorial å‚è€ƒèµ„æ–™Guide to technical development from Google educationOS Free Programming Books]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
</search>
