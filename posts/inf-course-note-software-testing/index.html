<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Inf Course Note - Software Testing | Cong's Log</title><meta name=keywords content="Java,Software Engineer,Inf Course Note"><meta name=description content="爱丁堡大学信息学院课程笔记 Software Testing, Informatics, University of Edinburgh
Reference:
http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html
Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.

Why Software Testing?
1, 软件的漏洞, 错误和失效 Software Faults, Errors & Failures
The problem start with Faults,

Fault(BUG): latent error, mistakes in programming.
e.g add(x, y) = x * y.
With the Faults in programs, if and only if executing add(x, y) = x * y, the fault being activated, and generate an Errors."><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/inf-course-note-software-testing/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/inf-course-note-software-testing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/inf-course-note-software-testing/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="Inf Course Note - Software Testing"><meta property="og:description" content="爱丁堡大学信息学院课程笔记 Software Testing, Informatics, University of Edinburgh
Reference: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.
Why Software Testing? 1, 软件的漏洞, 错误和失效 Software Faults, Errors & Failures The problem start with Faults,
Fault(BUG): latent error, mistakes in programming.
e.g add(x, y) = x * y. With the Faults in programs, if and only if executing add(x, y) = x * y, the fault being activated, and generate an Errors."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-30T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-30T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Software Engineer"><meta property="article:tag" content="Inf Course Note"><meta name=twitter:card content="summary"><meta name=twitter:title content="Inf Course Note - Software Testing"><meta name=twitter:description content="爱丁堡大学信息学院课程笔记 Software Testing, Informatics, University of Edinburgh
Reference:
http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html
Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.

Why Software Testing?
1, 软件的漏洞, 错误和失效 Software Faults, Errors & Failures
The problem start with Faults,

Fault(BUG): latent error, mistakes in programming.
e.g add(x, y) = x * y.
With the Faults in programs, if and only if executing add(x, y) = x * y, the fault being activated, and generate an Errors."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Inf Course Note - Software Testing","item":"https://congchan.github.io/posts/inf-course-note-software-testing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Inf Course Note - Software Testing","name":"Inf Course Note - Software Testing","description":"爱丁堡大学信息学院课程笔记 Software Testing, Informatics, University of Edinburgh\nReference: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.\nWhy Software Testing? 1, 软件的漏洞, 错误和失效 Software Faults, Errors \u0026amp; Failures The problem start with Faults,\nFault(BUG): latent error, mistakes in programming.\ne.g add(x, y) = x * y. With the Faults in programs, if and only if executing add(x, y) = x * y, the fault being activated, and generate an Errors.\n","keywords":["Java","Software Engineer","Inf Course Note"],"articleBody":"爱丁堡大学信息学院课程笔记 Software Testing, Informatics, University of Edinburgh\nReference: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.\nWhy Software Testing? 1, 软件的漏洞, 错误和失效 Software Faults, Errors \u0026 Failures The problem start with Faults,\nFault(BUG): latent error, mistakes in programming.\ne.g add(x, y) = x * y. With the Faults in programs, if and only if executing add(x, y) = x * y, the fault being activated, and generate an Errors.\nError: An incorrect internal state that is the manifestation of some fault\nNow we has an effective Error, if and only if we use the values from add(x, y) = x * y to contribute to the program function (such as, assign it to some variables), then we get the Failure.\nFailure : External, observable incorrect behavior with respect to the requirements or other description of the expected behavior.\n总结: 软件的漏洞不一定会导致错误, 错误不一定会导致软件失效.\n2, 软件工程需要验证确认\n在软件项目管理、软件工程及软件测试中，验证及确认（verification and validation，简称V\u0026V）是指检查软件是否匹配规格及其预期目的的程序。验证及确认也被视为一种软件质量管理，是软件开发过程的一部分，一般归类在软件测试中。\nValidation: 是否符合预期的目的，是否满足用户实际需求？\nVerification: meets the specification?\nVerification and Validation （V\u0026V） start at the beginning or even before we decide to build a software product. V\u0026V last far beyond the product delivery as long as the software is in use, to cope with evolution and adaptations to new conditions.\nThe distinction between the two terms is largely to do with the role of specifications. Validation is the process of checking whether the specification captures the customer’s needs, while verification is the process of checking that the software meets the specification. ![](/images/VandVtoolbox.jpg “V＆V包含的技术细节。 “modeling” 和 “model checking\"指建立和分析软件行为的抽象模型。image from: http://www.easterbrook.ca/steve/2010/11/the-difference-between-verification-and-validation/\")\n3, 软件工程的可靠性 Dependability\nIn software engineering, dependability is the ability to provide services that can defensibly be trusted within a time-period\nAssess the readiness of a product.\nDifferent measures of dependability: • Availability measures the quality of service in terms of running versus down time • Mean time between failures (MTBF) measures the quality of the service in terms of time between failures • Reliability indicates the fraction of all attempted operations that complete successfully\nJUnits JUnit Terminology • A test runner is software that runs tests and reports results. Many implementations: standalone GUI, command line, integrated into IDE • A test suite is a collection of test cases. • A test case tests the response of a single method to a particular set of inputs. • A unit test is a test of the smallest element of code you can sensibly test, usually a single class.\n如何使用请参考Java 测试.\nTest class @Before public void init(): Creates a test fixture by creating and initialising objects and values.\n@After public void cleanUp(): Releases any system resources used by the test fixture. Java usually does this for free, but files, network connections etc. might not get tidied up automatically.\n@Test public void noBadTriangles(), @Test public void scaleneOk(), etc. These methods contain tests for the Triangle constructor and its isScalene() method.\nTest assert static void assertTrue(boolean test), static void assertTrue(String message, boolean test), static void assertFalse(boolean test), static void assertFalse(String message, boolean test)\n软件测试的核心问题和解决思路 A key problem in software testing is selecting and evaluating test cases.\nTest case: A test case is a set of inputs, execution conditions, and a pass/fail criterion. Test case specification is a requirement to be satisfied by one or more actual test cases. Test suite: a set of test cases. Adequacy criterion: a predicate that is true (satisfied) or false (not satisfied) of a \u003c program, test suite \u003e pair. Adequacy criterion is a set of test obligations, which can be derived from several sources of information, including • specifications (functional and model-based testing) • detailed design and source code (structural testing), • model of system • hypothesized defects (fault-based testing), • security testing.\nTest Case Selection and Adequacy Criteria How do we know when the test suite is enough? It is impossibal to provide adequate test suite for a system to pass. Instead, design rules to highlight inadequacy of test suites: if outcome break the rule, then there is bugs, if not, then not sure…\nTest case specification: a requirement to be satisfied by one or more test cases.\nTest obligation: a partial test case specification, requiring some property deemed important to thorough testing. From: • Functional (black box specification Functional (black box, specification based): from software specifications • Structural (white or glass box): from code • Model-based: from model of system, models used in specification or design, or derived from code • Fault-based: from hypothesized faults (common bugs)\nAdequacy criterion: set of test obligations, a predicate that is true (satisfied) or false (not satisfied) of a (program, test suite) pair.\nA test suite satisfies an adequacy criterion if: • all the tests succeed (pass) • every test obligation in the criterion is satisfied by at least one of the test cases in the test suite.\nSatisfiability Sometimes no test suite can satisfy a criterion for a given program, e.g. defensive programming style includes “can’t happen” sanity checks.\nCoping with Unsatisfiability: Approach A, exclude any unsatisfiable obligation from the criterion. • Example: modify statement coverage to require execution only of statements that can be executed - But we can’t know for sure which are executable!\nApproach B, measure the extent to which a test suite approaches an adequacy criterion • Example: if a test suite satisfies 85 of 100 obligations we have reached 85% coverage.\nAn adequacy criterion is satisfied or not, a coverage measure is the fraction of satisfied obligations\nSubsumption relation Test adequacy criterion A subsumes test adequacy criterion B iff, for every program P, every test suite satisfying A with respect to P also satisfies B with respect to P.\ne.g. Exercising all program branches (branch coverage) subsumes exercising all program statements\nFunctional Testing Design functional test case: Generate test cases from specifications.\nSpecification: A functional specification is a description of intended program behavior.\nNot based on the internals of the code but program specifications, functional testing is also called specification-based or black-box testing 黑箱測試.\nThe core of functional test is systematic selection of test cases: partitioning the possible behaviors of the program into a finite number of homogeneous classes, where each such class can reasonably be expected to be consistently correct or incorrect. Test each category and boundaries between (experience suggests failures often lie at the boundaries).\nFunctional test case design is an indispensable base of a good test suite, complemented but never replaced by structural and fault-based testing, because there are classes of faults that only functional testing effectively detects. Omission of a feature, for example, is unlikely to be revealed by techniques that refer only to the code structure.\nPartition Strategies Failures are sparse in the whole input space, and dense in some specific regions, justified based on specification.\nRandom (uniform): • Pick possible inputs uniformly • Avoids designer bias: The test designer can make the same logical mistakes and bad assumptions as the program designer (especially if they are the same person) • But treats all inputs as equally valuable\nSystematic (non-uniform, Partition Testing Strategies): • Try to select inputs that are especially valuable • Usually by choosing representatives of classes that are apt to fail often or not at all • (Quasi-)Partition: separates the input space into classes whose union is the entire space (classes may overlap), sampling each class in the quasi-partition selects at least one input that leads to a failure, revealing the fault.\nSteps of systematic approaches to form test cases from specifications: 1, Decompose the specification. If the specification is large, break it into independently testable features (ITF) to be considered in testing: • An ITF is a functionality that can be tested independently of other functionalities of the software under test. It need not correspond to a unit or subsystem of the software. • ITFs are described by identifying all the inputs that form their execution environments. • ITFs are applied at different granularity levels, from unit testing through integration and system testing. The granularity of an ITF depends on the exposed interface and whichever granularity(unit or system) is being tested. 2, Identify Representative Classes of Values or Derive a Model • Representative values of each input • Representative behaviors of a model: simple input/output transformations don’t describe a system. We use models in program specification, in program design, and in test design 3, Generate Test Case Specifications with constraints: The test case specifications represented by the combinations (cartesian product) of all possible inputs or model behaviors, which must be restricted by ruling out illegal combinations and selecting a practical subset of the legal combinations.\nGiven a specification, there may be one or more techniques well suited for deriving functional test case. For example, the presence of several constraints on the input domain may suggest using a partitioning method with constraints, such as the category-partition method. While unconstrained combinations of values may suggest a pairwise combinatorial approach. If transitions among a finite set of system states are identifiable in the specification, a finite state machine approach may be indicated.\nCombinatorial approaches Combinatorial approaches to functional testing consist of a manual step of structuring the specification statement into a set of properties or attributes that can be systematically varied and an automatizable step of producing combinations of choices.\n总体思路： 1, Identify distinct attributes that can be varied: the data, environment, or configuration 2, Systematically generate combinations to be tested\nRational: test cases should be varied and include possible “corner cases”\nEnvironment describes external factors we need to configure in particular ways in order to specify and execute tests to fully exercise the system. Some common options: System memory, Locale.\nThere are three main techniques that are successfully used in industrial environments and represent modern approaches to systematically derive test cases from natural language specifications: • category-partition approach to identifying attributes, relevant values, and possible combinations; • Pairwise (n-way) combination test a large number of potential interactions of attributes with a relatively small number of inputs; • provision of catalogs to systematize the manual aspects of combinatorial testing.\nCombinatorial approaches 将test cases的粗暴合成分解成一个个步骤，通过解析和综合那些可以量化和监控(并得到工具部分支持)的活动来逐步拆解问题.\nA combinatorial approach may work well for functional units characterized by a large number of relatively independent inputs, but may be less effective for functional units characterized by complex interrelations among inputs.\nCategory-partition 和 pairwise partition 都是使用上面的总体思路，差别在于最后如何自动生成 test cases。\nCategory-partition 将穷举枚举作为自动生成combinations的基本方法，同时允许测试设计者添加限制组合数量增长的约束条件。当这些约束能够反映应用域中的真实约束（例如，category-partition中的\"error\"条目）时，能够非常有效地消除许多冗余组合。\nDecompose the specification into independently testable features for each feature: identify parameters, environment elements for each parameter and environment element: identify elementary characteristics (categories) Identify relevant/representative values: for each category identify representative (classes of) values normal values boundary values select extreme values within a class ((e.g., maximum and minimum legal values) select values outside but as close as possible to the class select interior (non-extreme) values of the class special values: 0 and 1, might cause unanticipated behavior alone or in combination with particular values of other parameters. error values: values outside the normal domain of the program Ignore interactions among values for different categories (considered in the next step) Introduce constraints: rule out invalid combinations. For single consgtraints, indicates a value class that test designers choose to test only once to reduce the number of test cases. 优点：Category partition testing gave us systematic approach -Identify characteristics and values (the creative step), generate combinations (the mechanical step).\n缺点：test suite size grows very rapidly with number of categories.\n不适合使用Category partition testing的情况：当缺乏应用领域的实际约束时，测试设计者为了减少组合数量被迫任意添加的约束（例如，“single\"条目），此时不能很有效的减少组合数量。\nPairwise combination testing Most failures are triggered by single values or combinations of a few values.\n为n个测试类选择组合时，除了简单地枚举所有可能的组合外，更实际的组合方案是在集合n中取出k(k","wordCount":"10351","inLanguage":"en","datePublished":"2018-06-30T00:00:00Z","dateModified":"2018-06-30T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/inf-course-note-software-testing/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Inf Course Note - Software Testing</h1><div class=post-meta><span title='2018-06-30 00:00:00 +0000 UTC'>2018-06-30</span>&nbsp;·&nbsp;49 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/UoE-st.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#why-software-testing aria-label="Why Software Testing?">Why Software Testing?</a></li><li><a href=#junits aria-label=JUnits>JUnits</a></li><li><a href=#%e8%bd%af%e4%bb%b6%e6%b5%8b%e8%af%95%e7%9a%84%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98%e5%92%8c%e8%a7%a3%e5%86%b3%e6%80%9d%e8%b7%af aria-label=软件测试的核心问题和解决思路>软件测试的核心问题和解决思路</a><ul><li><a href=#test-case-selection-and-adequacy-criteria aria-label="Test Case Selection and Adequacy Criteria">Test Case Selection and Adequacy Criteria</a></li><li><a href=#satisfiability aria-label=Satisfiability>Satisfiability</a></li><li><a href=#subsumption-relation aria-label="Subsumption relation">Subsumption relation</a></li></ul></li><li><a href=#functional-testing aria-label="Functional Testing">Functional Testing</a><ul><li><a href=#partition-strategies aria-label="Partition Strategies">Partition Strategies</a></li><li><a href=#combinatorial-approaches aria-label="Combinatorial approaches">Combinatorial approaches</a><ul><li><a href=#category-partition aria-label=Category-partition>Category-partition</a></li><li><a href=#pairwise-combination-testing aria-label="Pairwise combination testing">Pairwise combination testing</a></li></ul></li><li><a href=#befinits-of-functional-testing aria-label="Befinits of functional testing">Befinits of functional testing</a></li></ul></li><li><a href=#finite-models aria-label="Finite Models">Finite Models</a><ul><li><a href=#controal-flow-graph aria-label="Controal flow graph">Controal flow graph</a></li><li><a href=#call-graphs aria-label="Call Graphs">Call Graphs</a></li><li><a href=#finite-state-machines aria-label="Finite state machines">Finite state machines</a></li></ul></li><li><a href=#structural-testing aria-label="Structural Testing">Structural Testing</a><ul><li><a href=#control-flow-adequacy-expression-coverage aria-label="Control-flow Adequacy (expression coverage)">Control-flow Adequacy (expression coverage)</a></li><li><a href=#statement-testing aria-label="Statement testing">Statement testing</a></li><li><a href=#branch-testing aria-label="Branch testing">Branch testing</a></li><li><a href=#condition-testing aria-label="Condition testing">Condition testing</a></li><li><a href=#modified-conditiondecision-adequacy-criterion-mcdc aria-label="Modified condition/decision adequacy criterion (MC/DC)">Modified condition/decision adequacy criterion (MC/DC)</a></li><li><a href=#path-testing aria-label="Path Testing">Path Testing</a><ul><li><a href=#boundary-interior-coverage aria-label="Boundary Interior Coverage">Boundary Interior Coverage</a></li><li><a href=#loop-boundary-coverage aria-label="Loop Boundary Coverage">Loop Boundary Coverage</a></li><li><a href=#linear-code-sequences-and-jumps aria-label="Linear Code Sequences and Jumps">Linear Code Sequences and Jumps</a></li><li><a href=#cyclomatic-adequacy-complexity-coverage aria-label="Cyclomatic adequacy (Complexity coverage)">Cyclomatic adequacy (Complexity coverage)</a></li></ul></li><li><a href=#procedure-call-coverage aria-label="Procedure call coverage">Procedure call coverage</a></li><li><a href=#satisfying-structural-criteria aria-label="Satisfying structural criteria">Satisfying structural criteria</a></li></ul></li><li><a href=#dependence-and-data-flow-models aria-label="Dependence and Data Flow Models">Dependence and Data Flow Models</a><ul><li><a href=#definition-use-pairs-def-use-pairs aria-label="Definition-Use Pairs (Def-Use Pairs)">Definition-Use Pairs (Def-Use Pairs)</a></li><li><a href=#analyses-reaching-definition aria-label="Analyses: Reaching definition">Analyses: Reaching definition</a></li><li><a href=#analyses-live-and-avail aria-label="Analyses: Live and Avail">Analyses: Live and Avail</a></li><li><a href=#iterative-solution-of-dataflow-equations aria-label="Iterative Solution of Dataflow Equations">Iterative Solution of Dataflow Equations</a></li><li><a href=#from-execution-to-conservative-flow-analysis aria-label="From Execution to Conservative Flow Analysis">From Execution to Conservative Flow Analysis</a></li><li><a href=#data-flow-analysis-with-arrays-and-pointers aria-label="Data flow analysis with arrays and pointers">Data flow analysis with arrays and pointers</a></li><li><a href=#scope-of-data-flow-analysis aria-label="Scope of Data Flow Analysis">Scope of Data Flow Analysis</a></li><li><a href=#summary-of-data-flow-models aria-label="Summary of Data flow models">Summary of Data flow models</a></li></ul></li><li><a href=#data-flow-testing aria-label="Data Flow Testing">Data Flow Testing</a><ul><li><a href=#data-flow-coverage-with-complex-structures aria-label="Data flow coverage with complex structures">Data flow coverage with complex structures</a></li></ul></li><li><a href=#mutation-testing aria-label="Mutation testing">Mutation testing</a></li><li><a href=#model-based-testing aria-label="Model based testing">Model based testing</a></li><li><a href=#testing-object-oriented-software aria-label="Testing Object Oriented Software">Testing Object Oriented Software</a><ul><li><a href=#intraclass-state-machine-testing aria-label="Intraclass State Machine Testing">Intraclass State Machine Testing</a></li><li><a href=#intraclass-data-flow-testing aria-label="Intraclass data flow testing">Intraclass data flow testing</a></li><li><a href=#interclass-testing aria-label="Interclass Testing">Interclass Testing</a></li><li><a href=#interclass-structural-testing aria-label="Interclass structural testing">Interclass structural testing</a></li><li><a href=#polymorphism-and-dynamic-binding aria-label="Polymorphism and dynamic binding">Polymorphism and dynamic binding</a></li><li><a href=#inheritance aria-label=Inheritance>Inheritance</a></li><li><a href=#testing-exception-handling aria-label="Testing exception handling">Testing exception handling</a></li></ul></li><li><a href=#integration-testing aria-label="Integration Testing">Integration Testing</a></li><li><a href=#component-based-software-testing aria-label="Component-based software testing">Component-based software testing</a></li><li><a href=#system-acceptance-and-regression-testing aria-label="System, Acceptance, and Regression Testing">System, Acceptance, and Regression Testing</a></li><li><a href=#system-testing aria-label="System Testing">System Testing</a><ul><li><a href=#stress-testing aria-label="Stress Testing">Stress Testing</a></li></ul></li><li><a href=#acceptance-testing aria-label="Acceptance testing">Acceptance testing</a><ul><li><a href=#system-reliability aria-label="System Reliability">System Reliability</a></li><li><a href=#process-based-measures aria-label="Process-based Measures">Process-based Measures</a></li></ul></li><li><a href=#regression-testing aria-label="Regression Testing">Regression Testing</a><ul><li><a href=#regression-test-selection aria-label="Regression Test Selection">Regression Test Selection</a></li><li><a href=#test-set-minimization aria-label="Test Set Minimization">Test Set Minimization</a></li><li><a href=#test-set-prioritisation aria-label="Test Set Prioritisation">Test Set Prioritisation</a></li></ul></li><li><a href=#test-driven-development-tdd aria-label="Test-Driven Development (TDD)">Test-Driven Development (TDD)</a></li><li><a href=#automating-test-execution aria-label="Automating Test Execution">Automating Test Execution</a><ul><li><a href=#scaffolding aria-label=Scaffolding>Scaffolding</a></li></ul></li><li><a href=#security-testing aria-label="Security Testing">Security Testing</a><ul><li><a href=#penetration-testing aria-label="Penetration testing">Penetration testing</a></li><li><a href=#fuzz-testing aria-label="Fuzz testing">Fuzz testing</a></li><li><a href=#concolic-testing aria-label="Concolic testing">Concolic testing</a></li></ul></li><li><a href=#software-process-models---software-development aria-label="Software Process Models - Software Development">Software Process Models - Software Development</a></li><li><a href=#planning-and-monitoring-the-process aria-label="Planning and Monitoring the Process">Planning and Monitoring the Process</a><ul><li><a href=#strategies-vs-plans aria-label="Strategies vs. Plans">Strategies vs. Plans</a></li><li><a href=#schedule-risk aria-label="Schedule Risk">Schedule Risk</a></li><li><a href=#risk-planning aria-label="Risk Planning">Risk Planning</a></li><li><a href=#contingency-plan aria-label="Contingency Plan">Contingency Plan</a></li><li><a href=#process-monitoring aria-label="Process Monitoring">Process Monitoring</a></li><li><a href=#process-improvement aria-label="Process Improvement">Process Improvement</a></li></ul></li></ul></div></details></div><div class=post-content><p>爱丁堡大学信息学院课程笔记 Software Testing, Informatics, University of Edinburgh</p><p>Reference:
<a href=http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html>http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/index.html</a>
Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.</p><h2 id=why-software-testing>Why Software Testing?<a hidden class=anchor aria-hidden=true href=#why-software-testing>#</a></h2><p><strong>1, 软件的漏洞, 错误和失效 Software Faults, Errors & Failures</strong>
The problem start with Faults,</p><blockquote><p>Fault(BUG): latent error, mistakes in programming.</p></blockquote><p>e.g <code>add(x, y) = x * y</code>.
With the Faults in programs, <strong>if and only if</strong> executing <code>add(x, y) = x * y</code>, the fault being activated, and generate an Errors.</p><blockquote><p>Error: An incorrect <strong>internal</strong> state that is the manifestation of some fault</p></blockquote><p>Now we has an effective Error, <strong>if and only if</strong> we use the values from <code>add(x, y) = x * y</code> to contribute to the program function (such as, assign it to some variables), then we get the Failure.</p><blockquote><p>Failure : <strong>External</strong>, observable incorrect behavior with respect to the requirements or other description of the expected behavior.</p></blockquote><p>总结: 软件的漏洞不一定会导致错误, 错误不一定会导致软件失效.</p><p><strong>2, 软件工程需要验证确认</strong></p><blockquote><p>在软件项目管理、软件工程及软件测试中，验证及确认（verification and validation，简称V&amp;V）是指检查软件是否匹配规格及其预期目的的程序。验证及确认也被视为一种软件质量管理，是软件开发过程的一部分，一般归类在软件测试中。</p></blockquote><p>Validation: 是否符合预期的目的，是否满足用户实际需求？</p><p>Verification: meets the specification?</p><p>Verification and Validation （V&amp;V） start at the beginning or even before we decide to build a software product. V&amp;V last far beyond the product delivery as long as the software is in use, to cope with evolution and adaptations to new conditions.</p><p>The distinction between the two terms is largely to do with the role of specifications. Validation is the process of checking whether the specification captures the customer&rsquo;s needs, while verification is the process of checking that the software meets the specification.
![](/images/VandVtoolbox.jpg &ldquo;V＆V包含的技术细节。 &ldquo;modeling&rdquo; 和 &ldquo;model checking"指建立和分析软件行为的抽象模型。image from: <a href=http://www.easterbrook.ca/steve/2010/11/the-difference-between-verification-and-validation/%22>http://www.easterbrook.ca/steve/2010/11/the-difference-between-verification-and-validation/"</a>)</p><p><strong>3, 软件工程的可靠性 Dependability</strong></p><blockquote><p>In software engineering, dependability is the ability to provide services that can defensibly be trusted within a time-period</p></blockquote><p>Assess the readiness of a product.</p><p>Different measures of dependability:
• Availability measures the quality of service in terms of running versus down time
• Mean time between failures (MTBF) measures the quality of the service in terms of time between failures
• Reliability indicates the fraction of all attempted operations that complete successfully</p><h2 id=junits>JUnits<a hidden class=anchor aria-hidden=true href=#junits>#</a></h2><p>JUnit Terminology
• A test runner is software that runs tests and reports results. Many implementations: standalone GUI, command line, integrated into IDE
• A test suite is a collection of test cases.
• A test case tests the response of a single method to a particular set of inputs.
• A unit test is a test of the smallest element of code you can sensibly test, usually a single class.</p><p>如何使用请参考<a href=/NOTE-CS61B-data-structures-11-testing>Java 测试</a>.</p><p>Test class
<code>@Before public void init()</code>: Creates a test fixture by creating and initialising objects and values.</p><p><code>@After public void cleanUp()</code>: Releases any system resources used by the test fixture. Java usually does this for free, but files, network connections etc. might not get tidied up automatically.</p><p><code>@Test public void noBadTriangles()</code>, <code>@Test public void scaleneOk()</code>, etc.
These methods contain tests for the Triangle constructor and its isScalene() method.</p><p>Test assert
<code>static void assertTrue(boolean test)</code>,
<code>static void assertTrue(String message, boolean test)</code>,
<code>static void assertFalse(boolean test)</code>,
<code>static void assertFalse(String message, boolean test)</code></p><h2 id=软件测试的核心问题和解决思路>软件测试的核心问题和解决思路<a hidden class=anchor aria-hidden=true href=#软件测试的核心问题和解决思路>#</a></h2><p>A key problem in software testing is <strong>selecting and evaluating</strong> test cases.</p><ul><li>Test case: A test case is a set of inputs, execution conditions, and a pass/fail criterion.</li><li><strong>Test case specification</strong> is a requirement to be satisfied by one or more actual test cases.</li><li>Test suite: a set of test cases.</li><li>Adequacy criterion: a predicate that is true (satisfied) or false (not satisfied) of a &lt; program, test suite > pair.</li></ul><p>Adequacy criterion is a set of test obligations, which can be derived from several sources of information, including
• specifications (functional and model-based testing)
• detailed design and source code (structural testing),
• model of system
• hypothesized defects (fault-based testing),
• security testing.</p><h3 id=test-case-selection-and-adequacy-criteria>Test Case Selection and Adequacy Criteria<a hidden class=anchor aria-hidden=true href=#test-case-selection-and-adequacy-criteria>#</a></h3><p>How do we know when the test suite is enough?
It is impossibal to provide adequate test suite for a system to pass. Instead, <strong>design rules to highlight inadequacy of test suites</strong>: if outcome break the rule, then there is bugs, if not, then not sure&mldr;</p><p>Test case specification: a requirement to be satisfied by one or more test cases.</p><p>Test obligation: a partial test case specification, requiring some property deemed important to thorough testing. From:
• Functional (black box specification Functional (black box, specification based): from software specifications
• Structural (white or glass box): from code
• Model-based: from model of system, models used in specification or design, or derived from code
• Fault-based: from hypothesized faults (common bugs)</p><p>Adequacy criterion: set of test obligations, a predicate that is true (satisfied) or false (not satisfied) of a (program, test suite) pair.</p><p>A test suite satisfies an adequacy criterion if:
• all the tests succeed (pass)
• every test obligation in the criterion is satisfied by at least one of the test cases in the test suite.</p><h3 id=satisfiability>Satisfiability<a hidden class=anchor aria-hidden=true href=#satisfiability>#</a></h3><p>Sometimes no test suite can satisfy a criterion for a given program, e.g. defensive programming style includes &ldquo;can&rsquo;t happen&rdquo; sanity checks.</p><p>Coping with Unsatisfiability:
Approach A, exclude any unsatisfiable obligation from the criterion.
• Example: modify statement coverage to require execution only of statements that can be executed - But we can&rsquo;t know for sure which are executable!</p><p>Approach B, measure the extent to which a test suite approaches an adequacy criterion
• Example: if a test suite satisfies 85 of 100 obligations we have reached 85% coverage.</p><p>An adequacy criterion is satisfied or not, a coverage measure is the fraction of satisfied obligations</p><h3 id=subsumption-relation>Subsumption relation<a hidden class=anchor aria-hidden=true href=#subsumption-relation>#</a></h3><p>Test adequacy criterion A subsumes test adequacy criterion B iff, for every program P, every test suite satisfying A with respect to P also satisfies B with respect to P.</p><p>e.g. Exercising all program branches (branch coverage) subsumes exercising all program statements</p><h2 id=functional-testing>Functional Testing<a hidden class=anchor aria-hidden=true href=#functional-testing>#</a></h2><p>Design functional test case: Generate test cases from specifications.</p><p>Specification: A <strong>functional specification</strong> is a description of intended program behavior.</p><p>Not based on the internals of the code but program specifications, functional testing is also called <strong>specification-based</strong> or <strong>black-box testing 黑箱測試</strong>.</p><p>The core of functional test is systematic selection of test cases: <strong>partitioning</strong> the possible behaviors of the program into a finite number of homogeneous classes, where each such class can reasonably be expected to be consistently correct or incorrect. Test each category and boundaries between (experience suggests failures often lie at the boundaries).</p><blockquote><p><strong>Functional test case design</strong> is an indispensable base of a good test suite, complemented but never replaced by <strong>structural and fault-based testing</strong>, because there are classes of faults that only functional testing effectively detects. Omission of a feature, for example, is unlikely to be revealed by techniques that refer only to the code structure.</p></blockquote><h3 id=partition-strategies>Partition Strategies<a hidden class=anchor aria-hidden=true href=#partition-strategies>#</a></h3><p>Failures are sparse in the whole input space, and dense in some specific regions, justified based on specification.</p><p><strong>Random</strong> (uniform):
• Pick possible inputs uniformly
• Avoids designer bias: The test designer can make the same logical mistakes and bad assumptions as the program designer (especially if they are the same person)
• But treats all inputs as equally valuable</p><p><strong>Systematic</strong> (non-uniform, Partition Testing Strategies):
• Try to select inputs that are especially valuable
• Usually by choosing representatives of classes that are apt to fail often or not at all
• (Quasi-)Partition: separates the input space into classes whose union is the entire space (classes may overlap), sampling each class in the quasi-partition selects at least one input that leads to a failure, revealing the fault.</p><p>Steps of systematic approaches to form test cases from specifications:
1, Decompose the specification. If the specification is large, break it into independently testable features (ITF) to be considered in testing:
• An ITF is a functionality that can be tested independently of other functionalities of the software under test. It need not correspond to a unit or subsystem of the software.
• ITFs are described by identifying all the inputs that form their execution environments.
• ITFs are applied at different granularity levels, from unit testing through integration and system testing. The granularity of an ITF depends on the exposed interface and whichever granularity(unit or system) is being tested.
2, Identify Representative Classes of Values or Derive a Model
• Representative values of each input
• Representative behaviors of a model: simple input/output transformations don&rsquo;t describe a system. We use models in program specification, in program design, and in test design
3, Generate Test Case Specifications with constraints: The test case specifications represented by the <strong>combinations</strong> (cartesian product) of all possible inputs or model behaviors, which must be restricted by ruling out illegal combinations and selecting a practical subset of the legal combinations.</p><p>Given a specification, there may be one or more techniques well suited for deriving functional test case. For example, the presence of several constraints on the input domain may suggest using a partitioning method with constraints, such as the <a href=/posts/inf-course-note-software-testing/#category-partition>category-partition method</a>. While unconstrained combinations of values may suggest a <a href=/posts/inf-course-note-software-testing/#pairwise-combination-testing>pairwise combinatorial approach</a>. If transitions among a finite set of system states are identifiable in the specification, a finite state machine approach may be indicated.</p><h3 id=combinatorial-approaches>Combinatorial approaches<a hidden class=anchor aria-hidden=true href=#combinatorial-approaches>#</a></h3><blockquote><p>Combinatorial approaches to functional testing consist of a manual step of structuring the specification statement into a set of properties or attributes that can be <strong>systematically varied</strong> and an automatizable step of producing combinations of choices.</p></blockquote><p>总体思路：
1, Identify <strong>distinct</strong> attributes that can be varied: the data, environment, or configuration
2, Systematically generate combinations to be tested</p><p>Rational: test cases should be varied and include possible &ldquo;corner cases&rdquo;</p><p><strong>Environment</strong> describes external factors we need to configure in particular ways in order to specify and execute tests to fully exercise the system. Some common options: System memory, Locale.</p><p>There are three main techniques that are successfully used in industrial environments and represent modern approaches to systematically derive test cases from natural language specifications:
• category-partition approach to identifying attributes, relevant values, and possible combinations;
• Pairwise (n-way) combination test a large number of potential interactions of attributes with a relatively small number of inputs;
• provision of catalogs to systematize the manual aspects of combinatorial testing.</p><p>Combinatorial approaches 将test cases的粗暴合成分解成一个个步骤，通过解析和综合那些可以量化和监控(并得到工具部分支持)的活动来逐步拆解问题.</p><p>A combinatorial approach may work well for functional units characterized by a large number of <strong>relatively independent inputs</strong>, but may be less effective for functional units characterized by complex interrelations among inputs.</p><p>Category-partition 和 pairwise partition 都是使用上面的总体思路，差别在于最后如何自动生成 test cases。</p><h4 id=category-partition>Category-partition<a hidden class=anchor aria-hidden=true href=#category-partition>#</a></h4><p>将穷举枚举作为自动生成combinations的基本方法，同时允许测试设计者添加限制组合数量增长的约束条件。当这些约束能够反映应用域中的真实约束（例如，category-partition中的"error"条目）时，能够非常有效地消除许多冗余组合。</p><ol><li>Decompose the specification into independently testable features<ul><li>for each feature: identify parameters, environment elements</li><li>for each parameter and environment element: identify elementary characteristics (categories)</li></ul></li><li>Identify relevant/representative values: for each category identify representative (classes of) values<ul><li>normal values</li><li>boundary values<ul><li>select extreme values within a class ((e.g., maximum and minimum legal values)</li><li>select values outside but as close as possible to the class</li><li>select interior (non-extreme) values of the class</li></ul></li><li>special values: 0 and 1, might cause unanticipated behavior alone or in combination with particular values of other parameters.</li><li>error values: values outside the normal domain of the program</li><li>Ignore interactions among values for different categories (considered in the next step)</li></ul></li><li>Introduce constraints: rule out invalid combinations. For single consgtraints, indicates a value class that test designers choose to test only once to reduce the number of test cases.</li></ol><p>优点：Category partition testing gave us systematic approach -Identify characteristics and values (the creative step), generate combinations (the mechanical step).</p><p>缺点：test suite size grows very rapidly with number of categories.</p><p>不适合使用Category partition testing的情况：当缺乏应用领域的实际约束时，测试设计者为了减少组合数量被迫任意添加的约束（例如，&ldquo;single"条目），此时不能很有效的减少组合数量。</p><h4 id=pairwise-combination-testing>Pairwise combination testing<a hidden class=anchor aria-hidden=true href=#pairwise-combination-testing>#</a></h4><p>Most failures are triggered by single values or combinations of a few values.</p><p>为n个测试类选择组合时，除了简单地枚举所有可能的组合外，更实际的组合方案是在集合n中取出k(<code>k&lt;n</code>)项, 一般是二元组或三元组，总的 test cases 要包含所有 features 的两两（或三三）组合。生成测试用例时，先控制某一个变量逐一改变，记录配对了的变量，后续遇到重复的就可以忽略。这样即使没有加constraints也可以大大减少组合数（但我们也可以加constraints）。</p><p>使用低阶组合构建测试用例时，可能会遗漏某些高阶组合的情况。</p><h3 id=befinits-of-functional-testing>Befinits of functional testing<a hidden class=anchor aria-hidden=true href=#befinits-of-functional-testing>#</a></h3><p>Functional testing is the base-line technique for designing test cases:
• Timely: Often useful in refining specifications and assessing testability before code is written
• Effective: finds some classes of fault (e.g.,missing logic) that can elude other approaches
• Widely applicable: to any description of program behavior serving as spec, at any level of granularity from module to system testing.
• Economical: typically less expensive to design and execute than structural (code-based) test cases</p><p>Early functional testing design:
• Program code is not necessary: Only a description of intended behavior is needed
• Often reveals ambiguities and inconsistency in spec
• Useful for assessing testability, and improving test schedule and budget by improving spec
• Useful explanation of specification, or in the extreme case (as in Extreme Programming), test cases are the spec</p><h2 id=finite-models>Finite Models<a hidden class=anchor aria-hidden=true href=#finite-models>#</a></h2><p>建模主要解决两个工程问题:
• 首先，不能等到实际的产品出来后才分析和测试。
• 其次，对实际产品进行彻底的测试是不切实际的，无论是否受制于所有可能的状态和输入。</p><p>模型允许我们在开发早期就着手分析，并随着设计的发展重复分析，并允许我们应用比实际情况更广泛的分析方法。更重要的是，这些分析很多都是可以自动化的。</p><p>Model program execution, emphasized control.</p><blockquote><p>A model is a representation that is simpler than the artifact it represents but preserves (or at least approximates) some important attributes of the actual artifact.</p></blockquote><p>A good model is:
• compact: A model must be representable and manipulable in a reasonably compact form.
• Predictive: well enough to distinguish between &ldquo;good&rdquo; and &ldquo;bad&rdquo; outcomes of analysis.
• Semantically meaningful: interpret analysis results in a way that permits diagnosis of the causes of failure.
• Sufficiently general: Models intended for analysis of some important characteristic must be general enough for practical use in the intended domain of application.</p><p>模型的表达：使用有向图描述程序模型。通常我们将它们绘制为"方框和箭头"图，由一组节点N的组成的集合和它们间的关系E（即ordered pairs的集合），edges。节点表示某种类型的实体，例如源代码的步骤，类或区域。边表示实体之间的某种关系。</p><p>模拟程序执行的模型，是该程序状态空间的抽象。通过抽象函数，程序运行状态空间中的状态与程序运行的finite state 模型中的状态相关联。但抽象函数无法完美呈现程序运行的所有细节，将实际的无限可能的状态折叠成有限必然需要省略一些信息，这就引入了不确定性nondeterminism。</p><p>有什么软件模型的基本概念，又有哪些可以应用于测试和分析的模型？</p><h3 id=controal-flow-graph>Controal flow graph<a hidden class=anchor aria-hidden=true href=#controal-flow-graph>#</a></h3><p>程序中的单个步骤或方法的 Control flow 可以用 <strong>过程内流程图 intraprocedural control flow graph (CFG)</strong> 来表示. CFG 模拟通过<strong>单个过程或方法</strong>的可能运行路径, 是一个有向图，nodes 表示源代码的一个个区域，有向边 directed edges 表示程序可以在哪些代码区域间流转.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>collapseNewlines</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>argStr</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>char</span><span class=w> </span><span class=n>last</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>argStr</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>StringBuffer</span><span class=w> </span><span class=n>argBuf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>StringBuffer</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>cIdx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>cIdx</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>argStr</span><span class=p>.</span><span class=na>length</span><span class=p>();</span><span class=w> </span><span class=n>cIdx</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>char</span><span class=w> </span><span class=n>ch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>argStr</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>cIdx</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>ch</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=sc>&#39;\n&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>last</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=sc>&#39;\n&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>argBuf</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=n>ch</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>last</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ch</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>argBuf</span><span class=p>.</span><span class=na>toString</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>左边是上面代码对应的CFG，右边的表格是Linear Code Sequence and Jump (LCSJ)，表示从一个分支到另一个分支的控制流程图的子路径
<img loading=lazy src=/images/cfg.jpg title="Derive from code, not specifications. image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch05.pdf"></p><p>Nodes = regions of source code (basic blocks)
• Basic block = maximal program region with a single entry and single exit point
• Often statements are grouped in single regions to get a compact model
• Sometime single statements are broken into more than one node to model control flow within the statement
Directed edges = possibility that program execution proceeds from the end of one region directly to the beginning of another</p><p>为了便于分析，控制流程图通常会通过其他信息进一步加持。例如，后面介绍的数据流模型 data flow models 就是基于加持了有关变量被程序各个语句访问和修改的信息的CFG模型构建的.</p><h3 id=call-graphs>Call Graphs<a hidden class=anchor aria-hidden=true href=#call-graphs>#</a></h3><p>过程间流程 Interprocedural control flow 也可以表示为有向图。最基本的模型是调用图 call graphs, nodes represent procedures (methods, C functions, etc.) and edges represent the &ldquo;calls&rdquo; relation.</p><p>相较于CFG，调用图比有更多设计问题和权衡妥协， 因此基本调用图的表达方式是不固定的，特别是在面向对象的语言中，methods跟对象动态绑定。
调用图存在Overapproximation现象，比如尽管方法<code>A.check()</code>永远不会实际调用<code>C.foo()</code>，但是一个典型的调用图会认为这个调用是可能的。</p><p><strong>Context-sensitive call graph</strong>：调用图模型根据过程被调用的具体位置来表示不同行为。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Context</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>args</span><span class=o>[]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Context</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Context</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>c</span><span class=p>.</span><span class=na>foo</span><span class=p>(</span><span class=n>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>c</span><span class=p>.</span><span class=na>bar</span><span class=p>(</span><span class=n>17</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>foo</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>myArray</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>depends</span><span class=p>(</span><span class=w> </span><span class=n>myArray</span><span class=p>,</span><span class=w> </span><span class=n>2</span><span class=p>)</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>bar</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>myArray</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>depends</span><span class=p>(</span><span class=w> </span><span class=n>myArray</span><span class=p>,</span><span class=w> </span><span class=n>16</span><span class=p>)</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>depends</span><span class=p>(</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>a</span><span class=o>[</span><span class=n>n</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>42</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=/images/call_graphs_contex.jpg title="Contex Insensitive vs. Sensitive Call graphs"></p><p>Context sensitive analyses can be more precise than Context-insensitive analyses when the model includes some additional information that is shared or passed among procedures. But sensitive call graphs size grows exponentially, not fit for large program.</p><h3 id=finite-state-machines>Finite state machines<a hidden class=anchor aria-hidden=true href=#finite-state-machines>#</a></h3><p>前面介绍的模型都是都是基于源代码抽象出来的。不过，模型的构建也常常先于或者独立于源代码，有限状态机 finite state machines 就是这种模型。</p><blockquote><p>有限状态机（finite-state machine，FSM）又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。</p></blockquote><p>最简单的FSM由一个有限的状态集合和状态间的转移动作构成，可以有向图表示，节点表示状态，edges表示在状态间的转移需要的运算、条件或者事件。因为可能存在无限多的程序状态，所以状态节点的有限集合必须是具体编程状态的抽象。</p><p>Usually we label the edge to indicate a program operation, condition, or event associated with the transition. We may label transitions with both an external event or a condition and with a program operation that can be thought of as a &ldquo;response&rdquo; to the event. Such a finite state machine with event/response labels on transitions is called a Mealy machine.</p><blockquote><p>In the theory of computation, a <strong>Mealy machine</strong> is a finite-state machine whose output values are determined both by its current state and the current inputs. (This is in contrast to a <strong>Moore machine</strong>, whose output values are determined solely by its current state.)</p></blockquote><p>An alternative representation of finite state machines, including Mealy machines, is the state transition table:
<img loading=lazy src=/images/FSM_state_transition_table.png title="Could be constructed from features. image from: Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007.">
There is one row in the transition table for each state node and one column for each event or input. If the FSM is complete and deterministic, there should be exactly one transition in each table entry. Since this table is for a Mealy machine, the transition in each table entry indicates both the next state and the response (e.g., d / emit means &ldquo;emit and then proceed to state d&rdquo;).</p><h2 id=structural-testing>Structural Testing<a hidden class=anchor aria-hidden=true href=#structural-testing>#</a></h2><p>Judging test suite thoroughness based on the structure of the program itself, it is still testing product functionality against its specification, but the measure of thoroughness has changed to <strong>structural criteria</strong>. Also known as &ldquo;white-box&rdquo;, &ldquo;glass-box&rdquo;, or &ldquo;codebased&rdquo; testing.</p><p>Motivation:
1, If part of a program is not executed by any test case in the suite, faults in that part cannot be exposed. The <strong>part</strong> is a control flow element or combination, statements (or CFG nodes), branches (or CFG edges), fragments and combinations, conditions paths.
2, Complements functional testing, another way to recognize cases that are treated differently
3, Executing all control flow elements does not guarantee finding all faults: Execution of a faulty statement may not always result in a failure
• The state may not be corrupted when the statement is executed with some data values
• Corrupt state may not propagate through execution to eventually lead to failure
4, Structural coverage: Increases confidence in thoroughness of testing, removes some obvious inadequacies</p><p>Steps:</p><ol><li>Create functional test suite first, then measure structural coverage to identify see what is missing</li><li>Interpret unexecuted elements<ul><li>may be due to natural differences between specification and implementation</li><li>or may reveal flaws of the software or its development process<ul><li>inadequacy of specifications that do not include cases present in the implementation</li><li>coding practice that radically diverges from the specification</li><li>inadequate functional test suites</li></ul></li></ul></li></ol><p>Coverage measurements are convenient progress indicators, sometimes used as a criterion of completion.</p><h3 id=control-flow-adequacy-expression-coverage>Control-flow Adequacy (expression coverage)<a hidden class=anchor aria-hidden=true href=#control-flow-adequacy-expression-coverage>#</a></h3><p>A structural testing strategy that uses the program&rsquo;s control flow as a model. Control flow elements include statements, branches, conditions, and paths.</p><p>But a set of correct program executions in which all control flow elements are exercised does not guarantee the absence of faults.</p><p>Test based on control-flow are concerned with expression coverage.</p><h3 id=statement-testing>Statement testing<a hidden class=anchor aria-hidden=true href=#statement-testing>#</a></h3><p>Adequacy criterion: each statement (or node in the CFG) must be executed at least once. Because a fault in a statement can only be revealed by executing the faulty statement.</p><p>Coverage: <code>#(executed statements) / #(statements)</code></p><p>Minimizing test suite size is seldom the goal, but small test cases make failure diagnosis easier.</p><p>Complete statement coverage may not imply executing all branches in a program.</p><h3 id=branch-testing>Branch testing<a hidden class=anchor aria-hidden=true href=#branch-testing>#</a></h3><p>Adequacy criterion: each branch (edge in the CFG) must be executed at least once.</p><p>Coverage: <code>#(executed branches) / #(branches)</code>
Traversing all edges of a graph causes all nodes to be visited: test suites that satisfy the branch adequacy criterion for a program P also satisfy the statement adequacy criterion for the same program</p><p>But &ldquo;All branches&rdquo; can still miss conditions.
Sample fault: missing operator (negation):<code>digit_high == 1 || digit_low == -1</code>, branch adequacy criterion can be satisfied by varying only part of the condition.</p><h3 id=condition-testing>Condition testing<a hidden class=anchor aria-hidden=true href=#condition-testing>#</a></h3><p>Basic condition adequacy criterion: each basic condition must be executed at least once.</p><p>Coverage: <code>#(truth values taken by all basic conditions) / 2 * #(basic conditions)</code></p><p>Branch and basic condition are not comparable. Basic condition adequacy criterion can be satisfied without satisfying branch coverage</p><p>Branch and condition adequacy: cover all conditions and all decisions</p><p><strong>Compound condition adequacy</strong>:
• Cover all possible evaluations of compound conditions - A compound condition is either an atomic condition or some boolean formula of atomic conditions. For example, in the overall condition &ldquo;<code>A || (B && C)</code>&rdquo; the set of compound conditions are &ldquo;A&rdquo;, &ldquo;B&rdquo;, &ldquo;<code>C", "B && C</code>&rdquo;, &ldquo;<code>A || (B && C)</code>&rdquo;.
• Cover all branches of a decision tree.
• Number of test cases grows exponentially with the number of basic conditions in a decision ($2^N$).</p><p>练习 - Write tests that provide statement, branch, and basic condition coverage over the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=nf>search</span><span class=p>(</span><span class=n>string</span><span class=w> </span><span class=n>A</span><span class=o>[]</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=n>what</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>N</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>(</span><span class=n>A</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>what</span><span class=p>)){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>N</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>N</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=p>(</span><span class=n>index</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>N</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>A</span><span class=o>[</span><span class=n>index</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>what</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>index</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>else</span><span class=w> </span><span class=n>index</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>先画出 CFG 图，再遍历：<img loading=lazy src=/images/Structural_testin_%E7%AD%94%E6%A1%88.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Activity.pdf"></p><h3 id=modified-conditiondecision-adequacy-criterion-mcdc>Modified condition/decision adequacy criterion (MC/DC)<a hidden class=anchor aria-hidden=true href=#modified-conditiondecision-adequacy-criterion-mcdc>#</a></h3><p>Motivation: Effectively test <strong>important combinations</strong> of conditions, without exponential blow up in test suite size. (<strong>Important combinations</strong>: Each basic condition shown to independently affect the outcome of each decision)</p><p>假如这些组合表明每一个条件都可以独立影响结果，那么就不要穷尽各种条件组合了，对于那些不影响结果的条件组合，测了也没有意义。</p><p>Requires:
• For each basic condition $C_i$, two test cases
• 控制变量，只改变 $C_i$：values of all evaluated conditions except $C_i$ are the same
• Compound condition as a whole evaluates to <code>True</code> for one and <code>False</code> for the other，结果的改变表明 $C_i$ 可以独立影响结果</p><p><img loading=lazy src=/images/MC_DC.png title="每一个条件的下划线组合表明该条件独立地影响结果。 image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch12.pdf."></p><p>MC/DC:
• basic condition coverage (C)
• branch coverage (DC)
• plus one additional condition (M): every condition must independently affect the decision&rsquo;s output</p><p>It is subsumed by compound conditions and subsumes all other criteria discussed so far - stronger than statement and branch coverage. A good balance of thoroughness and test size (and therefore widely used).</p><h3 id=path-testing>Path Testing<a hidden class=anchor aria-hidden=true href=#path-testing>#</a></h3><p>Sometimes, a fault is revealed only through exercise of some sequence of decisions (i.e., a particular path through the program).</p><p>Path coverage requires that all paths through the CFG are covered. In theory, path coverage is the ultimate coverage metric. But in practice, it is impractical if there is loop involed.</p><p>Adequacy criterion: each path must be executed at least once:
Coverage = #(Paths Covered) / #(Total Paths)</p><p>Practical path coverage criteria:
• The number of paths in a program with loops is unbounded - the simple criterion is usually impossible to satisfy
• For a feasible criterion: Partition infinite set of paths into a finite number of classes
• Useful criteria can be obtained by limiting
•• the number of traversals of loops
•• the length of the paths to be traversed
•• the dependencies among selected paths</p><h4 id=boundary-interior-coverage>Boundary Interior Coverage<a hidden class=anchor aria-hidden=true href=#boundary-interior-coverage>#</a></h4><p>Groups paths that differ only in the subpath they follow when repeating the body of a loop.
• Follow each path in the control flow graph up to the first repeated node
• The set of paths from the root of the tree to each leaf is the required set of subpaths for boundary/interior coverage
<img loading=lazy src=/images/Boundary_interior_adequacy.png title="Deriving a tree from a CFG to derive subpaths for boundary/interior testing. Part (i) is the CFG of the C function cgi decode, Part (ii) is a tree derived from part (i) by following each path in the control flow graph up to the first repeated node. image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch12.pdf.">
把分支拆分为每一条可能的 path.</p><p>Limitations:
1, The number of paths through non-loop branches (conditions) can still be exponential ($2^N$).
2, Choosing input data to force execution of one particular path may be very difficult, or even impossible if the conditions are not independent.</p><h4 id=loop-boundary-coverage>Loop Boundary Coverage<a hidden class=anchor aria-hidden=true href=#loop-boundary-coverage>#</a></h4><p>Since coverage of non-looping paths is expensive, we can consider a variant of the boundary/interior criterion that treats loop boundaries similarly but is less stringent with respect to other differences among paths.</p><p>Criterion: A test suite satisfies the loop boundary adequacy criterion iff for every loop:
• In at least one test case, the loop body is iterated zero times
• In at least one test case, the loop body is iterated once
• In at least one test case, the loop body is iterated more than once</p><p>For simple loops, write tests that:</p><ul><li>Skip the loop entirely.</li><li>Take exactly one pass through the loop.</li><li>Take two or more passes through the loop.</li><li>(optional) Choose an upper bound N, and:<ul><li>M passes, where 2 &lt; M &lt; N</li><li>(N-1), N, and (N+1) passes</li></ul></li></ul><p>For Nested Loops:</p><ul><li>For each level, you should execute similar strategies to simple loops.</li><li>In addition:<ul><li>Test innermost loop first with outer loops executed minimum number of times.</li><li>Move one loops out, keep the inner loop at &ldquo;typical&rdquo; iteration numbers, and test this layer as you did the previous layer.</li><li>Continue until the outermost loop tested.</li></ul></li></ul><p>For Concatenated Loops, one loop executes. The next line of code starts a new loop:</p><ul><li>These are generally independent(Most of the time&mldr;)</li><li>If not, follow a similar strategy to nested loops.<ul><li>Start with bottom loop, hold higher loops at minimal iteration numbers.</li><li>Work up towards the top, holding lower loops at &ldquo;typical&rdquo; iteration numbers.</li></ul></li></ul><h4 id=linear-code-sequences-and-jumps>Linear Code Sequences and Jumps<a hidden class=anchor aria-hidden=true href=#linear-code-sequences-and-jumps>#</a></h4><p>There are additional path-oriented coverage criteria that do not explicitly consider loops. Among these are criteria that consider paths up to a fixed length. The most common such criteria are based on Linear Code Sequence and Jump (LCSAJ) - sequential subpath in the CFG starting and ending in a branch.</p><p>A single LCSAJ is a set of statements that come one after another (meaning no jumps) followed by a single jump. A LCSAJ starts at either the beginning of the function or at a point that can be jumped to. The <strong>LCSAJ coverage</strong> is what fraction of all LCSAJs in a unit are followed by your test suite.</p><p>We can require coverage of all sequences of LCSAJs of length N.
Stronger criteria can be defined by requiring N consecutive LCSAJs to be covered - $TER_{N+2}$:
1, $TER_1$ is equivalent to statement coverage.
2, $TER_2$ is equivalent to branch coverage
3, $TER_3$ is LCSAJ coverage
4, $TER_4$ is how many pairs of LCSAJ covered
&mldr;</p><h4 id=cyclomatic-adequacy-complexity-coverage>Cyclomatic adequacy (Complexity coverage)<a hidden class=anchor aria-hidden=true href=#cyclomatic-adequacy-complexity-coverage>#</a></h4><p>There are many options for the set of basis subpaths. When testing, count the number of independent paths that have already been covered, and add any new subpaths covered by the new test.</p><p>You can identify allpaths with a set of independent subpaths of size = the <strong>cyclomatic complexity</strong>. Cyclomatic coverage counts the number of independent paths that have been exercised, relative to cyclomatic complexity.</p><p>• A path is representable as a bit vector, where each component of the vector represents an edge
• &ldquo;Dependence&rdquo; is ordinary linear dependence between (bit) vectors</p><p>If e = #(edges), n = #(nodes), c = #(connected components) of a graph, it is $e - n + c$ for an arbitrary graph, $e - n + 2$ for a CFG.</p><p>Cyclomatic Complexity could be used to guess &ldquo;how much testing is enough&rdquo;.
○ Upper bound on number of tests for branch coverage.
○ Lower bound on number of tests for path coverage.</p><p>And Used to refactor code.
○ Components with a complexity > some threshold should be split into smaller modules.
○ Based on the belief that more complex code is more fault-prone.</p><h3 id=procedure-call-coverage>Procedure call coverage<a hidden class=anchor aria-hidden=true href=#procedure-call-coverage>#</a></h3><p>The criteria considered to this point measure coverage of control flow within individual procedures - not well suited to integration or system testing, where connections between procedures(calls and returns) should be covered.</p><p>Choose a coverage granularity commensurate with the granularity of testing - if unit testing has been effective, then faults that
remain to be found in integration testing will be primarily interface faults, and testing effort should focus on interfaces between units rather than their internal details.</p><p><strong>Procedure Entry and Exit Testing</strong> - A single procedure may have several entry and exit points.
• In languages with goto statements, labels allow multiple entry points.
• Multiple returns mean multiple exit points.</p><p><strong>Call coverage</strong>: The same entry point may be called from many points. Call coverage requires that a test suite executes all possible method calls.</p><h3 id=satisfying-structural-criteria>Satisfying structural criteria<a hidden class=anchor aria-hidden=true href=#satisfying-structural-criteria>#</a></h3><p><img loading=lazy src=/images/subsumption_relation.png title="Subsumption relation. image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch12.pdf">
The criterion requires execution of</p><ul><li><strong>statements</strong> that cannot be executed as a result of:<ul><li>defensive programming</li><li>code reuse (reusing code that is more general than strictly required for the application)</li></ul></li><li><strong>conditions</strong> that cannot be satisfied as a result of interdependent conditions</li><li><strong>paths</strong> that cannot be executed as a result of interdependent decisions</li></ul><p>Rather than requiring full adequacy, the &ldquo;degree of adequacy&rdquo; of a test suite is estimated by coverage measures.</p><h2 id=dependence-and-data-flow-models>Dependence and Data Flow Models<a hidden class=anchor aria-hidden=true href=#dependence-and-data-flow-models>#</a></h2><p>前面介绍的 Finite models (Control flow graph, call graph, finite state machines) 只是捕捉程序各部分之间依赖关系的其中一个方面。它们明确地表现<strong>控制</strong>流程，但不重视程序变量间的信息传递. <strong>Data flow models</strong> provide a complementary view, emphasizing and making explicit relations involving <strong>transmission of information</strong>.</p><blockquote><p>Models of data flow and dependence in software were originally developed in the field of compiler construction, where they were (and still are) used to detect opportunities for optimization.</p></blockquote><h3 id=definition-use-pairs-def-use-pairs>Definition-Use Pairs (Def-Use Pairs)<a hidden class=anchor aria-hidden=true href=#definition-use-pairs-def-use-pairs>#</a></h3><blockquote><p>The most fundamental class of data flow model associates the point in a program where a value is produced (called a &ldquo;definition&rdquo;) with the points at which the value may be accessed (called a &ldquo;use&rdquo;).</p></blockquote><p><strong>Definitions</strong> - Variable declaration (often the special value &ldquo;uninitialized&rdquo;), Variable initialization, Assignment, Values received by a parameter.
<strong>Use</strong> - Expressions, Conditional statements, Parameter passing, Returns.
<img loading=lazy src=/images/Def_Use_path.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch06.pdf"></p><p>A <strong>Definition-Use pair</strong> is formed if and only if there is a <strong>definition-clear path</strong> between the Definition and the Use. A definition-clear path is a path along the CFG path from a definition to a use of the same variable without another definition of the variable in between.</p><p><code>&lt;D,U></code> pairs coverage: #(pairs covered)/ #(total number of pairs)
If instead another definition is present on the path, then the latter definition kills the former.</p><p>Definition-use pairs record direct data dependence, which can be represented in the form of a graph - <strong>(Direct) Data Dependence Graph</strong>, with a directed edge for each definition-use pair.</p><p>The notion of dominators in a rooted, directed graph can be used to make this intuitive notion of &ldquo;controlling decision&rdquo; precise. Node M dominates node N if every path from the root of the graph to N passes through M.</p><h3 id=analyses-reaching-definition>Analyses: Reaching definition<a hidden class=anchor aria-hidden=true href=#analyses-reaching-definition>#</a></h3><p>Definition-use pairs can be defined in terms of paths in the program control flow graph.
• There is an association $(d,u)$ between a definition of variable $v$ at $d$ and a use of variable $v$ at $u$ if and only if there is at least one control flow path from $d$ to $u$ with no intervening definition of $v$.
• Definition $v_d$ <strong>reaches</strong> $u$ ($v_d$ is a <strong>reaching definition</strong> at $u$).
• If a control flow path passes through another definition $e$ of the same variable $v$, we say that $v_e$ kills $v_d$ at that point.</p><p>Practical algorithms do not search every individual path. Instead, they <strong>summarize the reaching definitions</strong> at a node over all the paths reaching that node.</p><p>An algorithm for <strong>computing reaching definitions</strong> is based on the way reaching definitions at one node are related to reaching definitions at an adjacent node.</p><p>Suppose we are calculating the reaching definitions of node n, and there is an edge $(p,n)$ from an immediate predecessor node $p$.
We observe:
• If the predecessor node $p$ can assign a value to variable $v$, then the definition $v_p$ reaches $n$. We say the definition $v_p$ is generated at $p$.
• If a definition $v_d$ of variable $v$ reaches a predecessor node $p$, and if $v$ is not redefined at that node, then the definition is propagated on from $p$ to $n$.</p><p>These observations can be stated in the form of an equation describing sets of reaching definitions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=cm>/** Euclid&#39;s algorithm */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>GCD</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>gcd</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>y</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>tmp</span><span class=p>;</span><span class=w>              </span><span class=c1>// A: def x, y, tmp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>y</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>      </span><span class=c1>// B: use y</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>tmp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>y</span><span class=p>;</span><span class=w>      </span><span class=c1>// C: def tmp; use x, y</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>y</span><span class=p>;</span><span class=w>            </span><span class=c1>// D: def x; use y</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tmp</span><span class=p>;</span><span class=w>          </span><span class=c1>// E: def y; use tmp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>             </span><span class=c1>// F: use x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=/images/data_dependence_graph.png title="Nodes: as in the control flow graph (CFG); Each edge represents a direct data dependence, labelled with the variable name. image from: Pezze and Young, Software Testing and Analysis: Process, Principles and Techniques, Wiley, 2007."></p><p>Reaching definitions at node E are those at node D, except that D adds a definition of x and replaces (kills) an earlier definition of x:</p>$$
\begin{equation}
\begin{split}
Reach(E) &= ReachOut(D) \\\\
ReachOut(D) &= (Reach(D) \backslash \{x_A\}) \cup \{x_D\}
\end{split}
\end{equation}
$$<p>Equations at the head of the while loop - node B, where values may be transmitted both from the beginning of the procedure - node A and through the end of the body of the loop - node E. The beginning of the procedure (node A) is treated as an initial definition of parameters and local variables:</p>$$
\begin{equation}
\begin{split}
Reach(B) &= ReachOut(A) \cup ReachOut(E) \\\\
ReachOut(A) &= gen(A) = \{x_A, y_A, tmp_A \} \\\\
ReachOut(E) &= (Reach(E) \backslash \{y_A\}) \cup \{y_D\}
\end{split}
\end{equation}
$$<p>(If a local variable is declared but not initialized, it is treated as a definition to the special value &ldquo;<strong>uninitialized</strong>.&rdquo;)</p><p>General equations for Reach analysis:</p>$$\begin{equation} \begin{split}
Reach(n) &= \mathop{\cup} \limits_{m \in pred(n)} ReachOut(m) \\\\
ReachOut(n) &=(Reach(n) \backslash kill(n)) \cup gen(n) \\\\
\end{split} \end{equation}$$<p>$gen(n) = v_n$, $v$ is defined or modified at $n$;
$kill(n) = v_x$, $v$ is defined or modified at $x, x \ne n$.</p><p>Reaching definitions calculation: first initializing the reaching definitions at each node in the control flow graph to the empty set, and then applying these equations repeatedly until the results stabilize.</p><h3 id=analyses-live-and-avail>Analyses: Live and Avail<a hidden class=anchor aria-hidden=true href=#analyses-live-and-avail>#</a></h3><p><strong>Available expressions</strong> is another classical data flow analysis, used in compiler construction to determine <strong>when</strong> the value of a subexpression can be saved and reused rather than recomputed.</p><blockquote><p>An expression is available at a point if, for all paths through the control flow graph from procedure entry to that point, the expression has been computed and not subsequently modified.</p></blockquote><p>An expression is generated (becomes available) where it is computed and is killed (ceases to be available) when the value of any part of it changes (e.g., when a new value is assigned to a variable in the expression).</p><p>The expressions propagation to a node from its predecessors is described by a pair of set equations:</p>$$\begin{equation} \begin{split}
Avail(n) &= \mathop{\cap} \limits_{m \in pred(n)} AvailOut(m) \\\\
AvailOut(n) &=(Avail(n) \backslash kill(n)) \cup gen(n) \\\\
\end{split} \end{equation}$$<p>$gen(n)$, available, computed at $n$;
$kill(n)$, has variables assigned at $n$.</p><p>Reaching definitions combines propagated sets using set union, since a definition can reach a use along any execution path. Available expressions combines propagated sets using set intersection, since an expression is considered available at a node only if it reaches that node along all possible execution paths.</p><p>Reaching definitions is a <strong>forward, any-path analysis</strong>; Available expressions is a <strong>forward, all-paths analysis</strong>.</p><p><strong>Live variables</strong> is a <strong>backward, any-path analysis</strong> that determines whether the value held in a variable may be subsequently used. Backward analyses are useful for determining what happens after an event of interest.</p><p>A variable is live at a point in the control flow graph if, on some execution path, its current value may be used before it is changed, i.e. there is any possible execution path on which it is used.</p>$$\begin{equation} \begin{split}
Live(n) &= \mathop{\cup} \limits_{m \in succ(n)} LiveOut(m) \\\\
LiveOut(n) &=(Live(n) \backslash kill(n)) \cup gen(n) \\
\end{split} \end{equation}$$<p>$gen(n)$, $v$ is used at $n$;
$kill(n)$, $v$ is modified at $n$.</p><p>One application of live variables analysis is to recognize useless definitions, that is, assigning a value that can never be used.</p><h3 id=iterative-solution-of-dataflow-equations>Iterative Solution of Dataflow Equations<a hidden class=anchor aria-hidden=true href=#iterative-solution-of-dataflow-equations>#</a></h3><p>Initialize values (first estimate of answer)
• For &ldquo;any path&rdquo; problems, first guess is &ldquo;nothing&rdquo;(empty set) at each node
• For &ldquo;all paths&rdquo; problems, first guess is &ldquo;everything&rdquo; (set of all possible values = union of all &ldquo;gen&rdquo; sets)</p><p>Repeat until nothing changes
• Pick some node and recalculate (new estimate)</p><h3 id=from-execution-to-conservative-flow-analysis>From Execution to Conservative Flow Analysis<a hidden class=anchor aria-hidden=true href=#from-execution-to-conservative-flow-analysis>#</a></h3><p>We can use the same data flow algorithms to approximate other dynamic properties
• Gen set will be &ldquo;facts that become true here&rdquo;
• Kill set will be &ldquo;facts that are no longer true here&rdquo;
• Flow equations will describe propagation</p><p>Example: Taintedness (in web form processing)
• &ldquo;Taint&rdquo;: a user-supplied value (e.g., from web form) that has not been validated
• Gen: we get this value from an untrusted source here
• Kill: we validated to make sure the value is proper</p><h3 id=data-flow-analysis-with-arrays-and-pointers>Data flow analysis with arrays and pointers<a hidden class=anchor aria-hidden=true href=#data-flow-analysis-with-arrays-and-pointers>#</a></h3><p>The models and flow analyses described in the preceding section have been limited to simple scalar variables in individual procedures.</p><p>Arrays and pointers (dynamic references and the potential for aliasing) introduce uncertainty: Do different expressions access the same storage?
• a[i] same as a[k] when i = k
• a[i] same as b[i] when a = b (aliasing)</p><p>The uncertainty is accomodated depending on the kind of analysis
• Any-path: gen sets should include all potential aliases and kill set should include only what is definitely modified
• All path: vice versa</p><h3 id=scope-of-data-flow-analysis>Scope of Data Flow Analysis<a hidden class=anchor aria-hidden=true href=#scope-of-data-flow-analysis>#</a></h3><p><strong>过程内 Intraprocedural</strong>: Within a single method or procedure, as described so far.</p><p><strong>过程之间 Interprocedural</strong>: Across several methods (and classes) or procedures</p><p>Cost/Precision trade-offs for <strong>interprocedural</strong> analysis are critical, and difficult: context sensitivity, flow-sensitivity.</p><p>Many <strong>interprocedural</strong> flow analyses are flow-insensitive
• $O(n^3)$ would not be acceptable for all the statements in a program. Though $O(n^3)$ on each individual procedure might be ok
• Often flow-insensitive analysis is good enough&mldr; considering type checking as an example</p><p>Reach, Avail, etc were flow-sensitive sensitive, <strong>intraprocedural</strong> analyses.
• They considered ordering and control flow decisions
• Within a single procedure or method, this is (fairly) cheap - $O(n^3)$ for $n$ CFG nodes.</p><h3 id=summary-of-data-flow-models>Summary of Data flow models<a hidden class=anchor aria-hidden=true href=#summary-of-data-flow-models>#</a></h3><ul><li>Data flow models detect patterns on CFGs:<ul><li>Nodes initiating the pattern</li><li>Nodes terminating it</li><li>Nodes that may interrupt it</li></ul></li><li>Often, but not always, about flow of information (dependence)</li><li>Pros:<ul><li>Can be impy g lemented by efficient iterative algorithms</li><li>Widely applicable (not just for classic &ldquo;data flow&rdquo; properties)</li></ul></li><li>Limitations:<ul><li>Unable to distinguish feasible from infeasible paths</li><li>Analyses spanning whole programs (e.g., alias analysis) must trade off precision against computational cost</li></ul></li></ul><h2 id=data-flow-testing>Data Flow Testing<a hidden class=anchor aria-hidden=true href=#data-flow-testing>#</a></h2><p>In structural testing,
• Node and edge coverage don&rsquo;t test interactions
• Path-based criteria require impractical number of test cases: And only a few paths uncover additional faults, anyway
• Need to distinguish &ldquo;important&rdquo; paths</p><p>Data flow testing attempts to distinguish &ldquo;important&rdquo; paths: Interactions between statements - Intermediate between simple statement and branch coverage and more expensive path-based structural testing.</p><p>Intuition: Statements interact through data flow
• Value computed in one statement used in another Value computed in one statement, used in another
• Bad value computation revealed only when it is used</p><p>Adequacy criteria:
• All DU pairs: Each DU pair is exercised by at least one test case
• All DU paths: Each simple (non looping) DU path is exercised by at least one test case
• All definitions: For each definition, there is at least one test case which exercises a DU pair containing it - Every computed value is used somewhere</p><p>Limits: Aliases, infeasible paths - Worst case is bad (undecidable properties, exponential blowup of paths), so 务实的 pragmatic compromises are required</p><h3 id=data-flow-coverage-with-complex-structures>Data flow coverage with complex structures<a hidden class=anchor aria-hidden=true href=#data-flow-coverage-with-complex-structures>#</a></h3><p>Arrays and pointers
• Under-estimation of aliases may fail to include some DU pairs
• Over-estimation, may introduce unfeasible test obligations</p><p>For testing, it may be preferrable to accept under-estimation of alias set rather than over-estimation or expensive analysis
• 有争议的 Controversial: In other applications (e.g., compilers), a conservative over-estimation of aliases is usually required
• Alias analysis may rely on external guidance or other global
analysis to calculate good estimates
• Undisciplined use of dynamic storage, pointer arithmetic, etc.
may make the whole analysis infeasible</p><h2 id=mutation-testing>Mutation testing<a hidden class=anchor aria-hidden=true href=#mutation-testing>#</a></h2><p>Fault-based Testing, directed towards &ldquo;typical&rdquo; faults that could occur in a program.</p><ol><li>Take a program and test suite generated for that program (using other test techniques)</li><li>Create a number of similar programs (<strong>mutants</strong>), each differing from the original in one small way, i.e., each possessing a fault</li><li>The original test data are then run through the mutants</li><li>Then mutants either:<ul><li>To be dead: test data detect all differences in mutants, the test set is adequate.</li><li>Remains live if:<ul><li>it is equivalent to the original program (functionally identical although syntactically different - called an <strong>equivalent mutant</strong>) or,</li><li>the test set is inadequate to kill the mutant. The test data need to be augmented (by adding one or more new test cases) to kill the live mutant.</li></ul></li></ul></li></ol><p>Numbers of mutants tend to be large (the number of mutation operators is large as they are supposed to capture all possible syntactic variations in a program), hence random sampling, selective mutation operators (Offutt).</p><p>Coverage - mutation score: #(killed mutants) / #(all non-equivalent mutants) (or random sample).</p><p>Benifits:
• It provides the tester with a clear target (mutants to kill)
• It does force the programmer to think of the test data that will expose certain kinds of faults
• Probably most useful at unit testing level</p><p>Mutation operators could be built on
• source code (body),
• module interfaces (aimed at integration testing),
• specifications: Petri-nets, state machines, (aimed at system testing)</p><p>Tools: MuClipse</p><h2 id=model-based-testing>Model based testing<a hidden class=anchor aria-hidden=true href=#model-based-testing>#</a></h2><p>Models used in specification or design have structure
• Useful information for selecting representative classes of behavior; behaviors that are treated differently with respect to the model should be tried by a thorough test suite
• In combinatorial testing, it is difficult to capture that structure clearly and correctly in constraints</p><p>Devise test cases to check actual behavior against behavior specified by the model - &ldquo;Coverage&rdquo; similar to structural testing, but applied to specification and design models.</p><p>Deriving test cases from finite state machines: From an informal specification, to a finite state machine, to a test suite</p><p>&ldquo;Covering&rdquo; finite state machines
• State coverage: Every state in the model should be visited by at least one test case
• Transition coverage
•• Every transition between states should be traversed by at least one test case.
•• A transition can be thought of as a (precondition, postcondition) pair.</p><p>Models are useful abstractions
• In specification and design, they help us think and communicate about complex artifacts by emphasizing key features and suppressing details
• Models convey structure and help us focus on one thing at a time</p><p>We can use them in systematic testing
• If a model divides behavior into classes, we probably want to exercise each of those classes!
• Common model-based testing techniques are based on state machines, decision structures, and grammars, but we can apply the same approach to other models.</p><h2 id=testing-object-oriented-software>Testing Object Oriented Software<a hidden class=anchor aria-hidden=true href=#testing-object-oriented-software>#</a></h2><p>Typical OO software <strong>characteristics</strong> that impact testing
• State dependent behavior
• Encapsulation
• Inheritance
• 多态性 Polymorphism and dynamic binding
• Abstract and generic classes
• Exception handling</p><p><strong>Procedural software</strong>, unit = single program, function, or procedure, more often: a unit of work that may correspond to one or more intertwined functions or programs.</p><p><strong>Object oriented software</strong>:
• unit = class or (small) cluster of strongly related classes (e.g., sets of Java classes that correspond to exceptions)
• unit testing = 类内测试 intra-class testing
• integration testing = 类之间测试 inter-class testing (cluster of classes)
• dealing with single methods separately is usually too expensive (complex scaffolding), so methods are usually tested in the context of the class they belong to.</p><p>Basic approach is <strong>orthogonal</strong>: Techniques for each major issue (e.g., exception handling, generics, inheritance ) can be applied incrementally and independently. <img loading=lazy src=/images/orthogonal_approach.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch14-15.pdf."></p><h3 id=intraclass-state-machine-testing>Intraclass State Machine Testing<a hidden class=anchor aria-hidden=true href=#intraclass-state-machine-testing>#</a></h3><p>Basic idea:
• The state of an object is modified by operations
• Methods can be modeled as state transitions
• Test cases are sequences of method calls that traverse the state machine model</p><p>State machine model can be derived from specification (functional testing), code (structural testing), or both.</p><p>Testing with State Diagrams:
• A statechart (called a &ldquo;state diagram&rdquo; in UML) may be produced as part of a specification or design - May also be implied by a set of message sequence charts (interaction diagrams), or other modeling formalisms.
• Two options:
1, Convert (&ldquo;flatten&rdquo;) into standard finite-state machine, then derive test cases
2, Use state diagram model directly</p><h3 id=intraclass-data-flow-testing>Intraclass data flow testing<a hidden class=anchor aria-hidden=true href=#intraclass-data-flow-testing>#</a></h3><p>Exercise sequences of methods
• From setting or modifying a field value
• To using that field value</p><p>The intraclass control flow graph - control flow through sequences of method calls:
• Control flow for each method
• node for class
• edges: from node class to the start nodes of the methods; from the end nodes of the methods to node class.</p><h3 id=interclass-testing>Interclass Testing<a hidden class=anchor aria-hidden=true href=#interclass-testing>#</a></h3><p>The first level of integration testing for object-oriented software - Focus on interactions between classes</p><p>Bottom-up integration according to <strong>&ldquo;depends&rdquo;</strong> relation - A depends on B - Build and test B, then A</p><p>Start from <strong>use/include</strong> hierarchy - Implementation-level parallel to logical &ldquo;depends&rdquo; relation
• Class A makes method calls on class B
• Class A objects include references to class B methods - but only if reference means &ldquo;is part of&rdquo;
<img loading=lazy src=/images/class_diagram_BankAccount.png title="A class with three compartments"></p><blockquote><p>In software engineering, a class diagram in the Unified Modeling Language (UML) is a type of static structure diagram that describes the structure of a system by showing the system&rsquo;s <strong>classes, their attributes, operations (or methods)</strong>, and the relationships among objects.</p></blockquote><blockquote><p>Dependency is a weaker form of bond that indicates that one class depends on another because it uses it at some point in time. One class depends on another if the independent class is a parameter variable or local variable of a method of the dependent class.</p></blockquote><p>Interactions in Interclass Tests:</p><ul><li>Proceed bottom-up</li><li>Consider all combinations of interactions<ul><li>example: a test case for class <code>Order</code> includes a call to a method of class <code>Model</code>, and the called method calls a method of class <code>Slot</code>, exercise all possible relevant states of the different classes.</li><li>problem: combinatorial explosion of cases</li><li>so select a subset of interactions:<ul><li>arbitrary or random selection</li><li>plus all significant interaction scenarios that have been previously identified in design and analysis: sequence + collaboration diagrams</li></ul></li></ul></li></ul><p>Using Structural Information:
• Start with functional testing: the specification (formal or informal) is the first source of information
• Then add information from the code (structural testing)</p><h3 id=interclass-structural-testing>Interclass structural testing<a hidden class=anchor aria-hidden=true href=#interclass-structural-testing>#</a></h3><p>Working &ldquo;bottom up&rdquo; in dependence hierarchy
• Dependence is not the same as class hierarchy; not always the same as call or inclusion relation.
• May match bottom-up build order</p><p>Starting from leaf classes, then classes that use leaf classes,&mldr;</p><p>Summarize effect of each method: Changing or using object state, or both - Treating a whole object as a variable (not just primitive types)</p><h3 id=polymorphism-and-dynamic-binding>Polymorphism and dynamic binding<a hidden class=anchor aria-hidden=true href=#polymorphism-and-dynamic-binding>#</a></h3><p>One variable potentially bound to methods of different (sub-)classes.</p><p>The combinatorial approach: identify a set of combinations that cover all pairwise combinations of dynamic bindings.</p><h3 id=inheritance>Inheritance<a hidden class=anchor aria-hidden=true href=#inheritance>#</a></h3><p>When testing a subclass, We would like to re-test only what has not been thoroughly tested in the parent class. But we should test any method whose behavior may have changed.</p><p>Reusing Tests with the Testing History Approach:</p><ul><li>Track test suites and test executions<ul><li>determine which new tests are needed</li><li>determine which old tests must be re-executed</li></ul></li><li>New and changed behavior &mldr;<ul><li>new methods must be tested</li><li>redefined methods must be tested, but we can partially reuse test suites defined for the ancestor</li><li>other inherited methods do not have to be retested</li></ul></li></ul><p>Abstract methods (and classes) - Design test cases when abstract method is introduced (even if it can t be executed yet)</p><p>Behavior changes
• Should we consider a method &ldquo;redefined&rdquo; if another new or redefined method changes its behavior?
• The standard &ldquo;testing history&rdquo; approach does not do this
• It might be reasonable combination of data flow (structural) OO testing with the (functional) testing history approach</p><h3 id=testing-exception-handling>Testing exception handling<a hidden class=anchor aria-hidden=true href=#testing-exception-handling>#</a></h3><p>Exceptions create implicit control flows and may be handled by different handlers.</p><p>Impractical to treat exceptions like normal flow
• too many flows: every array subscript reference, every memory, allocation, every cast, &mldr;
• multiplied by matching them to every handler that could appear immediately above them on the call stack.
• many actually impossible</p><p>So we separate testing exceptions, and ignore program error exceptions (test to prevent them, not to handle them)</p><p>What we do test: Each exception handler, and each explicit throw or re-throw of an exception.</p><h2 id=integration-testing>Integration Testing<a hidden class=anchor aria-hidden=true href=#integration-testing>#</a></h2><p>Unit (module) testing is a foundation, unit level has maximum controllability and visibility.</p><p>Integration testing may serve as a process check
• If module faults are revealed in integration testing, they signal inadequate unit testing
• If integration faults occur in interfaces between correctly implemented modules, the errors can be traced to module breakdown and interface specifications.
<img loading=lazy src=/images/module_integration_system_test.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch21.pdf">
Integration test plan drives and is driven by the project &ldquo;build plan&rdquo;</p><p>Structural orientation: Modules constructed, integrated and tested based on a hierarchical project structure - Top-down, Bottom-up, Sandwich, Backbone</p><p>Functional orientation: Modules integrated according to application characteristics or features - Threads, Critical module.</p><blockquote><p>A &ldquo;thread&rdquo; is a portion of several modules that together provide a user-visible program feature.</p></blockquote><h2 id=component-based-software-testing>Component-based software testing<a hidden class=anchor aria-hidden=true href=#component-based-software-testing>#</a></h2><p>Working Definition of <strong>Component</strong>
• Reusable unit of deployment and composition
• Characterized by an interface or contract
• Often larger grain than objects or packages - A complete database system may be a component</p><p><strong>Framework</strong>
• Skeleton or micro-architecture of an application
• May be packaged and reused as a component, with &ldquo;挂钩 hooks&rdquo; or &ldquo;插槽 slots&rdquo; in the interface contract</p><p><strong>Design patterns</strong>
• Logical design fragments
• Frameworks often implement patterns, but patterns are not frameworks. Frameworks are concrete, patterns are abstract</p><p><strong>Component-based system</strong>
• A system composed primarily by assembling components, often &ldquo;Commercial off-the-shelf&rdquo; (COTS) components
• Usually includes application-specific &ldquo;glue code&rdquo;</p><p><strong>Component Interface Contracts</strong>
• Application programming interface (API) is distinct from implementation
• Interface includes everything that must be known to use the component: More than just method signatures, exceptions, etc; May include non-functional characteristics like performance, capacity, security; May include dependence on other components.</p><p>Testing a Component: Producer View
• Thorough unit and subsystem testing
• Thorough acceptance testing: Includes stress and capacity testing</p><p>Testing a Component: User View
• Major question: Is the component suitable for this application?
• Reducing risk: Trial integration early</p><h2 id=system-acceptance-and-regression-testing>System, Acceptance, and Regression Testing<a hidden class=anchor aria-hidden=true href=#system-acceptance-and-regression-testing>#</a></h2><p><img loading=lazy src=/images/System_Acceptance_and_Regression.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/system-acceptance.pdf."></p><h2 id=system-testing>System Testing<a hidden class=anchor aria-hidden=true href=#system-testing>#</a></h2><p>Characteristics:
• Comprehensive (the whole system, the whole spec)
• Based on specification of observable behavior: Verification against a requirements specification, not validation, and not opinions
• Independent of design and implementation</p><p>Independence: Avoid repeating software design errors in system test design.</p><p>Maximizing independence:
• Independent V&amp;V: System (and acceptance) test performed by a different organization.
• Independence without changing staff: Develop system test cases early</p><p>System tests are often used to measure progress. As project progresses, the system passes more and more system tests. Features exposed at top level as they are developed.</p><p>System testing is the only opportunity to verify <strong>Global Properties</strong> - Performance, latency, reliability, &mldr; Especially to find unanticipated effects, e.g., an unexpected performance bottleneck.</p><p><strong>Context-Dependent Properties</strong> is beyond system-global: Some properties depend on the system context and use, Example:
• Performance properties depend on environment and configuration
• Privacy depends both on system and how it is used
• Security depends on threat profiles</p><h3 id=stress-testing>Stress Testing<a hidden class=anchor aria-hidden=true href=#stress-testing>#</a></h3><p>When a property (e.g., performance or real-time response) is parameterized by use - requests per second, size of database,&mldr; Extensive stress testing is required - varying parameters within the envelope, near the bounds, and beyond.</p><p>Often requires extensive simulation of the execution environment, and requires more resources (human and machine) than typical test cases - Separate from regular feature tests, Run less often, with more manual control.</p><p>Capacity, Security, Performance, Compliance, Documentation Testing.</p><h2 id=acceptance-testing>Acceptance testing<a hidden class=anchor aria-hidden=true href=#acceptance-testing>#</a></h2><p>Estimating dependability, measuring quality, not searching for faults. Requires valid <strong>statistical samples</strong> from <strong>operational profile</strong>(model), and a clear, precise definition of what is being measured.</p><p>Quantitative dependability goals are statistical:
• Reliability: Survival Probability - when function is critical during the mission time.
• Availability: The fraction of time a system meets its specification - Good when continuous service is important but it can be delayed or denied
• Failsafe: System fails to a known safe state
• Dependability: Generalisation - System does the right thing at right time</p><p>Usability, Reliability, Availability/Reparability Testing</p><h3 id=system-reliability>System Reliability<a hidden class=anchor aria-hidden=true href=#system-reliability>#</a></h3><p>The reliability $R_F(t)$ of a system is the <strong>probability</strong> that no fault of the class $F$ occurs (i.e. system survives) during time $t \sim (t_{init}, t_{failure})$.</p><p>Failure Probability $Q_F(t) = 1 -R_F(t)$.</p><p>When the lifetime of a system is exponentially distributed, the reliability of the system is: $R(t) = e^{-\lambda t}$ where the parameter $\lambda$ is called the failure rate.</p><p>MTTF: Mean Time To (first) Failure, or Expected Life.
$ MTTF = E(t_f) = \int_0^\infty R(t)dt = \frac{1}{\lambda}$</p><p><strong>Serial System Reliability</strong>: Serially Connected Components. Assuming the failure rates of components are statistically independent, The overall system reliability:</p>$$R_{ser}(t) = \prod_{i=1}^n R_i(t) = e^{-t(\lambda_{ser})} = e^{-t(\sum_{i=1}^n \lambda_i)}$$<p>$R_i(t) = e^{-\lambda_i t}$ is reliability of a single component $i$.</p><p><strong>Parallel System Reliability</strong>: Parallel Connected Components.</p>$$R_{par}(t) = 1 - Q_{par}(t) = 1 - \prod_{i=1}^n Q_i(t) = 1 - \prod_{i=1}^n (1 - e^{-\lambda_i t}) = 1 - \prod_{i=1}^n (1 - R_i(t)) $$<p>For example:
· if one is to build a serial system with 100 components each of which had a reliability of 0.999, the overall system reliability would be $0.999^{100} = 0.905$.
· Consider 4 identical modules are connected in parallel, System will operate correctly provided at least one module is operational. If the reliability of each module is 0.95, the overall system reliability is $1-(1-0.95)^4 = 0.99999375$.</p><p>Statistical testing is necessary for critical systems (safety critical, infrastructure, &mldr;), but difficult or impossible when operational profile is unavailable or just a guess, or when reliability requirement is very high.</p><h3 id=process-based-measures>Process-based Measures<a hidden class=anchor aria-hidden=true href=#process-based-measures>#</a></h3><p>Based on <strong>similarity with prior projects</strong>, less rigorous than statistical testing.</p><p>System testing process - Expected history of bugs found and resolved:
• Alpha testing: Real users, controlled environment
• Beta testing: Real users, real (uncontrolled) environment
• May statistically sample users rather than uses
• Expected history of bug reports</p><h2 id=regression-testing>Regression Testing<a hidden class=anchor aria-hidden=true href=#regression-testing>#</a></h2><p>Ideally, software should improve over time. But changes can both
• Improve software, adding features and fixing bugs
• Break software, introducing new bugs - <strong>regressions</strong></p><p>Tests must be re-run after any changes.</p><p>Make use of different techniques for selecting a subset of all tests to reduce the time and cost for regression testing.</p><h3 id=regression-test-selection>Regression Test Selection<a hidden class=anchor aria-hidden=true href=#regression-test-selection>#</a></h3><p>From the entire test suite, only select subset of test cases whose execution is relevant to changes.</p><p><strong>Code-based Regression Test Selection</strong>: Only execute test cases that execute changed or new <strong>code</strong>.</p><p><strong>Control-flow and Data-flow Regression Test Selection</strong>: Re-run test cases only if they include changed <strong>elements</strong> – elements may be modified control flow nodes and edges, or definition-use (DU) pairs in data flow. To automate selection:
• Tools record changed elements touched by each test case - stored in database of regression test cases
• Tools note changes in program
• Check test-case database for overlap</p><p><strong>Specification-based Regression Test Selection</strong>:
• Specification-based prioritization: <strong>Execute all test cases</strong>, but start with those that related to changed and added <strong>features</strong>.</p><h3 id=test-set-minimization>Test Set Minimization<a hidden class=anchor aria-hidden=true href=#test-set-minimization>#</a></h3><p>Identify test cases that are redundant and remove them from the test suite to reduce its size.
• Maximize coverage with minimum number of test cases.
• Stop after a pre-defined number of iterations
• Obtain an approximate solution by using a greedy heuristic</p><h3 id=test-set-prioritisation>Test Set Prioritisation<a hidden class=anchor aria-hidden=true href=#test-set-prioritisation>#</a></h3><p>• Sort test cases in order of increasing cost per additional coverage
• Select the first test case
• Repeat the above two steps until k test cases are selected or max cost is reached (whichever is first).
<img loading=lazy src=/images/Cost_per_additional_coverage.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/RegTesting.pdf."></p><p><strong>Prioritized Rotating Selection</strong>: Execute some sooner than others, eventually execute all test cases. Possible priority schemes:
• Round robin: Priority to least-recently-run test cases
• Track record: Priority to test cases that have detected faults before - They probably execute code with a high fault density
• Structural: Priority for executing elements that have not been recently executed - Can be coarse-grained: Features, methods, files.</p><h2 id=test-driven-development-tdd>Test-Driven Development (TDD)<a hidden class=anchor aria-hidden=true href=#test-driven-development-tdd>#</a></h2><p>Test-Driven Development (or test driven design) is a methodology.</p><p>• Short development iterations.
• Based on requirement and pre-written test cases.
• Produces code necessary to pass that iteration&rsquo;s test.
• Refactor both code and tests.
• The goal is to produce working clean code that fulfills requirements.</p><p>Principle of TDD - Kent Beck defines:
• Never write a single line of code unless you have a failing automated test.
• Eliminate duplication</p><p>TDD uses Black-box Unit test：
1， 明确功能需求。
2， 为功能需求编写 test。
3， 运行测试，<font color=red>按理应该无法通过测试</font>（因为还没写功能程序）。
4， 编写实现该功能的代码，<font color=green>通过测试</font>。
5， 可选：重构代码（和 test cases），使其更快，更整洁等等。
6， 可选：循环此步骤</p><p><img alt="source from http://ryantablada.com/post/red-green-refactor&mdash;a-tdd-fairytale " loading=lazy src=http://www.pathfindersolns.com/wp-content/uploads/2012/05/red-green-refactorFINAL2.png title="image from: http://ryantablada.com/post/red-green-refactor---a-tdd-fairytale"></p><h2 id=automating-test-execution>Automating Test Execution<a hidden class=anchor aria-hidden=true href=#automating-test-execution>#</a></h2><p>Designing test cases and test suites is creative, but executing test cases should be automatic.</p><p>Example Tool Chain for Test Case Generation & Execution:
Combine &mldr;
• A combinatorial test case generation (genpairs.py) to create test data
• DDSteps to convert from spreadsheet data to JUnit test cases
• JUnit to execute concrete test cases</p><h3 id=scaffolding>Scaffolding<a hidden class=anchor aria-hidden=true href=#scaffolding>#</a></h3><p>Code to support development and testing.
• Test driver: A &ldquo;main&rdquo; program for running a test
• Test stubs: Substitute for called functions/methods/objects.</p><blockquote><p><strong>Stub</strong> is an object that holds predefined data and uses it to answer calls during tests. It is used when we cannot or don&rsquo;t want to involve objects that would answer with real data or have undesirable side effects. 代指那些包含了预定义好的数据并且在测试时返回给调用者的对象。Stub 常被用于我们不希望返回真实数据或者造成其他副作用的场景。</p></blockquote><p>• Test harness: Substitutes for other parts of the deployed environment</p><p>• <strong>Comparison-based oracle</strong>: need predicted output for each input. Fine for a small number of hand-generated test cases, e.g. hand-written JUnit test cases.</p><p>• <strong>Self-Checking Code as Oracle</strong>: oracle written as self-checks, possible to judge correctness without predicting results. Advantages and limits: Usable with large, automatically
generated test suites, but often only a partial check.</p><p>• <strong>Capture and Replay</strong>: If human interaction is required, capture the manually run test case, replay it automatically. With a comparison-based test oracle, behavior same as previously accepted behavior.</p><h2 id=security-testing>Security Testing<a hidden class=anchor aria-hidden=true href=#security-testing>#</a></h2><p>&ldquo;Regular&rdquo; testing aims to ensure that the program meets customer requirements in terms of features and functionality. Tests &ldquo;normal&rdquo; use cases - Test with regards to common expected usage patterns.</p><p>Security testing aims to ensure that program fulfills security requirements. Often non-functional. More interested in misuse cases.</p><p>Two common approaches:
• Test for known vulnerability types
• Attempt directed or random search of program state space to uncover the &ldquo;weird corner cases&rdquo;</p><h3 id=penetration-testing>Penetration testing<a hidden class=anchor aria-hidden=true href=#penetration-testing>#</a></h3><p>• Manually try to &ldquo;break&rdquo; software
• Typically involves looking for known common problems.</p><h3 id=fuzz-testing>Fuzz testing<a hidden class=anchor aria-hidden=true href=#fuzz-testing>#</a></h3><p>Send semi-valid input to a program and observe its behavior.
• <strong>Black-box testing</strong> - System Under Test (SUT) treated as a &ldquo;black-box&rdquo;
• The only feedback is the output and/or externally observable
behavior of SUT.</p><p><strong>Input generation</strong>
• <strong>Mutation based fuzzing</strong>: Start with a valid seed input, and &ldquo;mutate&rdquo; it. Can typically only find the &ldquo;low-hanging fruit&rdquo; - shallow bugs that are easy to find.
• <strong>Generation based fuzzing</strong>: Use a specification of the input format (e.g. a grammar) to automatically generate semi-valid inputs - Very long strings, empty strings, Strings with format specifiers, &ldquo;extreme&rdquo; format strings, Very large or small values, values close to max or min for data type, Negative values. Almost invariably gives better coverage, but requires much more manual effort.</p><p><strong>The Dispatcher</strong>: running the SUT on each input generated by fuzzer module.</p><p><strong>The Assessor</strong>: automatically assess observed SUT behavior to determine if a fault was triggered.</p><h3 id=concolic-testing>Concolic testing<a hidden class=anchor aria-hidden=true href=#concolic-testing>#</a></h3><p>Concolic execution workflow:
1, Execute the program for real on some input, and record path taken.
2, Encode path as query to SMT solver and negate one branch condition
3, Ask the solver to find new satisfying input that will give a different path.</p><p><strong>White-box testing</strong> method.
• Input generated from control-structure of code to systematically explore different paths of the program.
• Generational search (&ldquo;whitebox fuzzing&rdquo;): Performs concolic testing, but prioritizes paths based on how much they improve coverage.</p><p><strong>Greybox fuzzing</strong>
▪ Coverage-guided semi-random input generation.
▪ High speed sometimes beats e.g. concolic testing, but shares some limitations with mutation-based fuzzing (e.g. magic constants, checksums).</p><h2 id=software-process-models---software-development>Software Process Models - Software Development<a hidden class=anchor aria-hidden=true href=#software-process-models---software-development>#</a></h2><p><strong>Waterfall model</strong>: Sequential, no feedback
1, Requirements
2, Design
3, Implementation
4, Testing
5, Release and maintenance</p><p><strong>V-model</strong>: modified version of the waterfall model
<img loading=lazy src=/images/V_model.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/02_dev_process.pdf.">
• Tests are created at the point the activity they validate is being carried out. So, for example, the acceptance test is created when the systems analysis is carried out.
• Failure to meet the test requires a further <strong>iteration</strong> beginning with the activity that has failed the validation</p><p><strong>Boehm&rsquo;s Spiral Model</strong>: focuse on controlling project risk and attempting formally to address project risk throughout the lifecycle.
<img loading=lazy src=/images/Boehm_Spiral_Model.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/02_dev_process.pdf.">
• V&amp;V activity is spread through the lifecycle with more explicit validation of the preliminary specification and the early stages of design. The goal here is to subject the early stages of design to V&amp;V activity.
• At the early stages there may be no code available so we are working with models of the system and environment and verifying that the model exhibits the required behaviours.</p><p><strong>Extreme Programming (XP)</strong>: one of [Agile Processes]
<img loading=lazy src=/images/Extreme_Programming.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/02_dev_process.pdf.">
• Advocates working directly with code almost all the time.
• The 12 principles of XP summarise the approach.</p><blockquote><p>1, Test-driven development; 2, The planning game; 3, On-site customer; 4, Pair programming; 5, Continuous integration; 6, Refactoring; 7, Small releases; 8, Simple design; 9, System metaphor; 10, Collective code ownership; 11, Coding standards; 12, 40-hour work week;</p></blockquote><p>• Development is test-driven.
• Tests play a central role in refactoring activity.
• &ldquo;Agile&rdquo; development mantra: Embrace Change.</p><p>Facebook&rsquo;s Process Model</p><blockquote><p>Perpetual development - a continuous development model. In this model, software will never be considered a finished product. Instead features are continuously added and adapted and shipped to users. Fast iteration is considered to support rapid innovation.</p></blockquote><h2 id=planning-and-monitoring-the-process>Planning and Monitoring the Process<a hidden class=anchor aria-hidden=true href=#planning-and-monitoring-the-process>#</a></h2><p>Monitoring: Judging progress against the plan.</p><p><strong>Quality process</strong>: Set of <strong>activities and responsibilities</strong>. Follows the overall software process in which it is embedded.
• Example: waterfall software process ––> &ldquo;V model&rdquo;: unit testing starts with implementation and finishes before integration
• Example: XP and agile methods ––> emphasis on unit testing and rapid iteration for acceptance testing by customers.</p><h3 id=strategies-vs-plans>Strategies vs. Plans<a hidden class=anchor aria-hidden=true href=#strategies-vs-plans>#</a></h3><p><img loading=lazy src=/images/Strategies_vs_Plans.png title="Strategies vs. Plans. image from: http://www.inf.ed.ac.uk/teaching/courses/st/2017-18/Ch20.pdf.">
Test and Analysis Strategy:
• Lessons of past experience: an organizational asset built and refined over time
• Body of explicit knowledge: amenable to improvement, reduces vulnerability to organizational change (e.g., loss of key individuals)</p><p>Elements of a Strategy:
• Common quality requirements that apply to all or most products - unambiguous definition and measures
• Set of documents normally produced during the quality process - contents and relationships
• Activities prescribed by the overall process - standard tools and practices
• Guidelines for project staffing and assignment of roles and responsibilities</p><p>Main Elements of a Plan:
• Items and features to be verified - Scope and target of the plan
• Activities and resources - Constraints imposed by resources on activities
• Approaches to be followed - Methods and tools
• Criteria for evaluating results</p><h3 id=schedule-risk>Schedule Risk<a hidden class=anchor aria-hidden=true href=#schedule-risk>#</a></h3><p>• Critical path = chain of activities that must be completed in sequence and that have maximum overall duration
• Critical dependence = task on a critical path scheduled immediately after some other task on the critical path</p><h3 id=risk-planning>Risk Planning<a hidden class=anchor aria-hidden=true href=#risk-planning>#</a></h3><p>• Generic management risk: personnel, technology, schedule
• Quality risk: development, execution, requirements</p><h3 id=contingency-plan>Contingency Plan<a hidden class=anchor aria-hidden=true href=#contingency-plan>#</a></h3><p>• Derives from risk analysis
• Defines actions in response to bad news - Plan B at the ready</p><h3 id=process-monitoring>Process Monitoring<a hidden class=anchor aria-hidden=true href=#process-monitoring>#</a></h3><p>• Identify deviations from the quality plan as early as possible and take corrective action</p><h3 id=process-improvement>Process Improvement<a hidden class=anchor aria-hidden=true href=#process-improvement>#</a></h3><p>Orthogonal Defect Classification (ODC)
• Accurate classification schema: for very large projects, to distill an unmanageable amount of detailed information
• Two main steps
1, Fault classification: when faults are detected, when faults are fixed.
2, Fault analysis</p><p>Root Cause Analysis (RCA)
• Technique for identifying and eliminating process faults
• Four main steps
1, What are the faults?
2, When did faults occur? When, and when were they found?
3, Why did faults occur?
4, How could faults be prevented?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/java/>Java</a></li><li><a href=https://congchan.github.io/tags/software-engineer/>Software Engineer</a></li><li><a href=https://congchan.github.io/tags/inf-course-note/>Inf Course Note</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/inf-course-note-software-architecture-process-and-management/><span class=title>« Prev</span><br><span>Inf Course Note - Software Architecture, Process, and Management</span>
</a><a class=next href=https://congchan.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3word2vec/><span class=title>Next »</span><br><span>深入理解word2vec</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Testing on x" href="https://x.com/intent/tweet/?text=Inf%20Course%20Note%20-%20Software%20Testing&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-testing%2f&amp;hashtags=Java%2cSoftwareEngineer%2cInfCourseNote"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Testing on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-testing%2f&amp;title=Inf%20Course%20Note%20-%20Software%20Testing&amp;summary=Inf%20Course%20Note%20-%20Software%20Testing&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Testing on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-testing%2f&title=Inf%20Course%20Note%20-%20Software%20Testing"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Testing on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Testing on whatsapp" href="https://api.whatsapp.com/send?text=Inf%20Course%20Note%20-%20Software%20Testing%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Testing on telegram" href="https://telegram.me/share/url?text=Inf%20Course%20Note%20-%20Software%20Testing&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-testing%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Testing on ycombinator" href="https://news.ycombinator.com/submitlink?t=Inf%20Course%20Note%20-%20Software%20Testing&u=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-testing%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>