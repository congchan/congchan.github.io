<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Inf Course Note - Natural Language Understanding | Cong's Log</title><meta name=keywords content="NLU,Inf Course Note"><meta name=description content="爱丁堡大学信息学院课程笔记 Natural Language Understanding, Informatics, University of Edinburgh
References:
Natural language understanding
CS224n: Natural Language Processing with Deep Learning
Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning

Meaning representations
意思的表达有很多方法。一种有效的表示单词的含义的方法是 distributional semantic.

Semantics (from Ancient Greek: σημαντικός sēmantikos, &ldquo;significant&rdquo;) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.

语义学 Semantics 在语言学中的研究目的在于找出语义表达的规律性、内在解释、不同语言在语义表达方面的个性以及共性；与计算机科学相关的语义学研究在于机器对自然语言的理解。
Tradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms."><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/inf-course-note-natural-language-understanding/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/inf-course-note-natural-language-understanding/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/inf-course-note-natural-language-understanding/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="Inf Course Note - Natural Language Understanding"><meta property="og:description" content="爱丁堡大学信息学院课程笔记 Natural Language Understanding, Informatics, University of Edinburgh
References: Natural language understanding CS224n: Natural Language Processing with Deep Learning Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning
Meaning representations 意思的表达有很多方法。一种有效的表示单词的含义的方法是 distributional semantic.
Semantics (from Ancient Greek: σημαντικός sēmantikos, “significant”) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.
语义学 Semantics 在语言学中的研究目的在于找出语义表达的规律性、内在解释、不同语言在语义表达方面的个性以及共性；与计算机科学相关的语义学研究在于机器对自然语言的理解。
Tradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-30T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-30T00:00:00+00:00"><meta property="article:tag" content="NLU"><meta property="article:tag" content="Inf Course Note"><meta name=twitter:card content="summary"><meta name=twitter:title content="Inf Course Note - Natural Language Understanding"><meta name=twitter:description content="爱丁堡大学信息学院课程笔记 Natural Language Understanding, Informatics, University of Edinburgh
References:
Natural language understanding
CS224n: Natural Language Processing with Deep Learning
Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning

Meaning representations
意思的表达有很多方法。一种有效的表示单词的含义的方法是 distributional semantic.

Semantics (from Ancient Greek: σημαντικός sēmantikos, &ldquo;significant&rdquo;) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.

语义学 Semantics 在语言学中的研究目的在于找出语义表达的规律性、内在解释、不同语言在语义表达方面的个性以及共性；与计算机科学相关的语义学研究在于机器对自然语言的理解。
Tradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Inf Course Note - Natural Language Understanding","item":"https://congchan.github.io/posts/inf-course-note-natural-language-understanding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Inf Course Note - Natural Language Understanding","name":"Inf Course Note - Natural Language Understanding","description":"爱丁堡大学信息学院课程笔记 Natural Language Understanding, Informatics, University of Edinburgh\nReferences: Natural language understanding CS224n: Natural Language Processing with Deep Learning Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning\nMeaning representations 意思的表达有很多方法。一种有效的表示单词的含义的方法是 distributional semantic.\nSemantics (from Ancient Greek: σημαντικός sēmantikos, \u0026ldquo;significant\u0026rdquo;) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.\n语义学 Semantics 在语言学中的研究目的在于找出语义表达的规律性、内在解释、不同语言在语义表达方面的个性以及共性；与计算机科学相关的语义学研究在于机器对自然语言的理解。\nTradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms.\n","keywords":["NLU","Inf Course Note"],"articleBody":"爱丁堡大学信息学院课程笔记 Natural Language Understanding, Informatics, University of Edinburgh\nReferences: Natural language understanding CS224n: Natural Language Processing with Deep Learning Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning\nMeaning representations 意思的表达有很多方法。一种有效的表示单词的含义的方法是 distributional semantic.\nSemantics (from Ancient Greek: σημαντικός sēmantikos, “significant”) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.\n语义学 Semantics 在语言学中的研究目的在于找出语义表达的规律性、内在解释、不同语言在语义表达方面的个性以及共性；与计算机科学相关的语义学研究在于机器对自然语言的理解。\nTradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms.\nTo convert natural language into values that computer understands, represent words as discrete symbols: Words can be represented by one-hot vectors, Vector dimension is the vocabulary. But there is no natural notion of similarity for one-hot vectors!\nSo learn to encode similarity in the vectors themselves.\nThe core idea is representing words by their context, building a dense vector for each word, chosen so that it is similar to vectors of words that appear in similar contexts.\nDistributional models of meaning = vector-­space models of meaning = vector semantics. word vectors = word embeddings = word representations.\nFour kinds of vector models Sparse vector representations: 1, Mutual-­information weighted word co-­occurrence matrices\nDense vector representations: 2, Singular value decomposition (SVD): A special case of this is called LSA - Latent Semantic Analysis 3, Neural­‐network­‐inspired models (skip­‐grams, CBOW) 4, Brown clusters\nPrediction-­based models learn embeddings as part of the process of word prediction. Train a neural network to predict neighboring words. The advantages: · Fast, easy to train (much faster than SVD) · Available online in the word2vec package · Including sets of pretrained embeddings\nWord representation and Word2vec Word2vec is a framework for learning word vectors representation. Idea: 1, We have a large corpus of text 2, Every word in a fixed vocabulary is represented by a vector 3, Go through each position t in the text, which has a center word c and context (“outside”) words o 4, Use the similarity of the word vectors for c and o to calculate the probability of o given c (or vice versa) 5, Keep adjusting the word vectors to maximize this probability\n在上面第四点, 如果是给定中心词，计算上下文词, 那么就是 Skip-grams model, 比如 Given word $w_t$, in a context window of 2C words, predict 4 context words [wt-2, wt-1, wt+1, wt+2] Skip-grams 给予模型跳词能力，比如 “I hit the tennis ball” 有三个trigrams: “I hit the”, “hit the tennis”, “the tennis ball”. 但是，这个句子也同样包含一个同样重要但是N-Gram无法提取的trigram:“hit the ball”. 而使用 skip-grams 允许我们跳过 “tennis” 生成这个trigram.\n反之，给定 bag-of-words context, predict target word, 那就是 Continuous Bag of Words, CBOW model.\n缺点：因为output size 等于 vocabulary，而 softmax 分母中需要求和每一个词的 output size × hidden units 的内积， 计算会非常昂贵。解决办法是使用负采样 negative sampling。\nWord2vec的本质是遍历语料库的每一个词$w_i$，捕捉$w_i$与其上下文位置目标词的同时出现的概率。\n目标函数 Obejective funtion (cost or loss function) J(θ): For each position $t = 1, … , T$, predict context words within a window of fixed size m, given center word, use chain rule to multiply all the probability to get the likelihood $L(θ)$: The θ is the vectors representations, which is the only parameters we needs to optimize(其实还有其他hyperparameters，这里暂时忽略).\nThe loss function is the (average) negative log likelihood: Minimizing objective function ⟺ Maximizing predictive accuracy.\nThe problem is how to calculate $P(w_{t+j} \\mid w_t; θ)$:\n每个词由两个向量表示（Easier optimization. Average both at the end）： $v_w$ when w is a center word, $u_w$ when w is a context word.\nThen for a center word c and a “outside” word o: The numerator contains dot product, compares similarity of o and c, larger dot product = larger probability. The denominator works as a normalization over entire vocabulary.\n高频词二次采样 subsampling 二次采样是指当决定是否选取一个词作为样本时，它被选择的概率反比于它出现的概率，这样不仅可以降低无意义但高频的词(“the”, “a\"等)的重要性，也可以加快采样速度。\n$$P(w_i) = (\\sqrt{\\frac{z(w_i)}{0.001}} + 1) \\cdot \\frac{0.001}{z(w_i)}$$ $z(w_i)$ 是词$w_i$在语料库中的占比，如果\"peanut\"在10亿语料库中出现了1,000次, 那么z(“peanut”) = 1e-6. Negative sampling 负采样是指每个训练样本仅更新模型权重的一小部分：only the output that represents the positive class(1) + other few randomly selected classes(0) are evaluated. 该论文指出\n负采样5-20个单词适用于较小的数据集，对于大型数据集只需要2-5个单词。\n修改目标函数，选择k个负样本（即除了概率最高的那个目标词之外的其他词）：\n这样可以最大化真正的外部词出现的概率，最小化随机负采样的词概率。\n负面样本的选择是基于 unigram 分布 $f(w_i)$: 一个词作为负面样本被选择的概率与其出现的频率有关，更频繁的词更可能被选作负面样本。 $$P(w_i) = \\frac{ {f(w_i)}^{3/4} }{\\sum_{j=0}^{n}\\left( {f(w_j)}^{3/4} \\right) }$$ 负采样的优点是： · Training speed is independent of the vocabulary size · Allowing parallelism. · 模型的表现更好。因为负采样契合NLP的稀疏性质，大部分情况下，虽然语料库很大，但是每一个词只跟很小部分词由关联，大部分词之间是毫无关联的，从无关联的两个词之间也别指望能学到什么有用的信息，不如直接忽略。\n与传统的NLP方法比较 在word2vec出现之前，NLP使用经典且直观的共生矩阵（co-occurrence matrix）来统计词语两两同时出现的频率，参考ANLP - Distributional semantic models。缺点也明显，词汇量的增加导致矩阵增大，需要大量内存，随之而来的分类模型出现稀疏性问题，模型不稳定。虽然可以使用SVD来降维，但是一个n×m矩阵的计算成本是O(mn2)浮点数（当n","wordCount":"5786","inLanguage":"en","datePublished":"2018-06-30T00:00:00Z","dateModified":"2018-06-30T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/inf-course-note-natural-language-understanding/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Inf Course Note - Natural Language Understanding</h1><div class=post-meta><span title='2018-06-30 00:00:00 +0000 UTC'>2018-06-30</span>&nbsp;·&nbsp;28 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/UoE-nlu.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#meaning-representations aria-label="Meaning representations">Meaning representations</a><ul><li><a href=#fourkindsofvectormodels aria-label=Four kinds of vector models>Four kinds of vector models</a></li><li><a href=#word-representation-and-word2vec aria-label="Word representation and Word2vec">Word representation and Word2vec</a><ul><li><a href=#%e7%9b%ae%e6%a0%87%e5%87%bd%e6%95%b0 aria-label=目标函数>目标函数</a></li><li><a href=#%e9%ab%98%e9%a2%91%e8%af%8d%e4%ba%8c%e6%ac%a1%e9%87%87%e6%a0%b7 aria-label=高频词二次采样>高频词二次采样</a></li><li><a href=#negative-sampling aria-label="Negative sampling">Negative sampling</a></li><li><a href=#%e4%b8%8e%e4%bc%a0%e7%bb%9f%e7%9a%84nlp%e6%96%b9%e6%b3%95%e6%af%94%e8%be%83 aria-label=与传统的NLP方法比较>与传统的NLP方法比较</a></li><li><a href=#todoglove aria-label=TODO(Glove)>TODO(Glove)</a></li></ul></li><li><a href=#morphological-recursive-neural-network-morphornn aria-label="Morphological Recursive Neural Network (morphoRNN)">Morphological Recursive Neural Network (morphoRNN)</a></li><li><a href=#compositional-character-representations aria-label="Compositional character representations">Compositional character representations</a><ul><li><a href=#%e5%93%aa%e7%a7%8d%e6%96%b9%e5%bc%8f%e6%9e%84%e5%bb%ba-subword-representations-%e6%af%94%e8%be%83%e5%a5%bd aria-label="哪种方式构建 subword representations 比较好？">哪种方式构建 subword representations 比较好？</a></li></ul></li><li><a href=#multi-word-language-representations aria-label="Multi-word language representations">Multi-word language representations</a></li></ul></li><li><a href=#%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b aria-label=神经网络语言模型>神经网络语言模型</a></li><li><a href=#%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b aria-label=循环神经网络语言模型>循环神经网络语言模型</a></li><li><a href=#%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%ad%a6%e4%b9%a0%e8%83%bd%e5%8a%9b aria-label=神经网络语言模型的学习能力>神经网络语言模型的学习能力</a></li><li><a href=#dependency-parsing aria-label="Dependency parsing">Dependency parsing</a><ul><li><a href=#graph-based-dependency-parsing aria-label="Graph-based dependency parsing">Graph-based dependency parsing</a></li><li><a href=#transition-based-dependency-parsing aria-label="Transition-based dependency parsing">Transition-based dependency parsing</a></li><li><a href=#comparing-mst-and-transition-based-parsers aria-label="Comparing MST and transition-based parsers:">Comparing MST and transition-based parsers:</a></li></ul></li><li><a href=#recurrent-neural-network-grammars-rnngs aria-label="Recurrent neural network grammars (RNNGs)">Recurrent neural network grammars (RNNGs)</a><ul><li><a href=#syntactic-composition aria-label="Syntactic Composition">Syntactic Composition</a></li><li><a href=#implement-rnngs aria-label="Implement RNNGs">Implement RNNGs</a></li><li><a href=#parameter-estimation aria-label="Parameter Estimation">Parameter Estimation</a></li><li><a href=#inference-problems-of-rnngs aria-label="Inference problems of RNNGs">Inference problems of RNNGs</a></li><li><a href=#importance-sampling aria-label="importance sampling">importance sampling</a></li><li><a href=#%e4%bb%8e%e5%8f%a5%e5%ad%90%e5%88%b0%e8%af%ad%e6%b3%95%e6%a0%91%e7%9a%84seq2seq%e6%a8%a1%e5%9e%8b aria-label=从句子到语法树的seq2seq模型>从句子到语法树的seq2seq模型</a></li></ul></li><li><a href=#parsing aria-label=Parsing>Parsing</a></li><li><a href=#semantic-role-labeling-srl aria-label="Semantic role labeling (SRL)">Semantic role labeling (SRL)</a><ul><li><a href=#frame-semantics aria-label="Frame Semantics">Frame Semantics</a></li><li><a href=#proposition-bank aria-label="Proposition Bank">Proposition Bank</a></li><li><a href=#end-to-end-srl-system aria-label="End-to-end SRL system">End-to-end SRL system</a></li></ul></li><li><a href=#semantic-parsing aria-label="Semantic Parsing">Semantic Parsing</a><ul><li><a href=#abstract-meaning-representation-amr aria-label="Abstract meaning representation (AMR)">Abstract meaning representation (AMR)</a></li></ul></li><li><a href=#todo%e6%8c%87%e4%bb%a3%e6%b6%88%e8%a7%a3-coreference-resolution aria-label="TODO(指代消解 Coreference Resolution)">TODO(指代消解 Coreference Resolution)</a></li><li><a href=#unsupervised-part-of-speech-tagging aria-label="Unsupervised Part-of-Speech Tagging">Unsupervised Part-of-Speech Tagging</a><ul><li><a href=#hidden-markov-models aria-label="Hidden Markov Models">Hidden Markov Models</a></li><li><a href=#bayesian-hmm aria-label="Bayesian HMM">Bayesian HMM</a></li></ul></li><li><a href=#bias-in-nlp aria-label="Bias in NLP">Bias in NLP</a><ul><li><a href=#the-social-impact-of-nlp aria-label="The social impact of NLP">The social impact of NLP</a></li><li><a href=#word-embeddings-contain-human-like-biases aria-label="Word embeddings contain human-like biases">Word embeddings contain human-like biases</a></li><li><a href=#debiasing-word-embeddings aria-label="Debiasing word embeddings">Debiasing word embeddings</a></li></ul></li><li><a href=#%e7%bc%96%e7%a0%81%e5%99%a8%e8%a7%a3%e7%a0%81%e5%99%a8-sequence-to-sequence-%e5%92%8c%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6 aria-label="编码器—解码器 Sequence-to-sequence 和注意力机制">编码器—解码器 Sequence-to-sequence 和注意力机制</a><ul><li><a href=#%e7%bc%96%e7%a0%81%e5%99%a8%e8%a7%a3%e7%a0%81%e5%99%a8-sequence-to-sequenceseq2seq aria-label="编码器—解码器 Sequence-to-sequence（seq2seq）">编码器—解码器 Sequence-to-sequence（seq2seq）</a></li><li><a href=#%e6%b3%a8%e6%84%8f%e5%8a%9b aria-label=注意力>注意力</a></li></ul></li></ul></div></details></div><div class=post-content><p>爱丁堡大学信息学院课程笔记 Natural Language Understanding, Informatics, University of Edinburgh</p><p>References:
<a href=http://www.inf.ed.ac.uk/teaching/courses/nlu/>Natural language understanding</a>
<a href=http://web.stanford.edu/class/cs224n/syllabus.html>CS224n: Natural Language Processing with Deep Learning</a>
<a href=https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html>Lecture Slides from the Stanford Coursera course Natural Language Processing, by Dan Jurafsky and Christopher Manning</a></p><h2 id=meaning-representations>Meaning representations<a hidden class=anchor aria-hidden=true href=#meaning-representations>#</a></h2><p>意思的表达有很多方法。一种有效的表示单词的含义的方法是 distributional semantic.</p><blockquote><p>Semantics (from Ancient Greek: σημαντικός sēmantikos, &ldquo;significant&rdquo;) is the linguistic and philosophical study of meaning, in language, programming languages, formal logics, and semiotics.</p></blockquote><blockquote><p>语义学 Semantics 在语言学中的研究目的在于找出语义表达的规律性、内在解释、不同语言在语义表达方面的个性以及共性；与计算机科学相关的语义学研究在于机器对自然语言的理解。</p></blockquote><p>Tradition solution of usable meaning in a computer: Use e.g. WordNet, a resource containing lists of synonym sets and hypernyms.</p><p>To convert natural language into values that computer understands, represent words as discrete symbols: Words can be represented by one-hot vectors, Vector dimension is the vocabulary. But there is no natural notion of similarity for one-hot vectors!</p><p>So learn to encode similarity in the vectors themselves.</p><p>The core idea is representing words by their context, building a <strong>dense</strong> vector for each word, chosen so that it is similar to vectors of words that appear in similar contexts.</p><p><code>Distributional models of meaning = vector-­space models of meaning = vector semantics</code>.
<code>word vectors = word embeddings = word representations</code>.</p><h3 id=fourkindsofvectormodels>Four kinds of vector models<a hidden class=anchor aria-hidden=true href=#fourkindsofvectormodels>#</a></h3><p>Sparse vector representations:
1, Mutual-­information weighted word co-­occurrence matrices</p><p>Dense vector representations:
2, Singular value decomposition (SVD): A special case of this is called LSA - Latent Semantic Analysis
3, Neural­‐network­‐inspired models (skip­‐grams, CBOW)
4, Brown clusters</p><p>Prediction-­based models learn embeddings as part of the process of word prediction. Train a neural network to predict neighboring words. The advantages:
· Fast, easy to train (much faster than SVD)
· Available online in the word2vec package
· Including sets of pretrained embeddings</p><h3 id=word-representation-and-word2vec>Word representation and Word2vec<a hidden class=anchor aria-hidden=true href=#word-representation-and-word2vec>#</a></h3><p>Word2vec is a framework for learning word vectors representation.
Idea:
1, We have a large corpus of text
2, Every word in a fixed vocabulary is represented by a vector
3, Go through each position t in the text, which has a center word c and context (&ldquo;outside&rdquo;) words o
4, Use the similarity of the word vectors for c and o to calculate the probability of o given c (or vice versa)
5, Keep adjusting the word vectors to maximize this probability</p><p>在上面第四点, 如果是给定中心词，计算上下文词, 那么就是 <strong>Skip-grams model</strong>, 比如 Given word $w_t$, in a context window of 2C words, predict 4 context words [w<sub>t-2</sub>, w<sub>t-1</sub>, w<sub>t+1</sub>, w<sub>t+2</sub>]
<img loading=lazy src=/images/word2vec_window.png title="Example windows and process for computing P(w<sub>t+j</sub> | w<sub>t</sub>), image from: http://web.stanford.edu/class/cs224n">
Skip-grams 给予模型跳词能力，比如 &ldquo;I hit the tennis ball&rdquo; 有三个trigrams: &ldquo;I hit the&rdquo;, &ldquo;hit the tennis&rdquo;, &ldquo;the tennis ball&rdquo;. 但是，这个句子也同样包含一个同样重要但是N-Gram无法提取的trigram:&ldquo;hit the ball&rdquo;. 而使用 skip-grams 允许我们跳过 &ldquo;tennis&rdquo; 生成这个trigram.</p><p>反之，给定 bag-of-words context, predict target word, 那就是 <strong>Continuous Bag of Words, CBOW model</strong>.</p><p>缺点：因为output size 等于 vocabulary，而 softmax 分母中需要求和每一个词的 output size × hidden units 的内积， 计算会非常昂贵。解决办法是使用负采样 <a href=/posts/inf-course-note-natural-language-understanding/#negative-sampling>negative sampling</a>。</p><p>Word2vec的本质是遍历语料库的每一个词$w_i$，捕捉$w_i$与其上下文位置目标词的同时出现的概率。</p><h4 id=目标函数>目标函数<a hidden class=anchor aria-hidden=true href=#目标函数>#</a></h4><p>Obejective funtion (cost or loss function) J(θ):
For each position $t = 1, … , T$, predict context words within a window of fixed size m, given center word, use chain rule to multiply all the probability to get the likelihood $L(θ)$:
<img loading=lazy src=/images/word2vec_likelihood.png title="Function for L(θ), image from: http://web.stanford.edu/class/cs224n">
The θ is the vectors representations, which is the only parameters we needs to optimize(其实还有其他hyperparameters，这里暂时忽略).</p><p>The loss function is the (average) negative log likelihood:
<img loading=lazy src=/images/word2vec_costfunction.png title="image from: http://web.stanford.edu/class/cs224n"></p><p>Minimizing objective function ⟺ Maximizing predictive accuracy.</p><p>The problem is how to calculate $P(w_{t+j} \mid w_t; θ)$:</p><p>每个词由两个向量表示（Easier optimization. Average both at the end）：
$v_w$ when w is a center word, $u_w$ when w is a context word.</p><p>Then for a center word c and a &ldquo;outside&rdquo; word o:
<img loading=lazy src=/images/word2vec_conprobability.png title="image from: http://web.stanford.edu/class/cs224n">
The numerator contains dot product, compares similarity of o and c, larger dot product = larger probability. The denominator works as a normalization over entire vocabulary.</p><h4 id=高频词二次采样>高频词二次采样<a hidden class=anchor aria-hidden=true href=#高频词二次采样>#</a></h4><p>subsampling
二次采样是指当决定是否选取一个词作为样本时，它被选择的概率反比于它出现的概率，这样不仅可以降低无意义但高频的词(&ldquo;the&rdquo;, &ldquo;a"等)的重要性，也可以加快采样速度。</p>$$P(w_i) = (\sqrt{\frac{z(w_i)}{0.001}} + 1) \cdot \frac{0.001}{z(w_i)}$$<p>$z(w_i)$ 是词$w_i$在语料库中的占比，如果"peanut"在10亿语料库中出现了1,000次, 那么z(&ldquo;peanut&rdquo;) = 1e-6.
<img loading=lazy src=/images/sub-sample.png title="sub sample of P(wi)"></p><h4 id=negative-sampling>Negative sampling<a hidden class=anchor aria-hidden=true href=#negative-sampling>#</a></h4><p>负采样是指每个训练样本仅更新模型权重的一小部分：only the output that represents the positive class(1) + other few randomly selected classes(0) are evaluated.
<a href=https://arxiv.org/pdf/1310.4546.pdf>该论文指出</a></p><blockquote><p>负采样5-20个单词适用于较小的数据集，对于大型数据集只需要2-5个单词。</p></blockquote><p>修改目标函数，选择k个负样本（即除了概率最高的那个目标词之外的其他词）：<img loading=lazy src=/images/negative-sample.png title="image from: http://web.stanford.edu/class/cs224n"></p><p>这样可以最大化真正的外部词出现的概率，最小化随机负采样的词概率。</p><p>负面样本的选择是基于 unigram 分布 $f(w_i)$: 一个词作为负面样本被选择的概率与其出现的频率有关，更频繁的词更可能被选作负面样本。</p>$$P(w_i) = \frac{ {f(w_i)}^{3/4} }{\sum_{j=0}^{n}\left( {f(w_j)}^{3/4} \right) }$$<p>负采样的优点是：
· Training speed is independent of the vocabulary size
· Allowing parallelism.
· 模型的表现更好。因为负采样契合NLP的稀疏性质，大部分情况下，虽然语料库很大，但是每一个词只跟很小部分词由关联，大部分词之间是毫无关联的，从无关联的两个词之间也别指望能学到什么有用的信息，不如直接忽略。</p><h4 id=与传统的nlp方法比较>与传统的NLP方法比较<a hidden class=anchor aria-hidden=true href=#与传统的nlp方法比较>#</a></h4><p>在word2vec出现之前，NLP使用经典且直观的共生矩阵（co-occurrence matrix）来统计词语两两同时出现的频率，参考<a href=/NOTE-ANLP-01-distributional-semantic-models>ANLP - Distributional semantic models</a>。缺点也明显，词汇量的增加导致矩阵增大，需要大量内存，随之而来的分类模型出现稀疏性问题，模型不稳定。虽然可以使用SVD来降维，但是一个<code>n×m</code>矩阵的计算成本是O(mn<sup>2</sup>)浮点数（当<code>n&lt;m</code>），还是非常大的。而且很难并入新词或新文档。
<img loading=lazy src=/images/count_based_vs_direct_prediction.png title="Count based vs direct prediction, image from: http://web.stanford.edu/class/cs224n"></p><p>目前融合了两种方法的优点的Glove是最常用的。</p><h4 id=todoglove>TODO(Glove)<a hidden class=anchor aria-hidden=true href=#todoglove>#</a></h4><h3 id=morphological-recursive-neural-network-morphornn>Morphological Recursive Neural Network (morphoRNN)<a hidden class=anchor aria-hidden=true href=#morphological-recursive-neural-network-morphornn>#</a></h3><p>Limitation of word2vec:
• Closed vocabulary assumption
• Cannot exploit functional relationships in learning:</p><blockquote><p>如英语的dog、dogs和dog-catcher有相当的关系，英语使用者能够利用他们的背景知识来判断此关系，对他们来说，dog和dogs的关系就如同cat和cats，dog和dog-catcher就如同dish和dishwasher</p></blockquote><p>To walk closer to open vocabulary, use compositional representations based on morphemes. Instead of word embedding, embed morphemes - the smallest meaningful unit of language. Compute representation recursively from morphemes, word embedding 由 morphemes embedding 拼接而来.![](/images/Morphological_Recursive_Neural_Network.png &ldquo;Morphological Recursive Neural Network. A vector representation for the word &ldquo;unfortunately&rdquo; is constructed from morphemic vectors: un<sub>pre</sub>, fortunate<sub>stm</sub>, ly<sub>suf</sub>. Dotted nodes are computed on-the-fly and not in the lexicon. image from: <a href=http://www.aclweb.org/anthology/W13-3512%22>http://www.aclweb.org/anthology/W13-3512"</a>)</p><p>与基础版的morphoRNN结构相同，Context-insensitive Morphological RNN model (cimRNN) 考察 morphoRNN 在不参考任何上下文信息情况下， 仅仅用 morphemic representation 构造词向量的能力。训练时，给每个词xi定义损失函数s(xi)为新构造的词向量p<sub>c</sub>(xi)和参考词向量p<sub>r</sub>(xi)之间的欧几里得距离平方
<img loading=lazy src=/images/cimRNN_cost.png></p><p>该cimRNN模型没有机会改进可能被估计不足的罕见词的表达.</p><p>Context-sensitive Morphological RNN (csmRNN) 在学习语素组成时同时参考语境信息，在训练过程中，神经网络顶层的更新将一直反向传播直至底层的语素层。
<img loading=lazy src=/images/Context_sensitive_morphological_RNN.png title="Context-sensitive morphological RNN has two layers: (a) the morphological RNN, which constructs representations for words from their morphemes and (b) the word-based neural language which optimizes scores for relevant ngrams. image from: http://www.aclweb.org/anthology/W13-3512"></p><h3 id=compositional-character-representations>Compositional character representations<a hidden class=anchor aria-hidden=true href=#compositional-character-representations>#</a></h3><p>在自然语言处理中使用 word 作为基本单位的问题在于词汇量太大了，所以几乎所有主流模型都会省略很多词，比如Bengio的RNNs语言模型就把所有出现频率<code>&lt;3</code>的单词统一标记为一个特殊词。但这样的操作也只是把词汇量降到了16,383。又比如word2vec模型只考虑出现频率最高的30,000个词。</p><p>所以寻找其他有限集合的语言单位成为替代选择，比如字母 character（更确切地说是 unicode code points），比如前面提到的 Morphemes，还有其他比如 Character n-grams，Morphological analysis等，这些可以统称为 subwords units。</p><p>然后再通过 subwords 来重构 word representation，进而构建整个文本的meaning representation.</p><p>构建 word representation 最简单的方法就是把 subwords vectors 相加、平均或者拼接等，但更好的是使用非线性的方法，比如 Bidirectional LSTMs, Convolutional NNs 等。
<img loading=lazy src=/images/char_rep.png title="Compose character representations into word representations with LSTMs. Illustration of the word lookup tables (top) and the lexical Composition Model (bottom). Square boxes represent vectors of neuron activations. Shaded boxes indicate that a non-linearity. image from: Finding function in form: compositional character models for open vocabulary word representation, Ling et al. 2015"></p><h4 id=哪种方式构建-subword-representations-比较好>哪种方式构建 subword representations 比较好？<a hidden class=anchor aria-hidden=true href=#哪种方式构建-subword-representations-比较好>#</a></h4><p>在 word representation 的重构中，涉及了几个变量:
1, Subword Unit
<img loading=lazy src=/images/Subword_Unit.png title="The last row is part of an oracle: the true morphology, a human annotator."></p><p>2, Composition Function
• Linear Vector operation
• Bi-LSTMs
• Convolutional NNs</p><p>3, Language Typology</p><table><thead><tr><th>Type</th><th>example</th><th>Morphology</th><th>analysis</th></tr></thead><tbody><tr><td>Fusional (English)</td><td>&ldquo;reads&rdquo;</td><td>read-s</td><td>read-3SG.SG</td></tr><tr><td>Agglutinative (Turkish)</td><td>&ldquo;If I read …&rdquo;</td><td>oku-r-sa-m</td><td>read-AOR.COND.1SG</td></tr><tr><td>Root&amp;Pattern (Arabic)</td><td>&ldquo;he wrote&rdquo;</td><td>k(a)t(a)b(a)</td><td>write-PST.3SG.M</td></tr><tr><td>Reduplication (Indonesian)</td><td>&ldquo;children&rdquo;</td><td>anak~anak</td><td>child-PL</td></tr></tbody></table><p><img loading=lazy src=/images/sum_biLSTMs_char_trigrams.png title="Summary of perplexity: use biLSTMs over character trigrams. In general, the results are better than vanilla word representation"></p><p>除了语言模型外, 其他NLP任务如SQuAd问答数据集上的很多优秀模型，也会加入character embedding.</p><p>但目前 Character-level models 并不具有触及实际 morphology 的模型预测能力。</p><h3 id=multi-word-language-representations>Multi-word language representations<a hidden class=anchor aria-hidden=true href=#multi-word-language-representations>#</a></h3><p><strong>Neural bag-of-words models</strong>:
· Simply average (or just sum) word vectors,
· Can improve effectiveness by putting output through 1+ fully connected layers (DANs)
· Recurrent neural networks(LSTM/GRU): cannot capture phrases without prefix context, and empirically, representations capture too much of last words in final vector – focus is LM next word prediction
· Convolutional Neural Network: compute vectors for every h-word phrase, often for several values of h. Example: &ldquo;the country of my birth&rdquo; computes vectors for: the country, country of, of my, my birth, the country of, country of my, of my birth, the country of my, country of my birth. Not very linguistic, but you get everything!</p><p><strong>Data-dependent composition</strong>:
Recursion is natural for describing language, Phrases correspond to semantic units of language.</p><p>How to map longer phrases into the same vector space?
利用复合性原理 principle of compositionality:</p><blockquote><p>在数学、语义学和语言哲学中，复合性原理是指，一个复杂表达式的意义是由其各组成部分的意义以及用以结合它们的规则来决定的。</p></blockquote><p>Recursive neural nets, a tree structure.
For Structure Prediction:
Inputs: two candidate children&rsquo;s representations
Outputs:
1, The semantic representation if the two nodes are merged.
2, Score of how plausible the new node would be.</p><h2 id=神经网络语言模型>神经网络语言模型<a hidden class=anchor aria-hidden=true href=#神经网络语言模型>#</a></h2><p>如何构建一个神经网络语言模型?
语言模型的目的是输入一串字符, 输出下一个字符的概率分布, 可以使用 fixed-window neural Language Model, 类似于N-Gram, 仅考虑前(n-1)个窗口长度序列, &ldquo;<del>as the proctor started the clock</del> the students opened their _&rdquo; 得到定长的输入序列, 而 Feedforward neural networks 的输入就是要求固定长度的向量.
<img loading=lazy src=/images/fixed_window_nn_lm.png title="一个固定长度的神经网络语言模型 image from: http://web.stanford.edu/class/cs224n"></p><p>用前馈神经网络做语言模型的优点（相对于N-Gram）就是没有了稀疏性问题，而且模型的大小也控制在 <code>O(n)</code>（N-Gram是<code>O(exp(n))</code>）</p><p>固定长度的前馈神经网络的固有缺陷就是它要求输入和输出都是固定长度的, 仅考虑前的(n-1)长度的序列, 很多时候会丢失NLP中的长距离依赖信息, 跟N-Gram的有一样的缺陷。而且实际的应用中语句的长度是不固定的，最好有一个神经网络可以接受任意长度的输入序列, 输出任意长度的序列。循环神经网络 (Recurrent neural networks, aka RNNs) 就可以解决这个问题.</p><h2 id=循环神经网络语言模型>循环神经网络语言模型<a hidden class=anchor aria-hidden=true href=#循环神经网络语言模型>#</a></h2><p>不同于前馈神经网络使用输入序列的每一个词单独训练一行(或一列, 取决于矩阵的设计)参数矩阵, RNNs的设计核心是用输入序列的每一个词, 反复地训练同一个参数, 即"共享参数&rdquo;.
<img loading=lazy src=/images/rnn_lm.png title="RNNs神经网络语言模型 image from: http://web.stanford.edu/class/cs224n"></p><p>因为参数共享:
1, 模型大小不会随着输入序列长度增加而增加。
2, 每一步的计算，理论上都使用到了之前的历史信息，所以理论上可以更好的捕捉长距离依赖（但实际上表现并不好，看后面的<a href=/posts/inf-course-note-natural-language-understanding/#%e6%a2%af%e5%ba%a6%e6%b6%88%e5%a4%b1%e4%b8%8e%e7%88%86%e7%82%b8>梯度消失与爆炸</a>）.
3, 模型有更好的泛化能力</p><p>使用基于Softmax的RNNs语言模型等同于解决矩阵分解问题, 参考<a href="https://openreview.net/forum?id=HkwZSG-CZ">Breaking the Softmax Bottleneck: A High-Rank RNN Language Model</a>。</p><p>循环神经网络语言模型使用损失函数评估模型表现: 损失函数 loss function on step t is usual 交叉熵 cross-entropy between predicted probability distribution and the true next word.</p><p>传统的统计语言模型使用困惑度(perplexity)来评估模型表现，但其实降低困惑度等价于减小损失函数.</p><h2 id=神经网络语言模型的学习能力>神经网络语言模型的学习能力<a hidden class=anchor aria-hidden=true href=#神经网络语言模型的学习能力>#</a></h2><p>Character models are good at reduplication (no oracle, though), works well on language with reduplication patterns like Indonesian, Malay. Character NLMs learn word boundaries, memorize POS tags.</p><p>What do NLMs learn about morphology?
1, Character-level NLMs work across typologies, but especially well for agglutinative morphology.
2, predictive accuracy is not as good as model with explicit knowledge of morphology (or POS).
3, They actually learn orthographic similarity of affixes, and forget meaning of root morphemes accordong to qualitative analyses.
4, More generally, they appear to <strong>memorize frequent subpatterns</strong></p><p>总的来说，神经网络处理自然语言的能力并不特殊，表现的性能，跟神经网络本身的长处相匹配，如泛化、模式匹配、端到端应用的能力等。</p><h2 id=dependency-parsing>Dependency parsing<a hidden class=anchor aria-hidden=true href=#dependency-parsing>#</a></h2><p>语言学里有两种角度看待语法结构 - Constituency and Dependency：</p><ul><li>Constituency: phrase structure grammar, 从句子成分构造的角度看，capture the configurational patterns of sentences，即把句子的语法理解为词组成分的递归嵌套. 可以用 context-free grammars (CFGs) 来表达语法规则，就是语法树。</li><li>Dependency syntax: 主要是从语义的角度来看，显示哪些单词依赖于（一般指修改或作为参数其参数）哪些单词。特别用于区分动词的主格（subject position or with nominative inflection）宾格（object position or with accusative inflection）. Dependencies can be identified even in non-configurational languages.</li></ul><p>A sentence dependency structure explains the <strong>dependency relation</strong> between its words: represented as a graph with the words as its nodes, linked by directed, labeled edges, with the following properties:
• connected: every node is related to <strong>at least one other node</strong>, and (through transitivity) to ROOT;
• single headed: every node (except ROOT) has exactly <strong>one incoming edge</strong> (from its head);
• acyclic: the graph cannot contain cycles of directed edges.
<img loading=lazy src=/images/dependency_relation.png title="A dependency relation consists of: a head (H); a dependent (D); a label identifying the relation between H and D. image from: Joakim Nivre, Dependency Grammar and Dependency Parsing."></p><p>Dependency trees 有两种，如果dependency graph中有edges交叉则是<strong>non-projective</strong>, 反之则是 <strong>projective</strong>。更确切的定义是：A dependency tree is <strong>projective</strong> wrt. a particular linear order of its nodes if, for all edges <code>h → d</code> and nodes w, w occurs between h and d in linear order only if w is dominated by h.</p><p>A non-projective dependency grammar is not context-free.
<img loading=lazy src=/images/non_projective.jpg title="上图是 non-projective，下图是 projective. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf"></p><p>Motivation for Dependency parsing:
• context-free parsing algorithms base their decisions on adjacency;
• in a dependency structure, a dependent need not be adjacent to its head (even if the structure is projective);
• we need new parsing algorithms to deal with non-adjacency (and with non-projectivity if present).</p><p>Evaluation: accuracy (# correct dependencies with or ignore label)).</p><h3 id=graph-based-dependency-parsing>Graph-based dependency parsing<a hidden class=anchor aria-hidden=true href=#graph-based-dependency-parsing>#</a></h3><p>Based on <strong>maximum spanning trees (MST parser)</strong>, views syntactic structure as a set of constraints</p><p>Intuition as tagging problem: since each word has exactly one parent, the possible tags are the other words in the sentence (or a dummy node called root). If we <strong>edge factorize</strong> the score of a tree so that it is simply the product of its edge scores, then we can simply select the best incoming edge for each word.</p><p>The tartget function is to find the highest scoring dependency tree in the space of all possible trees for a sentence. The score of dependency tree y for sentence x is:</p>$$s(x,y) = \sum_{(i,j)\in y} s(i,j)$$<p>$x = x_1...x_n, y$ is a set of dependency edges, with $(i, j) ∈ y$ if there is an edge from $x_i$ to $x_j$.</p><p>Scoring edges with a neural network
<img loading=lazy src=/images/dependency_nn_edge_scores.jpg title="Get a<sub>i</sub> by concatenating the hidden states of a forward and backward RNN at position i. image from: Zhang and Lapata (2016)">
The function g(a<sub>j</sub>, a<sub>i</sub>) computes an <strong>association score</strong> telling us how much word wi prefers word wj as its head. Association scores are a useful way to select from a dynamic group of candidates, 跟注意力机制的similarity score 异曲同工，方程的形式也很相似。</p><p>Parsing 算法：</p><ul><li>start with a <strong>totally connected graph</strong> G, i.e., assume a directed edge between every pair of words;</li><li>find the maximum spanning tree (MST) of G, i.e., the directed tree with the highest overall score that includes all nodes of G;</li><li>this is possible in O(n<sup>2</sup>) time using the <strong>Chu-Liu-Edmonds algorithm</strong>; it finds a MST which is not guaranteed to be projective;
1, Each node j in the graph greedily selects the incoming edge with the highest score s(i,j)
2, If result were a tree, it would have to be the maximum spanning tree; If not, there must be a cycle.
3, Break the cycle by replacing a single incoming edge to one of the nodes in the cycle. To choose the node, decide recursively by identifying the cycle and contract it into a single node and recalculate scores of incoming and outgoing edges. Now call CLE recursively on the contracted graph. MST on the contracted graph is equivalent to MST on the original graph. 这里是指先识别出循环体<code>saw ⇄ john</code>②，然后在这个循环体范围内，使用CLE找出 root 进出这个循环体的最大概率路线<code>(root → saw → john = 40) > (root → john → saw = 29)</code>③；
4, Greedily collect incoming edges to all nodes, find out to be a tree and thus the MST of the graph. 把循环体以及其包含的nodes合并为一个node wjs，并且已经有了进出wjs的最大概率路径，这样就可以在整个图上继续运行CLE算法找出最大概率路线<code>(root → wjs → mary = 70) > (root → mary → wjs = 40)</code>④.
<img loading=lazy src=/images/break_the_cycle.jpg title="Graph-based dependency parsing procedure. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf"></li></ul><p>Chu-Liu-Edmonds (CLE) Algorithm:</p><blockquote><p>In graph theory, Edmonds&rsquo; algorithm or Chu–Liu/Edmonds&rsquo; algorithm is an algorithm for finding a spanning arborescence of minimum weight (sometimes called an optimum branching). It is the directed analog of the minimum spanning tree problem</p></blockquote><h3 id=transition-based-dependency-parsing>Transition-based dependency parsing<a hidden class=anchor aria-hidden=true href=#transition-based-dependency-parsing>#</a></h3><p>An extension of shift-reduce parsing (MALT parser), views syntactic structure as the actions of an automaton:
• for a given parse state, the transition system defines a set of actions T which the parser can take;
• if more than one action is applicable, a machine learning classifier is used to decide which action to take;
• just like in the MST model, this requires a mechanism to compute scores over a set of (possibly dynamic) candidates.
<img loading=lazy src=/images/Transition_based_Dependency_Parsing.png title="Configuration c = (s, b, A) with stack s, buffer b, set of dependency arcs A; c is terminal if buffer is empty, stack contains only ROOT, and parse tree is given by Ac image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l07.pdf">
if si is the ith top element on stack, and bi the ith element on buffer, then we have the following transitions:
• <code>LEFT-ARC(l)</code>: adds arc <code>s1 → s2</code> with label <code>l</code> and removes s2 from stack (|s| ≥ 2);
• <code>RIGHT-ARC(l)</code>: adds arc <code>s2 → s1</code> with label <code>l</code> and removes s1 from stack (|s| ≥ 2);
• <code>SHIFT</code>: moves b1 from buffer to stack; recondition: |b| ≥ 1.
总的来说就是：父节点保留在stack中; 从始至终 root 一直都是父节点；从 buffer 中把候选词一个一个 push 到stack中，根据 classifier 预测的结果，分辨出哪个候选词是子节点，并把子节点 pop 出 stack；直到清空 buffer，stack 中只剩下 root。</p><h3 id=comparing-mst-and-transition-based-parsers>Comparing MST and transition-based parsers:<a hidden class=anchor aria-hidden=true href=#comparing-mst-and-transition-based-parsers>#</a></h3><p>Both require dynamic classifiers, and these can be implemented using neural networks, conditioned on bidirectional RNN encodings of the sentence.</p><p>The MST parser selects the globally optimal tree, given a set of edges with scores;
• it can naturally handle projective and non-projective trees;</p><p>A transition-based parser makes a sequence of local decisions about the best parse action;
• it can be extended to projective dependency trees by changing the transition set;</p><p>Accuracies are similar, but transition-based is faster;</p><h2 id=recurrent-neural-network-grammars-rnngs>Recurrent neural network grammars (RNNGs)<a hidden class=anchor aria-hidden=true href=#recurrent-neural-network-grammars-rnngs>#</a></h2><p>Widespread phenomenon: <strong>Polarity items</strong> can only appear in certain contexts, e.g. &ldquo;anybody&rdquo;.</p><blockquote><p>In linguistics, a <strong>polarity item</strong> is a lexical item that can appear only in environments associated with a particular grammatical polarity – affirmative or negative. A polarity item that appears in affirmative (positive) contexts is called a positive polarity item (PPI), and one that appears in negative contexts is a negative polarity item (NPI).</p></blockquote><blockquote><p>The environment in which a polarity item is permitted to appear is called a &ldquo;<strong>licensing context</strong>&rdquo;.</p></blockquote><p>The lecture that I gave did not appeal to anybody;
<del>The lecture that I gave appealed to anybody.</del></p><p>也许"anybody"出现的条件是前面出现过"not&rdquo;，那么应该可以使用 RNNs 模型来解码这点信息。然而:
<del>The lecture that I did not give appealed to anybody.</del></p><p>这说明 Language is hierarchical: The <strong>licensing context</strong> depends on recursive structure (syntax)。不能简单根据"not"是否出现来判断，而是需要看"not"修饰的成分，也就是说要考虑语法的合理。这就给文本生成任务（或者说构建语言模型）带来挑战。</p><p><a href=https://arxiv.org/pdf/1602.07776.pdf>Recurrent neural network grammars (Dyer et al. 2016)</a>提出了一种具有明确短语结构的语言模型 RNNGs。</p><blockquote><p>RNNGs operate via a recursive syntactic process reminiscent of probabilistic context-free grammar generation, but decisions are parameterized using RNNs that condition on the entire syntactic derivation history, greatly relaxing context-free independence assumptions.</p></blockquote><p>就是在使用 RNNs 构建语言模型，除了考虑历史词信息, 还会生成历史的语法结构, 并以此为参考预测语法结构和词语,以保证生成的语言符合语法结构。这里的语法是针对 phrase structure (constituency) grammars，所以 RNNGs 也是一种 <strong>constituency parsing</strong>：</p><ul><li>Generate symbols sequentially using an RNN</li><li>Add some &ldquo;control symbols&rdquo; to rewrite the history periodically<ul><li>Periodically &ldquo;compress&rdquo; a sequence into a single &ldquo;constituent&rdquo;</li><li>Augment RNN with an operation to compress recent history into a single vector (-> &ldquo;reduce&rdquo;)</li><li>RNN predicts next symbol based on the history of compressed elements and non-compressed terminals (&ldquo;shift&rdquo; or &ldquo;generate&rdquo;)</li><li>RNN must also predict &ldquo;control symbols&rdquo; that decide how big constituents are</li></ul></li></ul><p>首先注意到，如果有序地去遍历语法树，得出的就是一个序列：
<img loading=lazy src=/images/tree_traversals.gif title="(Ordered) tree traversals are sequences. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><p>What information can we use to predict the next action, and how can we encode it with an RNN?</p><p>Use an RNN for each of:</p><ul><li>Previous terminal symbols</li><li>Previous actions</li><li>Current stack contents
<img loading=lazy src=/images/tree_traversals_table.gif title="Actions prediction. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf">
最后得出的 stack 就是完整的语法树（以序列的形式）。</li></ul><h3 id=syntactic-composition>Syntactic Composition<a hidden class=anchor aria-hidden=true href=#syntactic-composition>#</a></h3><p>人们通过较小元素的语义组合来解释较大文本单元的含义 - 实体，描述性词语，事实，论据，故事.
When compressing &ldquo;The hungry cat&rdquo; into a single composite symbol, use Bi-LSTM to encode <code>(NP The hungry cat)</code>.
<img loading=lazy src=/images/NP_The_hungry_cat.png title="Representation of (NP The hungry cat). image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><p>基于此可以递归地解码更复杂的短语，比如<code>(NP The (ADJP very hungry) cat)</code>, 只需要把原来的<code>hungry</code>替换为<code>(ADJP very hungry)</code>即可。</p><p>这种递归地堆栈符号的构建行为映射了符号对应的树结构
<img loading=lazy src=/images/Stack_symbols_composed_recursively.png title="Stack encodes top-down syntactic recency, rather than left-to-right string recency. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><p>除此了使用 Bi-LSTM 解码，还可以使用 Attention：Replace composition with one that computes attention over objects in the composed sequence, using embedding of NT for similarity.</p><h3 id=implement-rnngs>Implement RNNGs<a hidden class=anchor aria-hidden=true href=#implement-rnngs>#</a></h3><p>Stack RNNs</p><ul><li>Augment a sequential RNN with a <strong>stack pointer</strong></li><li>Two constant-time operations<ul><li><label style=color:#1565c0><strong>push</strong></label> - read input, add to top of stack, connect to current location of the stack pointer</li><li><label style=color:#c62828><strong>pop</strong></label> - move stack pointer to its parent</li></ul></li><li>A <strong>summary</strong> of stack contents is obtained by accessing the output of the RNN at location of the stack pointer
<img loading=lazy src=/images/stack_LSTM_over_time.gif title="The evolution of the stack LSTM over time mirrors tree structure. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></li></ul><p>Training RNNs:</p><ul><li>Each word is conditioned on history represented by a trio of RNNs</li><li>backpropagate through these three RNNs, and recursively through the phrase structure <code>S → NP VP</code>.
<img loading=lazy src=/images/RNNGs_history_informationn.png title="RNNs compute probability conditions on histroy. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></li></ul><p>完整的RNNGs模型，用 softmax 计算下一个 action 的概率分布：
<img loading=lazy src=/images/RNNGs_model.png title="Complete RNNGs model. x is sentence, y is tree; $A_G$ is allowable actions at this step;  $a(x,y)$ is sequence of actions, ; $r_α$ is action embedding, $u_t$ is history embedding; $o_t$ is output (buffer), $s_t$ is stack, $h_t$ is action history, the three are concatenated together. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><h3 id=parameter-estimation>Parameter Estimation<a hidden class=anchor aria-hidden=true href=#parameter-estimation>#</a></h3><p>RNNGs jointly model sequences of words together with a &ldquo;tree structure&rdquo;.</p><p>Any parse tree can be converted to a sequence of actions (depth first traversal) and vice versa (subject to wellformedness constraints).</p><h3 id=inference-problems-of-rnngs>Inference problems of RNNGs<a hidden class=anchor aria-hidden=true href=#inference-problems-of-rnngs>#</a></h3><p>An RNNG is a joint distribution p(x,y) over strings (x) and parse trees (y), i.e. it jointly predicts the word, and the parse context together. So the model will still generate the syntactic information and the next word but we can discard the additional outputs if all we want is the language model.</p><p>Two inference questions:
• What is $p(x)$ for a given x? - language modeling
• What is $argmax_yp(y | x)$ for a given x? - parsing</p><p>The model predicts the next action (NT() GEN() or REDUCE in generative mode, NT() SHIFT or REDUCE in discriminative mode). The set of actions completely determines the string and tree structure, so we can get their joint probability by multiplying over the probabilities of all actions.</p><p>In discriminative mode, the input is a string of words, and the model cannot generate words, but instead &ldquo;consumes&rdquo; the words in the input buffer. The model can be used as a parser (find the maximum prob. tree, i.e., $argmax_yP(y \mid x)$).</p><p>In generative mode, there is a respective GEN() action for every word, so the word is predicted with the action. To be a language model (find the maximum prob. sentence/assign probabilities to a sentence, i.e., $p(x)$), we must marginalize over trees to get the probability of the sentence. This is intractable so is approximated with importance sampling by sampling from a discriminatively trained model.</p><h3 id=importance-sampling>importance sampling<a hidden class=anchor aria-hidden=true href=#importance-sampling>#</a></h3><p>Assume we"ve got a conditional distribution $q(y | x)$
s.t. (i) $p(x, y) > 0 \Rightarrow q(y | x) > 0$
(ii) $y \sim q(y | x)$ is tractable and
(iii) $q(y | x)$ is tractable</p><p>The importance weights $w(x,y) = \frac{p(x, y)}{q(y | x)}$</p><p><img loading=lazy src=/images/Importance_Sampling.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l08.pdf"></p><h3 id=从句子到语法树的seq2seq模型>从句子到语法树的seq2seq模型<a hidden class=anchor aria-hidden=true href=#从句子到语法树的seq2seq模型>#</a></h3><p>其实从句子到语法的映射类似于一个seq2seq模型。而直接的把语法树以字符序列的形式表达，使用简单的 RNNs 直接构建句子到语法序列的 seq2seq 模型效果也不错，比如：
input: The hungry cat meows .
output: S( NP( _ _ _ ) VP( _ ) _ )
Vanilla RNNs 在模式匹配和计数方面非常出色，经验证明，训练有素的 seq2seq 模型通常会输出格式良好的字符串，见<a href=https://arxiv.org/abs/1412.7449>这篇文章 section 3.2</a></p><p>但潜在的问题是，seq2seq 模型并不要求输出是有正确括号字符（数量对齐，位置正确）。另外，理论上单个RNN也只能记忆括号结构一定的有限深度，因为 RNNs 只有固定的有限数量的隐藏单元。例如，它将为这些输出分配非零概率：
S( NP( _ _ ) VP ( _ ) _ )
S( NP( _ _ _ ) VP ( _ ) _ ) ) )</p><p>理想情况下，模型应该给任何不完整的输出分配零概率。使用 RNNGs 是因为它本身能够履行这些限制， 保证生成完整正确的语法树。</p><p>从中可以看出，seq2seq模型可以用于快速原型和 baseline 搭建，但如果遇到要求输出遵守某些约束条件的问题，则需要直接执行这些约束条件。</p><h2 id=parsing>Parsing<a hidden class=anchor aria-hidden=true href=#parsing>#</a></h2><p>Parsing is a fundamental task in NLP. But what is parsing actually good for?</p><p>Parsing breaks up sentences into meaningful parts or finds meaningful relationships, which can then feed into downstream semantic tasks:
• semantic role labeling (figure out who did what do whom);
• semantic parsing (turn a sentence into a logical form);
• word sense disambiguation (figure out what the words in a sentence mean);
• compositional semantics (compute the meaning of a sentence based on the meaning of its parts).</p><h2 id=semantic-role-labeling-srl>Semantic role labeling (SRL)<a hidden class=anchor aria-hidden=true href=#semantic-role-labeling-srl>#</a></h2><p>虽然可以使用 Distributional semantics 表达含义，只是 Distributional semantics 比较擅长处理相似度，且无法很明确地处理复合性 Compositionality。</p><blockquote><p>在数学、语义学和语言哲学中，复合性原理是指，一个复杂表达式的意义是由其各组成部分的意义以及用以结合它们的规则来决定的。</p></blockquote><p>为了能够处理复合性和推理，我们需要象征性和结构化的意义表示。</p><p>虽然语言是无穷无尽的，句子是无限的集合，而人脑的能力却是有限的，但人们总能够理解一个句子的含义（假如人们熟知表达句子的语言）. 因此, 对于 semantics, 语义肯定是有限的集合, 这样才能确定句子的确切意义.</p><blockquote><p>In generative grammar, a central principle of formal semantics is that the relation between syntax and semantics is <strong>compositional</strong>.</p></blockquote><blockquote><p>The principle of compositionality (Fregean Principle): The meaning of a complex expression is determined by the meanings of its parts and the way they are syntactically combined.</p></blockquote><p>Semantic role labeling means identifying the arguments (<strong>frame elements</strong>) that participate in a prototypical situation (frame) and labeling them with their roles;</p><p>SRL task is typically broken down into a sequence of sub-tasks:</p><ol><li>parse the training corpus;</li><li>match <strong>frame elements</strong> to constituents;</li><li>extract features from the parse tree;</li><li>train a probabilistic model on the features.</li></ol><p>所谓 frame elements 是针对 Frame Semantics 而言的。</p><p>SRL provides a shallow semantic analysis that can benefit various NLP applications; no parsing needed, no handcrafted features.</p><h3 id=frame-semantics>Frame Semantics<a hidden class=anchor aria-hidden=true href=#frame-semantics>#</a></h3><p>表达词义，除了 Firth, J.R. (1957) 的 &ldquo;a word is characterized by the company it keeps&rdquo;（也即是 Distributional semantics）之外, 还有 Charles J. Fillmore 的 Frame Semantics.</p><blockquote><p>The basic idea is that one cannot understand the meaning of a single word without access to all the essential knowledge that relates to that word.</p></blockquote><blockquote><p>A semantic frame is a collection of facts that specify &ldquo;characteristic features, attributes, and functions of a denotatum, and its characteristic interactions with things necessarily or typically associated with it.&rdquo;</p></blockquote><blockquote><p>A semantic frame can also be defined as a coherent structure of related concepts that are related such that without knowledge of all of them, one does not have complete knowledge of any one; they are in that sense types of gestalt.</p></blockquote><h3 id=proposition-bank>Proposition Bank<a hidden class=anchor aria-hidden=true href=#proposition-bank>#</a></h3><p>完整的句子表达了命题 propositions, 也即一个主张. 比如"John smokes"这个句子的命题如果是真的,那么"John"在这里一定是某个"smokes"的人, 也就是必须是<code>NP</code>.</p><blockquote><p>在现代哲学、逻辑学、语言学中，命题是指一个判断（陈述）的语义（实际表达的概念），这个概念是可以被定义并观察的现象。命题不是指判断（陈述）本身。当相异判断（陈述）具有相同语义的时候，他们表达相同的命题。例如，雪是白的（汉语）和Snow is white（英语）是相异的判断（陈述），但它们表达的命题是相同的。在同一种语言中，两个相异判断（陈述）也可能表达相同命题。例如，刚才的命题也可以说成冰的小结晶是白的，不过，之所以是相同命题，取决于冰的小结晶可视为雪的有效定义。</p></blockquote><p>PropBank is a version of the Penn Treebank annotated with semantic roles. More coarse-grained than Frame Semantics:
<img loading=lazy src=/images/PropBank.png title="Proposition Bank, Arg2–Arg4 are often verb specific. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l09.pdf"></p><h3 id=end-to-end-srl-system>End-to-end SRL system<a hidden class=anchor aria-hidden=true href=#end-to-end-srl-system>#</a></h3><p>基本的结构单元是Bi-LSTM，用法是：
· a standard LSTM layer processes the input in forward direction;
· the output of this LSTM layer is the input to another LSTM layer, but in reverse direction;
这些Bi-LSTM单元可以叠加起来构造更深层的神经网络.</p><p>The input (processed word by word) features are:
• argument and predicate: the argument is the word being processed, the predicate is the word it depends on;
• predicate context (ctx-p): the words around the predicate; also used to distinguish multiple instances of the same predicate;
• region mark (m<sub>r</sub>): indicates if the argument is in the predicate context region or not;
• if a sequence has n<sub>p</sub> predicates it is processed n<sub>p</sub> times.</p><p>Output: semantic role label for the predicate/argument pair using IOB tags (inside, outside, beginning).
<img loading=lazy src=/images/end_to_end_SRL.png title="End to end SRL model. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l09.pdf"></p><p>Training:
• Word embeddings are used as input, not raw words;
• the embeddings for arguments, predicate, and ctx-p, as well as m<sub>r</sub> are <strong>concatenated</strong> and used as input for the Bi-LSTM;
• the output is passed through a conditional random field (CRF); allows to model dependencies between output labels;
• Viterbi decoding is used to compute the best output sequence</p><p>Model learns &ldquo;syntax&rdquo;(Maybe): it associates argument and predicate words using the forget gate:</p><h2 id=semantic-parsing>Semantic Parsing<a hidden class=anchor aria-hidden=true href=#semantic-parsing>#</a></h2><p>Semantic Parsing 指语义分析，把文本解析为任意的逻辑形式(一种 meaning representation)，比如 first-order logic(FOL).
<code>Sam likes Casey</code> - <code>likes(Sam, Casey)</code>;
<code>Anna's dog Mr. PeanutButter misses her</code> - <code>misses(MrPB, Anna) ∧ dog(MrPB)</code>;
<code>Kim likes everyone</code> - <code>∀x.likes(x, Kim)</code>.
Predicate-argument structure is a good match for FOL, as well as structures with argument-like elements (e.g. NPs).
Determiners, quantifiers (e.g. &ldquo;everyone&rdquo;, &ldquo;anyone&rdquo;), and negation can be expressed in FOL.</p><p>However, much of natural language is unverifiable, ambiguous, non-canonical. That makes it hard to represent the wide-coverage meaning of arbitrary NL. Closed domains are easier, and can sometimes be harvested automatically, e.g. GEOQUERY dataset.</p><p>This leads to a proliferation of domain-specific MRs.
· Pairs of NL sentences with structured MR can be collected, e.g. IFTTT dataset (Quirk et al. 2015).
· WikiTableQuestions
· Google&rsquo;s knowledge graph</p><p>Viewing MR as a string, semantic parsing is just conditional language modeling. Trainable alternative to compositional approaches: encoder-decoder neural models. The encoder and decoder can be mixed and matched: RNN, top-down tree RNN.
<img loading=lazy src=/images/meaning_representation_model.png title="Meaning representation model using standard sequence models. Since logical forms are treelike, can use treeLSTM decoder. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l10.pdf"></p><p>Works well on small, closed domains if we have training data, but there are many unsolved phenomena/ problems in semantics.</p><h3 id=abstract-meaning-representation-amr>Abstract meaning representation (AMR)<a hidden class=anchor aria-hidden=true href=#abstract-meaning-representation-amr>#</a></h3><p>• The edges (ARG0 and ARG1) are <label style=color:#c62828>relations</label>
• Each node in the graph has a <label style=color:#ba68c8>variable</label>
• They are labeled with <label style=color:#1565c0>concepts</label>
• <label style=color:#ba68c8>d</label> / <label style=color:#1565c0>dog</label> means &ldquo;<label style=color:#ba68c8>d</label> is an instance of <label style=color:#1565c0>dog</label>&rdquo;
<code>The dog is eating a bone</code>
(<label style=color:#ba68c8>e</label> / <label style=color:#1565c0>eat-01</label>
    :<label style=color:#c62828>ARG0</label> (<label style=color:#ba68c8>d</label> / <label style=color:#1565c0>dog</label>)
    :<label style=color:#c62828>ARG1</label> (<label style=color:#ba68c8>b</label> / <label style=color:#1565c0>bone</label>))</p><p><code>The dog wants to eat the bone</code>
(want-01
    :ARG0 (d / dog)
    :ARG1 (e / eat-01
        :ARG0 d
        :ARG1 (b / bone)))</p><p><strong>Coreference</strong>
Charles just graduated, and now Bob wants Anna to give <strong>him</strong> a job.
Q: who does <strong>him</strong> refer to?</p><p><strong>Metonymy</strong>
<strong>Westminster</strong> decided to distribute funds throughout England, Wales, Northern Island, and Scotland
decided(Parliament, …)</p><p><strong>Implicature</strong>
That cake looks delicious - I would like a piece of that cake.</p><p>Even more phenomena…
• Abbreviations (e.g. National Health Service=NHS)
• Nicknames (JLaw=Jennifer Lawrence)
• Metaphor (crime is a virus infecting the city)
• Time expressions and change of state
• Many others</p><h2 id=todo指代消解-coreference-resolution>TODO(指代消解 Coreference Resolution)<a hidden class=anchor aria-hidden=true href=#todo指代消解-coreference-resolution>#</a></h2><h2 id=unsupervised-part-of-speech-tagging>Unsupervised Part-of-Speech Tagging<a hidden class=anchor aria-hidden=true href=#unsupervised-part-of-speech-tagging>#</a></h2><p>Parts-of-speech(POS), word classes, or syntactic categories, 一般指八个词性：noun, verb, adjective, adverb, pronoun, preposition, conjunction, interjection, 有时候是 numeral, article or determiner.
1, noun 名詞 ( n. )
2, pronoun 代名詞 ( pron. )
3, verb 動詞 ( v. )
4, adjective 形容詞 ( adj. )
5, adverb 副詞 ( adv. )
6, preposition 介系詞 ( prep. )
7, conjunction 連接詞 ( conj. )
8, interjection 感歎詞 ( int. )</p><p>Tagging is a task that take a sentence, assign each word a label indicating its syntactic category (part of speech).</p><p>One common standard label is Penn Treebank PoS tagset.</p><blockquote><p>DT - Determiner 定语
IN - Preposition or subord. conjunction
NN - Noun, singular or mass
NNS - Noun, plural
NNP - Proper noun, singular
RB - Adverb
TO - to
VB - Verb, base form
VBZ - Verb, 3rd person singular present</p></blockquote><p>In supervised POS tagging, the input is the text and a set of allowed POS labels. The training data contains input and output examples. The output is a guess, for each word in the test data, which POS label it should have.</p><p>A common approach is to use an HMM. To train it, choose parameters θ that maximize $P(x,y \mid θ)$, the probability of the training data given the parameters. This is <strong>maximum likelihood estimation</strong> and it was covered in <a href>ANLP</a>. You can use the model to predict y for each x in the test data by solving $P(y \mid x,θ)$ using the <strong>Viterbi algorithm</strong>.</p><p>A consequence of supervised training with MLE is that the model will only learn <strong>non-zero probability</strong> for tag-word pairs that actually appear in the data. Hence, if &ldquo;the&rdquo; is only ever tagged with DT in the training data, then the model will learn that the probability of producing &ldquo;the&rdquo; from any other tag is zero. This means that many word tokens will be (empirically) unambiguous, which is one of the things that makes supervised POS tagging easy.</p><p>RNNs 虽然也可以处理序列模型, 但是神经网络需要目标函数, 没有目标无法计算损失, 就无法调整参数, 也就是"监督学习".</p><p>Current PoS taggers are highly accurate (97% accuracy on Penn Treebank). But they require manually labelled training data, which for many major language is not available. Hence motivated for unsupervised PoS tagging.</p><p>In unsupervised POS tagging, the input is the text and <strong>the number of clusters</strong>. The training data contains only input examples. The output is a guess, for each word in the text, which cluster the word belongs to. For example:</p><pre tabindex=0><code>Number of clusters: 50
Input x: The hungry cat meows
Output y: 23 45 7 18
</code></pre><p>What we hope is that the cluster labels will correlate with true POS labels; that is, that tokens labeled 23 will tend to be determiners, that clusters label 45 will tend to be adjectives, and so on.</p><p>这个时候可以使用隐马尔科夫模型, 这个"隐"就是针对没有目标可以参考这种情况.</p><h3 id=hidden-markov-models>Hidden Markov Models<a hidden class=anchor aria-hidden=true href=#hidden-markov-models>#</a></h3><p>The unsupervised tagging models here are based on Hidden Markov Models (HMMs).
<img loading=lazy src=/images/HMM.png title="Hidden Markov Models (HMMs). image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf">
To train it, choose parameters θ that maximize $P(x \mid θ)$, the probability of the training data given the parameters.</p><p>The parameters θ = (τ, ω) define:
• τ : the probability distribution over tag-tag transitions;
• ω: the probability distribution over word-tag outputs.
The parameters are sets of multinomial distributions:
• $ω = ω^{(1)} . . . ω^{(T)}$: the output distributions for each tag;
• $τ = τ^{(1)} . . . τ^{(T)}$: the transition distributions for each tag;
• $ω^{(t)} = ω_1^{(t)}. . . ω_W^{(t)}$: the output distribution from tag $t$;
• $τ^{(t)} = τ_1^{(t)}. . . τ_T^{(t)}$: the transition distribution from tag $t$.</p><p>Another way to write the model, often used in statistics and machine learning:</p><p>$w_i | t_i = t ∼ Multinomial(ω^{(t)})$</p><p>So as tag, given that $t_{i−1} = t$, the value of $t_i$ is drawn from a multinomial distribution with parameters $τ^{(t)}$.</p><p>How to estimate ω and τ without supervision. This is still maximum likelihood estimation, but notice that it&rsquo;s more difficult because the tags y are unobserved, so you must marginalize them out.</p><p>For <strong>estimation</strong> (i.e., training the model, determining its parameters), we need a procedure to set θ based on data. Rely on Bayes Rule:
\begin{equation}\begin{split}
P(θ|w)&=\frac{P(w|θ)P(θ)}{P(w)}\\
&∝P(w|θ)P(θ)\\
\end{split}\end{equation}
Choose the θ that maximize the likelihood $P(w|θ)$. Basically, we ignore the prior. In most cases, this is equivalent to assuming a uniform prior.</p><p>To do this, you can use <strong>expectation maximization</strong> (EM), a variant of MLE that can cope with unobserved data, which was also covered in <a href>ANLP</a>. For examples, forward-backward algorithm for HMMs, inside-outside algorithm for PCFGs, k-means clustering.</p><p>For <strong>inference</strong> (i.e., decoding, applying the model at test time), we need to know θ and then we can compute $P(t, w)$:
<img loading=lazy src=/images/Inference_for_HMMs.png title="Inference for HMMs. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p><p>E-step: use current estimate of θ to compute expected counts of hidden events ($n(t,t^{\prime})$, $n(t,w)$).
M-step: recompute θ using expected counts.</p><p>You can then use the trained model to predict y for each x in the test data by solving $P(y \mid x,θ)$ using the Viterbi algorithm.</p><p>But EM often fails, even very small amounts of training data have been show to work better than EM. One consequence of unsupervised training with EM is that every word can be assigned to any cluster label. This makes things really difficult, because it means every word is ambiguous. The basic assumptions of EM (that any tag-word or tag-tag distribution is equally likely) make this even more difficult.</p><p>Instead, use Bayesian HMM with Gibbs sampling.</p><h3 id=bayesian-hmm>Bayesian HMM<a hidden class=anchor aria-hidden=true href=#bayesian-hmm>#</a></h3><p>When training HMM model, we are not actually interested in the value of θ, we could simply integrate it out. This approach is called <strong>Bayesian integration</strong>. Integrating over θ gives us an average over all possible parameters values.</p><p>The Bayesian HMM is simply an alternative way to solve the unsupervised POS tagging problem. The input and output is the same. But instead of learning θ, we directly solve $P(y \mid x)$. Note that we don&rsquo;t need to learn θ (though we could) - in this setting, we integrate it out, after first supplying some information about the tag-tag and word-tag distributions encoded in θ. Specifically, we tell the model that a sparse distribution is much more likely than a uniform distribution. We do this by defining a distribution $P(θ)$, and this gives us a new model, $P(y,x \mid θ)×P(θ)$. By integrating out θ we can solve the unsupervised tagging problem directly.</p><p>Example: we want to predict a spinner result will be &ldquo;a&rdquo; or not?
• Parameter θ indicates spinner result: $P(θ = a) = .45$, $P(θ = b) = .35$, $P(θ = c) = .2$;
• define t = 1: result is &ldquo;a&rdquo;, t = 0: result is not &ldquo;a&rdquo;;
• make a prediction about one random variable (t) based on the value of another random variable (θ).</p><p><strong>Maximum likelihood approach</strong>: choose most probable θ, $\hat{θ} = a$, and $P(t = 1|\hat{θ}) = 1$, so we predict $t = 1$.</p><p><strong>Bayesian approach</strong>:
average over θ,
$P(t = 1) = \sum_θ P(t = 1|θ)P(θ) = 1(.45) + 0(.35) + 0(0.2) = .45$, predict t = 0.</p><p>Advantages of Bayesian integration:
• accounts for uncertainty as to the exact value of θ;
• models the shape of the distribution over θ;
• increases robustness: there may be a range of good values of θ;
• we can use priors favoring sparse solutions (more on this later).</p><p>Dirichlet distribution
Choosing the right prior can make integration easier. A $K$-dimensional Dirichlet with parameters $α = α_1 . . . α_K$ is defined as:</p>$$ P(θ) = \frac{1}{Z} \prod_{j=1}^K θ_j^{α_j−1} $$<p>We usually only use symmetric Dirichlets, where $α_1 . . . α_K$ are all equal to β. We write Dirichlet(β) to mean $Dirichlet(β, . . . , β)$.</p><p><img loading=lazy src=/images/Dirichlet_Distribution.png title="A 2-dimensional symmetric Dirichlet(β) prior over θ = (θ1, θ2), β > 1: prefer uniform distributions, β = 1: no preference, β < 1: prefer sparse (skewed) distributions. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf">
注意到这是一个二维的概率密度图. $β>1$意味着更喜欢均值分布, 此时$θ$大概率落在$0.5$附近,因为$θ_1+θ_2=1$, 所以此时$θ_1, θ_2$概率均等. 如果$β=1$, $θ_1$的任何取值是等概率的, 等于说任何$θ_1,θ_2$的组合概率都是均等的.</p><p>To Bayesianize the HMM, we augment with it with symmetric Dirichlet priors:
<img loading=lazy src=/images/Bayesianizing_the_HMM.png title="image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p><p>To simplify things, use a bigram version of the Bayesian HMM; If we integrate out the parameters θ = (τ, ω), we get:
<img loading=lazy src=/images/BHMM_Dirichlet_Distribution_.png title="With T possible tags and Wt possible words with tag t. image from: http://www.inf.ed.ac.uk/teaching/courses/nlu/assets/slides/2018/l11.pdf"></p><p>Use these distributions to find $P(t|w)$ using an estimation method called <strong>Gibbs sampling</strong>.</p><p>Results: Integrating over parameters is useful in itself, even with uninformative priors $(α = β = 1)$;</p><p>总结：
· Bayesian HMM improves performance by averaging out uncertainty;
· allows us to use priors that favor sparse solutions as they occur in language data.
· Using a tag dictionary is also really helpful. We still have no labeled training data, but if we only allow each word to be tagged with one of the labels that appears in the dictionary, then most word-tag pairs will have probability zero. So this is a very different way of supplying information to the unsupervised model that is very effective.</p><h2 id=bias-in-nlp>Bias in NLP<a hidden class=anchor aria-hidden=true href=#bias-in-nlp>#</a></h2><h3 id=the-social-impact-of-nlp>The social impact of NLP<a hidden class=anchor aria-hidden=true href=#the-social-impact-of-nlp>#</a></h3><p>Outcome of an NLP experiment can have a direct effect on people&rsquo;s lives, e.g.</p><ol><li><a href="https://www.youtube.com/watch?v=p8phGxzUC_Y">频繁出现亚马逊 Alexa 突然发出诡异笑声，给多名用户造成困惑和恐慌</a>, 因为人们谈话中偶然包含 trigger 词：&ldquo;Alexa, laugh&rdquo; 而发出 - 亚马逊的<a href=https://www.nytimes.com/2018/03/08/business/alexa-laugh-amazon-echo.html>解决方案是把 trigger 改为更难触发的 &ldquo;Alexa, can you laugh&rdquo;</a></li><li>Chatbot 对于人们敏感问题的不恰当回答, 比如 &ldquo;Should I kill myself?&rdquo; - &ldquo;Yes."，这些回答对患有心理障碍的人群或者青少年儿童带来非常大的危害。</li><li><a href=https://www.theverge.com/2016/3/24/11297050/tay-microsoft-chatbot-racist>Microsoft 的 AI chatbot 上线仅一天, 就通过 twitter 和人交谈并学会涉及种族, 性别歧视等的话语</a>, 典型的 &ldquo;garbage in, garbage out&rdquo; 现象.</li><li>其他涉及数据隐私等问题</li></ol><p><strong>语言的特性，导致NLP涉及的社会伦理问题非常多, 而且影响非常大</strong>：
· 语言传递着信息、偏见，是政治性的、权力的工具, 同时比其他技术带有更明显的拟人化、人格化倾向，这可能给个人生活带来不便或危害，给整个社会带来舆论影响。
· Any dataset carries demographic bias: latent information about the demographics of the people that produced it. That excludes people from other demographics.</p><p><strong>同时人类本身的认知容易加深偏见</strong>:
The <strong>availability heuristic</strong>: the more knowledge people have about a specific topic, the more important they think it must be. <strong>Topic overexposure</strong> creates biases that can lead to discrimination and reinforcement of existing biases. E.g. NLP focused on English may be self-reinforcing.</p><p><strong>NLP 实验本身容易加深偏见</strong>：
• Advanced grammar analysis can improve search and educational NLP, but also reinforce prescriptive linguistic norms.
• Stylometric analysis can help discover provenance of historical documents, but also unmask anonymous political dissenters.</p><p><strong>NLP 技术可能被不恰当地使用</strong>：
• Text classification and IR can help identify information of interest, but also aid censors.
• NLP can be used to discriminate fake reviews and news, and also to generate them.</p><h3 id=word-embeddings-contain-human-like-biases>Word embeddings contain human-like biases<a hidden class=anchor aria-hidden=true href=#word-embeddings-contain-human-like-biases>#</a></h3><p>word2vec learns semantic/ syntactic relationships, also keep company with unsavoury stereotypes and biases?
• Man:Woman - King:Queen
• Man:Doctor - Woman:Nurse
• Man:Computer Programmer - Woman:Homemaker</p><p>Measure bias using implicit association tests:
1, Compute similarity of group1 and stereotype1 word embeddings. Cosine similarity is use to measure association (in place of reaction time).
2, Compute similarity of group1 and stereotype 2 word embeddings.
3, Null hypothesis: if group1 is not more strongly associated to one of the stereotypes, there will be no difference in the means.
4, Effect size measured using Cohen&rsquo;s d.
5, Repeat for group 2.</p><p>Experiments
• Uses GloVe trained on Common Crawl—a large-scale crawl of the web.
• Removed low frequency names.
• Removed names that were least &ldquo;name-like&rdquo; (e.g. Will) algorithmically.
• Each concept is represented using a small set of words, designed for previous experiments in the psychology literature.</p><p>Result:
· flowers associate with pleasant, insects associate with unpleasant. $p < 10^{−7}$
· Men&rsquo;s names associate with career, women&rsquo;s names associate with family. $p < 10^{−3}$
· European American names associate with pleasant, African American names associate with unpleasant. $p < 10^{−8}$</p><p>这些结果的确真实地反映人类社会的现状。但大部分性别方面的偏见其实是反映了目前的社会分工，无所谓高低贵贱；人种的偏见倒是反映了历史问题对现在的影响，这种偏见是不符合道德的。人对于其他生物的偏见，虽然是没必要的，但人类的确倾向于喜爱行为"可爱&rdquo;，外形"美好"的生物，比如大熊猫就是比鳄鱼受欢迎。</p><p>偏见的存在不一定合理。哪些偏见是不合理的，才是人们更应该去思考和讨论的地方。</p><h3 id=debiasing-word-embeddings>Debiasing word embeddings<a hidden class=anchor aria-hidden=true href=#debiasing-word-embeddings>#</a></h3><p><a href=https://arxiv.org/abs/1607.06520>Bolukbasi. et. al., 2016. Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings</a>提供了一个思路:</p><ol><li>确认偏见的方向</li><li>中和抵消偏见: 对于非定性的词（如"医生"），通过投射来消除偏见</li><li>等价：让<code>father - mother</code>和<code>boy - girl</code>等距，让定性词间的距离只有性别的距离；或者让<code>doctor - woman</code>和<code>doctor - man</code>等距，消除非定性词的性别偏见。</li></ol><p>什么词需要抵消偏见: 训练一个线性分类器来确定词是非定性还是非定性的, 结果当然是大部分英语词都是非定性的.</p><p>If analogies reveal a gender dimension, use analogies on specific seed pairs to find it.
<img loading=lazy src=/images/Gender_subspace.png title="Selected words projected along two axes: x is a projection onto the difference between the embeddings of the words he and she, and y is a direction learned in the embedding that captures gender neutrality, with gender neutral words above the line and gender specific words below the line. In this figure, the words above the horizontal line would all be collapsed to the vertical line. image from: Bolukbasi. et. al., 2016. Man is to Computer Programmer as Woman is to Homemaker? Debiasing Word Embeddings">
y 轴下面的词属于定性词, 不需要中性化, 而y轴之上的词则需要进行中性化处理.</p><p>不同的偏见, 需要不同的 seed words; 一种偏见, 可以有多种 seed words 选择: 除了用"She-He"作为性别偏见的基准, 还有其他选择.</p><h2 id=编码器解码器-sequence-to-sequence-和注意力机制>编码器—解码器 Sequence-to-sequence 和注意力机制<a hidden class=anchor aria-hidden=true href=#编码器解码器-sequence-to-sequence-和注意力机制>#</a></h2><p>当输入输出都是不定长序列时, 比如机器翻译这种任务，需要使用 Sequence-to-sequence（seq2seq）或者 encoder-decoder 神经网络结构。这种结构可以通过一种方法叫注意力机制来显著提高性能。</p><h3 id=编码器解码器-sequence-to-sequenceseq2seq>编码器—解码器 Sequence-to-sequence（seq2seq）<a hidden class=anchor aria-hidden=true href=#编码器解码器-sequence-to-sequenceseq2seq>#</a></h3><p>编码器：所谓编码，就是把不定长的输入序列输入RNN，以得出某种定长的编码信息。
解码器：所谓解码，就是把编码器编码后的信息（一般取编码器的RNN最终时刻的隐含层变量）输入到解码器的RNN中，每个t时刻的输出既取决于之前时刻（t-1）的输出又取决于编码信息。等同于一个以解码信息作为条件概率生成目标语言句子的语言模型。</p><p>所以 seq2seq 本质是一个条件概率语言模型：语言模型是指解码器每次会预测下一个出现的单词，条件概率是指预测是基于编码后的源句子。</p><h3 id=注意力>注意力<a hidden class=anchor aria-hidden=true href=#注意力>#</a></h3><p>在传统的seq2seq模型中，解码器各个时刻都使用相同的编码信息，这就要求解码器把源输入序列的所有信息都解码并整合到最后时刻的隐含状态中，这个是很大的信息瓶颈。而人们知道，在实际任务中，比如机器翻译，目标句子的不同单词，一般只对应源句子的某一部分而已。如果能够让解码器在解码时，在不同时刻专注于源输入序列的不同部分，那么就可以突破这个瓶颈。</p><ol><li>对于解码器的每一时间步的隐含状态s<sub>t</sub>，可以衡量其与编码器的所有时间步隐含状态h<sub>0</sub>……e<sub>t</sub>的相似性(或score评分) <code>e = α(s, h)</code>，简单的评分方式是元素间相乘, <code>e = s*h</code>（<a href=https://arxiv.org/abs/1409.0473>Bahanau的论文</a>提供了更复杂的形式), 也可以参考<a href=https://nlp.stanford.edu/pubs/emnlp15_attn.pdf>论文Effective Approaches to Attention-based Neural Machine Translation</a>探讨的集中评分方式, 这篇论文提供了一种 Bilinear 形式的相似性评分法, 就是在s和h之间以点乘的形式插入一个交互矩阵 interaction matrix.</li><li>对得出的评分求加权平均<code>a = softmax(e)</code>, 得出的权值分布也称注意力权重</li><li>通过注意力权重把编码器隐含状态加权求和，得到注意力输出 <code>A = Σah</code></li><li>最后把注意力输出和对应时间步的解码器隐含状态s<sub>t</sub>拼接在一起 [A;s<sub>t</sub>]，作为解码器rnn的隐含层.</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/nlu/>NLU</a></li><li><a href=https://congchan.github.io/tags/inf-course-note/>Inf Course Note</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/inf-course-note-accelerated-natural-language-processing/><span class=title>« Prev</span><br><span>Inf Course Note - Accelerated Natural Language Processing</span>
</a><a class=next href=https://congchan.github.io/posts/inf-course-note-parallel-programming-language-and-systems/><span class=title>Next »</span><br><span>Inf Course Note - Parallel Programming Language and Systems</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Natural Language Understanding on x" href="https://x.com/intent/tweet/?text=Inf%20Course%20Note%20-%20Natural%20Language%20Understanding&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-natural-language-understanding%2f&amp;hashtags=NLU%2cInfCourseNote"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Natural Language Understanding on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-natural-language-understanding%2f&amp;title=Inf%20Course%20Note%20-%20Natural%20Language%20Understanding&amp;summary=Inf%20Course%20Note%20-%20Natural%20Language%20Understanding&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-natural-language-understanding%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Natural Language Understanding on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-natural-language-understanding%2f&title=Inf%20Course%20Note%20-%20Natural%20Language%20Understanding"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Natural Language Understanding on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-natural-language-understanding%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Natural Language Understanding on whatsapp" href="https://api.whatsapp.com/send?text=Inf%20Course%20Note%20-%20Natural%20Language%20Understanding%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-natural-language-understanding%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Natural Language Understanding on telegram" href="https://telegram.me/share/url?text=Inf%20Course%20Note%20-%20Natural%20Language%20Understanding&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-natural-language-understanding%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Natural Language Understanding on ycombinator" href="https://news.ycombinator.com/submitlink?t=Inf%20Course%20Note%20-%20Natural%20Language%20Understanding&u=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-natural-language-understanding%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>