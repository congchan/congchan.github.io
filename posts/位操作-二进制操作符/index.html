<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>位操作 - 二进制操作符 | Cong's Log</title><meta name=keywords content="Bitwise Operation,Software Engineer,Computer Science,Algorithms"><meta name=description content="在很多语言中，字符char类型是八位, 那么可能取值有256种(-128 ~ -1, 0 ~ 127). 但是用二进制表示为0000 0000 ~ 1111 1111, 无符号整数的全部位都表示数值，而有符号数的最高位是符号位（0表示正数，1表示负数），所以实际表达数值的只剩下n-1位。这样理论上char的取值应该是1111 1111 = -127到0111 1111 = 127. 而-128 = 1 1000 0000需要9位来表达, 所以char是如何仅仅通过八位表达-128?

首先, 因为计算机只能做加法, 所以减法操作要转化为加法, 尝试将符号位参与运算, 1-1就转化为1 + (-1), 用二进制表达为0000 0001 + 1000 0001 = -2, 很明显是错的. 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的. 这也就是为何计算机内部不使用原码表示一个数.
为了避免这种错误, 引入反码(正数的反码是其本身, 负数的反码是符号位不变, 其余位取反), 用-1的原码1000 0001的反码1111 1110来表达-1, 这样1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反, 转为原码1000 0000 = -0. 发现用反码计算减法, 结果的真值部分是正确的."><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/%E4%BD%8D%E6%93%8D%E4%BD%9C-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E7%AC%A6/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/%E4%BD%8D%E6%93%8D%E4%BD%9C-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E7%AC%A6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/%E4%BD%8D%E6%93%8D%E4%BD%9C-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E7%AC%A6/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="位操作 - 二进制操作符"><meta property="og:description" content="在很多语言中，字符char类型是八位, 那么可能取值有256种(-128 ~ -1, 0 ~ 127). 但是用二进制表示为0000 0000 ~ 1111 1111, 无符号整数的全部位都表示数值，而有符号数的最高位是符号位（0表示正数，1表示负数），所以实际表达数值的只剩下n-1位。这样理论上char的取值应该是1111 1111 = -127到0111 1111 = 127. 而-128 = 1 1000 0000需要9位来表达, 所以char是如何仅仅通过八位表达-128?
首先, 因为计算机只能做加法, 所以减法操作要转化为加法, 尝试将符号位参与运算, 1-1就转化为1 + (-1), 用二进制表达为0000 0001 + 1000 0001 = -2, 很明显是错的. 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的. 这也就是为何计算机内部不使用原码表示一个数.
为了避免这种错误, 引入反码(正数的反码是其本身, 负数的反码是符号位不变, 其余位取反), 用-1的原码1000 0001的反码1111 1110来表达-1, 这样1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反, 转为原码1000 0000 = -0. 发现用反码计算减法, 结果的真值部分是正确的."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-21T00:00:00+00:00"><meta property="article:modified_time" content="2017-08-21T00:00:00+00:00"><meta property="article:tag" content="Bitwise Operation"><meta property="article:tag" content="Software Engineer"><meta property="article:tag" content="Computer Science"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="位操作 - 二进制操作符"><meta name=twitter:description content="在很多语言中，字符char类型是八位, 那么可能取值有256种(-128 ~ -1, 0 ~ 127). 但是用二进制表示为0000 0000 ~ 1111 1111, 无符号整数的全部位都表示数值，而有符号数的最高位是符号位（0表示正数，1表示负数），所以实际表达数值的只剩下n-1位。这样理论上char的取值应该是1111 1111 = -127到0111 1111 = 127. 而-128 = 1 1000 0000需要9位来表达, 所以char是如何仅仅通过八位表达-128?

首先, 因为计算机只能做加法, 所以减法操作要转化为加法, 尝试将符号位参与运算, 1-1就转化为1 + (-1), 用二进制表达为0000 0001 + 1000 0001 = -2, 很明显是错的. 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的. 这也就是为何计算机内部不使用原码表示一个数.
为了避免这种错误, 引入反码(正数的反码是其本身, 负数的反码是符号位不变, 其余位取反), 用-1的原码1000 0001的反码1111 1110来表达-1, 这样1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反, 转为原码1000 0000 = -0. 发现用反码计算减法, 结果的真值部分是正确的."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"位操作 - 二进制操作符","item":"https://congchan.github.io/posts/%E4%BD%8D%E6%93%8D%E4%BD%9C-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E7%AC%A6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"位操作 - 二进制操作符","name":"位操作 - 二进制操作符","description":"在很多语言中，字符char类型是八位, 那么可能取值有256种(-128 ~ -1, 0 ~ 127). 但是用二进制表示为0000 0000 ~ 1111 1111, 无符号整数的全部位都表示数值，而有符号数的最高位是符号位（0表示正数，1表示负数），所以实际表达数值的只剩下n-1位。这样理论上char的取值应该是1111 1111 = -127到0111 1111 = 127. 而-128 = 1 1000 0000需要9位来表达, 所以char是如何仅仅通过八位表达-128?\n首先, 因为计算机只能做加法, 所以减法操作要转化为加法, 尝试将符号位参与运算, 1-1就转化为1 + (-1), 用二进制表达为0000 0001 + 1000 0001 = -2, 很明显是错的. 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的. 这也就是为何计算机内部不使用原码表示一个数.\n为了避免这种错误, 引入反码(正数的反码是其本身, 负数的反码是符号位不变, 其余位取反), 用-1的原码1000 0001的反码1111 1110来表达-1, 这样1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反, 转为原码1000 0000 = -0. 发现用反码计算减法, 结果的真值部分是正确的.\n","keywords":["Bitwise Operation","Software Engineer","Computer Science","Algorithms"],"articleBody":"在很多语言中，字符char类型是八位, 那么可能取值有256种(-128 ~ -1, 0 ~ 127). 但是用二进制表示为0000 0000 ~ 1111 1111, 无符号整数的全部位都表示数值，而有符号数的最高位是符号位（0表示正数，1表示负数），所以实际表达数值的只剩下n-1位。这样理论上char的取值应该是1111 1111 = -127到0111 1111 = 127. 而-128 = 1 1000 0000需要9位来表达, 所以char是如何仅仅通过八位表达-128?\n首先, 因为计算机只能做加法, 所以减法操作要转化为加法, 尝试将符号位参与运算, 1-1就转化为1 + (-1), 用二进制表达为0000 0001 + 1000 0001 = -2, 很明显是错的. 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的. 这也就是为何计算机内部不使用原码表示一个数.\n为了避免这种错误, 引入反码(正数的反码是其本身, 负数的反码是符号位不变, 其余位取反), 用-1的原码1000 0001的反码1111 1110来表达-1, 这样1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反, 转为原码1000 0000 = -0. 发现用反码计算减法, 结果的真值部分是正确的.\n二进制补码 为了彻底解决负数表达中的-0 = 0, 1000 0000 = 0000 0000问题, 引入补码(正数的补码是其本身，负数的补码为其反码加1). 补码是计算机中最常用的有符号数的表达形式。补码定义为最高位权重为负的二进制码。 $$ B2T_4(0001) = -0 + 0 + 0 + 1 = 1 $$ $$ B2T_4(1111) = -8 + 4 + 2 + 1 = -1 $$ $$ B2T_4(0101) = -0 + 4 + 0 + 1 = 5 $$ $$ B2T_4(1011) = -8 + 0 + 2 + 1 = -5 $$0 1 1 1 1 1 1 1 = 127 0 0 0 0 0 0 1 0 = 2 0 0 0 0 0 0 0 1 = 1 0 0 0 0 0 0 0 0 = 0 1 1 1 1 1 1 1 1 = −128 + 127 = -1 1 1 1 1 1 1 1 0 = −2 1 0 0 0 0 0 0 1 = −128 + 1 = -127 1 0 0 0 0 0 0 0 = −128\n这样减法操作转化为加补码1+(-1) = [0000 0001]补 + [1111 1111]补 = [1 0000 0000]补, char定义为8位, 故第九位舍弃, 得到[0000 0000]补, 转换为原码为[1000 0000]原 = -0.\n所以, -0 = [1000 0000]原的补码为1 0000 0000 = 0000 0000 = 0, 0 = 0000 0000的补码为1000 0000 = -0. 鉴于0的非负非正特性, 仅仅使用0000 0000来表达0和其补码就足够了. 这样1000 0000就可以挪作他用,用来表达-128. 之所以用来表达-128是有其合理性的. 因为-1 + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补, -128 = 1 1000 0000的补码也刚好是1 1000 0000, 放进char的八位空间中, 需要把第九位截断, 得到的刚好是1000 0000.\n可以推理出补码的取值范围，最小值为[10...0], $TMin_w = -2^{w-1}$, 最大值为[01...1], $TMax_w = 2^{w-1} - 1$. 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 同理16位short中-32768~32767，-32768原码为17位，丢弃最高位剩下的16和-0的原码相同。\n可以观察到, abs(TMin) = TMax + 1 = TMin, 也就是最小值的绝对值还是最小值: -(INT_MIN) = - 0[1000 0000]补 = 1[1000 0000]补 = [1000 0000]补 = -128 = [0111 1111]补 + 1.\n二进制补码运算是加法逆运算。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成各种有号数加法及减法。\nBitwise operators Bitwise NOT - ~, or complement: 0 become 1, 1 become 0.\nThe bitwise complement is equal to the two’s complement of the value minus one. ~x = -x − 1\n因为~x + x = b[1...1] = -1, 通过~x + 1得到一个数的负数, 得到的负数也就是该二进制数字的补码. 比如0 = b[0000], ~0 = b[1111],b[1111] + b[0001] = b[0000] = 0, 又比如TMin = b[1000], ~TMin = b[0111], ~TMin + 1 = b[0111] + b[0001] = b[1000] = TMin, 也就是-TMin = TMin.\nBitwise AND - \u0026: 1 \u0026 1 = 1, 1 \u0026 0 = 0, 0 \u0026 0 = 0.\nperforms the logical AND operation on each pair of the corresponding bits, which is equivalent to multiplying them. Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1 (1 × 1 = 1); otherwise, the result is 0 (1 × 0 = 0 and 0 × 0 = 0).\nBitwise OR - |: 1 | 1 = 1, 1 | 0 = 1, 0 | 0 = 0\ntakes two bit patterns of equal length and performs the logical inclusive OR operation on each pair of corresponding bits. The result in each position is 0 if both bits are 0, while otherwise the result is 1.\nBitwise XOR - ^: 1 ^ 1 = 0, 1 ^ 0 = 1, 0 ^ 0 = 0\ntakes two bit patterns of equal length and performs the logical exclusive OR operation on each pair of corresponding bits. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1. In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same.\nBit shifts Java中有三种移位运算符.\n\u003c\u003c: 左移运算符，num \u003c\u003c n, 把num的二进制左移n位, 右边的空位用0补上, 每一次移位相当于num * 2(除非overflow) \u003e\u003e: 右移运算符，num \u003e\u003e n, 右移n, 每次移位相当于num / 2 如果是无符号数值，也就是\u003e\u003e\u003e，左边空缺用0补上, 如果是有符号数值，则用数字的符号位填补最左边的n位 如果是正数, 则右移后在最左边补n个0 如果原先是负数, 则右移后在最左边补n个1 ","wordCount":"672","inLanguage":"en","datePublished":"2017-08-21T00:00:00Z","dateModified":"2017-08-21T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/%E4%BD%8D%E6%93%8D%E4%BD%9C-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%E7%AC%A6/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">位操作 - 二进制操作符</h1><div class=post-meta><span title='2017-08-21 00:00:00 +0000 UTC'>2017-08-21</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/bits-operations-01.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e8%a1%a5%e7%a0%81 aria-label=二进制补码>二进制补码</a></li><li><a href=#bitwise-operators aria-label="Bitwise operators">Bitwise operators</a></li><li><a href=#bit-shifts aria-label="Bit shifts">Bit shifts</a></li></ul></div></details></div><div class=post-content><p>在很多语言中，字符<code>char</code>类型是八位, 那么可能取值有256种(<code>-128 ~ -1, 0 ~ 127</code>). 但是用二进制表示为<code>0000 0000 ~ 1111 1111</code>, 无符号整数的全部位都表示数值，而有符号数的最高位是符号位（0表示正数，1表示负数），所以实际表达数值的只剩下<code>n-1</code>位。这样理论上<code>char</code>的取值应该是<code>1111 1111 = -127</code>到<code>0111 1111 = 127</code>. 而<code>-128 = 1 1000 0000</code>需要9位来表达, 所以<code>char</code>是如何仅仅通过八位表达<code>-128</code>?</p><p>首先, 因为计算机只能做加法, 所以减法操作要转化为加法, 尝试将符号位参与运算, <code>1-1</code>就转化为<code>1 + (-1)</code>, 用二进制表达为<code>0000 0001 + 1000 0001 = -2</code>, 很明显是错的. 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的. 这也就是为何计算机内部不使用原码表示一个数.</p><p>为了避免这种错误, 引入<strong>反码</strong>(正数的反码是其本身, 负数的反码是符号位不变, 其余位取反), 用<code>-1</code>的原码<code>1000 0001</code>的反码<code>1111 1110</code>来表达<code>-1</code>, 这样<code>1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反</code>, 转为原码<code>1000 0000 = -0</code>. 发现用反码计算减法, 结果的真值部分是正确的.</p><h2 id=二进制补码>二进制补码<a hidden class=anchor aria-hidden=true href=#二进制补码>#</a></h2><p>为了彻底解决负数表达中的<code>-0 = 0</code>, <code>1000 0000 = 0000 0000</code>问题, 引入<strong>补码</strong>(正数的补码是其本身，负数的补码为其反码加1). 补码是计算机中最常用的有符号数的表达形式。补码定义为最高位权重为负的二进制码。<img loading=lazy src="/images/two's_complement.png" title="image from: csapp"></p>$$ B2T_4(0001) = -0 + 0 + 0 + 1 = 1 $$<p></p>$$ B2T_4(1111) = -8 + 4 + 2 + 1 = -1 $$<p></p>$$ B2T_4(0101) = -0 + 4 + 0 + 1 = 5 $$<p></p>$$ B2T_4(1011) = -8 + 0 + 2 + 1 = -5 $$<p>0 1 1 1 1 1 1 1 = 127
0 0 0 0 0 0 1 0 = 2
0 0 0 0 0 0 0 1 = 1
0 0 0 0 0 0 0 0 = 0
1 1 1 1 1 1 1 1 = −128 + 127 = -1
1 1 1 1 1 1 1 0 = −2
1 0 0 0 0 0 0 1 = −128 + 1 = -127
1 0 0 0 0 0 0 0 = −128</p><p>这样减法操作转化为加补码<code>1+(-1) = [0000 0001]补 + [1111 1111]补 = [1 0000 0000]补</code>, <code>char</code>定义为8位, 故第九位舍弃, 得到<code>[0000 0000]补</code>, 转换为原码为<code>[1000 0000]原 = -0</code>.</p><p>所以, <code>-0 = [1000 0000]原</code>的补码为<code>1 0000 0000 = 0000 0000 = 0</code>, <code>0 = 0000 0000</code>的补码为<code>1000 0000 = -0</code>. 鉴于<code>0</code>的非负非正特性, 仅仅使用<code>0000 0000</code>来表达<code>0</code>和其补码就足够了. 这样<code>1000 0000</code>就可以挪作他用,用来表达<code>-128</code>. 之所以用来表达<code>-128</code>是有其合理性的. 因为<code>-1 + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</code>, <code>-128 = 1 1000 0000</code>的补码也刚好是<code>1 1000 0000</code>, 放进<code>char</code>的八位空间中, 需要把第九位截断, 得到的刚好是<code>1000 0000</code>.</p><p>可以推理出补码的取值范围，最小值为<code>[10...0]</code>, $TMin_w = -2^{w-1}$, 最大值为<code>[01...1]</code>, $TMax_w = 2^{w-1} - 1$. 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为<code>[-127, +127]</code>, 而使用补码表示的范围为<code>[-128, 127]</code>. 同理16位<code>short</code>中<code>-32768~32767</code>，<code>-32768</code>原码为17位，丢弃最高位剩下的16和<code>-0</code>的原码相同。</p><p>可以观察到, <code>abs(TMin) = TMax + 1 = TMin</code>, 也就是最小值的绝对值还是最小值: <code>-(INT_MIN) = - 0[1000 0000]补 = 1[1000 0000]补 = [1000 0000]补 = -128 = [0111 1111]补 + 1</code>.</p><blockquote><p>二进制补码运算是加法逆运算。补码系统的最大优点是可以在加法或减法处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成各种有号数加法及减法。</p></blockquote><h2 id=bitwise-operators>Bitwise operators<a hidden class=anchor aria-hidden=true href=#bitwise-operators>#</a></h2><p>Bitwise NOT - <code>~</code>, or complement: <code>0</code> become <code>1</code>, <code>1</code> become <code>0</code>.</p><blockquote><p>The bitwise complement is equal to the <strong>two&rsquo;s complement</strong> of the value minus one. <code>~x = -x − 1</code></p></blockquote><p>因为<code>~x + x = b[1...1] = -1</code>, 通过<code>~x + 1</code>得到一个数的负数, 得到的负数也就是该二进制数字的补码. 比如<code>0 = b[0000]</code>, <code>~0 = b[1111]</code>,<code>b[1111] + b[0001] = b[0000] = 0</code>, 又比如<code>TMin = b[1000]</code>, <code>~TMin = b[0111]</code>, <code>~TMin + 1 = b[0111] + b[0001] = b[1000] = TMin</code>, 也就是<code>-TMin = TMin</code>.</p><p>Bitwise AND - <code>&</code>: <code>1 & 1 = 1</code>, <code>1 & 0 = 0</code>, <code>0 & 0 = 0</code>.</p><blockquote><p>performs the logical AND operation on each pair of the corresponding bits, which is equivalent to multiplying them. Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1 (1 × 1 = 1); otherwise, the result is 0 (1 × 0 = 0 and 0 × 0 = 0).</p></blockquote><p>Bitwise OR - <code>|</code>: <code>1 | 1 = 1</code>, <code>1 | 0 = 1</code>, <code>0 | 0 = 0</code></p><blockquote><p>takes two bit patterns of equal length and performs the logical inclusive OR operation on each pair of corresponding bits. The result in each position is 0 if both bits are 0, while otherwise the result is 1.</p></blockquote><p>Bitwise XOR - <code>^</code>: <code>1 ^ 1 = 0</code>, <code>1 ^ 0 = 1</code>, <code>0 ^ 0 = 0</code></p><blockquote><p>takes two bit patterns of equal length and performs the logical exclusive OR operation on each pair of corresponding bits. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1. In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same.</p></blockquote><h2 id=bit-shifts>Bit shifts<a hidden class=anchor aria-hidden=true href=#bit-shifts>#</a></h2><p>Java中有三种<a href=https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html>移位运算符</a>.</p><ul><li><code>&lt;&lt;</code>: 左移运算符，<code>num &lt;&lt; n</code>, 把<code>num</code>的二进制左移<code>n</code>位, 右边的空位用<code>0</code>补上, 每一次移位相当于<code>num * 2</code>(除非overflow)</li><li><code>>></code>: 右移运算符，<code>num >> n</code>, 右移<code>n</code>, 每次移位相当于<code>num / 2</code><ul><li>如果是无符号数值，也就是<code>>>></code>，左边空缺用<code>0</code>补上,</li><li>如果是有符号数值，则用数字的符号位填补最左边的<code>n</code>位<ul><li>如果是正数, 则右移后在最左边补<code>n</code>个<code>0</code></li><li>如果原先是负数, 则右移后在最左边补<code>n</code>个<code>1</code></li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/bitwise-operation/>Bitwise Operation</a></li><li><a href=https://congchan.github.io/tags/software-engineer/>Software Engineer</a></li><li><a href=https://congchan.github.io/tags/computer-science/>Computer Science</a></li><li><a href=https://congchan.github.io/tags/algorithms/>Algorithms</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/%E4%BD%8D%E6%93%8D%E4%BD%9C-%E5%9F%BA%E7%A1%80%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/><span class=title>« Prev</span><br><span>位操作 - 基础的位运算</span>
</a><a class=next href=https://congchan.github.io/posts/algorithms-03-memory-%E5%86%85%E5%AD%98/><span class=title>Next »</span><br><span>Algorithms 03 - Memory 内存</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 位操作 - 二进制操作符 on x" href="https://x.com/intent/tweet/?text=%e4%bd%8d%e6%93%8d%e4%bd%9c%20-%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%93%8d%e4%bd%9c%e7%ac%a6&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BD%258D%25E6%2593%258D%25E4%25BD%259C-%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%2f&amp;hashtags=BitwiseOperation%2cSoftwareEngineer%2cComputerScience%2cAlgorithms"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 位操作 - 二进制操作符 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BD%258D%25E6%2593%258D%25E4%25BD%259C-%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%2f&amp;title=%e4%bd%8d%e6%93%8d%e4%bd%9c%20-%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%93%8d%e4%bd%9c%e7%ac%a6&amp;summary=%e4%bd%8d%e6%93%8d%e4%bd%9c%20-%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%93%8d%e4%bd%9c%e7%ac%a6&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BD%258D%25E6%2593%258D%25E4%25BD%259C-%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 位操作 - 二进制操作符 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BD%258D%25E6%2593%258D%25E4%25BD%259C-%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%2f&title=%e4%bd%8d%e6%93%8d%e4%bd%9c%20-%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%93%8d%e4%bd%9c%e7%ac%a6"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 位操作 - 二进制操作符 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BD%258D%25E6%2593%258D%25E4%25BD%259C-%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 位操作 - 二进制操作符 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%bd%8d%e6%93%8d%e4%bd%9c%20-%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%93%8d%e4%bd%9c%e7%ac%a6%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BD%258D%25E6%2593%258D%25E4%25BD%259C-%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 位操作 - 二进制操作符 on telegram" href="https://telegram.me/share/url?text=%e4%bd%8d%e6%93%8d%e4%bd%9c%20-%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%93%8d%e4%bd%9c%e7%ac%a6&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BD%258D%25E6%2593%258D%25E4%25BD%259C-%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 位操作 - 二进制操作符 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%bd%8d%e6%93%8d%e4%bd%9c%20-%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%93%8d%e4%bd%9c%e7%ac%a6&u=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BD%258D%25E6%2593%258D%25E4%25BD%259C-%25E4%25BA%258C%25E8%25BF%259B%25E5%2588%25B6%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>