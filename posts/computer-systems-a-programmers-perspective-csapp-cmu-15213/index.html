<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213 | Cong's Log</title><meta name=keywords content="csapp,C"><meta name=description content="
CSAPP 非常巧妙的把程序设计及优化、数字电路基础、指令集体系、汇编语言、存储器体系结构、链接与装载、进程、虚存等来自不同学科的核心知识点和在一起，并以程序员的视角呈现; 告诉我们作为一个程序员，究竟需要对计算机的硬件了解到什么程度？
本笔记是 CMU CSAPP 的学习笔记, 使用 CMU 15-213, UW CSE351 的课程视频, lab, 作业, project 辅助练习.

Computer Systems: A Programmer&rsquo;s Perspective (csapp), 豆瓣-深入理解计算机系统
卡内基梅隆大学 CMU 15-213 Introduction to Computer Systems (ICS)
华盛顿大学 UW CSE351: The Hardware/Software Interface


信息的表达与操作
Information is Bits + Context. Study systems by tracing the lifetime of the hello program, from the time it is created by a programmer, until it runs on a system, prints its simple message, and terminates."><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/computer-systems-a-programmers-perspective-csapp-cmu-15213/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/computer-systems-a-programmers-perspective-csapp-cmu-15213/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/computer-systems-a-programmers-perspective-csapp-cmu-15213/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213"><meta property="og:description" content=" CSAPP 非常巧妙的把程序设计及优化、数字电路基础、指令集体系、汇编语言、存储器体系结构、链接与装载、进程、虚存等来自不同学科的核心知识点和在一起，并以程序员的视角呈现; 告诉我们作为一个程序员，究竟需要对计算机的硬件了解到什么程度？
本笔记是 CMU CSAPP 的学习笔记, 使用 CMU 15-213, UW CSE351 的课程视频, lab, 作业, project 辅助练习.
Computer Systems: A Programmer’s Perspective (csapp), 豆瓣-深入理解计算机系统 卡内基梅隆大学 CMU 15-213 Introduction to Computer Systems (ICS) 华盛顿大学 UW CSE351: The Hardware/Software Interface 信息的表达与操作 Information is Bits + Context. Study systems by tracing the lifetime of the hello program, from the time it is created by a programmer, until it runs on a system, prints its simple message, and terminates."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-29T00:00:00+00:00"><meta property="article:modified_time" content="2018-01-29T00:00:00+00:00"><meta property="article:tag" content="Csapp"><meta property="article:tag" content="C"><meta name=twitter:card content="summary"><meta name=twitter:title content="Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213"><meta name=twitter:description content="
CSAPP 非常巧妙的把程序设计及优化、数字电路基础、指令集体系、汇编语言、存储器体系结构、链接与装载、进程、虚存等来自不同学科的核心知识点和在一起，并以程序员的视角呈现; 告诉我们作为一个程序员，究竟需要对计算机的硬件了解到什么程度？
本笔记是 CMU CSAPP 的学习笔记, 使用 CMU 15-213, UW CSE351 的课程视频, lab, 作业, project 辅助练习.

Computer Systems: A Programmer&rsquo;s Perspective (csapp), 豆瓣-深入理解计算机系统
卡内基梅隆大学 CMU 15-213 Introduction to Computer Systems (ICS)
华盛顿大学 UW CSE351: The Hardware/Software Interface


信息的表达与操作
Information is Bits + Context. Study systems by tracing the lifetime of the hello program, from the time it is created by a programmer, until it runs on a system, prints its simple message, and terminates."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213","item":"https://congchan.github.io/posts/computer-systems-a-programmers-perspective-csapp-cmu-15213/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213","name":"Computer Systems - A Programmer\u0027s Perspective (CSAPP) - CMU 15213","description":" CSAPP 非常巧妙的把程序设计及优化、数字电路基础、指令集体系、汇编语言、存储器体系结构、链接与装载、进程、虚存等来自不同学科的核心知识点和在一起，并以程序员的视角呈现; 告诉我们作为一个程序员，究竟需要对计算机的硬件了解到什么程度？\n本笔记是 CMU CSAPP 的学习笔记, 使用 CMU 15-213, UW CSE351 的课程视频, lab, 作业, project 辅助练习.\nComputer Systems: A Programmer\u0026rsquo;s Perspective (csapp), 豆瓣-深入理解计算机系统 卡内基梅隆大学 CMU 15-213 Introduction to Computer Systems (ICS) 华盛顿大学 UW CSE351: The Hardware/Software Interface 信息的表达与操作 Information is Bits + Context. Study systems by tracing the lifetime of the hello program, from the time it is created by a programmer, until it runs on a system, prints its simple message, and terminates.\n","keywords":["csapp","C"],"articleBody":" CSAPP 非常巧妙的把程序设计及优化、数字电路基础、指令集体系、汇编语言、存储器体系结构、链接与装载、进程、虚存等来自不同学科的核心知识点和在一起，并以程序员的视角呈现; 告诉我们作为一个程序员，究竟需要对计算机的硬件了解到什么程度？\n本笔记是 CMU CSAPP 的学习笔记, 使用 CMU 15-213, UW CSE351 的课程视频, lab, 作业, project 辅助练习.\nComputer Systems: A Programmer’s Perspective (csapp), 豆瓣-深入理解计算机系统 卡内基梅隆大学 CMU 15-213 Introduction to Computer Systems (ICS) 华盛顿大学 UW CSE351: The Hardware/Software Interface 信息的表达与操作 Information is Bits + Context. Study systems by tracing the lifetime of the hello program, from the time it is created by a programmer, until it runs on a system, prints its simple message, and terminates.\n#include int main() { printf(\"hello, world\\n\"); } The source program is a sequence of bits, each with a value of 0 or 1, organized in 8-bit chunks(bytes). Each byte represents some text character in the program.\nAll information in a system — including disk files, programs stored in memory, user data stored in memory, and data transferred across a network—is represented as a bunch of bits.\n整数加减乘位移 Most machines shift and add faster than multiply, compiler translate multiply to shift and add automatically.\nPower-of-2 Multiply with Shift: u \u003c\u003c k gives $u \\times 2^k$, u * 24 = u * 32 - u * 8 = (u \u003c\u003c 5) - (u \u003c\u003c 3)\nSigned Power-of-2 Divide with Shift: x \u003e\u003e k using arithmetic shift(补1) gives $x / 2^k$, when u \u003c 0, say y = -15213 = b[11000100 10010011], y \u003e\u003e 1 = b[11100010 01001001] = -7607, the rounding is downward, which is not the same as the convention toward zero.\nCorrect Power-of-2 Divide by adding bias: $x / 2^k$, computed as $(x + 2^k - 1) / 2^k$, in C (x\u003c0 ? x+(1\u003c\u003e k\n浮点数 IEEE floating-point standard represents a number in a form $V = (−1)^s × M × 2^E$\nsign s: determines whether the number is negative (s = 1) or positive (s = 0) exponent E weights the value by a (possibly negative) power of 2, encoded by the k-bit exponent field exp. significand M: a fractional binary number that ranges either [1, 2 − ϵ) or [0, 1 − ϵ), encoded by the n-bit fraction field frac Case 1: Normalized Values E is interpreted as representing a signed integer in biased form, E = e − Bias, where e is the unsigned number, Bias equals to $2^{k−1}−1$. The significand is defined to be M = 1 + f, where f is the fraction field, 0 ≤ f \u003c 1, M = $1.f_{n−1}f_{n−2}...f_0$\nCase 2: Denormalized Values Exponent field is all zeros, the exponent value is E = 1 − Bias, and the significand value is M = f, M = $0.f_{n−1}f_{n−2}...f_0$ Denormalized numbers serve two purposes.\nprovide a way to represent numeric value 0, +0.0, bit pattern all zeros, s = M = f = 0 −0.0, bit pattern all zeros except s = 1. represent numbers that are very close to 0.0: possible numeric values are spaced evenly near 0.0 Case 3: Special Values Exponent field is all ones.\nWhen the fraction field is all zeros, the resulting values represent infinity, either +∞ when s = 0, or −∞ when s = 1. Infinity can represent results that overflow When the fraction field is nonzero, the resulting value is NaN Programs are traslated by other programs into different forms The hello program begins as a high-level C program because it can be read and understood by human beings in that form. However, in order to run hello.c on the system, the individual C statements must be translated by other programs into a sequence of low-level machine-language instructions.\nThese instructions are then packaged in a form called an executable object program and stored as a binary disk file. Object programs are also referred to as executable object files.\nThe programs that perform the four phases (preprocessor, compiler, assembler, and linker) are known collectively as the compilation system.\nPreprocessing phase.The preprocessor (cpp) modifies the original C program according to directives that begin with the # character. Compilation phase. The compiler (cc1) translates the text file hello.i into the text file hello.s, which contains an assembly-language program. Assembly language is useful because it provides a common output language for different compilers for different high-level languages. Assembly phase. Next, the assembler (as) translates hello.s into machinelanguage instructions, packages them in a form known as a relocatable object program, and stores the result in the object file hello.o. The hello.o file is a binary file whose bytes encode machine language instructions rather than characters. Linking phase. The printf function resides in a separate precompiled object file called printf.o, which must somehow be merged with our hello.o program. The linker (ld) handles this merging. 大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区）, Heap（堆）, Program Counter Register（程序计数器）, VM Stack（虚拟机栈/JAVA方法栈）, Native Method Stack（ 本地方法栈 ），其中Method Area和Heap是线程共享的，VM Stack，Native Method Stack和Program Counter Register是非线程共享的。\n程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的 虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的 原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的 方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息 一个一般性的 Java 程序工作过程：\n一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。 程序开始运行后，开始涉及各内存区域： JVM初始运行的时候都会分配好 Method Area（方法区）和Heap（堆）， 而JVM每遇到一个线程，就为其分配一个Program Counter Register（程序计数器）, VM Stack（虚拟机栈）和Native Method Stack（本地方法栈），当线程终止时，三者所占用的内存空间也会被释放掉。 这也是为什么把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。\nProcessors read and interpret instructions stored in memory The hello.c source program has been translated by the compilation system into an executable object file called hello that is stored on disk, to run the executable file on Unix:\nunix\u003e ./hello hello, world unix\u003e The shell is a command-line interpreter that prints a prompt, waits for you to type a command line, and then performs the command.\nHardware organization of a systems Hardware organization of a typical system.\nBuses Electrical conduits that carry bytes of information back and forth between the components. Buses are typically designed to transfer fixed-sized chunks of bytes known as words. USB: Universal Serial bus.\nInput/output (I/O) devices The system’s connection to the external world. Each I/O deviceisconnected to the I/O bus by either a controller or an adapter：\nControllers are chip sets in the device itself or on the system’s main printed circuit board (often called the motherboard). An adapter is a card that plugs into a slot on the motherboard. Main Memory A temporary storage device that holds both a program and the data it manipulates while the processor is executing the program.\nPhysically, main memory consists of a collection of dynamic random access memory (DRAM) chips. Logically, memory is organized as a linear array of bytes, each with its own unique address (array index) starting at zero Processor: Central Processing Unit (CPU) PC: Program counter, a word-sized storage device (or register) at CPU core. At any point in time, the PC points at (contains the address of) some machine-language instruction in main memory. Register: a quickly accessible location available to CPU, Register file: an array of registers, each with its own unique name. Arithmetic/logic unit: ALU computes new data and address values. A processor repeatedly executes the instruction pointed at by the program counter and updates the program counter to point to the next instruction. The processor reads the instruction from memory pointed at by the PC, interprets the bits in the instruction, performs some simple operation dictated by the instruction, and then updates the PC to point to the next instruction.\nCPU operations examples Load: Copy a byte or a word from main memory into a register, overwriting the previous contents of the register.\nStore(write): Copy a byte or a word from a register to a location in main memory, overwriting the previous contents of that location.\nOperate: Copy the contents of two registers to the ALU, perform an arithmetic operation on the two words, and store the result in a register, overwriting the previous contents of that register.\nJump: Extract a word from the instruction itself and copy that word into the program counter (PC), overwriting the previous value of the PC.\nBranch greater than (BGT): compares two registers and decides whether to branch (target would be the address to branch to), i.e. it is implementing the “if” decision.\nRunning a programs Initially, the shell program is waiting for user types a command. As we type the characters “./hello” at the keyboard, the shell program reads each one into a register, and then stores it in memory. When we hit the enter key on the keyboard, the shell knows that we have finished typing the command. The shell then loads the executable hello file by executing a sequence of instructions that copies the code and data in the hello object file from disk to main memory. The data include the string of characters “hello, world\\n” that will eventually be printed out. Using a technique known as direct memory access (DMA), the data travels directly from disk to main memory, without passing through the processor. Once the code and data in the hello object file are loaded into memory, the processor begins executing the machine-language instructions in the hello program’s main routine. These instructions copy the bytes in the hello, world\\n string from memory to the register file, and from there to the display device, where they are displayed on the screen. Caches An important lesson from this simple example is that a system spends a lot of time moving information from one place to another. From a programmer’s perspective, much of this copying is overhead that slows down the “real work” of the program. Because of physical laws, larger storage devices are slower than smaller storage devices. Speed that processor read from: register \u003e memory \u003e disk.\nIt is easier and cheaper to make processors run faster than it is to make main memory run faster. To deal with the processor-memory gap, system designers include smaller faster storage devices called cache memories (or simply caches) that serve as temporary staging areas for information that the processor is likely to need in the near future.\nThe L1 and L2 caches are implemented with a hardware technology known as static random access memory (SRAM). Newer and more powerful systems even have three levels of cache: L1, L2, and L3.\nBy setting up caches to hold data that is likely to be accessed often, we can perform most memory operations using the fast caches.\nStorage Devices Form a Hierarchy Operating system The operating system has two primary purposes: (1) to protect the hardware from misuse by runaway applications, and (2) to provide applications with simple and uniform mechanisms for manipulating complicated and often wildly different low-level hardware devices.\nThink of the operating system as a layer of software interposed between the application program and the hardware, with fundamental abstractions: processes, virtual memory, and files. Process进程 A process is the operating system’s abstraction for a running program. Multiple processes can run concurrently on the same system by having the processor switch (context switching) among them, and each process appears to have exclusive use of the hardware.\nThe os keeps track of all the state information that the process needs in order to run. This state, i.e. the context, includes information such as the current values of the PC, the register file, and the contents of main memory.\nWhen the operating system decides to transfer control from the current process to some new process, it performs a context switch by saving the context of the current process, restoring the context of the new process, and then passing control to the new process. The new process picks up exactly where it left off. Virtual Memory Virtual memory is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its virtual address space.\nIn Linux, the topmost region of the address space is reserved for code and data in the operating system that is common to all processes. The lower region of the address space holds the code and data defined by the user’s process. Starting with the lowest addresses and working our way up:\nProgram code and data: Fixed in size once the process begins running. The code and data areas are initialized directly from the contents of an executable object file, in our case the hello executable. Run-time heap: expands and contracts dynamically at run time as a result of calls to C standard library routines such as malloc and free. Shared libraries: holds the code and data for shared libraries such as the C standard library and the math library. User stack: the compiler uses to implement function calls. Each time we call a function, the stack grows. Each time we return from a function, it contracts. Kernel virtual memory: The kernel is the part of the operating system that is always resident in memory. Application programs are not allowed to read or write the contents of the top region of the address space (which is reserved for the kernel) or to directly call functions defined in the kernel code. Thread线程 In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system.\nIn most cases a thread is a component of a process. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources.\nThreads are an increasingly important programming model because of the requirement for concurrency in network servers, because it is easier to share data between multiple threads than between multiple processes, and because threads are typically more efficient than processes.\nFiles A file is a sequence of bytes. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as Unix I/O.\nConcurrency and Parallelism Concurrency: general concept of a system with multiple, simultaneous activities. Parallelism: the use of concurrency to make a system run faster.\nParallelism could be achieved in different levels of abstraction in computer system. There are three common levels (from the highest to the lowest level in the system hierarchy):\nThread-Level Concurrency Building on the process abstraction, we are able to devise systems where multiple programs execute at the same time, leading to concurrency. With threads, we can even have multiple control flows executing within a single process.\nWhen we construct a system consisting of multiple processors all under the control of a single operating system kernel, we have a multiprocessor system\nMulti-core processors: Several CPUs (referred to as “cores”) integrated onto a single integrated-circuit chip.\nHyperthreading: Sometimes called simultaneous multi-threading, is a technique that allows a single CPU to execute multiple flows of control.\ninstruction-level parallelism At a much lower level of abstraction, modern processors can execute multiple instructions at one time.\nSingle-Instruction, Multiple-Data (SIMD) Parallelism At the lowest level, special hardware that allows a single instruction to cause multiple operations to be performed in parallel.\nMemory, Data, \u0026 Addressing 十进制，2进制，16进制:\nA single byte consists of 8 bits. 二进制 value ranges from 000000002 to 111111112, 十进制 value ranges from 010 to 25510 二进制表示法过于冗长，而使用十进制表示法，与bits进行模式转换非常繁琐。 十六进制，hexadecimal numbers: Hexadecimal (or simply “hex”) uses digits ‘0’ through ‘9’ along with characters ‘A’ through ‘F’ to represent 16 possible values. Values range from 0016 to FF16. 内存：\nA machine-level program views memory as a very large array of bytes, referred to as virtual memory. Every byte of memory is identified by a unique number, known as its address. The set of all possible addresses is known as the virtual address space - 进程可用的虚拟地址范围称为该进程的“虚拟地址空间”。 这个虚拟地址空间只是一个呈现给机器级程序的虚拟概念。实际的实现需要用到随机访问存储器（RAM），磁盘存储，特殊的硬件和操作系统软件的组合来构建相对于程序而言的单片字节数组。\nAddress and Pointers 地址是内存的位置，指针是一种包含地址的数据对象。\nByte ordering: Endianness\nlittle endian - where the least significant byte comes first, followed by most Intel-compatible machines. big endian - where the most significant byte comes first, followed by most machines from IBM and Sun Microsystems Many recent microprocessors are bi-endian, meaning that they can be configured to operate as either little- or big-endian machines. Integer and floating point numbers 把多个bits组合起来，通过解码，可以表达有限集合内的所有元素。比如二进制数字系统可以表示正整数。\nThree most important representations of numbers.\nUnsigned encodings：based on traditional binary notation, representing numbers greater than or equal to 0. Two’s-complement encodings: the most common way to represent signed integers, that is, numbers that may be either positive or negative. Floating-point encodings: base-two version of scientific notation for representing real numbers. C Methods Naming data types with typedef: C的typedef声明用于给数据类型命名。这对提高代码可读性有很大的帮助，因为深层嵌套类型声明可能难以解读。 typedef int *int_pointer; int_pointer ip; 等同于int *ip; Formatted printing with printf(fprintf and sprintf): provides a way to print information with considerable control over the formatting details. The first argument is a format string. Each character sequence starting with ‘%’ indicates how to format the next argument. %d - 输出十进制整数, %f - 浮点数, %c - 字符 while any remaining arguments are values to be printed. sizeof(T) returns the number of bytes required to store an object of type T void *malloc(size_t size)分配请求的内存(size in bytes)并返回一个指向它的指针(如果请求失败，则返回NULL)。 Addresses and pointer in C 指针是C的核心功能，可以引用数据结构元素（包括数组）。就像变量一样，指针有两个组成部分：值和类型。该值指示某个对象的位置，而其类型指示该位置处存储什么类型的对象（例如，整数或浮点数）。\n\u0026 - “address of\", return a pointer; Variable declarations： int x, find location in memory in which to store integer. Pointer declarations use *: int *pointer, declares a variable pointer that is a pointer pointing to an object of type integer. Assignment to a pointer: pointer = \u0026x, assigns pointer to point to the address where x is stored. To use the value pointed to by a pointer, use *: if pointer = \u0026x, then x = *pointer +1 is the same as x = x + 1 假如x是一个对象, 那么*(\u0026x)=*\u0026x = x Pointers and arrays C通过数组将标量数据聚合为更大的数据类型。In C, we can dereference a pointer with array notation, and we can reference array elements with pointer notation. C有一个不常见的特性, 就是我们可以生成指向数组内的元素的指针，并使用这些指针来执行算术运算。\nT A[N]; 首先，它在内存中分配一个L*N大小的连续区域, 其中L是数据类型T的大小（以bytes为单位）. 数组的元素可以使用 0 ~ N-1 之间的整数索引来访问 A[i];\n其次，它引入了一个标识符A，可以作为指向数组开头的指针;\n在指针上进行算术运算时，其实际的索引值会根据指针引用的数据类型的大小进行缩放, 即假设A的值是xa, 那么A+i的值就是xa + L * i, A[i] = *(A+i);\n其他 #define 指令允许在源代码中定义宏 macro。这些宏定义允许在整个代码中声明常量值。 宏定义不是变量，不能像变量那样通过程序代码进行更改。创建表示数字，字符串或表达式的常量时，通常使用此语法。\n定义常数：#define CNAME value or #define CNAME (expression)。CNAME是常数的名称。大多数C程序员用大写字母来定义常量名，但这不是C语言的要求。expression就是被分配给常量的表达式。如果表达式包含运算符，则该表达式必须括在括号内。\n","wordCount":"2916","inLanguage":"en","datePublished":"2018-01-29T00:00:00Z","dateModified":"2018-01-29T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/computer-systems-a-programmers-perspective-csapp-cmu-15213/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213</h1><div class=post-meta><span title='2018-01-29 00:00:00 +0000 UTC'>2018-01-29</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/csapp.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bf%a1%e6%81%af%e7%9a%84%e8%a1%a8%e8%be%be%e4%b8%8e%e6%93%8d%e4%bd%9c aria-label=信息的表达与操作>信息的表达与操作</a><ul><li><a href=#%e6%95%b4%e6%95%b0%e5%8a%a0%e5%87%8f%e4%b9%98%e4%bd%8d%e7%a7%bb aria-label=整数加减乘位移>整数加减乘位移</a></li><li><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0 aria-label=浮点数>浮点数</a></li><li><a href=#programs-are-traslated-by-other-programs-into-different-forms aria-label="Programs are traslated by other programs into different forms">Programs are traslated by other programs into different forms</a></li><li><a href=#processors-read-and-interpret-instructions-stored-in-memory aria-label="Processors read and interpret instructions stored in memory">Processors read and interpret instructions stored in memory</a></li><li><a href=#hardware-organization-of-a-systems aria-label="Hardware organization of a systems">Hardware organization of a systems</a><ul><li><a href=#buses aria-label=Buses>Buses</a></li><li><a href=#inputoutput-io-devices aria-label="Input/output (I/O) devices">Input/output (I/O) devices</a></li><li><a href=#main-memory aria-label="Main Memory">Main Memory</a></li><li><a href=#processor-central-processing-unit-cpu aria-label="Processor: Central Processing Unit (CPU)">Processor: Central Processing Unit (CPU)</a></li><li><a href=#cpu-operations-examples aria-label="CPU operations examples">CPU operations examples</a></li></ul></li><li><a href=#running-a-programs aria-label="Running a programs">Running a programs</a></li><li><a href=#caches aria-label=Caches>Caches</a></li><li><a href=#storage-devices-form-a-hierarchy aria-label="Storage Devices Form a Hierarchy">Storage Devices Form a Hierarchy</a></li><li><a href=#operating-system aria-label="Operating system">Operating system</a><ul><li><a href=#process%e8%bf%9b%e7%a8%8b aria-label=Process进程>Process进程</a></li><li><a href=#virtual-memory aria-label="Virtual Memory">Virtual Memory</a></li><li><a href=#thread%e7%ba%bf%e7%a8%8b aria-label=Thread线程>Thread线程</a></li><li><a href=#files aria-label=Files>Files</a></li></ul></li></ul></li><li><a href=#concurrency-and-parallelism aria-label="Concurrency and Parallelism">Concurrency and Parallelism</a><ul><li><a href=#thread-level-concurrency aria-label="Thread-Level Concurrency">Thread-Level Concurrency</a></li><li><a href=#instruction-level-parallelism aria-label="instruction-level parallelism">instruction-level parallelism</a></li><li><a href=#single-instruction-multiple-data-simd-parallelism aria-label="Single-Instruction, Multiple-Data (SIMD) Parallelism">Single-Instruction, Multiple-Data (SIMD) Parallelism</a></li></ul></li><li><a href=#memory-data--addressing aria-label="Memory, Data, & Addressing">Memory, Data, & Addressing</a><ul><li><a href=#address-and-pointers aria-label="Address and Pointers">Address and Pointers</a></li><li><a href=#integer-and-floating-point-numbers aria-label="Integer and floating point numbers">Integer and floating point numbers</a></li></ul></li><li><a href=#c aria-label=C>C</a><ul><li><a href=#methods aria-label=Methods>Methods</a></li><li><a href=#addresses-and-pointer-in-c aria-label="Addresses and pointer in C">Addresses and pointer in C</a></li><li><a href=#pointers-and-arrays aria-label="Pointers and arrays">Pointers and arrays</a></li><li><a href=#%e5%85%b6%e4%bb%96 aria-label=其他>其他</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>CSAPP 非常巧妙的把程序设计及优化、数字电路基础、指令集体系、汇编语言、存储器体系结构、链接与装载、进程、虚存等来自不同学科的核心知识点和在一起，并以程序员的视角呈现; 告诉我们作为一个程序员，究竟需要对计算机的硬件了解到什么程度？</p></blockquote><p>本笔记是 CMU CSAPP 的学习笔记, 使用 CMU 15-213, UW CSE351 的课程视频, lab, 作业, project 辅助练习.</p><ol><li><a href=http://csapp.cs.cmu.edu/>Computer Systems: A Programmer&rsquo;s Perspective (csapp)</a>, 豆瓣-<a href=https://book.douban.com/subject/26912767/>深入理解计算机系统</a></li><li><a href=https://www.cs.cmu.edu/~213/>卡内基梅隆大学 CMU 15-213 Introduction to Computer Systems (ICS)</a></li><li><a href=https://courses.cs.washington.edu/courses/cse351/>华盛顿大学 UW CSE351: The Hardware/Software Interface</a></li></ol><h2 id=信息的表达与操作>信息的表达与操作<a hidden class=anchor aria-hidden=true href=#信息的表达与操作>#</a></h2><p>Information is Bits + Context. Study systems by tracing the lifetime of the hello program, from the time it is created by a programmer, until it runs on a system, prints its simple message, and terminates.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello, world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> <span class=p>}</span>
</span></span></code></pre></div><p>The source program is a sequence of bits, each with a value of 0 or 1, organized in 8-bit chunks(bytes). Each byte represents some text character in the program.</p><p>All information in a system — including disk files, programs stored in memory, user data stored in memory, and data transferred across a network—is represented as a bunch of bits.</p><h3 id=整数加减乘位移>整数加减乘位移<a hidden class=anchor aria-hidden=true href=#整数加减乘位移>#</a></h3><p>Most machines shift and add faster than multiply, compiler translate multiply to shift and add automatically.</p><p>Power-of-2 Multiply with Shift: <code>u &lt;&lt; k</code> gives $u \times 2^k$, <code>u * 24 = u * 32 - u * 8 = (u &lt;&lt; 5) - (u &lt;&lt; 3)</code></p><p>Signed Power-of-2 Divide with Shift: <code>x >> k</code> using arithmetic shift(补1) gives $x / 2^k$, when <code>u &lt; 0</code>, say <code>y = -15213 = b[11000100 10010011]</code>, <code>y >> 1 = b[11100010 01001001] = -7607</code>, the rounding is downward, which is not the same as the convention toward zero.</p><p>Correct Power-of-2 Divide by adding bias: $x / 2^k$, computed as $(x + 2^k - 1) / 2^k$, in C <code>(x&lt;0 ? x+(1&lt;&lt;k)-1 : x) >> k</code></p><h3 id=浮点数>浮点数<a hidden class=anchor aria-hidden=true href=#浮点数>#</a></h3><p>IEEE floating-point standard represents a number in a form $V = (−1)^s × M × 2^E$</p><ol><li>sign <code>s</code>: determines whether the number is negative (s = 1) or positive (s = 0)</li><li>exponent <code>E</code> weights the value by a (possibly negative) power of 2, encoded by the <code>k</code>-bit exponent field <code>exp</code>.</li><li>significand <code>M</code>: a fractional binary number that ranges either [1, 2 − ϵ) or [0, 1 − ϵ), encoded by the <code>n</code>-bit fraction field <code>frac</code></li></ol><p><img loading=lazy src=/images/floating_point.png title="image from http://www.cs.cmu.edu/~213/">
Case 1: Normalized Values
<code>E</code> is interpreted as representing a signed integer in biased form, <code>E = e − Bias</code>, where <code>e</code> is the <strong>unsigned</strong> number, <code>Bias</code> equals to $2^{k−1}−1$.
The significand is defined to be <code>M = 1 + f</code>, where <code>f</code> is the fraction field, <code>0 ≤ f &lt; 1</code>, <code>M</code> = $1.f_{n−1}f_{n−2}...f_0$</p><p>Case 2: Denormalized Values
Exponent field is all zeros, the exponent value is <code>E = 1 − Bias</code>, and the significand value is <code>M = f</code>, <code>M</code> = $0.f_{n−1}f_{n−2}...f_0$
Denormalized numbers serve two purposes.</p><ol><li>provide a way to represent numeric value <code>0</code>,</li></ol><ul><li><code>+0.0</code>, bit pattern all zeros, <code>s = M = f = 0</code></li><li><code>−0.0</code>, bit pattern all zeros except <code>s = 1</code>.</li></ul><ol start=2><li>represent numbers that are very close to <code>0.0</code>: possible numeric values are spaced evenly near <code>0.0</code></li></ol><p>Case 3: Special Values
Exponent field is all ones.</p><ol><li>When the fraction field is all zeros, the resulting values represent <strong>infinity</strong>, either <code>+∞</code> when <code>s = 0</code>, or <code>−∞</code> when <code>s = 1</code>. Infinity can represent results that overflow</li><li>When the fraction field is nonzero, the resulting value is <code>NaN</code></li></ol><p><img loading=lazy src=/images/floating_decoding.png title="image from http://www.cs.cmu.edu/~213/">
<img loading=lazy src=/images/floating_point_range.png title="image from http://www.cs.cmu.edu/~213/"></p><h3 id=programs-are-traslated-by-other-programs-into-different-forms>Programs are traslated by other programs into different forms<a hidden class=anchor aria-hidden=true href=#programs-are-traslated-by-other-programs-into-different-forms>#</a></h3><p>The hello program begins as a high-level C program because it can be read and understood by human beings in that form. However, in order to run hello.c on the system, the individual C statements must be translated by other programs into a sequence of low-level machine-language instructions.</p><p>These instructions are then packaged in a form called an executable object program and stored as a binary <strong>disk</strong> file. Object programs are also referred to as executable object files.</p><p>The programs that perform the four phases (preprocessor, compiler, assembler, and linker) are known collectively as the compilation system.</p><ul><li>Preprocessing phase.The preprocessor (cpp) modifies the original C program according to directives that begin with the # character.</li><li>Compilation phase. The compiler (cc1) translates the text file hello.i into the text file hello.s, which contains an assembly-language program. Assembly language is useful because it provides a common output language for different compilers for different high-level languages.</li><li>Assembly phase. Next, the assembler (as) translates hello.s into machinelanguage instructions, packages them in a form known as a relocatable object program, and stores the result in the object file hello.o.<ul><li>The hello.o file is a binary file whose bytes encode machine language instructions rather than characters.</li></ul></li><li>Linking phase. The printf function resides in a separate precompiled object file called printf.o, which must somehow be merged with our hello.o program. The linker (ld) handles this merging.</li></ul><p>大多数 JVM 将内存区域划分为 <strong>Method Area（Non-Heap）（方法区）</strong>, <strong>Heap（堆）</strong>, <strong>Program Counter Register（程序计数器）</strong>, <strong>VM Stack（虚拟机栈/JAVA方法栈）</strong>, <strong>Native Method Stack（ 本地方法栈 ）</strong>，其中Method Area和Heap是线程共享的，VM Stack，Native Method Stack和Program Counter Register是非线程共享的。<img loading=lazy src=/images/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%BE.png></p><ul><li>程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的</li><li>虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的</li><li>原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的</li><li>方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息</li></ul><p>一个一般性的 Java 程序工作过程：</p><ol><li>一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。</li><li>程序开始运行后，开始涉及各内存区域：<ol><li>JVM初始运行的时候都会分配好 Method Area（方法区）和Heap（堆），</li><li>而JVM每遇到一个线程，就为其分配一个Program Counter Register（程序计数器）, VM Stack（虚拟机栈）和Native Method Stack（本地方法栈），当线程终止时，三者所占用的内存空间也会被释放掉。</li></ol></li></ol><p>这也是为什么把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。<img loading=lazy src=/images/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png></p><h3 id=processors-read-and-interpret-instructions-stored-in-memory>Processors read and interpret instructions stored in memory<a hidden class=anchor aria-hidden=true href=#processors-read-and-interpret-instructions-stored-in-memory>#</a></h3><p>The hello.c source program has been translated by the compilation system into an executable object file called hello that is stored on disk, to run the executable file on Unix:</p><pre tabindex=0><code>unix&gt; ./hello
hello, world
unix&gt;
</code></pre><p>The shell is a command-line interpreter that prints a prompt, waits for you to type a command line, and then performs the command.</p><h3 id=hardware-organization-of-a-systems>Hardware organization of a systems<a hidden class=anchor aria-hidden=true href=#hardware-organization-of-a-systems>#</a></h3><p>Hardware organization of a typical system.</p><h4 id=buses>Buses<a hidden class=anchor aria-hidden=true href=#buses>#</a></h4><p>Electrical conduits that carry bytes of information back and forth between the components. Buses are typically designed to transfer fixed-sized chunks of bytes known as words. USB: Universal Serial bus.</p><h4 id=inputoutput-io-devices>Input/output (I/O) devices<a hidden class=anchor aria-hidden=true href=#inputoutput-io-devices>#</a></h4><p>The system’s connection to the external world. Each I/O deviceisconnected to the I/O bus by either a controller or an adapter：</p><ul><li>Controllers are chip sets in the device itself or on the system’s main printed circuit board (often called the motherboard).</li><li>An adapter is a card that plugs into a slot on the motherboard.</li></ul><h4 id=main-memory>Main Memory<a hidden class=anchor aria-hidden=true href=#main-memory>#</a></h4><p>A temporary storage device that holds both a program and the data it manipulates while the processor is executing the program.</p><ul><li>Physically, main memory consists of a collection of dynamic random access memory (DRAM) chips.</li><li>Logically, memory is organized as a linear array of bytes, each with its own unique address (array index) starting at zero</li><li></li></ul><h4 id=processor-central-processing-unit-cpu>Processor: Central Processing Unit (CPU)<a hidden class=anchor aria-hidden=true href=#processor-central-processing-unit-cpu>#</a></h4><ul><li>PC: Program counter, a word-sized storage device (or register) at CPU core. At any point in time, the PC points at (contains the address of) some machine-language instruction in main memory.</li><li>Register: a quickly accessible location available to CPU,</li><li>Register file: an array of registers, each with its own unique name.</li><li>Arithmetic/logic unit: ALU computes new data and address values.</li></ul><p>A processor repeatedly executes the instruction pointed at by the program counter and updates the program counter to point to the next instruction. The processor reads the instruction from memory pointed at by the PC, interprets the bits in the instruction, performs some simple operation dictated by the instruction, and then updates the PC to point to the next instruction.</p><h4 id=cpu-operations-examples>CPU operations examples<a hidden class=anchor aria-hidden=true href=#cpu-operations-examples>#</a></h4><p>Load: Copy a byte or a word from main memory into a register, overwriting the previous contents of the register.</p><p>Store(write): Copy a byte or a word from a register to a location in main memory, overwriting the previous contents of that location.</p><p>Operate: Copy the contents of two registers to the ALU, perform an arithmetic operation on the two words, and store the result in a register, overwriting the previous contents of that register.</p><p>Jump: Extract a word from the instruction itself and copy that word into the program counter (PC), overwriting the previous value of the PC.</p><p>Branch greater than (BGT): compares two registers and decides whether to branch (target would be the address to branch to), i.e. it is implementing the &ldquo;if&rdquo; decision.</p><h3 id=running-a-programs>Running a programs<a hidden class=anchor aria-hidden=true href=#running-a-programs>#</a></h3><ol><li>Initially, the shell program is waiting for user types a command. As we type the characters “./hello” at the keyboard, the shell program reads each one into a register, and then stores it in memory.</li><li>When we hit the <em>enter</em> key on the keyboard, the shell knows that we have finished typing the command. The shell then loads the executable hello file by executing a sequence of instructions that copies the code and data in the hello object file <strong>from disk to main memory</strong>. The data include the string of characters “hello, world\n” that will eventually be printed out. Using a technique known as direct memory access (DMA), the data travels directly from disk to main memory, without passing through the processor.</li><li>Once the code and data in the hello object file are loaded into memory, the processor begins executing the machine-language instructions in the hello program’s main routine. These instructions copy the bytes in the <code>hello, world\n</code> string from memory to the register file, and from there to the display device, where they are displayed on the screen.</li></ol><h3 id=caches>Caches<a hidden class=anchor aria-hidden=true href=#caches>#</a></h3><p>An important lesson from this simple example is that a system spends a lot of time moving information from one place to another. From a programmer’s perspective, much
of this copying is overhead that slows down the “real work” of the program. Because of physical laws, larger storage devices are slower than smaller storage devices. Speed that processor read from: register > memory > disk.</p><p>It is easier and cheaper to make processors run faster than it is to make main memory run faster. To deal with the processor-memory gap, system designers include smaller
faster storage devices called cache memories (or simply caches) that serve as temporary staging areas for information that the processor is likely to need in the near future.</p><p>The L1 and L2 caches are implemented with a hardware technology known as static random access memory (SRAM). Newer and more powerful systems even have three levels of cache: L1, L2, and L3.</p><p>By setting up caches to hold data that is likely to be accessed often, we can perform most memory operations using the fast caches.</p><h3 id=storage-devices-form-a-hierarchy>Storage Devices Form a Hierarchy<a hidden class=anchor aria-hidden=true href=#storage-devices-form-a-hierarchy>#</a></h3><p><img loading=lazy src=/images/memory_hierarchy.png title="source from:http://csapp.cs.cmu.edu/"></p><h3 id=operating-system>Operating system<a hidden class=anchor aria-hidden=true href=#operating-system>#</a></h3><p>The operating system has two primary purposes: (1) to protect the hardware from misuse by runaway applications, and (2) to provide applications with simple and uniform mechanisms for manipulating complicated and often wildly different low-level hardware devices.</p><p>Think of the operating system as a layer of software interposed between the application program and the hardware, with fundamental abstractions: processes, virtual memory, and files.
<img loading=lazy src=/images/operating_system_abs.png title="Abstractions provided by an operating system. Source from:http://csapp.cs.cmu.edu/"></p><h4 id=process进程>Process进程<a hidden class=anchor aria-hidden=true href=#process进程>#</a></h4><p>A process is the operating system’s abstraction for a running program. Multiple processes can run concurrently on the same system by having the processor switch (<strong>context switching</strong>) among them, and each process appears to have exclusive use of the hardware.</p><p>The os keeps track of all the state information that the process needs in order to run. This state, i.e. the context, includes information such as the current values of the PC, the register file, and the contents of main memory.</p><p>When the operating system decides to transfer control from the current process to some new process, it performs a context switch by saving the context of the current process, restoring the context of the new process, and then passing control to the new process. The new process picks up exactly where it left off. <img loading=lazy src=/images/Process_context.png title="Process context switching. Source from:http://csapp.cs.cmu.edu/"></p><h4 id=virtual-memory>Virtual Memory<a hidden class=anchor aria-hidden=true href=#virtual-memory>#</a></h4><p>Virtual memory is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its virtual address space.</p><p>In Linux, the topmost region of the address space is reserved for code and data in the operating system that is common to all processes. The lower region of the address space holds the code and data defined by the user’s process.
<img loading=lazy src=/images/Process_virtual_address.png title="Process virtual address space. Source from:http://csapp.cs.cmu.edu/">
Starting with the lowest addresses and working our way up:</p><ol><li>Program code and data: Fixed in size once the process begins running. The code and data areas are initialized directly from the contents of an executable object file, in our case the hello executable.</li><li>Run-time heap: expands and contracts dynamically at run time as a result of calls to C standard library routines such as <code>malloc</code> and <code>free</code>.</li><li>Shared libraries: holds the code and data for shared libraries such as the C standard library and the math library.</li><li>User stack: the compiler uses to implement function calls. Each time we call a function, the stack grows. Each time we return from a function, it contracts.</li><li>Kernel virtual memory: The kernel is the part of the operating system that is always resident in memory. Application programs are not allowed to read or write the contents of the top region of the address space (which is reserved for the kernel) or to directly call functions defined in the kernel code.</li></ol><h4 id=thread线程>Thread线程<a hidden class=anchor aria-hidden=true href=#thread线程>#</a></h4><p>In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system.</p><p>In most cases a thread is a component of a process. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources.</p><p>Threads are an increasingly important programming model because of the requirement for concurrency in network servers, because it is easier to share data between multiple threads than between multiple processes, and because threads are typically more efficient than processes.</p><h4 id=files>Files<a hidden class=anchor aria-hidden=true href=#files>#</a></h4><p>A file is a sequence of bytes. Every I/O device, including disks, keyboards, displays, and even networks, is modeled as a file. All input and output in the system is performed by reading and writing files, using a small set of system calls known as <em>Unix I/O</em>.</p><h2 id=concurrency-and-parallelism>Concurrency and Parallelism<a hidden class=anchor aria-hidden=true href=#concurrency-and-parallelism>#</a></h2><p>Concurrency: general concept of a system with multiple, simultaneous activities.
Parallelism: the use of concurrency to make a system run faster.</p><p>Parallelism could be achieved in different levels of abstraction in computer system. There are three common levels (from the highest to the lowest level in the system hierarchy):</p><h3 id=thread-level-concurrency>Thread-Level Concurrency<a hidden class=anchor aria-hidden=true href=#thread-level-concurrency>#</a></h3><p>Building on the process abstraction, we are able to devise systems where multiple programs execute at the same time, leading to concurrency. With threads, we can even have multiple control flows executing within a single process.</p><p>When we construct a system consisting of multiple processors all under the control of a single operating system kernel, we have a multiprocessor system</p><p><strong>Multi-core processors</strong>: Several CPUs (referred to as “cores”) integrated onto a single integrated-circuit chip.</p><p><strong>Hyperthreading</strong>: Sometimes called simultaneous multi-threading, is a technique that allows a single CPU to execute multiple flows of control.</p><h3 id=instruction-level-parallelism>instruction-level parallelism<a hidden class=anchor aria-hidden=true href=#instruction-level-parallelism>#</a></h3><p>At a much lower level of abstraction, modern processors can execute multiple instructions at one time.</p><h3 id=single-instruction-multiple-data-simd-parallelism>Single-Instruction, Multiple-Data (SIMD) Parallelism<a hidden class=anchor aria-hidden=true href=#single-instruction-multiple-data-simd-parallelism>#</a></h3><p>At the lowest level, special hardware that allows a single instruction to cause multiple operations to be performed in parallel.</p><h2 id=memory-data--addressing>Memory, Data, & Addressing<a hidden class=anchor aria-hidden=true href=#memory-data--addressing>#</a></h2><p>十进制，2进制，16进制:</p><ul><li>A single byte consists of 8 bits.</li><li>二进制 value ranges from 00000000<sub>2</sub> to 11111111<sub>2</sub>,</li><li>十进制 value ranges from 0<sub>10</sub> to 255<sub>10</sub></li><li>二进制表示法过于冗长，而使用十进制表示法，与bits进行模式转换非常繁琐。</li><li>十六进制，hexadecimal numbers: Hexadecimal (or simply “hex”) uses digits ‘0’ through ‘9’ along with characters ‘A’ through ‘F’ to represent 16 possible values. Values range from 00<sub>16</sub> to FF<sub>16</sub>.</li></ul><p>内存：</p><ul><li>A machine-level program views memory as a very large array of bytes, referred to as virtual memory.</li><li>Every byte of memory is identified by a unique number, known as its address.</li><li>The set of all possible addresses is known as the virtual address space - 进程可用的虚拟地址范围称为该进程的“虚拟地址空间”。</li></ul><p>这个虚拟地址空间只是一个呈现给机器级程序的虚拟概念。实际的实现需要用到随机访问存储器（RAM），磁盘存储，特殊的硬件和操作系统软件的组合来构建相对于程序而言的单片字节数组。</p><h3 id=address-and-pointers>Address and Pointers<a hidden class=anchor aria-hidden=true href=#address-and-pointers>#</a></h3><p>地址是内存的位置，指针是一种包含地址的数据对象。</p><p>Byte ordering: Endianness</p><ul><li><strong>little endian</strong> - where the least significant byte comes first, followed by most Intel-compatible machines.</li><li><strong>big endian</strong> - where the most significant byte comes first, followed by most machines from IBM and Sun Microsystems</li><li>Many recent microprocessors are bi-endian, meaning that they can be configured to operate as either little- or big-endian machines.</li></ul><h3 id=integer-and-floating-point-numbers>Integer and floating point numbers<a hidden class=anchor aria-hidden=true href=#integer-and-floating-point-numbers>#</a></h3><p>把多个bits组合起来，通过解码，可以表达有限集合内的所有元素。比如二进制数字系统可以表示正整数。</p><p>Three most important representations of numbers.</p><ol><li>Unsigned encodings：based on traditional binary notation, representing numbers greater than or equal to 0.</li><li>Two’s-complement encodings: the most common way to represent signed integers, that is, numbers that may be either positive or negative.</li><li>Floating-point encodings: base-two version of scientific notation for
representing real numbers.</li></ol><h2 id=c>C<a hidden class=anchor aria-hidden=true href=#c>#</a></h2><h3 id=methods>Methods<a hidden class=anchor aria-hidden=true href=#methods>#</a></h3><ul><li>Naming data types with <code>typedef</code>: C的<code>typedef</code>声明用于给数据类型命名。这对提高代码可读性有很大的帮助，因为深层嵌套类型声明可能难以解读。<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=o>*</span><span class=n>int_pointer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>int_pointer</span> <span class=n>ip</span><span class=p>;</span>
</span></span></code></pre></div>等同于<code>int *ip;</code></li><li>Formatted printing with <code>printf</code>(<code>fprintf</code> and <code>sprintf</code>): provides a way to print information
with considerable control over the formatting details.<ul><li>The first argument is a format string. Each character sequence starting with ‘%’ indicates how to format the next argument. <code>%d</code> - 输出十进制整数, <code>%f</code> - 浮点数, <code>%c</code> - 字符</li><li>while any remaining arguments are values to be printed.</li></ul></li><li><code>sizeof(T)</code> returns the number of bytes required to store an object of type T</li><li><code>void *malloc(size_t size)</code>分配请求的内存(size in bytes)并返回一个指向它的指针(如果请求失败，则返回<code>NULL</code>)。</li></ul><h3 id=addresses-and-pointer-in-c>Addresses and pointer in C<a hidden class=anchor aria-hidden=true href=#addresses-and-pointer-in-c>#</a></h3><p>指针是C的核心功能，可以引用数据结构元素（包括数组）。就像变量一样，指针有两个组成部分：值和类型。该值指示某个对象的位置，而其类型指示该位置处存储什么类型的对象（例如，整数或浮点数）。</p><ul><li><code>&</code> - “address of", return a pointer;</li><li>Variable declarations： <code>int x</code>, find location in memory in which to store integer.</li><li>Pointer declarations use <code>*</code>: <code>int *pointer</code>, declares a variable <code>pointer</code> that is a pointer pointing to an object of type integer.</li><li>Assignment to a pointer: <code>pointer = &amp;x</code>, assigns <code>pointer</code> to point to the address where <code>x</code> is stored.</li><li>To use the value pointed to by a pointer, use <code>*</code>:<ul><li>if <code>pointer = &amp;x</code>, then <code>x = *pointer +1</code> is the same as <code>x = x + 1</code></li><li>假如x是一个对象, 那么<code>*(&amp;x)</code>=<code>*&amp;x</code> = <code>x</code></li></ul></li></ul><h3 id=pointers-and-arrays>Pointers and arrays<a hidden class=anchor aria-hidden=true href=#pointers-and-arrays>#</a></h3><p>C通过数组将标量数据聚合为更大的数据类型。In C, we can dereference a pointer with array notation, and we can reference array elements with pointer notation.
C有一个不常见的特性, 就是我们可以生成指向数组内的元素的指针，并使用这些指针来执行算术运算。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>T</span> <span class=n>A</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span></code></pre></div><p>首先，它在内存中分配一个L*N大小的连续区域, 其中L是数据类型T的大小（以bytes为单位）. 数组的元素可以使用 0 ~ N-1 之间的整数索引来访问 <code>A[i]</code>;</p><p>其次，它引入了一个标识符A，可以作为指向数组开头的指针;</p><p>在指针上进行算术运算时，其实际的索引值会根据指针引用的数据类型的大小进行缩放, 即假设A的值是xa, 那么<code>A+i</code>的值就是<code>xa + L * i</code>, <code>A[i]</code> = <code>*(A+i)</code>;</p><h3 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h3><p><code>#define</code> 指令允许在源代码中定义宏 macro。这些宏定义允许在整个代码中声明常量值。 宏定义不是变量，不能像变量那样通过程序代码进行更改。创建表示数字，字符串或表达式的常量时，通常使用此语法。</p><p>定义常数：<code>#define CNAME value</code> or <code>#define CNAME (expression)</code>。<code>CNAME</code>是常数的名称。大多数C程序员用大写字母来定义常量名，但这不是C语言的要求。<code>expression</code>就是被分配给常量的表达式。如果表达式包含运算符，则该表达式必须括在括号内。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/csapp/>Csapp</a></li><li><a href=https://congchan.github.io/tags/c/>C</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/python-digest/><span class=title>« Prev</span><br><span>Python Digest</span>
</a><a class=next href=https://congchan.github.io/posts/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%94%A8%E4%BA%8E%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB/><span class=title>Next »</span><br><span>神经网络用于文本分类</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213 on x" href="https://x.com/intent/tweet/?text=Computer%20Systems%20-%20A%20Programmer%27s%20Perspective%20%28CSAPP%29%20-%20CMU%2015213&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fcomputer-systems-a-programmers-perspective-csapp-cmu-15213%2f&amp;hashtags=csapp%2cC"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fcomputer-systems-a-programmers-perspective-csapp-cmu-15213%2f&amp;title=Computer%20Systems%20-%20A%20Programmer%27s%20Perspective%20%28CSAPP%29%20-%20CMU%2015213&amp;summary=Computer%20Systems%20-%20A%20Programmer%27s%20Perspective%20%28CSAPP%29%20-%20CMU%2015213&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2fcomputer-systems-a-programmers-perspective-csapp-cmu-15213%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2fcomputer-systems-a-programmers-perspective-csapp-cmu-15213%2f&title=Computer%20Systems%20-%20A%20Programmer%27s%20Perspective%20%28CSAPP%29%20-%20CMU%2015213"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2fcomputer-systems-a-programmers-perspective-csapp-cmu-15213%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213 on whatsapp" href="https://api.whatsapp.com/send?text=Computer%20Systems%20-%20A%20Programmer%27s%20Perspective%20%28CSAPP%29%20-%20CMU%2015213%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2fcomputer-systems-a-programmers-perspective-csapp-cmu-15213%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213 on telegram" href="https://telegram.me/share/url?text=Computer%20Systems%20-%20A%20Programmer%27s%20Perspective%20%28CSAPP%29%20-%20CMU%2015213&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fcomputer-systems-a-programmers-perspective-csapp-cmu-15213%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Computer Systems - A Programmer's Perspective (CSAPP) - CMU 15213 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Computer%20Systems%20-%20A%20Programmer%27s%20Perspective%20%28CSAPP%29%20-%20CMU%2015213&u=https%3a%2f%2fcongchan.github.io%2fposts%2fcomputer-systems-a-programmers-perspective-csapp-cmu-15213%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>