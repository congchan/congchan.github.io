<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java Hash Table | Cong's Log</title><meta name=keywords content="Java"><meta name=description content="Hash Tables
Save items in a key-indexed table. Index is a function of the key - Hash function, method for computing array index from key.
要实现哈希表, 需要解决几个问题:

如何定义/计算哈希函数。
相等判定：如何检查两个键是否相等。
冲突解决：寻找能够处理哈希到同一索引的两个密钥的算法和数据结构。

时空权衡设计问题:

如果没有空间限制, 那么可以使用非常简单的哈希函数, 极端情况就是给每一种键分配一个索引。
如果没有时间限制, 那么对于键冲突问题可以使用简单的顺序搜索。
而现实中, 哈希表就是解决同时存在空间和时间限制的问题。

哈希函数
最理想的目标, 生成均匀分布的索引, 这样计算高效.
比如电话号码, 使用前三个数字作为索引是一种比较草稿的设计, 因为前三个数字一般代表区号, 且区号都是有限的, 这样同一个区的号码都会挤在同一个索引位置. 较好的方式是使用后三位数字. 身份证号同理.
在实际设计过程中, 不同的数据类型适用不同的方法.
所有Java类都继承了int hashCode()方法. 该方法的基本要求是:
If x.equals(y), then (x.hashCode() == y.hashCode())
最好(但不是必须的)能够满足:
If !x.equals(y), then (x.hashCode() != y.hashCode())
默认的实现方式是利用内存位置.
Java integers, booleans, and doubles:"><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/java-hash-table/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/java-hash-table/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/java-hash-table/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="Java Hash Table"><meta property="og:description" content="Hash Tables Save items in a key-indexed table. Index is a function of the key - Hash function, method for computing array index from key.
要实现哈希表, 需要解决几个问题:
如何定义/计算哈希函数。 相等判定：如何检查两个键是否相等。 冲突解决：寻找能够处理哈希到同一索引的两个密钥的算法和数据结构。 时空权衡设计问题:
如果没有空间限制, 那么可以使用非常简单的哈希函数, 极端情况就是给每一种键分配一个索引。 如果没有时间限制, 那么对于键冲突问题可以使用简单的顺序搜索。 而现实中, 哈希表就是解决同时存在空间和时间限制的问题。 哈希函数 最理想的目标, 生成均匀分布的索引, 这样计算高效.
比如电话号码, 使用前三个数字作为索引是一种比较草稿的设计, 因为前三个数字一般代表区号, 且区号都是有限的, 这样同一个区的号码都会挤在同一个索引位置. 较好的方式是使用后三位数字. 身份证号同理.
在实际设计过程中, 不同的数据类型适用不同的方法.
所有Java类都继承了int hashCode()方法. 该方法的基本要求是: If x.equals(y), then (x.hashCode() == y.hashCode()) 最好(但不是必须的)能够满足: If !x.equals(y), then (x.hashCode() != y.hashCode()) 默认的实现方式是利用内存位置.
Java integers, booleans, and doubles:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-06-19T00:00:00+00:00"><meta property="article:modified_time" content="2017-06-19T00:00:00+00:00"><meta property="article:tag" content="Java"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java Hash Table"><meta name=twitter:description content="Hash Tables
Save items in a key-indexed table. Index is a function of the key - Hash function, method for computing array index from key.
要实现哈希表, 需要解决几个问题:

如何定义/计算哈希函数。
相等判定：如何检查两个键是否相等。
冲突解决：寻找能够处理哈希到同一索引的两个密钥的算法和数据结构。

时空权衡设计问题:

如果没有空间限制, 那么可以使用非常简单的哈希函数, 极端情况就是给每一种键分配一个索引。
如果没有时间限制, 那么对于键冲突问题可以使用简单的顺序搜索。
而现实中, 哈希表就是解决同时存在空间和时间限制的问题。

哈希函数
最理想的目标, 生成均匀分布的索引, 这样计算高效.
比如电话号码, 使用前三个数字作为索引是一种比较草稿的设计, 因为前三个数字一般代表区号, 且区号都是有限的, 这样同一个区的号码都会挤在同一个索引位置. 较好的方式是使用后三位数字. 身份证号同理.
在实际设计过程中, 不同的数据类型适用不同的方法.
所有Java类都继承了int hashCode()方法. 该方法的基本要求是:
If x.equals(y), then (x.hashCode() == y.hashCode())
最好(但不是必须的)能够满足:
If !x.equals(y), then (x.hashCode() != y.hashCode())
默认的实现方式是利用内存位置.
Java integers, booleans, and doubles:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java Hash Table","item":"https://congchan.github.io/posts/java-hash-table/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java Hash Table","name":"Java Hash Table","description":"Hash Tables Save items in a key-indexed table. Index is a function of the key - Hash function, method for computing array index from key.\n要实现哈希表, 需要解决几个问题:\n如何定义/计算哈希函数。 相等判定：如何检查两个键是否相等。 冲突解决：寻找能够处理哈希到同一索引的两个密钥的算法和数据结构。 时空权衡设计问题:\n如果没有空间限制, 那么可以使用非常简单的哈希函数, 极端情况就是给每一种键分配一个索引。 如果没有时间限制, 那么对于键冲突问题可以使用简单的顺序搜索。 而现实中, 哈希表就是解决同时存在空间和时间限制的问题。 哈希函数 最理想的目标, 生成均匀分布的索引, 这样计算高效.\n比如电话号码, 使用前三个数字作为索引是一种比较草稿的设计, 因为前三个数字一般代表区号, 且区号都是有限的, 这样同一个区的号码都会挤在同一个索引位置. 较好的方式是使用后三位数字. 身份证号同理.\n在实际设计过程中, 不同的数据类型适用不同的方法.\n所有Java类都继承了int hashCode()方法. 该方法的基本要求是: If x.equals(y), then (x.hashCode() == y.hashCode()) 最好(但不是必须的)能够满足: If !x.equals(y), then (x.hashCode() != y.hashCode()) 默认的实现方式是利用内存位置.\nJava integers, booleans, and doubles:\n","keywords":["Java"],"articleBody":"Hash Tables Save items in a key-indexed table. Index is a function of the key - Hash function, method for computing array index from key.\n要实现哈希表, 需要解决几个问题:\n如何定义/计算哈希函数。 相等判定：如何检查两个键是否相等。 冲突解决：寻找能够处理哈希到同一索引的两个密钥的算法和数据结构。 时空权衡设计问题:\n如果没有空间限制, 那么可以使用非常简单的哈希函数, 极端情况就是给每一种键分配一个索引。 如果没有时间限制, 那么对于键冲突问题可以使用简单的顺序搜索。 而现实中, 哈希表就是解决同时存在空间和时间限制的问题。 哈希函数 最理想的目标, 生成均匀分布的索引, 这样计算高效.\n比如电话号码, 使用前三个数字作为索引是一种比较草稿的设计, 因为前三个数字一般代表区号, 且区号都是有限的, 这样同一个区的号码都会挤在同一个索引位置. 较好的方式是使用后三位数字. 身份证号同理.\n在实际设计过程中, 不同的数据类型适用不同的方法.\n所有Java类都继承了int hashCode()方法. 该方法的基本要求是: If x.equals(y), then (x.hashCode() == y.hashCode()) 最好(但不是必须的)能够满足: If !x.equals(y), then (x.hashCode() != y.hashCode()) 默认的实现方式是利用内存位置.\nJava integers, booleans, and doubles:\npublic final class Integer { private final int value; ... public int hashCode() { return value; } } public final class Boolean { private final boolean value; ... public int hashCode() { if (value) return 1231; else return 1237; } } // convert to IEEE 64-bit representation; // xor most significant 32-bits // with least significant 32-bits public final class Double { private final double value; ... public int hashCode() { long bits = doubleToLongBits(value); return (int) (bits ^ (bits \u003e\u003e\u003e 32)); } } strings\npublic final class String { private int hash = 0; private final char[] s; ... public int hashCode() { int h = hash; if (h != 0) return h; for (int i = 0; i \u003c length(); i++) hash = s[i] + (31 * h); hash = h; return h; } } Horner’s method to hash string of length L: L multiplies/adds $$h = s[0] \\cdot 31^{L-1} + ... + s[L-3] \\cdot 31^2 + s[L–2] \\cdot 31^1 + s[L–1]$$String s = \"call\"; int code = s.hashCode();, $$code = 99 \\cdot 31^3 + 97 \\cdot 31^2 + 108 \\cdot 31^1 + 108 = 3045982$$“Standard” recipe for user-defined types. ・Combine each significant field using the 31x + y rule. ・If field is a primitive type, use wrapper type hashCode(). ・If field is null, return 0. ・If field is a reference type, use hashCode(). ・If field is an array, apply to each entry, or use Arrays.deepHashCode().\nBasic rule. Need to use the whole key to compute hash code;\nModular hashing Hash code. An int between $-2^{31}$ and $2^{31} - 1$. Hash function. An int between 0 and M - 1 (for use as array index, typically M is a prime or power of 2) A buggy version: 1-in-a-billion bug\nprivate int hash(Key key) { return Math.abs(key.hashCode()) % M; } hashCode() of \"polygenelubricants\" is $-2^{31}$\nA correct version\nprivate int hash(Key key) { return (key.hashCode() \u0026 0x7fffffff) % M; } 键索引冲突 Collision. Two distinct keys hashing to same index.\nSeparate chaining symbol table Use an array of M \u003c N linked lists. (H. P. Luhn, IBM 1953) public class SeparateChainingHashST\u003cKey, Value\u003e { private int M = 97; // number of chains private Node[] st = new Node[M]; // array of chains private static class Node { private Object key; // no generic array creation private Object val; private Node next; public Node(Key key, Value val, Node next) { this.key = key; this.val = val; this.next = next; } } private int hash(Key key) { return (key.hashCode() \u0026 0x7fffffff) % M; } public Value get(Key key) { int i = hash(key); for (Node x = st[i]; x != null; x = x.next) if (key.equals(x.key)) return (Value) x.val; return null; } public void put(Key key, Value val) { int i = hash(key); for (Node x = st[i]; x != null; x = x.next) if (key.equals(x.key)) { x.val = val; return; } st[i] = new Node(key, val, st[i]); //new key put ahead } } Proposition. Under uniform hashing assumption, prob. that the number of keys in a list is within a constant factor of N / M is extremely close to 1. Consequence. Number of probes for search/insert is proportional to N / M\nIf M too large ⇒ too many empty chains. If M too small ⇒ chains too long. Typical choice: M ~ N / 5 ⇒ constant-time ops. Linear Probing Open addressing. (Amdahl-Boehme-Rocherster-Samuel, IBM 1953) When a new key collides, find next empty slot, and put it there.\nHash. Map key to integer i between 0 and M-1. Insert. Put at table index i if free; if not try i+1, i+2, etc Search. Search table index i; if occupied but no match, try i+1, i+2, etc.\npublic class LinearProbingHashST\u003cKey, Value\u003e { private int M = 30001; private Value[] vals = (Value[]) new Object[M]; private Key[] keys = (Key[]) new Object[M]; private int hash(Key key) { /* as before */ } public Value get(Key key) { for (int i = hash(key); keys[i] != null; i = (i+1) % M) if (key.equals(keys[i])) return vals[i]; return null; } public void put(Key key, Value val) { int i; for (i = hash(key); keys[i] != null; i = (i+1) % M) if (keys[i].equals(key)) break; keys[i] = key; vals[i] = val; } } Knuth’s parking problem 提供了一个理解 linear probing的模型: Cars arrive at one-way street with M parking spaces. Each desires a random space i : if space i is taken, try i + 1, i + 2, etc. So what is mean displacement of a car?\nHalf-full. With M / 2 cars, mean displacement is ~ 3 / 2. Full. With M cars, mean displacement is ~ sqrt(π M / 8)\nProposition. Under uniform hashing assumption, the average # of probes in a linear probing hash table of size M that contains N = α M keys is: search hit ~ (1 + 1 / (1 - α)) / 2, search miss / insert $1/2 (1 + 1 / (1 - α)^ 2)$\nTypical choice: α = N / M ~ ½. So that # probes for search hit is about 3/2, # probes for search miss is about 5/2.\n不同哈希表实现比较 Separate chaining. ・Easier to implement delete. ・Performance degrades gracefully. ・Clustering less sensitive to poorly-designed hash function.\nLinear probing. ・Less wasted space. ・Better cache performance.\n其他变种 Two-probe hashing. (separate-chaining variant) ・Hash to two positions, insert key in shorter of the two chains. ・Reduces expected length of the longest chain to log log N\nDouble hashing. (linear-probing variant) ・Use linear probing, but skip a variable amount, not just 1 each time. ・Effectively eliminates clustering. ・Can allow table to become nearly full. ・More difficult to implement delete.\nCuckoo hashing. (linear-probing variant) ・Hash key to two positions; insert key into either position; if occupied, reinsert displaced key into its alternative position (and recur). ・Constant worst case time for search.\n哈希表和平衡二叉树的比较 Hash tables. ・Simpler to code. ・No effective alternative for unordered keys. ・Faster for simple keys (a few arithmetic ops versus log N compares). ・Better system support in Java for strings (e.g., cached hash code).\nBalanced search trees. ・Stronger performance guarantee. ・Support for ordered ST operations. ・Easier to implement compareTo() correctly than equals() and hashCode().\nJava system includes both. ・Red-black BSTs: java.util.TreeMap, java.util.TreeSet. ・Hash tables: java.util.HashMap, java.util.IdentityHashMap.\n有关哈希表的攻击 均匀哈希假设在实践中是否重要？ 恶意攻击者学习你的哈希函数（例如，通过阅读Java API）并导致单个插槽大量堆积，从而使性能停滞不前\n案例:\nBro服务器：使用比拨号调制解调器更少的带宽，将精心选择的数据包发送到DOS服务器。 Perl 5.8.0：将精心挑选的字符串插入关联数组中。 Linux 2.4.20内核：使用精心选择的名称保存文件。 单向哈希函数, 使得找到一个键对应的哈希值（或两个哈希到相同值的键）变得困难. 如已知是不安全的MD4, MD5, SHA-0和SHA-1. 其他的还有SHA-2, WHIRLPOOL, RIPEMD-160, ….\n/* prints bytes as hex string */ String password = args[0]; MessageDigest sha1 = MessageDigest.getInstance(\"SHA1\"); byte[] bytes = sha1.digest(password); 这种哈希函数对于符号表而言有点过于昂贵了\nBit Map Bit-map用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。\n假设我们要对0-7内的5个元素4,7,2,5,3排序（假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），\n首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，0 0 0 0 0 0 0 0. 然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置设为1, p+(i/8)|(0x01\u003c\u003c(i%8)), 这里默认为Big-ending, 0 0 0 0 1 0 0 0. 然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态0 0 1 1 1 1 0 1 遍历一遍Bit区域，把1的索引依次输出（2，3，4，5，7），这样就达到了排序的目的。 算法的关键是如何确定十进制的数映射到二进制bit位的map图。算法占用很少内存，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。缺点是不能有重复数据。\nMap映射表 假设需要排序或者查找的总数N=10000000，那么我们需要申请内存空间的大小为int a[1 + N/32]，其中：a[0]在内存中占32位, 可以对应十进制数0-31，依次类推： bitmap表为：\na[0]---------\u003e0-31 a[1]---------\u003e32-63 a[2]---------\u003e64-95 a[3]---------\u003e96-127 .......... 十进制数需要转换为对应的bit位\n位移转换 将十进制数转换为对应的bit位, 申请一个int一维数组，作为32列的二维数组，\nint a[0] |0000000000000000000000000000000000000| int a[1] |0000000000000000000000000000000000000| ……………… int a[N] |0000000000000000000000000000000000000| 例如十进制0，对应在a[0]第一位： 00000000000000000000000000000001\n求十进制0-N对应在数组a的索引：十进制0-31，对应a[0]，先由十进制数n转换为与32的余可转化为对应在数组a中的索引0。比如n=24,那么 n/32=0，则24对应a[0]。又比如n=60, 那么n/32=1，则60对应a[1]。 求0-N对应0-31中的数：十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。 利用移位0-31使得对应32bit位为1. 找到对应0-31的数为M, 左移M位：即2 ^ M, 置1. Bloom Filter 为了降低键值冲突的概率，Bloom Filter使用了多个哈希函数：创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为h(i, str)，且h(i, str)的范围是0到m-1 。\n对于字符串str，分别计算h(1, str), h(2, str), ... h(k, str), 以这些哈希值作为索引, 将BitSet的对应位置的位设为1, 这样就把str映射到BitSet的k个二进制位了.\n如果要检查某string是否已经被记录在BitSet中, 只需要计算其哈希值数组, 并检查BitSet上对应位置的值是否为1, 若对应位置中有任何一个不是1, 那么该字符串一定没有被记录过, 若全部对应位置都为1, 那么按照false positive认为该字符串已经被记录过了(但不是100%肯定).\n删除操作会影响到其他字符串。如果需要删除字符串的功能，使用Counting bloomfilter(CBF)，这是一种Bloom Filter的变体，CBF将Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。\nBloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。\n","wordCount":"1254","inLanguage":"en","datePublished":"2017-06-19T00:00:00Z","dateModified":"2017-06-19T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/java-hash-table/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Java Hash Table</h1><div class=post-meta><span title='2017-06-19 00:00:00 +0000 UTC'>2017-06-19</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/java-HashTable.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#hash-tables aria-label="Hash Tables">Hash Tables</a><ul><li><a href=#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0 aria-label=哈希函数>哈希函数</a></li><li><a href=#modular-hashing aria-label="Modular hashing">Modular hashing</a></li><li><a href=#%e9%94%ae%e7%b4%a2%e5%bc%95%e5%86%b2%e7%aa%81 aria-label=键索引冲突>键索引冲突</a><ul><li><a href=#separate-chaining-symbol-table aria-label="Separate chaining symbol table">Separate chaining symbol table</a></li></ul></li><li><a href=#linear-probing aria-label="Linear Probing">Linear Probing</a></li><li><a href=#%e4%b8%8d%e5%90%8c%e5%93%88%e5%b8%8c%e8%a1%a8%e5%ae%9e%e7%8e%b0%e6%af%94%e8%be%83 aria-label=不同哈希表实现比较>不同哈希表实现比较</a></li><li><a href=#%e5%93%88%e5%b8%8c%e8%a1%a8%e5%92%8c%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%af%94%e8%be%83 aria-label=哈希表和平衡二叉树的比较>哈希表和平衡二叉树的比较</a></li><li><a href=#%e6%9c%89%e5%85%b3%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e6%94%bb%e5%87%bb aria-label=有关哈希表的攻击>有关哈希表的攻击</a></li></ul></li><li><a href=#bit-map aria-label="Bit Map">Bit Map</a><ul><li><a href=#map%e6%98%a0%e5%b0%84%e8%a1%a8 aria-label=Map映射表>Map映射表</a></li><li><a href=#%e4%bd%8d%e7%a7%bb%e8%bd%ac%e6%8d%a2 aria-label=位移转换>位移转换</a></li><li><a href=#bloom-filter aria-label="Bloom Filter">Bloom Filter</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=hash-tables>Hash Tables<a hidden class=anchor aria-hidden=true href=#hash-tables>#</a></h2><p>Save items in a key-indexed table. Index is a function of the key - <strong>Hash function</strong>, method for computing array index from key.</p><p>要实现哈希表, 需要解决几个问题:</p><ul><li>如何定义/计算哈希函数。</li><li>相等判定：如何检查两个键是否相等。</li><li>冲突解决：寻找能够处理哈希到同一索引的两个密钥的算法和数据结构。</li></ul><p>时空权衡设计问题:</p><ul><li>如果没有空间限制, 那么可以使用非常简单的哈希函数, 极端情况就是给每一种键分配一个索引。</li><li>如果没有时间限制, 那么对于键冲突问题可以使用简单的顺序搜索。</li><li>而现实中, 哈希表就是解决同时存在空间和时间限制的问题。</li></ul><h3 id=哈希函数>哈希函数<a hidden class=anchor aria-hidden=true href=#哈希函数>#</a></h3><p>最理想的目标, 生成均匀分布的索引, 这样计算高效.</p><p>比如电话号码, 使用前三个数字作为索引是一种比较草稿的设计, 因为前三个数字一般代表区号, 且区号都是有限的, 这样同一个区的号码都会挤在同一个索引位置. 较好的方式是使用后三位数字. 身份证号同理.</p><p>在实际设计过程中, 不同的数据类型适用不同的方法.</p><p>所有Java类都继承了<code>int hashCode()</code>方法. 该方法的基本要求是:
<code>If x.equals(y), then (x.hashCode() == y.hashCode())</code>
最好(但不是必须的)能够满足:
<code>If !x.equals(y), then (x.hashCode() != y.hashCode())</code>
默认的实现方式是利用内存位置.</p><p>Java integers, booleans, and doubles:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>class</span> <span class=nc>Integer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hashCode</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>class</span> <span class=nc>Boolean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hashCode</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>1231</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>else</span><span class=w>       </span><span class=k>return</span><span class=w> </span><span class=n>1237</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// convert to IEEE 64-bit representation;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// xor most significant 32-bits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// with least significant 32-bits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>class</span> <span class=nc>Double</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>double</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hashCode</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>long</span><span class=w> </span><span class=n>bits</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>doubleToLongBits</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=n>bits</span><span class=w> </span><span class=o>^</span><span class=w> </span><span class=p>(</span><span class=n>bits</span><span class=w> </span><span class=o>&gt;&gt;&gt;</span><span class=w> </span><span class=n>32</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>strings</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>class</span> <span class=nc>String</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hash</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hashCode</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=kt>int</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>h</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>h</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>length</span><span class=p>();</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>hash</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>31</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>h</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>hash</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>h</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>return</span><span class=w> </span><span class=n>h</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Horner&rsquo;s method to hash string of length L: L multiplies/adds</p>$$h = s[0] \cdot 31^{L-1} + ... + s[L-3] \cdot 31^2 + s[L–2] \cdot 31^1 + s[L–1]$$<p><code>String s = "call"; int code = s.hashCode();</code>,</p>$$code = 99 \cdot 31^3 + 97 \cdot 31^2 + 108 \cdot 31^1 + 108 = 3045982$$<p>&ldquo;Standard&rdquo; recipe for user-defined types.
・Combine each significant field using the <code>31x + y</code> rule.
・If field is a primitive type, use wrapper type <code>hashCode()</code>.
・If field is null, return 0.
・If field is a reference type, use <code>hashCode()</code>.
・If field is an array, apply to each entry, or use <code>Arrays.deepHashCode()</code>.</p><blockquote><p>Basic rule. Need to use the whole key to compute hash code;</p></blockquote><h3 id=modular-hashing>Modular hashing<a hidden class=anchor aria-hidden=true href=#modular-hashing>#</a></h3><p>Hash code. An int between $-2^{31}$ and $2^{31} - 1$.
Hash function. An int between 0 and M - 1 (for use as array index, typically M is a prime or power of 2)
A buggy version: 1-in-a-billion bug</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hash</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>abs</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>())</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>M</span><span class=p>;</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>hashCode()</code> of <code>"polygenelubricants"</code> is $-2^{31}$</p><p>A correct version</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hash</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>0x7fffffff</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>M</span><span class=p>;</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=键索引冲突>键索引冲突<a hidden class=anchor aria-hidden=true href=#键索引冲突>#</a></h3><p>Collision. Two distinct keys hashing to same index.</p><h4 id=separate-chaining-symbol-table>Separate chaining symbol table<a hidden class=anchor aria-hidden=true href=#separate-chaining-symbol-table>#</a></h4><p>Use an array of M &lt; N linked lists. (H. P. Luhn, IBM 1953) <img loading=lazy src=/images/separate_chaining_symbol_table.png title="image from: https://algs4.cs.princeton.edu/"></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SeparateChainingHashST</span><span class=o>&lt;</span><span class=n>Key</span><span class=p>,</span><span class=w> </span><span class=n>Value</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>M</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>97</span><span class=p>;</span><span class=w>     </span><span class=c1>// number of chains</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=o>[]</span><span class=w> </span><span class=n>st</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>[</span><span class=n>M</span><span class=o>]</span><span class=p>;</span><span class=w>  </span><span class=c1>// array of chains</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>Node</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=kd>private</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w> </span><span class=c1>// no generic array creation</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=kd>private</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>val</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=kd>private</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=kd>public</span><span class=w> </span><span class=nf>Node</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>Value</span><span class=w> </span><span class=n>val</span><span class=p>,</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=n>next</span><span class=p>)</span><span class=w>  </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>key</span><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>val</span><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=n>val</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hash</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>hashCode</span><span class=p>()</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>0x7fffffff</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>M</span><span class=p>;</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Value</span><span class=w> </span><span class=nf>get</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Node</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>st</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=na>next</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=na>key</span><span class=p>))</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=n>Value</span><span class=p>)</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=na>val</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>put</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>Value</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Node</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>st</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=na>next</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=na>key</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=na>val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>val</span><span class=p>;</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>st</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>,</span><span class=w> </span><span class=n>st</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>);</span><span class=w> </span><span class=c1>//new key put ahead</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>Proposition. Under uniform hashing assumption, prob. that the number of keys in a list is within a constant factor of N / M is extremely close to 1.
Consequence. Number of probes for search/insert is proportional to N / M</p></blockquote><ul><li>If M too large ⇒ too many empty chains.</li><li>If M too small ⇒ chains too long.</li><li>Typical choice: M ~ N / 5 ⇒ constant-time ops.</li></ul><h3 id=linear-probing>Linear Probing<a hidden class=anchor aria-hidden=true href=#linear-probing>#</a></h3><p>Open addressing. (Amdahl-Boehme-Rocherster-Samuel, IBM 1953) When a new key collides, find next empty slot, and put it there.</p><p>Hash. Map key to integer i between 0 and M-1.
Insert. Put at table index i if free; if not try i+1, i+2, etc
Search. Search table index i; if occupied but no match, try i+1, i+2, etc.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>LinearProbingHashST</span><span class=o>&lt;</span><span class=n>Key</span><span class=p>,</span><span class=w> </span><span class=n>Value</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>M</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>30001</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=n>Value</span><span class=o>[]</span><span class=w> </span><span class=n>vals</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Value</span><span class=o>[]</span><span class=p>)</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=o>[</span><span class=n>M</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=n>Key</span><span class=o>[]</span><span class=w>   </span><span class=n>keys</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Key</span><span class=o>[]</span><span class=p>)</span><span class=w>   </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=o>[</span><span class=n>M</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hash</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* as before */</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=n>Value</span><span class=w> </span><span class=nf>get</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w> </span><span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>M</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=k>return</span><span class=w> </span><span class=n>vals</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>put</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>Value</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hash</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w> </span><span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>M</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>key</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>key</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>vals</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>val</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Knuth&rsquo;s parking problem 提供了一个理解 linear probing的模型: Cars arrive at one-way street with M parking spaces. Each desires a random space i : if space i is taken, try i + 1, i + 2, etc. So what is mean displacement of a car?</p><p>Half-full. With M / 2 cars, mean displacement is <code>~ 3 / 2</code>.
Full. With M cars, mean displacement is <code>~ sqrt(π M / 8)</code></p><p>Proposition. Under uniform hashing assumption, the average # of probes in a linear probing hash table of size M that contains N = α M keys is:
search hit <code>~ (1 + 1 / (1 - α)) / 2</code>,
search miss / insert $1/2 (1 + 1 / (1 - α)^ 2)$</p><p>Typical choice: α = N / M ~ ½. So that # probes for search hit is about 3/2, # probes for search miss is about 5/2.</p><h3 id=不同哈希表实现比较>不同哈希表实现比较<a hidden class=anchor aria-hidden=true href=#不同哈希表实现比较>#</a></h3><p><img loading=lazy src=/images/symbol_table_summary.png title=" * under uniform hashing assumption. image from: https://algs4.cs.princeton.edu/">
Separate chaining.
・Easier to implement delete.
・Performance degrades gracefully.
・Clustering less sensitive to poorly-designed hash function.</p><p>Linear probing.
・Less wasted space.
・Better cache performance.</p><p>其他变种
Two-probe hashing. (separate-chaining variant)
・Hash to two positions, insert key in shorter of the two chains.
・Reduces expected length of the longest chain to log log N</p><p>Double hashing. (linear-probing variant)
・Use linear probing, but skip a variable amount, not just 1 each time.
・Effectively eliminates clustering.
・Can allow table to become nearly full.
・More difficult to implement delete.</p><p>Cuckoo hashing. (linear-probing variant)
・Hash key to two positions; insert key into either position; if occupied,
reinsert displaced key into its alternative position (and recur).
・Constant worst case time for search.</p><h3 id=哈希表和平衡二叉树的比较>哈希表和平衡二叉树的比较<a hidden class=anchor aria-hidden=true href=#哈希表和平衡二叉树的比较>#</a></h3><p>Hash tables.
・Simpler to code.
・No effective alternative for unordered keys.
・Faster for simple keys (a few arithmetic ops versus log N compares).
・Better system support in Java for strings (e.g., cached hash code).</p><p>Balanced search trees.
・Stronger performance guarantee.
・Support for ordered ST operations.
・Easier to implement compareTo() correctly than equals() and hashCode().</p><p>Java system includes both.
・Red-black BSTs: java.util.TreeMap, java.util.TreeSet.
・Hash tables: java.util.HashMap, java.util.IdentityHashMap.</p><h3 id=有关哈希表的攻击>有关哈希表的攻击<a hidden class=anchor aria-hidden=true href=#有关哈希表的攻击>#</a></h3><p>均匀哈希假设在实践中是否重要？
恶意攻击者学习你的哈希函数（例如，通过阅读Java API）并导致单个插槽大量堆积，从而使性能停滞不前</p><p>案例:</p><ul><li>Bro服务器：使用比拨号调制解调器更少的带宽，将精心选择的数据包发送到DOS服务器。</li><li>Perl 5.8.0：将精心挑选的字符串插入关联数组中。</li><li>Linux 2.4.20内核：使用精心选择的名称保存文件。</li></ul><p>单向哈希函数, 使得找到一个键对应的哈希值（或两个哈希到相同值的键）变得困难. 如已知是不安全的MD4, MD5, SHA-0和SHA-1. 其他的还有SHA-2, WHIRLPOOL, RIPEMD-160, &mldr;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/* prints bytes as hex string */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>password</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>MessageDigest</span><span class=w> </span><span class=n>sha1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>MessageDigest</span><span class=p>.</span><span class=na>getInstance</span><span class=p>(</span><span class=s>&#34;SHA1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>bytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sha1</span><span class=p>.</span><span class=na>digest</span><span class=p>(</span><span class=n>password</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>这种哈希函数对于符号表而言有点过于昂贵了</p><h2 id=bit-map>Bit Map<a hidden class=anchor aria-hidden=true href=#bit-map>#</a></h2><p>Bit-map用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p><p>假设我们要对0-7内的5个元素<code>4,7,2,5,3</code>排序（假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），</p><ol><li>首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，<code>0 0 0 0 0 0 0 0</code>.</li><li>然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置设为1, <code>p+(i/8)|(0x01&lt;&lt;(i%8))</code>, 这里默认为Big-ending, <code>0 0 0 0 1 0 0 0</code>.</li><li>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态<code>0 0 1 1 1 1 0 1</code></li><li>遍历一遍Bit区域，把<code>1</code>的索引依次输出（<code>2，3，4，5，7</code>），这样就达到了排序的目的。</li></ol><p>算法的关键是如何确定十进制的数映射到二进制bit位的map图。算法占用很少内存，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M。缺点是不能有重复数据。</p><h3 id=map映射表>Map映射表<a hidden class=anchor aria-hidden=true href=#map映射表>#</a></h3><p>假设需要排序或者查找的总数<code>N=10000000</code>，那么我们需要申请内存空间的大小为<code>int a[1 + N/32]</code>，其中：<code>a[0]</code>在内存中占32位, 可以对应十进制数0-31，依次类推：
bitmap表为：</p><pre tabindex=0><code>a[0]---------&gt;0-31
a[1]---------&gt;32-63
a[2]---------&gt;64-95
a[3]---------&gt;96-127
..........
</code></pre><p>十进制数需要转换为对应的bit位</p><h3 id=位移转换>位移转换<a hidden class=anchor aria-hidden=true href=#位移转换>#</a></h3><p>将十进制数转换为对应的bit位, 申请一个<code>int</code>一维数组，作为32列的二维数组，</p><pre tabindex=0><code>int a[0]    |0000000000000000000000000000000000000|

int a[1]    |0000000000000000000000000000000000000|

………………

int a[N]    |0000000000000000000000000000000000000|
</code></pre><p>例如十进制0，对应在<code>a[0]</code>第一位： <code>00000000000000000000000000000001</code></p><ol><li>求十进制<code>0-N</code>对应在数组<code>a</code>的索引：十进制<code>0-31</code>，对应<code>a[0]</code>，先由十进制数n转换为与32的余可转化为对应在数组<code>a</code>中的索引<code>0</code>。比如n=24,那么 n/32=0，则24对应<code>a[0]</code>。又比如n=60, 那么n/32=1，则60对应<code>a[1]</code>。</li><li>求<code>0-N</code>对应<code>0-31</code>中的数：十进制0-31就对应0-31，而32-63则对应也是0-31，即给定一个数n可以通过模32求得对应0-31中的数。</li><li>利用移位0-31使得对应32bit位为1. 找到对应0-31的数为M, 左移M位：即<code>2 ^ M</code>, 置1.</li></ol><h3 id=bloom-filter>Bloom Filter<a hidden class=anchor aria-hidden=true href=#bloom-filter>#</a></h3><p>为了降低键值冲突的概率，Bloom Filter使用了多个哈希函数：创建一个m位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为<code>h(i, str)</code>，且<code>h(i, str)</code>的范围是0到m-1 。</p><p>对于字符串<code>str</code>，分别计算<code>h(1, str), h(2, str), ... h(k, str)</code>, 以这些哈希值作为索引, 将BitSet的对应位置的位设为1, 这样就把<code>str</code>映射到BitSet的k个二进制位了.<img loading=lazy src=/images/bloom_filter.png></p><p>如果要检查某<code>string</code>是否已经被记录在BitSet中, 只需要计算其哈希值数组, 并检查BitSet上对应位置的值是否为<code>1</code>, 若对应位置中有任何一个不是<code>1</code>, 那么该字符串<strong>一定</strong>没有被记录过, 若全部对应位置都为<code>1</code>, 那么按照<strong>false positive</strong>认为该字符串已经被记录过了(但不是100%肯定).</p><p>删除操作会影响到其他字符串。如果需要删除字符串的功能，使用Counting bloomfilter(CBF)，这是一种Bloom Filter的变体，CBF将Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</p><p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/stanford-cs106a/b-programming-intro-%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%AF%BE/><span class=title>« Prev</span><br><span>Stanford CS106A/B Programming Intro 斯坦福大学编程入门课</span>
</a><a class=next href=https://congchan.github.io/posts/java-hashmap/><span class=title>Next »</span><br><span>Java HashMap</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash Table on x" href="https://x.com/intent/tweet/?text=Java%20Hash%20Table&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-table%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash Table on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-table%2f&amp;title=Java%20Hash%20Table&amp;summary=Java%20Hash%20Table&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-table%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash Table on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-table%2f&title=Java%20Hash%20Table"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash Table on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-table%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash Table on whatsapp" href="https://api.whatsapp.com/send?text=Java%20Hash%20Table%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-table%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash Table on telegram" href="https://telegram.me/share/url?text=Java%20Hash%20Table&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-table%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash Table on ycombinator" href="https://news.ycombinator.com/submitlink?t=Java%20Hash%20Table&u=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-table%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>