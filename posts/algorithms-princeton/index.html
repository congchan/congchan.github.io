<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithms - Princeton | Cong's Log</title><meta name=keywords content="Software Engineer,Java,algs4,Algorithms"><meta name=description content="
Algorithms, Part I, https://online.princeton.edu/course/algorithms-part-i
Algorithms, Part II, https://online.princeton.edu/course/algorithms-part-ii
Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne https://algs4.cs.princeton.edu/


Union−Find
Considering the dynamic connectivity problem, modeling of multiple objects connected in a space/network.
Applications involve manipulating objects of all types.
・Pixels in a digital photo.
・Computers in a network.
・Friends in a social network.
・Transistors in a computer chip.
Given a set of N objects.

union(a, b): connect two objects.
connected(p, q): is two objects connected?
find(p): Find component identifier for p (0 to N – 1)

Modeling the objects: array."><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/algorithms-princeton/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/algorithms-princeton/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/algorithms-princeton/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="Algorithms - Princeton"><meta property="og:description" content=" Algorithms, Part I, https://online.princeton.edu/course/algorithms-part-i Algorithms, Part II, https://online.princeton.edu/course/algorithms-part-ii Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne https://algs4.cs.princeton.edu/ Union−Find Considering the dynamic connectivity problem, modeling of multiple objects connected in a space/network.
Applications involve manipulating objects of all types. ・Pixels in a digital photo. ・Computers in a network. ・Friends in a social network. ・Transistors in a computer chip.
Given a set of N objects.
union(a, b): connect two objects. connected(p, q): is two objects connected? find(p): Find component identifier for p (0 to N – 1) Modeling the objects: array."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-01T00:00:00+00:00"><meta property="article:modified_time" content="2018-01-01T00:00:00+00:00"><meta property="article:tag" content="Software Engineer"><meta property="article:tag" content="Java"><meta property="article:tag" content="Algs4"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="Algorithms - Princeton"><meta name=twitter:description content="
Algorithms, Part I, https://online.princeton.edu/course/algorithms-part-i
Algorithms, Part II, https://online.princeton.edu/course/algorithms-part-ii
Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne https://algs4.cs.princeton.edu/


Union−Find
Considering the dynamic connectivity problem, modeling of multiple objects connected in a space/network.
Applications involve manipulating objects of all types.
・Pixels in a digital photo.
・Computers in a network.
・Friends in a social network.
・Transistors in a computer chip.
Given a set of N objects.

union(a, b): connect two objects.
connected(p, q): is two objects connected?
find(p): Find component identifier for p (0 to N – 1)

Modeling the objects: array."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Algorithms - Princeton","item":"https://congchan.github.io/posts/algorithms-princeton/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Algorithms - Princeton","name":"Algorithms - Princeton","description":" Algorithms, Part I, https://online.princeton.edu/course/algorithms-part-i Algorithms, Part II, https://online.princeton.edu/course/algorithms-part-ii Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne https://algs4.cs.princeton.edu/ Union−Find Considering the dynamic connectivity problem, modeling of multiple objects connected in a space/network.\nApplications involve manipulating objects of all types. ・Pixels in a digital photo. ・Computers in a network. ・Friends in a social network. ・Transistors in a computer chip.\nGiven a set of N objects.\nunion(a, b): connect two objects. connected(p, q): is two objects connected? find(p): Find component identifier for p (0 to N – 1) Modeling the objects: array.\n","keywords":["Software Engineer","Java","algs4","Algorithms"],"articleBody":" Algorithms, Part I, https://online.princeton.edu/course/algorithms-part-i Algorithms, Part II, https://online.princeton.edu/course/algorithms-part-ii Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne https://algs4.cs.princeton.edu/ Union−Find Considering the dynamic connectivity problem, modeling of multiple objects connected in a space/network.\nApplications involve manipulating objects of all types. ・Pixels in a digital photo. ・Computers in a network. ・Friends in a social network. ・Transistors in a computer chip.\nGiven a set of N objects.\nunion(a, b): connect two objects. connected(p, q): is two objects connected? find(p): Find component identifier for p (0 to N – 1) Modeling the objects: array.\nModeling the connections: Maximal set of objects that are mutually connected - Connected components.\nData structure:\nQuick find Integer array id[] of length N, two objects are connected iff they have the same id. Defect: union too expensive, $\\in \\Theta(N^2)$.\nQuick-union Integer array id[] of length N, id[i] is parent of i, root of i is id[id[id[...id[i]...]]] (until it doesn’t change). The find is recursive.\n/** chase parent pointers until reach root * (depth of i array accesses) */ private int find(int i) { while (i != id[i]) i = id[i]; return i; } Defect: Trees can get tall, find too expensive, $\\in \\Theta(N)$.\nWeighted quick-union Modify quick-union to avoid tall trees. Balance by linking root of smaller tree to root of larger tree. Maintain extra array sz[i] to keep track of size of each tree (number of objects). find: time proportional to depth of p and q, the depth of any node x is at most $\\log N$,\nWeighted quick-union with path compression Making all the nodes that examined directly link to its root. Keeps tree almost completely flat.\n/** Make every other node in path point to its grandparent * (thereby halving path length). */ private int root(int i) { while (i != id[i]) { id[i] = id[id[i]]; i = id[i]; } return i; } Amortized analysis: `[Hopcroft-Ulman, Tarjan]` Starting from an empty data structure, any sequence of M union-find ops on N objects makes $≤ c ( N + M \\lg \\ast N )$ array accesses. $\\lg \\ast N$ is [Iterated logarithm](https://en.wikipedia.org/wiki/Iterated_logarithm), for $N = 2^{65536}$, $\\lg \\ast N = 5$. In theory, WQUPC is not quite linear. In practice, WQUPC is linear. Amazing fact. [Fredman-Saks] No linear-time algorithm exists.\nElement Sort Two elementary sorting methods: selection sort and insertion sort. Shellsort is a variation of one of them.\nThe objective is to rearrange the items such that their keys are in ascending order.\nIn Java, the abstract notion of a key is captured by the Comparable interface. The Comparable interface provides an elegant API for callback when Java need to compare keys.\nSome background knowlege:\nCost model, please refer to Asymptotic Analysis Sorting cost model. How many compares and exchanges, or array accesses, for a sorting. Memory. There are sorting algorithms that sort in place (no extra memory except perhaps for a small function-call stack or a constant number of instance variables), and those that need enough extra memory to hold another copy of the array to be sorted. Selection Sort Repeatedly selecting the smallest remaining item:\nFind the smallest item in the array, and exchange it with the first entry. Find the next smallest item and exchange it with the second entry. Continue until the entire array is sorted. Selection sort uses ~$n^2/2$ compares and n exchanges to sort an array of length n.\nInsertion Sort Works like people sort Pokers: consider the cards one at a time, inserting each into its proper place among those already considered (keeping them sorted). In a computer implementation, we need to make space for the current item by moving larger items one position to the right, before inserting the current item into the vacated position.\nFor randomly ordered arrays of length N with distinct keys, insertion sort uses ~$N^2/4$ compares and ~$N^2/4$ exchanges on the average. The worst case is ~ $N^2/2$ compares and ~ $N^2/2$ exchanges and the best case is $N-1$ compares and 0 exchanges.\nInsertion sort works well for certain types of nonrandom arrays that often arise in practice, even if they are huge. An inversion is a pair of keys that are out of order in the array. For instance, E X A M P L E has 11 inversions: E-A, X-A, X-M, X-P, X-L, X-E, M-L, M-E, P-L, P-E, and L-E. If the number of inversions in an array is less than a constant multiple of the array size, we say that the array is partially sorted.\nShellsort Shellsort gains speed by allowing exchanges of entries that are far apart, to produce partially sorted arrays that can be efficiently sorted, eventually by insertion sort.\nThe idea is to rearrange the array to give it the property that taking every $h_{th}$ entry (starting anywhere) yields a sorted sequence. Such an array is said to be h-sorted.By h-sorting for some large values of h, we can move entries in the array long distances and thus make it easier to h-sort for smaller values of h. Using such a procedure for any increment sequence of values of h that ends in 1 will produce a sorted array:\nThe number of compares used by shellsort with the increments 1, 4, 13, 40, 121, 364, … is O(N^{3/2}).\nMerge Sort Merging means combining two ordered arrays to make one larger ordered array. Merge sort is an utility of divide and conquer paradigm.\nMergesort guarantees to sort an array of N items in time proportional to $N \\log N$, no matter what the input. But it uses extra space proportional to N. Specifically, mergesort uses between $1/2 N \\lg N$ and $N \\lg N$ compares and at most $6 N \\lg N$ array accesses to sort any array of length N.\nAbstract in-place merge: The method merge(a, lo, mid, hi) in Merge.java puts the results of merging the subarrays a[lo..mid] with a[mid+1..hi] into a single ordered array, leaving the result in a[lo..hi]. While it would be desirable to implement this method without using a significant amount of extra space, such solutions are remarkably complicated.\npublic class Merge { private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { assert isSorted(a, lo, mid); // precondition: a[lo..mid] sorted assert isSorted(a, mid+1, hi); // precondition: a[mid+1..hi] sorted for (int k = lo; k \u003c= hi; k++) // copy aux[k] = a[k]; int i = lo, j = mid+1; for (int k = lo; k \u003c= hi; k++) // merge { if (i \u003e mid) a[k] = aux[j++]; else if (j \u003e hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } assert isSorted(a, lo, hi); // postcondition: a[lo..hi] sorted } private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid+1, hi); merge(a, aux, lo, mid, hi); } public static void sort(Comparable[] a) { aux = new Comparable[a.length]; sort(a, aux, 0, a.length - 1); } } } Proposition. Mergesort uses at most $N lg N$ compares and $6 N lg N$ array accesses to sort any array of size N. Mergesort uses extra space proportional to N\nA sorting algorithm is in-place if it uses $≤ c \\log N$ extra memory. Ex. Insertion sort, selection sort, shellsort.\nMergesort: Practical improvements Use insertion sort for small subarrays (7).\nprivate static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u003c= lo + CUTOFF - 1) { Insertion.sort(a, lo, hi); return; } int mid = lo + (hi - lo) / 2; sort (a, aux, lo, mid); sort (a, aux, mid+1, hi); merge(a, aux, lo, mid, hi); } Stop if already sorted: Is biggest item in first half ≤ smallest item in second half?\nprivate static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort (a, aux, lo, mid); sort (a, aux, mid+1, hi); if (!less(a[mid+1], a[mid])) return; merge(a, aux, lo, mid, hi); } Eliminate the copy to the auxiliary array. Save time (but not space) by switching the role of the input and auxiliary array in each recursive call.\nprivate static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) { int i = lo, j = mid+1; for (int k = lo; k \u003c= hi; k++) // merge from a[] to aux[] { if (i \u003e mid) aux[k] = a[j++]; else if (j \u003e hi) aux[k] = a[i++]; else if (less(a[j], a[i])) aux[k] = a[j++]; else aux[k] = a[i++]; } } private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) { if (hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; // switch roles of aux[] and a[] sort (aux, a, lo, mid); sort (aux, a, mid+1, hi); merge(a, aux, lo, mid, hi); } Top-down mergesort A recursive mergesort implementation based on this abstract in-place merge. Bottom-up mergesort Do all the merges of tiny arrays on one pass, then do a second pass to merge those arrays in pairs, and so forth, continuing until we do a merge that encompasses the whole array.\nWe start by doing a pass of 1-by-1 merges then a pass of 2-by-2 merges (merge subarrays of size 2 to make subarrays of size 4), then 4-by-4 merges, and so forth. Proposition: No compare-based sorting algorithm can guarantee to sort N items with fewer than $lg(N!)$ ~ $N \\lg N$ compares. Proposition. Mergesort is an asymptotically optimal compare-based sorting algorithm. That is, both the number of compares used by mergesort in the worst case and the minimum number of compares that any compare-based sorting algorithm can guarantee are ~N lg N.\npublic class MergeBU { private static void merge(...) { /* as before */ } public static void sort(Comparable[] a) { int N = a.length; Comparable[] aux = new Comparable[N]; for (int sz = 1; sz \u003c N; sz = sz+sz) for (int lo = 0; lo \u003c N-sz; lo += sz+sz) merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1)); } } About 10% slower than recursive, top-down mergesort on typical systems\nMergesort Applications Java sort for objects. Perl, C++ stable sort, Python stable sort, Firefox JavaScript, …\nCounting inversions: An inversion in an array a[] is a pair of entries a[i] and a[j] such that i \u003c j but a[i] \u003e a[j]. Given an array, design a linearithmic algorithm to count the number of inversion.\n在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007\npublic int InversePairs(int [] array) { int len = array.length; int[] aux = new int[len]; for (int k = 0; k \u003c len; k++) // copy aux[k] = array[k]; return InversePairsSort(array, aux, 0, len - 1); } private int InversePairsSort(int[] a, int[] b, int s, int e) { if (e \u003c= s) return 0; int mid = (e + s) / 2; int n1 = InversePairsSort(b, a, s, mid) % 1000000007; int n2 = InversePairsSort(b, a, mid + 1, e) % 1000000007; return (n1 + n2 + InversePairsMerge(a, b, s, mid, e)) % 1000000007; } private int InversePairsMerge(int[] a, int[] b, int s, int mid, int e) { int i = mid, j = e, n = 0; for (int k = e; k \u003e= s; k--) {// merge from a to b if (i \u003c s) b[k] = a[j--]; else if (j \u003c= mid) b[k] = a[i--]; else if (a[i] \u003e a[j]) { n += j - mid; if(n \u003e= 1000000007)//数值过大求余 n %= 1000000007; b[k] = a[i--]; } else b[k] = a[j--]; } return n; } count while mergesorting.\nShuffling a linked list: Given a singly-linked list containing n items, rearrange the items uniformly at random. Your algorithm should consume a logarithmic (or constant) amount of extra memory and run in time proportional to $n \\log n$ in the worst case:\nDesign a linear-time subroutine that can take two uniformly shuffled linked lists of sizes $n_1$ and $n_2$ and combined them into a uniformly shuffled linked lists of size $n_1 + n_2$.\nQuick Sort Basic plan:\nShuffle the array: Random shuffle. Probabilistic guarantee against worst case. Partition so that, for some j entry a[j] is in place no larger entry to the left of j no smaller entry to the right of j Sort each piece recursively Patition:\nRepeat until i and j pointers cross. Scan i from left to right so long as (a[i] \u003c a[lo]) Scan j from right to left so long as (a[j] \u003e a[lo]) Exchange a[i] with a[j] When pointers cross. Exchange a[lo] with a[j] public class Quick { // return index of item now known to be in place private static int partition(Comparable[] a, int lo, int hi) { int i = lo, j = hi+1; while (true) { while (less(a[++i], a[lo])) // find item on left to swap if (i == hi) break; while (less(a[lo], a[--j])) // find item on right to swap if (j == lo) break; if (i \u003e= j) break; // check if pointers cross exch(a, i, j); } exch(a, lo, j); // swap with partitioning item return j; } private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); } public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } } Best case. Number of compares is ~ $N \\lg N$ Worst case. Number of compares is ~ $½N^2$ Average case. Number of compares is ~ $1.39 N \\lg N$, 39% more compares than mergesort. But faster than mergesort in practice because of less data movement.\nQuicksort: practical improvements Insertion sort small subarrays (10 items), could delay insertion sort until one pass at end.\nprivate static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo + CUTOFF - 1) { Insertion.sort(a, lo, hi); return; } int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); } Median of sample: Best choice of pivot item = median. Estimate true median by taking median of sample. Median-of-3 (random) items\nprivate static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int m = medianOf3(a, lo, lo + (hi - lo)/2, hi); swap(a, lo, m); int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); } Quicksort with duplicate keys ・Algorithm goes quadratic unless partitioning stops on equal keys! ・1990s C user found this defect in qsort() Mistake. Put all items equal to the partitioning item on one side. Consequence. ~ $½N^2$ compares when all keys equal. Recommended. Stop scans on items equal to the partitioning item. Consequence. ~ $N \\lg N$ compares when all keys equal.\n3-way partitioning: Dutch national flag problem. Partition array into 3 parts so that: ・Entries between lt and gt equal to partition item v. ・No larger entries to left of lt. ・No smaller entries to right of gt.\nLet v be partitioning item a[lo] Scan i from left to right. (a[i] \u003c v): exchange a[lt] with a[i]; increment both lt and i (a[i] \u003e v): exchange a[gt] with a[i]; decrement gt (a[i] == v): increment i private static void sort(Comparable[] a, int lo, int hi) { if (hi \u003c= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo; while (i \u003c= gt) { int cmp = a[i].compareTo(v); if (cmp \u003c 0) exch(a, lt++, i++); else if (cmp \u003e 0) exch(a, i, gt--); else i++; } sort(a, lo, lt - 1); sort(a, gt + 1, hi); } Quicksort Applications Java sort for primitive types. C qsort, Unix, Visual C++, Python, Matlab, Chrome JavaScript, …\nSelection: Order statistics, Find the “top k.” Given an array of N items, find a $k^{th}$ smallest item. Ex. Min(k = 0), max(k = N - 1), median(k = N/2).\nQuick-select\nPartition array so that: Entry a[j] is in place No larger entry to the left of j No smaller entry to the right of j Repeat in one subarray, depending on j; finished when j equals k. public static Comparable select(Comparable[] a, int k) { StdRandom.shuffle(a); int lo = 0, hi = a.length - 1; while (hi \u003e lo) { int j = partition(a, lo, hi); if (j \u003c k) lo = j + 1; else if (j \u003e k) hi = j - 1; else return a[k]; } return a[k]; } Quick-select takes linear time on average.\nPriority Queues 优先队列可用于快速地（O(1)）返回最大或者最小的值。\npublic class MaxPQ","wordCount":"3473","inLanguage":"en","datePublished":"2018-01-01T00:00:00Z","dateModified":"2018-01-01T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/algorithms-princeton/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Algorithms - Princeton</h1><div class=post-meta><span title='2018-01-01 00:00:00 +0000 UTC'>2018-01-01</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/algorithms.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#unionfind aria-label=Union−Find>Union−Find</a></li><li><a href=#element-sort aria-label="Element Sort">Element Sort</a><ul><li><a href=#selection-sort aria-label="Selection Sort">Selection Sort</a></li><li><a href=#insertion-sort aria-label="Insertion Sort">Insertion Sort</a></li><li><a href=#shellsort aria-label=Shellsort>Shellsort</a></li></ul></li><li><a href=#merge-sort aria-label="Merge Sort">Merge Sort</a><ul><li><a href=#mergesort-practical-improvements aria-label="Mergesort: Practical improvements">Mergesort: Practical improvements</a></li><li><a href=#top-down-mergesort aria-label="Top-down mergesort">Top-down mergesort</a></li><li><a href=#bottom-up-mergesort aria-label="Bottom-up mergesort">Bottom-up mergesort</a></li><li><a href=#mergesort-applications aria-label="Mergesort Applications">Mergesort Applications</a></li></ul></li><li><a href=#quick-sort aria-label="Quick Sort">Quick Sort</a><ul><li><a href=#quicksort-practical-improvements aria-label="Quicksort: practical improvements">Quicksort: practical improvements</a></li><li><a href=#quicksort-with-duplicate-keys aria-label="Quicksort with duplicate keys">Quicksort with duplicate keys</a></li><li><a href=#quicksort-applications aria-label="Quicksort Applications">Quicksort Applications</a></li></ul></li><li><a href=#priority-queues aria-label="Priority Queues">Priority Queues</a><ul><li><a href=#binary-heap aria-label="Binary Heap">Binary Heap</a></li><li><a href=#heap-sort aria-label="Heap Sort">Heap Sort</a></li></ul></li><li><a href=#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%b1%87%e6%80%bb%e6%af%94%e8%be%83 aria-label=排序算法汇总比较>排序算法汇总比较</a></li><li><a href=#pigeonhole-sort aria-label="Pigeonhole sort">Pigeonhole sort</a></li><li><a href=#bucket-sort aria-label="Bucket sort">Bucket sort</a></li><li><a href=#graph aria-label=Graph>Graph</a></li></ul></div></details></div><div class=post-content><ul><li>Algorithms, Part I, <a href=https://online.princeton.edu/course/algorithms-part-i>https://online.princeton.edu/course/algorithms-part-i</a></li><li>Algorithms, Part II, <a href=https://online.princeton.edu/course/algorithms-part-ii>https://online.princeton.edu/course/algorithms-part-ii</a></li><li>Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne <a href=https://algs4.cs.princeton.edu/>https://algs4.cs.princeton.edu/</a></li></ul><h2 id=unionfind>Union−Find<a hidden class=anchor aria-hidden=true href=#unionfind>#</a></h2><p>Considering the dynamic connectivity problem, modeling of multiple objects connected in a space/network.</p><p>Applications involve manipulating objects of all types.
・Pixels in a digital photo.
・Computers in a network.
・Friends in a social network.
・Transistors in a computer chip.</p><p>Given a set of N objects.</p><ul><li><code>union(a, b)</code>: connect two objects.</li><li><code>connected(p, q)</code>: is two objects connected?</li><li><code>find(p)</code>: Find component identifier for <code>p</code> (0 to N – 1)</li></ul><p>Modeling the objects: array.</p><p>Modeling the connections:
Maximal set of objects that are mutually connected - Connected components.</p><p>Data structure:</p><ol><li><p>Quick find
Integer array <code>id[]</code> of length N, two objects are connected iff they have the same id.
<img loading=lazy src=https://algs4.cs.princeton.edu/15uf/images/quick-find-overview.png title="image from: https://algs4.cs.princeton.edu/">
Defect: <code>union</code> too expensive, $\in \Theta(N^2)$.</p></li><li><p>Quick-union
Integer array <code>id[]</code> of length N, <code>id[i]</code> is parent of i, root of i is <code>id[id[id[...id[i]...]]]</code> (until it doesn’t change).
<img loading=lazy src=https://algs4.cs.princeton.edu/15uf/images/quick-union-overview.png title="image from: https://algs4.cs.princeton.edu/">
The <code>find</code> is recursive.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=cm>/** chase parent pointers until reach root
</span></span></span><span class=line><span class=cl><span class=cm> * (depth of i array accesses) */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>find</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>id</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Defect: Trees can get tall, <code>find</code> too expensive, $\in \Theta(N)$.</p></li><li><p>Weighted quick-union
Modify quick-union to avoid tall trees. Balance by linking root of smaller tree to root of larger tree. Maintain extra array <code>sz[i]</code> to keep track of size of each tree (number of objects).
<img loading=lazy src=https://algs4.cs.princeton.edu/15uf/images/weighted-quick-union-overview.png title="image from: https://algs4.cs.princeton.edu/">
<code>find</code>: time proportional to depth of p and q, the depth of any node x is at most $\log N$,</p></li><li><p>Weighted quick-union with path compression
Making all the nodes that examined directly link to its root. Keeps tree almost completely flat.</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=cm>/** Make every other node in path point to its grandparent
</span></span></span><span class=line><span class=cl><span class=cm>* (thereby halving path length). */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>root</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>id</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>id</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=o>[</span><span class=n>id</span><span class=o>[</span><span class=n>i</span><span class=o>]]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><pre><code>Amortized analysis: `[Hopcroft-Ulman, Tarjan]` Starting from an empty data structure, any sequence of M union-find ops on N objects makes $≤ c ( N + M \lg \ast N )$ array accesses. $\lg \ast N$ is [Iterated logarithm](https://en.wikipedia.org/wiki/Iterated_logarithm), for $N = 2^{65536}$, $\lg \ast N = 5$. In theory, WQUPC is not quite linear. In practice, WQUPC is linear.
</code></pre><blockquote><p>Amazing fact. <code>[Fredman-Saks]</code> No linear-time algorithm exists.</p></blockquote><p><img loading=lazy src=https://algs4.cs.princeton.edu/15uf/images/uf-performance.png title="Summary. image from: https://algs4.cs.princeton.edu/"></p><h2 id=element-sort>Element Sort<a hidden class=anchor aria-hidden=true href=#element-sort>#</a></h2><p>Two elementary sorting methods: selection sort and insertion sort. Shellsort is a variation of one of them.</p><blockquote><p>The objective is to rearrange the items such that their keys are in ascending order.</p></blockquote><p>In Java, the abstract notion of a key is captured by the Comparable interface. The Comparable interface provides an elegant API for callback when Java need to compare keys.</p><p>Some background knowlege:</p><ul><li>Cost model, please refer to <a href=/NOTE-data-structures-efficient-programming#Asymptotic-Analysis>Asymptotic Analysis</a></li><li>Sorting cost model. How many compares and exchanges, or array accesses, for a sorting.</li><li>Memory. There are sorting algorithms that sort in place (no extra memory except perhaps for a small function-call stack or a constant number of instance variables), and those that need enough extra memory to hold another copy of the array to be sorted.</li></ul><h3 id=selection-sort>Selection Sort<a hidden class=anchor aria-hidden=true href=#selection-sort>#</a></h3><p>Repeatedly selecting the smallest remaining item:</p><ol><li>Find the smallest item in the array, and exchange it with the first entry.</li><li>Find the next smallest item and exchange it with the second entry.</li><li>Continue until the entire array is sorted.
<img loading=lazy src=https://algs4.cs.princeton.edu/21elementary/images/selection.png title="image from: https://algs4.cs.princeton.edu/"></li></ol><p>Selection sort uses ~$n^2/2$ compares and n exchanges to sort an array of length n.</p><h3 id=insertion-sort>Insertion Sort<a hidden class=anchor aria-hidden=true href=#insertion-sort>#</a></h3><p>Works like people sort Pokers: consider the cards one at a time, inserting each into its proper place among those already considered (keeping them sorted).
<img loading=lazy src=https://algs4.cs.princeton.edu/21elementary/images/insertion.png title="image from: https://algs4.cs.princeton.edu/">
In a computer implementation, we need to make space for the current item by moving larger items one position to the right, before inserting the current item into the vacated position.</p><blockquote><p>For randomly ordered arrays of length N with distinct keys, insertion sort uses ~$N^2/4$ compares and ~$N^2/4$ exchanges on the average. The worst case is ~ $N^2/2$ compares and ~ $N^2/2$ exchanges and the best case is $N-1$ compares and 0 exchanges.</p></blockquote><blockquote><p>Insertion sort works well for certain types of nonrandom arrays that often arise in practice, even if they are huge. An inversion is a pair of keys that are out of order in the array. For instance, E X A M P L E has 11 inversions: E-A, X-A, X-M, X-P, X-L, X-E, M-L, M-E, P-L, P-E, and L-E. If the number of inversions in an array is less than a constant multiple of the array size, we say that the array is partially sorted.</p></blockquote><h3 id=shellsort>Shellsort<a hidden class=anchor aria-hidden=true href=#shellsort>#</a></h3><p>Shellsort gains speed by allowing exchanges of entries that are far apart, to produce partially sorted arrays that can be efficiently sorted, eventually by insertion sort.</p><p>The idea is to rearrange the array to give it the property that taking every $h_{th}$ entry (starting anywhere) yields a sorted sequence. Such an array is said to be h-sorted.<img loading=lazy src=https://algs4.cs.princeton.edu/21elementary/images/h-sorted.png title="image from: https://algs4.cs.princeton.edu/">By h-sorting for some large values of h, we can move entries in the array long distances and thus make it easier to h-sort for smaller values of h. Using such a procedure for any increment sequence of values of h that ends in 1 will produce a sorted array:<img loading=lazy src=https://algs4.cs.princeton.edu/21elementary/images/shell.png title="image from: https://algs4.cs.princeton.edu/"></p><blockquote><p>The number of compares used by shellsort with the increments 1, 4, 13, 40, 121, 364, &mldr; is O(N^{3/2}).</p></blockquote><h2 id=merge-sort>Merge Sort<a hidden class=anchor aria-hidden=true href=#merge-sort>#</a></h2><p>Merging means combining two ordered arrays to make one larger ordered array. Merge sort is an utility of divide and conquer paradigm.</p><p>Mergesort guarantees to sort an array of N items in time proportional to $N \log N$, no matter what the input. But it uses extra space proportional to N. Specifically, mergesort uses between $1/2 N \lg N$ and $N \lg N$ compares and at most $6 N \lg N$ array accesses to sort any array of length N.</p><blockquote><p><strong>Abstract in-place merge</strong>: The method <code>merge(a, lo, mid, hi)</code> in <a href=https://algs4.cs.princeton.edu/22mergesort/Merge.java.html>Merge.java</a> puts the results of merging the subarrays <code>a[lo..mid]</code> with <code>a[mid+1..hi]</code> into a single ordered array, leaving the result in <code>a[lo..hi]</code>. While it would be desirable to implement this method without using a significant amount of extra space, such solutions are remarkably complicated.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Merge</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>merge</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>assert</span><span class=w> </span><span class=n>isSorted</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>);</span><span class=w>   </span><span class=c1>// precondition: a[lo..mid]   sorted</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>assert</span><span class=w> </span><span class=n>isSorted</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=o>+</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w> </span><span class=c1>// precondition: a[mid+1..hi] sorted</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>hi</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=c1>// copy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mid</span><span class=o>+</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>hi</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=c1>// merge</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>if</span><span class=w>      </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>mid</span><span class=p>)</span><span class=w>              </span><span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>               </span><span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>less</span><span class=p>(</span><span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>))</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>else</span><span class=w>                           </span><span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>assert</span><span class=w> </span><span class=n>isSorted</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>     </span><span class=c1>// postcondition: a[lo..hi] sorted</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=o>+</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>merge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>aux</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Comparable</span><span class=o>[</span><span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>Proposition. Mergesort uses at most $N lg N$ compares and $6 N lg N$ array accesses to sort any array of size N. Mergesort uses extra space proportional to N</p></blockquote><p>A sorting algorithm is in-place if it uses $≤ c \log N$ extra memory. Ex. Insertion sort, selection sort, shellsort.</p><h3 id=mergesort-practical-improvements>Mergesort: Practical improvements<a hidden class=anchor aria-hidden=true href=#mergesort-practical-improvements>#</a></h3><p>Use insertion sort for small subarrays (7).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>CUTOFF</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Insertion</span><span class=p>.</span><span class=na>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=o>+</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>merge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Stop if already sorted: Is biggest item in first half ≤ smallest item in second half?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=o>+</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>less</span><span class=p>(</span><span class=n>a</span><span class=o>[</span><span class=n>mid</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span><span class=p>))</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>merge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Eliminate the copy to the auxiliary array. Save time (but not space) by switching the role of the input and auxiliary array in each recursive call.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>merge</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mid</span><span class=o>+</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>hi</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=c1>// merge from a[] to aux[]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w>      </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>mid</span><span class=p>)</span><span class=w>          </span><span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>           </span><span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>less</span><span class=p>(</span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>))</span><span class=w> </span><span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>else</span><span class=w>                       </span><span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// switch roles of aux[] and a[]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=w> </span><span class=p>(</span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=w> </span><span class=p>(</span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=o>+</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>merge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=top-down-mergesort>Top-down mergesort<a hidden class=anchor aria-hidden=true href=#top-down-mergesort>#</a></h3><p>A recursive mergesort implementation based on this abstract in-place merge.
<img loading=lazy src=https://algs4.cs.princeton.edu/22mergesort/images/mergesortTD.png title="image from: https://algs4.cs.princeton.edu/"></p><h3 id=bottom-up-mergesort>Bottom-up mergesort<a hidden class=anchor aria-hidden=true href=#bottom-up-mergesort>#</a></h3><p>Do all the merges of tiny arrays on one pass, then do a second pass to merge those arrays in pairs, and so forth, continuing until we do a merge that encompasses the whole array.</p><ol><li>We start by doing a pass of 1-by-1 merges</li><li>then a pass of 2-by-2 merges (merge subarrays of size 2 to make subarrays of size 4),</li><li>then 4-by-4 merges, and so forth.</li></ol><blockquote><p>Proposition: No compare-based sorting algorithm can guarantee to sort N items with fewer than $lg(N!)$ ~ $N \lg N$ compares.
Proposition. Mergesort is an asymptotically optimal compare-based sorting algorithm. That is, both the number of compares used by mergesort in the worst case and the minimum number of compares that any compare-based sorting algorithm can guarantee are ~N lg N.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MergeBU</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>merge</span><span class=p>(...)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w> </span><span class=cm>/* as before */</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>aux</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Comparable</span><span class=o>[</span><span class=n>N</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>sz</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>sz</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=n>sz</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sz</span><span class=o>+</span><span class=n>sz</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>N</span><span class=o>-</span><span class=n>sz</span><span class=p>;</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>sz</span><span class=o>+</span><span class=n>sz</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>merge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=o>+</span><span class=n>sz</span><span class=o>-</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>min</span><span class=p>(</span><span class=n>lo</span><span class=o>+</span><span class=n>sz</span><span class=o>+</span><span class=n>sz</span><span class=o>-</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>N</span><span class=o>-</span><span class=n>1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>About 10% slower than recursive, top-down mergesort on typical systems</p><h3 id=mergesort-applications>Mergesort Applications<a hidden class=anchor aria-hidden=true href=#mergesort-applications>#</a></h3><p>Java sort for objects. Perl, C++ stable sort, Python stable sort, Firefox JavaScript, &mldr;</p><p>Counting inversions: An inversion in an array <code>a[]</code> is a pair of entries <code>a[i]</code> and <code>a[j]</code> such that <code>i &lt; j</code> but <code>a[i] > a[j]</code>. Given an array, design a linearithmic algorithm to count the number of inversion.</p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>InversePairs</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=o>[]</span><span class=w> </span><span class=n>array</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>array</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>aux</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>len</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>len</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=c1>// copy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>array</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>InversePairsSort</span><span class=p>(</span><span class=n>array</span><span class=p>,</span><span class=w> </span><span class=n>aux</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>InversePairsSort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>e</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>e</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>n1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>InversePairsSort</span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>1000000007</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>n2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>InversePairsSort</span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>1000000007</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=n>n1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>n2</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>InversePairsMerge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=n>e</span><span class=p>))</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>1000000007</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>InversePairsMerge</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mid</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>s</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=o>--</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=c1>// merge from a to b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>           </span><span class=n>b</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>--]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>mid</span><span class=p>)</span><span class=w>   </span><span class=n>b</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>--]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                             </span><span class=n>n</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>mid</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                             </span><span class=k>if</span><span class=p>(</span><span class=n>n</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>1000000007</span><span class=p>)</span><span class=c1>//数值过大求余</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                 </span><span class=n>n</span><span class=w> </span><span class=o>%=</span><span class=w> </span><span class=n>1000000007</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                             </span><span class=n>b</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>--]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=w>                 </span><span class=n>b</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>--]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>count while mergesorting.</p><p>Shuffling a linked list: Given a singly-linked list containing n items, rearrange the items uniformly at random. Your algorithm should consume a logarithmic (or constant) amount of extra memory and run in time proportional to $n \log n$ in the worst case:</p><blockquote><p>Design a linear-time subroutine that can take two uniformly shuffled linked lists of sizes $n_1$ and $n_2$ and combined them into a uniformly shuffled linked lists of size $n_1 + n_2$.</p></blockquote><h2 id=quick-sort>Quick Sort<a hidden class=anchor aria-hidden=true href=#quick-sort>#</a></h2><p>Basic plan:</p><ul><li>Shuffle the array: Random shuffle. Probabilistic guarantee against worst case.</li><li>Partition so that, for some j<ul><li>entry <code>a[j]</code> is in place</li><li>no larger entry to the left of j</li><li>no smaller entry to the right of j</li></ul></li><li>Sort each piece recursively</li></ul><p>Patition:</p><ul><li>Repeat until i and j pointers cross.<ul><li>Scan i from left to right so long as (<code>a[i] &lt; a[lo]</code>)</li><li>Scan j from right to left so long as (<code>a[j] > a[lo]</code>)</li><li>Exchange <code>a[i]</code> with <code>a[j]</code></li></ul></li><li>When pointers cross. Exchange <code>a[lo]</code> with <code>a[j]</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Quick</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// return index of item now known to be in place</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>partition</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hi</span><span class=o>+</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>less</span><span class=p>(</span><span class=n>a</span><span class=o>[++</span><span class=n>i</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>lo</span><span class=o>]</span><span class=p>))</span><span class=w> </span><span class=c1>// find item on left to swap</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w> </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>less</span><span class=p>(</span><span class=n>a</span><span class=o>[</span><span class=n>lo</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=o>[--</span><span class=n>j</span><span class=o>]</span><span class=p>))</span><span class=w> </span><span class=c1>// find item on right to swap</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=k>break</span><span class=p>;</span><span class=w>          </span><span class=c1>// check if pointers cross</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=n>exch</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>exch</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=p>);</span><span class=w>                </span><span class=c1>// swap with partitioning item</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>return</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>partition</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=o>-</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=o>+</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>StdRandom</span><span class=p>.</span><span class=na>shuffle</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Best case. Number of compares is ~ $N \lg N$
Worst case. Number of compares is ~ $½N^2$
Average case. Number of compares is ~ $1.39 N \lg N$, 39% more compares than mergesort. But <strong>faster</strong> than mergesort in practice because of <strong>less data movement</strong>.</p><h3 id=quicksort-practical-improvements>Quicksort: practical improvements<a hidden class=anchor aria-hidden=true href=#quicksort-practical-improvements>#</a></h3><p>Insertion sort small subarrays (10 items), could delay insertion sort until one pass at end.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>CUTOFF</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Insertion</span><span class=p>.</span><span class=na>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>partition</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=o>-</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=o>+</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Median of sample:
Best choice of pivot item = median. Estimate true median by taking median of sample. Median-of-3 (random) items</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>medianOf3</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=o>/</span><span class=n>2</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>swap</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>m</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>partition</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=o>-</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=o>+</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=quicksort-with-duplicate-keys>Quicksort with duplicate keys<a hidden class=anchor aria-hidden=true href=#quicksort-with-duplicate-keys>#</a></h3><p>・Algorithm goes quadratic unless partitioning stops on equal keys!
・1990s C user found this defect in qsort()
Mistake. Put all items equal to the partitioning item on one side.
Consequence. ~ $½N^2$ compares when all keys equal.
Recommended. Stop scans on items equal to the partitioning item.
Consequence. ~ $N \lg N$ compares when all keys equal.</p><p>3-way partitioning: Dutch national flag problem.
Partition array into 3 parts so that:
・Entries between lt and gt equal to partition item v.
・No larger entries to left of lt.
・No smaller entries to right of gt.</p><ul><li>Let v be partitioning item <code>a[lo]</code></li><li>Scan i from left to right.<ul><li>(<code>a[i] &lt; v</code>): exchange <code>a[lt]</code> with <code>a[i]</code>; increment both <code>lt</code> and <code>i</code></li><li>(<code>a[i] > v</code>): exchange <code>a[gt]</code> with <code>a[i]</code>; decrement <code>gt</code></li><li>(<code>a[i] == v</code>): increment <code>i</code></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>hi</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>lt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>gt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>hi</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>Comparable</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>lo</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lo</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>gt</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>cmp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>.</span><span class=na>compareTo</span><span class=p>(</span><span class=n>v</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w>      </span><span class=p>(</span><span class=n>cmp</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=n>exch</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lt</span><span class=o>++</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>cmp</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=n>exch</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>gt</span><span class=o>--</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>else</span><span class=w>              </span><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>lt</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>gt</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=quicksort-applications>Quicksort Applications<a hidden class=anchor aria-hidden=true href=#quicksort-applications>#</a></h3><p>Java sort for primitive types. C qsort, Unix, Visual C++, Python, Matlab, Chrome JavaScript, &mldr;</p><p>Selection: Order statistics, Find the &ldquo;top k.&rdquo;
Given an array of N items, find a $k^{th}$ smallest item. Ex. Min(k = 0), max(k = N - 1), median(k = N/2).</p><p>Quick-select</p><ul><li>Partition array so that:<ul><li>Entry <code>a[j]</code> is in place</li><li>No larger entry to the left of j</li><li>No smaller entry to the right of j</li></ul></li><li>Repeat in <strong>one</strong> subarray, depending on j; finished when j equals k.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Comparable</span><span class=w> </span><span class=nf>select</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>StdRandom</span><span class=p>.</span><span class=na>shuffle</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>hi</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>lo</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>partition</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>lo</span><span class=p>,</span><span class=w> </span><span class=n>hi</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w>      </span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=n>lo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=n>hi</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>else</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Quick-select takes linear time on average.</p><h2 id=priority-queues>Priority Queues<a hidden class=anchor aria-hidden=true href=#priority-queues>#</a></h2><p>优先队列可用于快速地（O(1)）返回最大或者最小的值。</p><pre tabindex=0><code>public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;
{
    MaxPQ() create an empty priority queue
    MaxPQ(Key[] a) create a priority queue with given keys
    void insert(Key v) insert a key into the priority queue
    Key delMax() return and remove the largest key
    boolean isEmpty() is the priority queue empty?
    Key max() return the largest key
    int size() number of entries in the priority queue
}
</code></pre><p>应用:
・Event-driven simulation. [customers in a line, colliding particles]
・Numerical computation. [reducing roundoff error]
・Data compression. [Huffman codes]
・Graph searching. [Dijkstra&rsquo;s algorithm, Prim&rsquo;s algorithm]
・Number theory. [sum of powers]
・Artificial intelligence. [A* search]
・Statistics. [maintain largest M values in a sequence]
・Operating systems. [load balancing, interrupt handling]
・Discrete optimization. [bin packing, scheduling]
・Spam filtering. [Bayesian spam filter]</p><p>比如对于数据流, 需要用优先队列保存最大的M个值, 因为内存不足以储存数据流全部数据.</p><h3 id=binary-heap>Binary Heap<a hidden class=anchor aria-hidden=true href=#binary-heap>#</a></h3><p>Heap-ordered binary tree: 父节点比其所有子节点都大（或都小）。根节点为最大值的binary heap称之为最大堆, 根节点为最小值的称之为最小堆.</p><p>以最大堆为例, 使用数组来表达：</p><ul><li>索引从<code>1</code>开始, 按照层次遍历顺序存储节点.</li><li>最大值就是根节点<code>a[1]</code>\</li><li>可以使用数组索引遍历树<ul><li>节点<code>a[k]</code>的父节点是<code>a[k/2]</code></li><li>节点<code>a[k]</code>的子节点为<code>a[2k], a[2k+1]</code></li></ul></li></ul><p>当子节点的值比父节点大时, 需要不断调换二者的值, 直到不再有子节点比父节点大的情况存在:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>swim</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>k</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>less</span><span class=p>(</span><span class=n>k</span><span class=o>/</span><span class=n>2</span><span class=p>,</span><span class=w> </span><span class=n>k</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>exch</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>k</span><span class=o>/</span><span class=n>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>k</span><span class=o>/</span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>反之当父节点比子节点小时:不断把父节点和较大的子节点调换, 直到恢复 heap order:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sink</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>2</span><span class=o>*</span><span class=n>k</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=o>*</span><span class=n>k</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>less</span><span class=p>(</span><span class=n>j</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=o>+</span><span class=n>1</span><span class=p>))</span><span class=w> </span><span class=n>j</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>less</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=p>))</span><span class=w> </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>exch</span><span class=p>(</span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>j</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>插入操作, 需要先把新节点放在末端, 然后<code>swim</code>. 至多<code>1 + lgN</code>比较:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>insert</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>x</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>pq</span><span class=o>[++</span><span class=n>N</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>swim</span><span class=p>(</span><span class=n>N</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>删除操作, 需要把根节点和尾节点调换, 然后<code>sink</code>, 至多<code>2lgN</code>比较</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=n>Key</span><span class=w> </span><span class=nf>delMax</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>Key</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pq</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>exch</span><span class=p>(</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>N</span><span class=o>--</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>sink</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>pq</span><span class=o>[</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=n>max</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MaxPQ</span><span class=o>&lt;</span><span class=n>Key</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Comparable</span><span class=o>&lt;</span><span class=n>Key</span><span class=o>&gt;&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Key</span><span class=o>[]</span><span class=w> </span><span class=n>pq</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>MaxPQ</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>capacity</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>  </span><span class=n>pq</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Key</span><span class=o>[]</span><span class=p>)</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Comparable</span><span class=o>[</span><span class=n>capacity</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>isEmpty</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>insert</span><span class=p>(</span><span class=n>Key</span><span class=w> </span><span class=n>key</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Key</span><span class=w> </span><span class=nf>delMax</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>   </span><span class=cm>/* see previous code */</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>swim</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sink</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>   </span><span class=cm>/* see previous code */</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>less</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=n>pq</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>.</span><span class=na>compareTo</span><span class=p>(</span><span class=n>pq</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>exch</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>   </span><span class=n>Key</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pq</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=n>pq</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pq</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=n>pq</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如果要实现最小堆, 那么就用<code>greater()</code>替代<code>less()</code>
<img loading=lazy src=/images/priorityqueue.png title="不同数据结构实现的优先队列有不同的时间复杂度操作. image from: https://algs4.cs.princeton.edu/"></p><h3 id=heap-sort>Heap Sort<a hidden class=anchor aria-hidden=true href=#heap-sort>#</a></h3><p>可以使用heap数据结构来排序一个数组，核心步骤是两个</p><ol><li>创建一个最大堆</li><li>然后不断拿出当前最大值，放置于后面.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Heap</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// bottom-up方法创建堆,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 虽然是 heap order, 但不一定是sorted order</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>N</span><span class=o>/</span><span class=n>2</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=o>--</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>sink</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=n>N</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>N</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=w> </span><span class=c1>// 把当前最大值调换到N位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>exch</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>N</span><span class=p>);</span><span class=w> </span><span class=c1>// 最大值放在尾部</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>sink</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=o>--</span><span class=n>N</span><span class=p>);</span><span class=w> </span><span class=c1>// 恢复heap order</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sink</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>  </span><span class=cm>/* as before */</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>less</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>  </span><span class=cm>/* as before */</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>exch</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w>  </span><span class=cm>/* as before */</span><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>In-place sorting algorithm with N log N worst-case, but not stable</p></blockquote><h2 id=排序算法汇总比较>排序算法汇总比较<a hidden class=anchor aria-hidden=true href=#排序算法汇总比较>#</a></h2><p><img loading=lazy src=/images/sorting_summary.png title="image from: https://algs4.cs.princeton.edu/"></p><h2 id=pigeonhole-sort>Pigeonhole sort<a hidden class=anchor aria-hidden=true href=#pigeonhole-sort>#</a></h2><p>鸽巢排序(基数分类)</p><blockquote><p>Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements (n) and the length of the range of possible key values (N) are approximately the same. It requires O(n + N) time.</p></blockquote><ol><li>给定要排序的数组，设置一个辅助数组作为初始的空“鸽笼”，通过原始数组的范围为每个键值设置一个鸽笼。</li><li>遍历原始数组，将每个值放入与其键对应的鸽笼中，这样每个鸽笼最终都包含该键的所有值的列表。</li><li>按顺序迭代鸽笼数组，并将非空鸽笼中的元素依次放回原始数组中。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/* Java program to implement Pigeonhole Sort */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>GFG</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>pigeonhole_sort</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>arr</span><span class=o>[]</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>min</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>range</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>j</span><span class=p>,</span><span class=w> </span><span class=n>index</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=o>=</span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>a</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=w> </span><span class=n>a</span><span class=o>++</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>a</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>max</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>max</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>a</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>a</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>min</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>min</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>a</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>range</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>min</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>phole</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>range</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//Arrays.fill(phole, 0);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>phole</span><span class=o>[</span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>min</span><span class=o>]++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>range</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=o>++</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=p>(</span><span class=n>phole</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>arr</span><span class=o>[</span><span class=n>index</span><span class=o>++]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>min</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>GFG</span><span class=w> </span><span class=n>sort</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>GFG</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=n>8</span><span class=p>,</span><span class=w> </span><span class=n>3</span><span class=p>,</span><span class=w> </span><span class=n>2</span><span class=p>,</span><span class=w> </span><span class=n>7</span><span class=p>,</span><span class=w> </span><span class=n>4</span><span class=p>,</span><span class=w> </span><span class=n>6</span><span class=p>,</span><span class=w> </span><span class=n>8</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&#34;Sorted order is : &#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>sort</span><span class=p>.</span><span class=na>pigeonhole_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=o>=</span><span class=n>0</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>&lt;</span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=n>arr</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; &#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>类似于counting sort<img loading=lazy src=/images/pidgeonholesort_countingsort.png title="image from https://www.geeksforgeeks.org/pigeonhole-sort/"></p><h2 id=bucket-sort>Bucket sort<a hidden class=anchor aria-hidden=true href=#bucket-sort>#</a></h2><p>桶排序(箱排序 bin sort)主要用于均匀分布区间值的排序，如浮点数排序，</p><blockquote><p>distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a distribution sort, a generalization of pigeonhole sort, and is a cousin of radix sort in the most-to-least significant digit flavor. Bucket sort can be implemented with comparisons and therefore can also be considered a comparison sort algorithm. The computational complexity estimates involve the number of buckets.</p></blockquote><p>Worst-case performance ${\displaystyle O(n^{2})}$
Best-case performance ${\displaystyle \Omega (n+k)}$
Average performance ${\displaystyle \Theta (n+k)}$</p><ol><li>设置一个初始为空的“桶”数组。</li><li>Scatter：遍历原始数组，将每个对象分发到桶中。</li><li>对每个非空桶进行排序。</li><li>Gather：按顺序访问桶并将所有元素放回原始数组中。</li></ol><h2 id=graph>Graph<a hidden class=anchor aria-hidden=true href=#graph>#</a></h2><p>图：由边连接的成对的顶点集。</p><p>无向图，有向图</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/software-engineer/>Software Engineer</a></li><li><a href=https://congchan.github.io/tags/java/>Java</a></li><li><a href=https://congchan.github.io/tags/algs4/>Algs4</a></li><li><a href=https://congchan.github.io/tags/algorithms/>Algorithms</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96/><span class=title>« Prev</span><br><span>信息抽取</span>
</a><a class=next href=https://congchan.github.io/posts/bash-%E7%9B%B4%E6%8E%A5%E5%90%AF%E5%8A%A8-sublime-%E6%88%96-atom-%E7%AD%89%E7%BC%96%E8%BE%91%E5%99%A8%E4%BB%A5%E6%89%93%E5%BC%80%E6%88%96%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6/><span class=title>Next »</span><br><span>Bash 直接启动 sublime 或 atom 等编辑器以打开或新建文件</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms - Princeton on x" href="https://x.com/intent/tweet/?text=Algorithms%20-%20Princeton&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2falgorithms-princeton%2f&amp;hashtags=SoftwareEngineer%2cJava%2calgs4%2cAlgorithms"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms - Princeton on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2falgorithms-princeton%2f&amp;title=Algorithms%20-%20Princeton&amp;summary=Algorithms%20-%20Princeton&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2falgorithms-princeton%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms - Princeton on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2falgorithms-princeton%2f&title=Algorithms%20-%20Princeton"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms - Princeton on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2falgorithms-princeton%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms - Princeton on whatsapp" href="https://api.whatsapp.com/send?text=Algorithms%20-%20Princeton%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2falgorithms-princeton%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms - Princeton on telegram" href="https://telegram.me/share/url?text=Algorithms%20-%20Princeton&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2falgorithms-princeton%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms - Princeton on ycombinator" href="https://news.ycombinator.com/submitlink?t=Algorithms%20-%20Princeton&u=https%3a%2f%2fcongchan.github.io%2fposts%2falgorithms-princeton%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>