<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Inf Course Note - Software Architecture, Process, and Management | Cong's Log</title><meta name=keywords content="Software Engineer,Inf Course Note"><meta name=description content="爱丁堡大学信息学院课程笔记 Software Architecture, Process, and Management, Informatics, University of Edinburgh
Reference:
microsoft
IBM
Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman

What is Software Architecture?
Software architecture is often described as the organization or structure of a system, where the system represents a collection of components that accomplish a specific function or set of functions.

grouping components into areas of concern (layers): For example, the UI, business processing, and data access.
focus on interaction between the components and how different components work together.

在书中的定义："><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/inf-course-note-software-architecture-process-and-management/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/inf-course-note-software-architecture-process-and-management/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/inf-course-note-software-architecture-process-and-management/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="Inf Course Note - Software Architecture, Process, and Management"><meta property="og:description" content="爱丁堡大学信息学院课程笔记 Software Architecture, Process, and Management, Informatics, University of Edinburgh
Reference: microsoft IBM Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman
What is Software Architecture? Software architecture is often described as the organization or structure of a system, where the system represents a collection of components that accomplish a specific function or set of functions.
grouping components into areas of concern (layers): For example, the UI, business processing, and data access. focus on interaction between the components and how different components work together. 在书中的定义："><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-30T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-30T00:00:00+00:00"><meta property="article:tag" content="Software Engineer"><meta property="article:tag" content="Inf Course Note"><meta name=twitter:card content="summary"><meta name=twitter:title content="Inf Course Note - Software Architecture, Process, and Management"><meta name=twitter:description content="爱丁堡大学信息学院课程笔记 Software Architecture, Process, and Management, Informatics, University of Edinburgh
Reference:
microsoft
IBM
Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman

What is Software Architecture?
Software architecture is often described as the organization or structure of a system, where the system represents a collection of components that accomplish a specific function or set of functions.

grouping components into areas of concern (layers): For example, the UI, business processing, and data access.
focus on interaction between the components and how different components work together.

在书中的定义："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Inf Course Note - Software Architecture, Process, and Management","item":"https://congchan.github.io/posts/inf-course-note-software-architecture-process-and-management/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Inf Course Note - Software Architecture, Process, and Management","name":"Inf Course Note - Software Architecture, Process, and Management","description":"爱丁堡大学信息学院课程笔记 Software Architecture, Process, and Management, Informatics, University of Edinburgh\nReference: microsoft IBM Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman\nWhat is Software Architecture? Software architecture is often described as the organization or structure of a system, where the system represents a collection of components that accomplish a specific function or set of functions.\ngrouping components into areas of concern (layers): For example, the UI, business processing, and data access. focus on interaction between the components and how different components work together. 在书中的定义：\n","keywords":["Software Engineer","Inf Course Note"],"articleBody":"爱丁堡大学信息学院课程笔记 Software Architecture, Process, and Management, Informatics, University of Edinburgh\nReference: microsoft IBM Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman\nWhat is Software Architecture? Software architecture is often described as the organization or structure of a system, where the system represents a collection of components that accomplish a specific function or set of functions.\ngrouping components into areas of concern (layers): For example, the UI, business processing, and data access. focus on interaction between the components and how different components work together. 在书中的定义：\nThe software architecture of a system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both. – Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman\n架构的关注点在于系统内各个应用和模块的交互和调用。软件架构的设计，需要考虑满足什么样的需求（用户或甲方），如何解决和优化问题（不同的方向各有偏重），操作中如何做选择（在不同的方面平衡，妥协）。\nArchitecture and design concerns very often overlap - The selection of data structures and algorithms or the implementation details of individual components are design concerns.\n没必要强硬区分二者，而应该综合起来看待。某些情况下，决策是自然而然的结构层面的；在某些情况下，决策更多是关于于设计层面，以及设计如何帮助实现架构。\n软件架构的定义有如下隐含意思： 1, Architecture Is a Set of Software Structures Three frequently occurring types of structure: – Modular structure: static structure that focus on how functionality is divided up, structured, and assigned to development and implementation teams. – Component and Connector structure: runtime structures that focus on how components interact (e.g. information passing, synchronisation, interference,…) – Allocation structures: mapping to organizational, development, installation, execution environments. (e.g. Components are deployed onto hardware to execute)\n2, Architecture Is an abstraction Architecture specifcally omits certain information about elements that is not useful for reasoning about the system - in particular, it omits information that has no ramifcations outside of a single element.\n3, Every Software System Has a Software architecture\n4, Architecture Includes behavior Behavior embodies how elements interact with each other.\n在本课程, 一个软件项目成功与否, 基于如下三点考量: – The software is delivered on schedule – Development costs were within budget – The software meets the needs of users\nContexts for Software Architecture Technical: where architecture supports technical activity like measurement, V\u0026V, compliance,… Controlling Quality Attributes Availability - ensuring there is a system to take over if a system fails. Safety - ensuring that the system only behaves as intended and has no additonal behaviour. Testability - ensuring: elements are clearly able to be isolated we know what behaviour to expect of components of the system we know how components relate to modules so we can track down faulty code We know how components are intended to integrate to give the overall behaviour Other qa: performance, usability, interoperability,.. Design - Patterns, Styles, Domain Specific Architecture (DSSA) A DSSA is collection of (pre-decided) design decisions that: Capture important aspects of particular tasks (domain), Common across a range of systems in the domain Typically they will have some predefined structures These are not general purpose because they incorporate many specific characteristics of the domain. Architectural pattern is a set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears. Similar to DSSAs but capture less of the behaviour and attributes of the system More general because they are intended to abstract a common pattern over several domains. Three-Tiered Pattern: State(database)-Logic(Business)-Display(UI) Model-View-Controller (MVC): to separate between information, presentation and user interaction. Sense-Compute-Control: Structuring embedded control applications Project lifecycle: where architecture interacts with and supports development process Lifecycle Models: V-model, iterative models (Boehm’s spiral model), Agile Business: where architecture supports organisations, e.g. customer organisations and development organisations. Professional: where the role of architect defines requirements and constraints on architects. Quality Attributes (QA) Architecture is the right level of abstraction to resolve conflicts between Stakeholders.\nQuality Attributes specify, usually quantitative, requirements on particular bits of functionality or on the whole systems (e.g. that the system should be available 99% of the time).\nProblems With QA 1, Often QA requirements are not “testable”, for example modifiable, usable, dependable or resilient. 2, It can be difficult to map from a concern about the system to a QA. For example, a high failure rate in some transaction could be a performance issue or it could be an availability issue. 3, Communities around a particular quality attribute have developed their own terminology (e.g. security has attacks, performance has events, etc).\nThe solution for 1 and 2 is to use quality attribute scenarios to provide sufficient specificity to avoid some of these issues.\nQuality Attributes Scenarios 场景 A quality attribute requirement should be unambiguous and testable. To specify quality attribute requirements, we capture them formally as six-part scenarios:\nSource of stimulus. This is some entity (a human, a computer system, or a system administrator) that generated the stimulus. Stimulus. A condition (event) that requires a response when it arrives at a system. e.g. a user operation to the usability community, or an attack to the security community. Environment. The stimulus occurs under certain conditions. The system may be in an overload condition or in normal operation. For many systems, “normal” operation can refer to one of a number of modes. For these kinds of systems, the environment should specify in which mode the system is executing. Artifact. A collection of systems, the whole system, or part of the system that is stimulated e.g. the configuration checker in the system. Response. The response is the activity undertaken as the result of the arrival of the stimulus. e.g. the configuration issue is identified and then repaired. Response measure. how to measure the response so the scenario is testable. e.g. time to detect the wrong configuration and the time to repair. Each QA has a General Scenario associated with it that tries to capture the possible components involved in that particular QA. This acts as a template or guide for the architect specifying a specific QA Scenario.\nSpecific QA Scenarios take account of specific stimuli and measures on response, they capture the specification of the QA for a particular system.\nAchieving QA through tactics Architectural tactics are design decisions to achieve the required quality attributes, more specifcally, to control responses to stimuli.\nThe focus of a tactic is on a single quality attribute response. Within a tactic, there is no consideration of tradeoffs (differ from architectural patterns, where tradeoffs are built into the pattern).\nBy cataloging tactics, we provide a way of making design more systematic within some limitations.\nAn architecture can be viewed as the result of applying a collection of design decisions. A systematic categorization of these decisions:\nAllocation of responsibilities 责任分配: Identifying the important responsibilities, and determining how these responsibilities are allocated to static and runtime elements (namely, modules, components, and connectors). Coordination model 模型协调 - Components in the architecture interact with one another via a collection of mechanisms. What elements in the system need to coordinate with one another. What properties the coordination needs to have (e.g. timing properties, security of coordination, …) Choosing the mechanisms (ideally a small number) that realize properties like statefulness, synchrony, delivery guarantees, performance. Data model: Every system must represent artifacts of system-wide interest—data—in some internal fashion Choosing abstractions, operations, and properties. How data is created and destroyed, access methods, … Maintaining metadata that controls the interpretation of the data. Organising the data, what kind of system will be used to store it, how will it be backed up, how do we recover from data loss Management of resources: hard (CPU, memory, battery, I/O ports…) or soft resources(system locks, software buffers, thread pools…): Identifying resources to be managed What system element should manage a resource 资源共享策略和争端仲裁 Work out sharing strategies and how to arbitrate in contention situations Consider the consequences of resource starvation(e.g. Memory). Mapping among architectural elements two important types of mapping: Mapping between different types of elements in the architecture, e.g. from static development structures (modules) to execution elements e.g. threads or processes. Mappings between software elements and environment elements, e.g. from processes to specific processors and other hardware. Useful mappings include: code to runtime structure; runtime elements to environment; data model elements to data stores. Binding time decisions: introduce allowable ranges of variation. This variation can range from design time by a designer to runtime by an end user might allocate a responsibility. The decisions in the other six categories have an associated binding time decision: we might want some variability in the resources to be managed determined at run time or we might make the coordination model negotiable at runtime if we want to inter-operate with a range of systems. Choice of technology: critical to being able to realize all the other decisions in a concrete system. What technologies are available What tools are available to support technologies How much training will it take to be able to use a technology? What are the full range of consequences of the choice of a technology (e.g. it may restrict markets because it is incompatible with some other technologies). If the technology is new, how does it fit into the existing preferred technologies for the organisation. Availability Availability refers to a property of software that it is there and ready to carry out its task when you need it to be. The availability of a system is usually defined to be the probability it will be there when you ask it to work: $\\frac{mtbf}{mtbf+mttr}$\n$mtbf$ – mean time between failures: MTBF of a component is the sum of the lengths of the operational periods divided by the number of observed failures: $mtbf = \\frac{t}{N(t)}$, $t$ is the cumulative operating time, $N(t)$ is the observed number of failures by time $t$. 假设恒定的故障率 $\\lambda$，则 $mtbf = \\frac{1}{\\lambda}$\n$mttr$ – mean time to repair\nAvailability measures the quality of service in terms of running versus down time\nReliability indicates the fraction of all attempted operations that complete successfully. The reliability of the system is: $R(t) = e^{-\\lambda t}$ where the parameter $\\lambda$ is called the failure rate. 由于MTBF主要针对可以修复的系统，因此建议针对不可修复的系统（在故障后选择更换而不是修复系统的情况）使用平均故障时间（MTTF），在数学上二者是等价的。 MTTF: Mean Time To (first) Failure, or Expected Life. $ MTTF = E(t_f) = \\int_0^\\infty R(t)dt = \\frac{1}{\\lambda}$\nFaults, Errors, Failures: A fault is something in the system (e.g. failed component, wrong bit of code,…) that can cause the system to move into an error state when the fault is activated, an error may then eventually cause an externally observable deviation from the intended operation - failure.\nGeneric Scenario Design Checklist for Availability Allocation of Responsibilities ■ Determine the system responsibilities that need to be highly available. ■ Within those responsibilities, ensure that additional responsibilities have been allocated to detect an omission, crash, incorrect timing, or incorrect response. ■ Additionally, ensure that there are responsibilities to do the following: • Log the fault • Notify appropriate entities (people or systems) • Disable the source of events causing the fault • Be temporarily unavailable • Fix or mask the fault/failure • Operate in a degraded mode\nCoordination Model Determine the system responsibilities that need to be highly available. With respect to those responsibilities, do the following: ■ Ensure that coordination mechanisms can detect an omission, crash, incorrect timing, or incorrect response. For example, whether guaranteed delivery is necessary. Will the coordination work under conditions of degraded communication? ■ Ensure that coordination mechanisms enable the logging of the fault, notification of appropriate entities, disabling of the source of the events causing the fault, fxing or masking the fault, or operating in a degraded mode. ■ Ensure that the coordination model supports the replacement of the artifacts used (processors, communications channels, persistent storage, and processes). For example, does replacement of a server allow the system to continue to operate? ■ Determine if the coordination will work under conditions of degraded communication, at startup/shutdown, in repair mode, or under overloaded operation. For example, how much lost information can the coordination model withstand and with what consequences?\nData Model ■ Determine which portions of the system need to be highly available. ■ Within those portions, determine which data abstractions, along with their operations or their properties, could cause a fault of omission, a crash, incorrect timing behavior, or an incorrect response. ■ For those data abstractions, operations, and properties, ensure that they can be disabled, be temporarily unavailable, or be fxed or masked in the event of a fault. ■ For example, ensure that write requests are cached if a server is temporarily unavailable and performed when the server is returned to service.\nMapping among Architectural Elements ■ Determine which artifacts (processors, communication channels, persistent storage, or processes) may produce a fault. ■ Ensure that the mapping (or remapping) of architectural elements is ﬂexible enough to permit the recovery from the fault. This may involve a consideration of the following: • Which processes on failed processors need to be reassigned at runtime • Which processors, data stores, or communication channels can be activated or reassigned at runtime • How data on failed processors or storage can be served by replacement units • How quickly the system can be reinstalled based on the units of delivery provided • How to (re)assign runtime elements to processors, communication channels, and data stores • When employing tactics that depend on redundancy of functionality, the mapping from modules to redundant components is important. For example, it is possible to write one module that contains code appropriate for both the active component and backup components in a protection group.\nResource Management ■ Determine what critical resources are necessary to continue operating in the presence of a fault. ■ Ensure there are suffcient remaining resources in the event of a fault to log the fault; notify appropriate entities (people or systems); disable the source of events causing the fault; be temporarily unavailable; fx or mask the fault/failure; operate normally, in startup, shutdown, repair mode, degraded operation, and overloaded operation. ■ Determine the availability time for critical resources, what critical resources must be available during specifed time intervals, time intervals during which the critical resources may be in a degraded mode, and repair time for critical resources. Ensure that the critical resources are available during these time intervals. ■ For example, ensure that input queues are large enough to buffer anticipated messages if a server fails so that the messages are not permanently lost.\nBinding Time ■ Determine how and when architectural elements are bound. ■ If late binding is used to alternate between components that can themselves be sources of faults (e.g., processes, processors, communication channels), ensure the chosen availability strategy is suffcient to cover faults introduced by all sources. ■ For example: • If late binding is used to switch between artifacts such as processors that will receive or be the subject of faults, will the chosen fault detection and recovery mechanisms work for all possible bindings? • If late binding is used to change the defnition or tolerance of what constitutes a fault (e.g., how long a process can go without responding before a fault is assumed), is the recovery strategy chosen suffcient to handle all cases? For example, if a fault is ﬂagged after 0.1 milliseconds, but the recovery mechanism takes 1.5 seconds to work, that might be an unacceptable mismatch. • What are the availability characteristics of the late binding mechanism itself? Can it fail?\nChoice of Technology ■ Determine the available technologies that can (help) detect faults, recover from faults, or reintroduce failed components. ■ Determine what technologies are available that help the response to a fault (e.g., event loggers). ■ Determine the availability characteristics of chosen technologies themselves: What faults can they recover from? What faults might they introduce into the system?\nPerformance To ensure resource is effectively monitored and managed.\nDesign Checklist for Performance Allocation of Responsibilities ■ Work out areas responsibility of that require heavy resource use to ensure time-critical events take place. ■ Work out processing requirements. ■ Take account of: • Responsibilites arising from threads crossing boundaries of responsibility • Responsibilities for thread management • Responsibilities for scheduling shared resources\nCoordination Model ■ What needs to coordinate. ■ Is there concurrency? Ensure it is safe. ■ Ensure coordination is appropriate for the style of stimulus. ■ Ensure the properties of the coordination model are good for the stimuli and concurrency control?\nData Model ■ Determine what parts of the data model will be heavily loaded or behaves tight time constraints. ■ For those data abstractions, determine: • Would keeping multiple copies help? • Would partitioning the data help? • Is it possible to reduce processing requirements for the data? • Does adding resource help deal with data bottlenecks?\nMapping Among Architecture Elements ■ Does colocation of some components reduce latencies? ■ Ensure components with high processing needs are allocated to big processors ■ Consider introducing concurrency when you map. ■ Consider whether some mappings introduce bottlenecks (e.g. allocating non-interfering tasks to the same thread)\nResource Management ■ Work out what needs high levels of resource ■ Ensure these are monitoredand managed under all operating modes. ■ For example: • Time critical components • Thread management • Prioritization • Locking and scheduling strategies • Deploying additional resource to meet elevated load.\nBinding time ■ Look at when you bind. ■ Consider the cost of binding at different times ■ Try to avoid performance penalties caused by late binding.\nChoice of Technology ■ Is the technology right to let you meet hard deadlines and resource use (e.g. use a real-time OS with proper scheduling). ■ Do you know its characteristics under load and its limits? ■ Does your choice of technology give you the ability to set the following: • Good scheduling • Priorities • Policies for demand reduction • Allocating processing to tasks • Other performance-related parameters. ■ Does your choice of technology introduce excessive overhead for heavily used operations?\nSecurity 最简单的表征安全的三个特征 - confdentiality, integrity, and availability (CIA):\n机密性 Confidentiality: Only those who should have access are given access. 完整性 Integrity: Data or services are not subject to unauthorised manipulation. 可用性 Availability: the system is available for legitimate use. 其他用于支撑 CIA 的特征: 4. 认证识别 Authentication verifes the identities of the parties to a transaction and checks if they are truly who they claim to be. 5. 不可否认性 Nonrepudiation guarantees that the sender of a message cannot later deny having sent the message, and that the recipient cannot deny having received the message. 6. 授权 Authorization grants a user the privileges to perform a task.\nSecurity General Scenario A Design Checklist for Security Allocation of Responsibilities ■ Ensure all actors have identities ■ Authenticate identities ■ Check authorizations ■ Ensure authorization is required for all such actors ■ Log attempts, successes and failures on all sensitive operations ■ Ensure data is encrypted ■ Ensure responsibilities are allocated to appropriate actors.\nCoordination Model ■ Ensure coordination mechanisms use authentication and authorisation. ■ Ensure coordination mechanisms are not vulnerable to impersonation, tampering, interception, … ■ Ensure data involved in coordination is protected using encryption. ■ Monitor level of demand for communication to identify excessive demands\nData Model ■ Ensure there is a valid data model that disallows invalid data flows. ■ Ensure logging of access, modification and attempted access or modification. ■ Data is protected in flight and at rest using appropriate encryption. ■ Ensure appropriate backup/recovery mechanisms are in place.\nMapping among Architectural Elements ■ Explore how different mappings change the way users can access resources. ■ Ensure for all of these mappings the models of access and authorisation are preserved. • Actors should be identified and authenticated • Use appropriate authorisation mechanisms • Ensure logging is enabled • Ensure data is protected by encryption • Recognise impact of attack on resources ■ Ensure recovery from attack is possible\nResource Management ■ Explore the overheads resulting from monitoring, detecting, preventing and recovering from attacks. ■ Analyse how a user can access and make demands on critical resources. ■ Manage resource access to ensure malicious use of resource is detected and managed. ■ Identify the potential for corruption/contamination and how to manage this. ■ Explore the potential for resource use to be used as a covert channel to transmit data. ■ Limit resources used to manage attempts at unauthorised use\nBinding Time ■ Explore the consequences of varying binding times on the ability to trust an actor or component. ■ Put in place appropriate mechanisms to ensure trust given binding time. ■ Explore potential impact on resource use, capacity/throughput, response time ■ Ensure appropriate encryption of all data around binding. ■ Explore the potential of variation in binding time as a covert channel.\nChoice of Technologies ■ Ensure limitations of technologies are understood and the potential for future compromise is well identified. ■ Ensure your chosen technologies support the tactics you want to deploy to protect the system.\nConnectors Key part of Architectures ■ Connect components and define the rules of interaction between components • Simple: shared variable access; method calls; … • Complex: database access; client-server; scheduler; load balancer ■ Connectors provide: Interaction ducts;\nIn coding often connectors are implicit, but in software architecture: ■ They are identified and have an identity ■ Capture system interaction (at the level of components) ■ They have a specification that can be complex\nRelationship between Connectors and components: ■ Components have application-specific functionality. ■ Connectors provide interaction mechanisms that are generic across different applications. ■ Interaction may involve multiple components ■ Interaction may have a protocol associated to it. The specification of the connector protocols determine: the types of interface that it works with; properties of interaction; rules about ordering of interaction; measurable features of interaction.\nBenefits of Explicit Connectors ■ Interaction is defined by the arrangement of the connectors (as far as possible) ■ Component interaction is defined by the pattern of connectors in the architecture ■ Interaction is “independent” of the components\nThe main roles(services) of Connectors are:\nCommunication Information is transmitted between components (e.g. message passing; method call; remote procedure call,…). Connectors constrain things: Direction of flow (e.g. pipes), Capacity, rates of flow, etc. May have other effects e.g. coordination (e.g. blocking I/O) Influences measurable Quality Attributes of the system Separates communication from functional aspects (components do the functional part). Coordination: Controls the timing relationship of functional aspects of the system, e.g. coordinating the arrival of data at a collection of components Conversion How to get components to interact that don’t have the right means of interaction. 如何让兼容性差的组件进行交互？ Incompatibilities might be related to: datatypes, ordering, frequency, structure of parameters etc. Examples of types of converters: Wrappers (deal with structural issues), Adaptors (deal with datatype incompatibilities) Facilitation Enable interaction among a group of components that are intended to interact. Help manage the interaction Examples: load balancer; replication management; redundancy management; scheduler Can also relate to coordination, e.g. synchronization (critical sections; monitors) Select Connectors Types of Connector: • Method/Procedure call • Data access • Events • Stream • Distributor • Arbitrator • Adaptor\nSelection\nDetermine a system’s interconnection and interaction needs Determine roles to be fulfilled by the system’s connectors: Communication, coordination, conversion, facilitation For each connector Determine its appropriate type(s) Determine its dimensions of interest Select appropriate values for each dimension For multi-type, i.e., composite connectors, determine the atomic connector compatibilities Architectural Patterns An architectural patterns is a package of design decisions that is found repeatedly in practice, has known properties that permit reuse, and describes a class of architectures.\nAn architectural pattern comprises:\nA context that provides the frame for a problem. A problem that is a generalised description of a class of problems often with QA requirements that should be met. A solution that is suitably generalised in the same way as the problem. A solution: Describes the architectural structures that solve the problem, including how to balance the many forces at work. The solution might be static, runtime or deployment oriented. The solution for a pattern is determined and described by: A set of element types (for example, data repositories, processes, and objects) A set of interaction mechanisms or connectors (for example, method calls, events, or message bus) A topological layout of the components A set of semantic constraints covering topology, element behavior, and interaction mechanisms Module Patterns Static Pattern: Layered Pattern\nOverview: The layered pattern defines layers (groupings of modules that offer a cohesive set of services) and a unidirectional allowed-to-use relation among the layers. The pattern is usually shown graphically by stacking boxes representing layers on top of each other. Suitable for controlling static aspects of architecture.\nElements: Layer, a kind of module. The description of a layer should define what modules the layer contains and a characterization of the cohesive set of services that the layer provides.\nRelations: Allowed to use, which is a specialization of a more generic depends-on relation. The design should define what the layer usage rules are (e.g., “a layer is allowed to use any lower layer” or “a layer is allowed to use only the layer immediately below it”) and any allowable exceptions. Constraints: ■ Every piece of software is allocated to exactly one layer. ■ There are at least two layers (but usually there are three or more). ■ The allowed-to-use relations should not be circular (i.e., a lower layer cannot use a layer above).\nWeaknesses: ■ The addition of layers adds up-front cost and complexity to a system. ■ Layers contribute a performance penalty.\nComponent-and-Connector Patterns Model-View-Controller Pattern\nContext: User interface software is typically the most frequently modifed portion of an interactive application. For this reason it is important to keep modifcations to the user interface software separate from the rest of the system.\nProblem: • Isolating the UI functionality from the Application functionality. • Maintaining multiple views in the presence of change in the underlying data.\nSolution: Other Component-Connector Patterns • Pipe and Filter Pattern • Broker Pattern • Client-Server Pattern • Peer-to-Peer Pattern • Service-Oriented Architecture Pattern • Publish-Subscribe Pattern • Shared Data Pattern\nDeployment/Allocation Patterns Context: – we are concerned with resource use – We might consider flexible deployment of resource – The QAs we care about are sensitive to the pattern of deployment and the use of resources.\nAllocation: Map-Reduce Pattern Context: – We have large quantities of data we wish to treat as “population” data. – This encourages an approach that involves significant amounts of independent processing.\nProblem: Where for ultra-large data sets doing some individual processing to a portion of the data set and then sorting and analyzing grouped data, map-reduce provides a simple way of doing this processing.\nSolution: Other Allocation Patterns • Multi-tier architecture pattern • Cloud architectures\nRelationships between Tactics and Patterns Architectural patterns and tactics are ways of capturing proven good design structures and making them reusable.\nTactics are simpler and more atomic than patterns • Tactics capture one step to take for a particular Quality Attribute to change behaviour with respect to that QA. • use just a single structure or computational mechanism, and they are meant to address a single architectural force. • Tactics can be seen as the building blocks of patterns; Most patterns consist of (are constructed from) several different tactics. Testability Testability illustrate QAs from a static perspective.\nA system or element of a system is testable if it is possible to test it in the way required by a particular development or maintenance process.\nTestability Concerns • Unlike the other QA (availability, performance and security), testability is concerned with the code structure rather than the connector/component view or deployment view. • The system elements we consider are code modules and the relationships are dependencies involved in building the code for components.\nTestability General Scenario 举例 Coverage Concrete Scenario • Source: Regression Tester • Stimulus: Completion of maintenance development to repair a critical bug • Artifact: Modules for the full system • Environment: Maintenance Development • Response: Results from path coverage tool • Response Measure: Path coverage is better than 95% of non-looping paths inside modules\nTestability Tactics\nadding controllability and observability to the system. Specialized Interfaces Record/Playback Localize State Storage Abstract Data Sources Sandbox Executable Assertions limiting complexity in the system’s designs: If it could be broken into smaller modules with lower complexity that could allow the regression test to achieve higher path coverage. Limit Structural Complexity Limit behavioral complexity - Nondeterminism A Design Checklist for Testability Allocation of Responsibilities ■ Determine which system responsibilities are most critical and hence need to be most thoroughly tested. ■ Ensure that additional system responsibilities have been allocated to do the following: Execute test suite and capture results (external test or self-test) • Capture (log) the activity that resulted in a fault or that resulted in unexpected (perhaps emergent) behavior that was not necessarily a fault • Control and observe relevant system state for testing Make sure the allocation of functionality provides high cohesion, low coupling, strong separation of concerns, and low structural complexity.\nCoordination Model Ensure the system’s coordination and communication mechanisms ■ Support the execution of a test suite and capture the results within a system or between systems ■ Support capturing activity that resulted in a fault within a system or between systems ■ Support injection and monitoring of state into the communication channels for use in testing, within a system or between systems ■ Do not introduce needless nondeterminism\nData Model Determine the major data abstractions that must be tested to ensure the correct operation of the system. ■ Ensure that it is possible to capture the values of instances of these data abstractions ■ Ensure that the values of instances of these data abstractions can be set when state is injected into the system, so that system state leading to a fault may be re-created ■ Ensure that the creation, initialization, persistence, manipulation, translation, and destruction of instances of these data abstractions can be exercised and captured\nMapping among Architectural Elements ■ Determine how to test the possible mappings of architectural elements (especially mappings of processes to processors, threads to processes, and modules to components) so that the desired test response is achieved and potential race conditions identifed. ■ In addition, determine whether it is possible to test for illegal mappings of architectural elements.\nResource Management ■ Ensure there are suffcient resources available to execute a test suite and capture the results. ■ Ensure that your test environment is representative of (or better yet, identical to) the environment in which the system will run. ■ Ensure that the system provides the means to do the following: • Test resource limits • Capture detailed resource usage for analysis in the event of a failure • Inject new resource limits into the system for the purposes of testing • Provide virtualized resources for testing\nBinding Time ■ Ensure that components that are bound later than compile time can be tested in the late-bound context. ■ Ensure that late bindings can be captured in the event of a failure, so that you can re-create the system’s state leading to the failure. ■ Ensure that the full range of binding possibilities can be tested\nChoice of Technology ■ Determine what technologies are available to help achieve the testability scenarios that apply to your architecture. Are technologies available to help with regression testing, fault injection, recording and playback, and so on? ■ Determine how testable the technologies are that you have chosen (or are considering choosing in the future) and ensure that your chosen technologies support the level of testing appropriate for your system. For example, if your chosen technologies do not make it possible to inject state, it may be diffcult to re-create fault scenarios.\nModifiability Modifiability illustrate QAs from a static perspective. Measure how easy it might be to modify. This is a key area because change incurs cost.\nFour key questions: – What can change? – How likely is something to change? – When, where, how and by whom will changes be made? – What is the cost of making the change?\nGeneral Scenario Tactics to control modifiability GPES Example Version 1: General purpose query facility in each GP system. Version 2: Building a specific piece of business logic for each different query. Think about: – What changes can happen? – How likely is a change? – When, where, how and by whom? – How mush will it cost?\nGPES-relevant Scenario • Source: One of the stakeholders e.g. Medicines and Healthcare Products Regulatory Agency • Stimulus: Wants prescribing data on NSAIDs • Artifacts: Code (but depending on the architecture this could be configuration data) • Environment: Operation • Response: Develop the code • Response Measure: Data available 5 weeks after request\nGPES Version 1 • Design and validate the query with the Medicines agency. • Code the query. • Test on some systems to ensure it does not have bad effects. • Rollout to all systems. • Make the query available to Medicines agency.\nGPES Version 2 • Design and validate the query with Medicines agency. • Negotiate with the GP system providers on the design of the business logic (different in all systems?) • Are the providers the only vendor of such services? Should it go to a procurement? • Validate the queries on each system • Integrate the results • Roll out to all systems • Make the query available to the Medicines Agency\nIt seems likely that the GPES V2 architecture will not pass the modifiability scenario we describe. Are any of the modifiability tactics appropriate to change the architecture to enable it to pass the scenario? ■ Reduce Coupling is the category of tactics we need to consider. ■ Each of the following offer potential routes with slightly different emphases: • Use an intermediary • Restrict dependencies • Refactor • Abstract common services ■ Defer Binding: can we do this later in the process so it is more likely to be done by a computer than a human? Here this is unlikely. ■ More on Binding Time • Compile time/Build Time: component replacement, compile time parameters,… • Deployment time: configuration scripts that bind at deployment, … • Initialization time: resource files • Runtime: dynamic lookup, service lookup, name servers, plugins, publish-subscribe, shared repositories, (Maybe just in time compilation fits here too)\nDesign checklist for Modifiability Allocation of responsibilities Work out how things are likely to change e.g. technical, legal, organisational, social, markets, customers.. ■ Work out what responsibilities change. ■ Try to modularise so a change does not affect responsibilities that span many modules.\nCoordination model Look at how changes are likely to affect coordination and try to ensure that the most likely changes impact coordination across a small number of modules\nData model Similar to coordination model – see how a change impacts on data models and try to esnure data model changes span as few modules as possible.\nMapping among architectural elements ■ Looking at potential changes to the system, assess whether some may best be responded to by changing the mapping to elements. ■ Explore issues such as dependencies between elements, data holdings in elements, assignment of elements to processes, threads or processors.\nResource Management ■ Determine how a change in responsibility or quality attribute will change resource. ■ Attempt to localise resourcing change resulting from a likely change to a small number of modules. ■ Look at ways of using policies or configuration to manage resource change more effectively\nBinding Time ■ Control choice of binding times so there are not too many combinations to consider. ■ Consider attempting to defer binding to later, balance this against the cost of providing a later binding mechanism.\nChoice of Technology Choose technologies that make the most likely changes easier (e.g. choose a technology that allows runtime alteration of critical parameters rather than one where parameters are chosen at compile time) but balance this agains the cost of the different technologies.\nArchitectural Modelling Software Architecture is intended to give us control over Quality Attributes. Ideally we’d like to be able to use Software Architecture to predict Quality Attributes. We should be able to build a predictive model of the Software Architecture and use the model to predict QAs. The current situation is patchy…\nSome quality attributes, most notably performance and availability, have well-understood, time-tested analytic models that can be used to assist in an analysis. Analytic model means one that supports quantitative analysis.\nTypes of Analysis • Thought experiment: just a sort of discussion using informed people. • Back of the envelope: using very approximate techniques with unreliable assumptions. • Checklist: collated experience. • Analytic Model: based on sound abstractions – heavily dependent on estimates being correct • Simulation: higher level of detail – less analytic, more concrete. • Prototype: approximate system in an experimental setup. • Experiment: fielded system, simulated load • Instrumentation: measuring the variable of interest\nAnalyzing Performance Models have parameters, which are values you can set to predict values about the entity being modeled. Model can be used to understand the latency characteristics of an architectural design. Data Needed for the Queuing Model ■ We need the following information in order to model effectively: • The distribution for the arrival of service requests • The queuing discipline • The scheduling algorithm • The distribution of service times for service requests • Network characteristics ■ The theory places restrictions on the distributions • Arrivals are usually expected to be Poisson Distributions specified by arrival rate • Service times are usually exponentially distributed on the service rate. • Some queuing behaviors are excluded such as reneging or jockying\nExample: MVC, says nothing about its deployment. That is, there is no specifcation of how the model, the view, and the controller are assigned to processes and processors; that’s not part of the pattern’s concern. These and other design decisions have to be made to transform a pattern into an architecture. Until that happens, one cannot say anything with authority about how an MVC-based implementation will perform. Data for MVC • Rate of service requests: the View component will service them at some rate. • Service requests to the Controller are generated by the View component. • Service requests from the Controller to the View component • Service requests from the Controller to the model • Service requests from the Model to the View Component\nModelling MVC We need estimates of: ■ Distribution of external service demands ■ Queuing Disciplines within the queues in front of each component. ■ Network latencies ■ Transfer characteristics: • View – Controller • Controller – View • Controller – Model • Model – View ■ Scaling to large numbers of components is an issue\nAnalyzing Availability One key issue is how long it takes to detect that a failure has taken place. Example is a Broker system. Hot Spare 热备用 (Active Redundancy) • Active and redundant both receive identical request stream. • Synchronous maintenance of broker state. • Fast failover in the event of failure of the active system.\nWarm Spare (Passive Redundancy) • Warm broker is maintained at the most recent checkpoint state. • In the event of failure the system rolls back to the most recent checkpoint. • This is slower than the hot spare approach\nCold Spare • No attempt to synchronise. • In the event of failure the cold spare is started. • The system state is recovered via interaction with other systems (so they have to be resilient to failure in the broker)\nAnalysis at Different Stages of the Life Cycle Architecture in the Life Cycles 前面部分关注软件架构的 technical context。这里开始关注 life cycles。 The role of software architecture is different for different lifecycles.\nBalancing Agility and Discipline • Lifecycles generally impose some discipline on the development process. • Software Architectures often feature in Lifecycles as a stage or support for analysis or design • Lifecycles exist because they codify useful patterns of activity and save us time and effort • Agility focusses on getting adequate solutions to stakeholders with less time and effort • We need to balance the discipline of lifecycles against the delivery focus of agility\nLifecycles • Lifecycles underpin development processes by ordering stages and activities. • Any good organisation is always looking to improve its processes so there is usually an ongoing process improvement cycle focussed on making the process better.\nV-Model approach works well when you understand the concept and requirements. Agile Practice • Test-first programming • Refactoring • Continuous integration • Simple Design • Pair Programming • Common Codebase • Coding Standards • Open Work Area\nAgile vs. Plan Driven Early software development methods that emerged in the 1970s - such as the Waterfall method - is plan-driven and inﬂexible. But having a strong 先期 up-front plan provides for considerable predictability (as long as the requirements don’t change too much) and makes it easier to coordinate large numbers of teams.\nAgile methods and practitioners, on the other hand, often 轻视 scorn planning, preferring teamwork, frequent face-to-face communication, ﬂexibility, and adaptation. This enhances invention and creativity.\n• Work top-down and bottom-up simultaneously - balance will depend on the size and complexity of the project. • Top-down does architectural work based on things like patterns, product-line. • Bottom-up develops implementation and environment-specific constraints and solutions. • Focus on QAs, scenarios, tactics and processes to 调和 reconcile competing aspects provides a bottomup/top-down link • Balancing commitment and flexibility\nAnalysis Techniques Product Line Architecture One of the early success areas for Software Architecture was the development of Product Line Architectures. Product Line Architecture is an approach to adopt systematic reuse of architectural elements that involves changes in development process supported by specific practices that encourage reuse.\nA collection of software-intensive systems sharing a common, managed, set of features that satisfy the specific needs of a market segment or mission that are developed from a set of core assets in a prescribed way.\nSoftware Product Lines are directed by business goals in a particular application domain. • The products in a product line share a software product line architecture • Products are structured by the product line architecture and are built from services and components. • Architercture and components are the core assets used to satisfy the business goals. • Product line leverage commonality and limit variability of the product.\nBenefits to the organisation • Large-scale productivity gains • Improve time to market • Maintian market presence (rapidly evolving variants) • Sustain growth • Improved market agility • Better use of skills • Enable mass customisation • Gain control of configuration • Improve product quality • Better predictability of cost, schedule and quality\nCosts of a product line • Architecture: flexible enough to support variation in the products • Software components: general enough to support variability • Test plans, cases, data: take account of variation in components • Business cases: must operate at the level of a product family • Project plans: generic and extensible to deal with variation • Tools and processes: must support architecture, variation, configuration, .. • People, skills, training: need to be skilled in architecture and product lines. Product lines spread costs over several products:• Requirements and requirements analysis • Domain model • Architecture and design • Performance engineering • Documentation • Test cases, data, and plans • Skills • Processes, methods and tools • Defect fixing • Components and services\nCore Process Activities • Core asset development: improving the base components in terms of qualities, products they support, and architecture. • Product development: identifying and building products to meet market need inside the product line. • Management: monitoring and improving the processes, tools and practices.\nIntroducing Product Lines • Proactive: Up-front investment to develop the core assets - need to know the market well (maybe have an already established set of products) • Reactive: Start with one or two products and use them to generate core assets. • Incremental: Develop core assets as the business need evolves.\nExample: Bosch Gasoline Systems Goals ■ Competitiveness: • Reduced hardware resource consumption • Reduced time to market for new features ■ Development efficiency • Reuse: Applications can be used across different generations of system; “core” software is highly configurable and is reused via reconfiguration; “Vehicle functions” can be used across gasoline and diesel engines • Easy configuration of software products • Increased planning accuracy ■ Quality • Interface integrity • Reuse of core assets ■ Customer needs • Differentiation by individual software solutions • Clear feature-cost mapping\nComponent Redesign ■ Focussed on: reuse; simplification of calibration; resource consumption; stabilisation of interfaces (within the architecture) ■ Redesign progressed by: • Analysing existing software inventory: features, sources of variability; relation to product line; document interdependency. • Concept development and design of components: simplification; configurability; architecture driven structure; document relations between features and components; • Baselines for variants of software components: document baselines; implement; maintain up-to-date document and implementation.\nPhased Introduction ■ Investigate and customise product line engineering. ■ Design and pilot adequate processes and methods. ■ Roll out and institutionalise in the standard development process. DevOps The line between development and operation becomes more blurred and the use of the live environment to test innovations becomes more common. DevOps is a set of practices that span development and operation.\nOperations have the direct experience of use of the system – monitoring that use is a way of empirically verifying quality – operations have the data that is used to regulate operations and is essential information for development.\nDevelopment is responsible for building in the right monitoring to ensure operations can operate effectively.\nDevOps is a set of practices intended to reduce the time between committing a change to a system and the change being placed into normal operation while ensuring necessary quality.\nOpen Services for Lifecycle Collaboration (OSLC): OSLC is an open and scalable approach to lifecycle integration. It simplifies key integration scenarios across heterogeneous tools.\nTraditionally we use test as the way of delivering quality change but we can “shepherd” committed change into use by controlling quantities of change, users experiencing change, results of monitoring than this may offer a better way. Delivery mechanism needs to be high quality: reliable, repeatable, available.\nCritical points • Making the decision to commit the code to be introduced into the system. • Transitioning from being under consideration into part of the production deployment that will be used by all users. • Issues is how to have enough confidence to make each of these transitions. Monitoring is critical. • The question is how to ensure the transitions are as reliable as possible.\nThe extent of the lifecycle • Involves all people involved in the delivery of the service/application • Operations and development people are in continuous interaction. • We need architecture to achieve this. • Microservices architectural pattern is often used.\nMicroservices The term “Microservice Architecture” has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services.\nThe microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. — https://martinfowler.com/articles/microservices.html\nAttributes of Microservice Architecture • Separately deployed units • Very small service components • Single purpose function or an independent portion of functionality • Distributed • Loosely coupled • Multiple versions are acceptable • Asynchronous • No Orchestration\nArchitecture Evaluation Evaluation by Designer • The consequences of the decision making regulate how much effort to put into the process – more importance means more effort in evaluation. • Try to use iterative approaches that get deeper in order to eliminate unpromising alternatives early. • Don’t strive for perfection, good enough for the context is usually enough.\nPeer Evaluation • Fix on the QAs to consider as part of the review – may be determined by the process or the business case. • The architect presents the architecture to the reviewers – questions are for information. • The review is driven by the relevant scenarios – the architect talks the review team through a scenario demonstrating the architecture meets the requirements captured in the scenario. • The outcome is a list of potential issues with actions: fix, mitigate, tolerate, …\nExternal Evaluation • Means to bring in additional expertise. • May represent some stakeholder interests. • More expensive and difficult to organise so this will often correspond to some major hurdle in the process.\nThe Architecture Tradeoff Analysis Method (ATAM) ATAM is a risk-mitigation process. Its purpose is to help choose a suitable architecture for a software system by discovering trade-offs and sensitivity points, to capture project risks. ATAM is most beneficial when done early in the software development life-cycle, when the cost of changing architectures is minimal.\nDesigned to be usable where: – Evaluators are not expert in the architecture – Evaluators need not be familiar with the business goals. – The system need not be fully developed – There may be large numbers of stakeholders\nParticipants in ATM • The evaluation team: 3-5 people with designated roles (people may have multiple roles). Team members should be seen to be neutral with respect to the project. • Project decision takers: manager of the project, funder of the project, main architect • Architecture stakeholders: developers, testers, integrators, maintainers, performance engineers, …\nATAM evaluation team roles and responsibilities Team Leader Sets up the evaluation; coordinates with client, making sure client’s needs are met; establishes evaluation contract; forms evaluation team; sees that final report is produced and delivered (although the writing may be delegated)\nEvaluation Leader Runs evaluation; facilitates elicitation of scenarios; administers scenario selection/prioritization process; facilitates evaluation of scenarios against architecture; facilitates onsite analysis\nScenario Scribe Writes scenarios on flipchart or whiteboard during scenario elicitation; captures agreed-on wording of each scenario, halting discussion until exact wording is captured\nProceedings Scribe Captures proceedings in electronic form on laptop or workstation, raw scenarios, issue(s) that motivate each scenario (often lost in the wording of the scenario itself), and resolution of each scenario when applied to architecture(s); also generates a printed list of adopted scenarios for handout to all participants\nTimekeeper Helps evaluation leader stay on schedule; helps control amount of time devoted to each scenario during the evaluation phase\nProcess Observer Keeps notes on how evaluation process could be improved or deviated from; usually keeps silent but may make discreet process-based suggestions to the evaluation leader during the evaluation; after evaluation, reports on how the process went and lessons learned for future improvement; also responsible for reporting experience to architecture evaluation team at large\nProcess Enforcer Helps evaluation leader remember and carry out the steps of the evaluation method\nQuestioner Raise issues of architectural interest that stakeholders may not have thought of\nATAM Outputs • Concise presentation of the architecture – needs to be presentable in around one hour. • Articulation of the business goals – clearly communicated to all participants • Prioritized QA requirements expressed as scenarios – testable QA requirements. • Risks and non-risks – architecture decision that carries risks (or not). • Risk themes – attempt to identify systemic risk by grouping risks into themes. • Mapping of Architecture Decisions to QA requirements – motivating architecture decisions by QA requirements • Identified sensitivity and tradeoff decisions – critical decisions that have significant impact on QA requirements.\nPartnership and preparation: Getting the schedule, agendas and list of stakeholders prepared, preparing necessary documents and presentations, and gettting documents to the evaluation team\nSteps of Evaluation Phase The ATAM analysis phases (phase 1 and phase 2) consist of nine steps.\nSteps 1 through 6 are carried out in phase 1\nPresentation of the ATAM approach – remind participants of the approach Business drivers presentation – functions; constraints; business goals; major stakeholders; architectural drivers Architecture presentation: Context for the system Static modular view Component and connector view Deployment view Main QA requirements and how the architecture addresses them: What has been reused Trace of key use cases Trace of key change scenarios Main issues/risks driving architectural change Identify architectural approaches – create a catalogue of patterns and tactics used in the architecture. Generate Quality Attribute Utility Tree this is an approach to identifying architecturally significant requirements (ASR) by looking through the QAs - identifying particular aspects of the QA that are relevant and any requirements related to that aspect of the QA. Each ASR is ranked High, Medium or Low in importance. Analyze architectural approaches – look at the most important QA requirement scenarios as identified at stage 5 and probe how the architecture meets the QA scenario. In phase 2, with all stakeholders present, those steps are summarized 7. Brainstorm prioritization of scenarios – revisit the prioritization for additional scenarios, e.g. a particular stakeholder (performance engineer) might propose a scenario on the response time of the system. 8. Analyze Architectural Approaches – revisit stage 6 but with an expanded and reprioritized set of scenarios 9. Present results – the evaluation group tries to group risks into risk themes to identify systemic issues and results are presented.\nATAM Results • Documentation of architectural approaches taken by the project. • Prioritized list of scenarios • Utility tree • Risks discovered • Non-risks identified • Sensitivity and Tradeoff points identified\nGeneral Practice Extraction Service (GPES) An IT system designed to allow NHS organizations to extract data from GP practice computer systems in England. This data would be used to monitor quality, plan and pay for health services and help medical research. 数据的请求和返回不需要实时，更多的是定期的请求，一定时间内返回数据。\nGeneral practitioner (GP), 全科医生。在英国，每个人都需要注册一个全科医生的诊所，当人们感到身体不适后首先会去联系的自己的全科医生。全科医生只进行有限的治疗，并建议是否有必要去医院看专科医生。每个 GP 都像小公司一样运作，有自己的 GP 系统，为患者保留病患记录。在英国，各种不同的机构组织可能需要了解GP正在做什么，因此需要从所有这些GP系统中提取数据。GPES 系统允许那些已经得到授权的机构组织，通过 NHSCIC（国家卫生和社会保健信息中心）提取各种GP数据。因为不同机构需要的信息不同，NHSCIC 需要研究制定如何提取指定的数据，并运行 GPES 系统从英国的所有GP系统提取数据。GP 可以从四种不同的 GP 系统中四选一。而 GPES 的挑战在于整合来自各个不同系统的GP的数据。\n问题\nThe project has been significantly delayed and many customers have yet to receive data. Mistakes in the original 采购 procurement and contract management contributed to losses of public funds, through asset write-offs and settlements with suppliers. Only one customer, NHS England has so far received data from GPES. The time needed to design a new type of extract and restrictions in the contracts severely limits HSCIC’s ability to provide data to those who request it. It is unlikely that GPES in its current form can provide the NHS-wide service planned. Data Extract Issue\nNHS did a technical review of GPES in early 2011, which recommended several significant changes to its design. In the original design, each GP system supplier would use a common query language as part of their extraction system. This would allow the NHSIC to design a single extract centrally using the query tool, which all GP clinical systems could understand. The technical review recommended an alternative where each supplier would be free to develop their own query methods. New queries would no longer be designed in the query tool using a common language, but would instead need to be designed as logical ‘business rules’ and sent to GP system suppliers to implement. The NHSIC decided to abandon both the GPSOC contract approach and the common query language, as they could not agree either with the Department and GP system suppliers. They then procured the extraction systems by negotiating direct with the GP clinical system suppliers. NHSIC is using a non-competitive procurement approach, plus the changes in design, contributed to the restrictive process for designing new extracts. The HSCIC, has continued to use the GPSOC framework to require data sharing between NHS systems. The new framework, effective from 2014, says that principal clinical system suppliers must provide an interface method for third-party systems to use. This would improve interoperability between systems in GP practices and the health community. The HSCIC cannot do the wide range and scale of data extracts the NHS requests, because of the design of the GPES system and restrictions in supplier contracts. Customers have requested over 100 different data extracts from GPES, but the HSCIC estimate they will be able to design only 24 new extracts in 2015-16. Figure shows a summary of the HSCIC’s process to develop a new extract, each of which the supplier designs and programmes from scratch. The HSCIC have limited flexibility to amend extracts once developed, for example to change a time period and the specific organisations it will extract data from. GPES will continue to operate in the short term, as its data is critical for determining payments to GPs. Its coverage of all practices in England cannot currently be replicated by other primary care data extraction systems. However, limited capacity and the difficulty of developing new extracts deters wider use. The HSCIC has acknowledged there is unlikely to be a long-term future for all or part of the GPES. However, they intend to reuse parts for a replacement system if possible. The HSCIC estimate that they will achieve less than two more years of use from the GPES in its current form, in contrast to the five-year minimum lifetime assumed for new IT systems. ","wordCount":"9395","inLanguage":"en","datePublished":"2018-06-30T00:00:00Z","dateModified":"2018-06-30T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/inf-course-note-software-architecture-process-and-management/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Inf Course Note - Software Architecture, Process, and Management</h1><div class=post-meta><span title='2018-06-30 00:00:00 +0000 UTC'>2018-06-30</span>&nbsp;·&nbsp;45 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/UoE-sapm.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-software-architecture aria-label="What is Software Architecture?">What is Software Architecture?</a></li><li><a href=#contexts-for-software-architecture aria-label="Contexts for Software Architecture">Contexts for Software Architecture</a></li><li><a href=#quality-attributes-qa aria-label="Quality Attributes (QA)">Quality Attributes (QA)</a><ul><li><a href=#quality-attributes-scenarios-%e5%9c%ba%e6%99%af aria-label="Quality Attributes Scenarios 场景">Quality Attributes Scenarios 场景</a></li><li><a href=#achieving-qa-through-tactics aria-label="Achieving QA through tactics">Achieving QA through tactics</a></li></ul></li><li><a href=#availability aria-label=Availability>Availability</a><ul><li><a href=#design-checklist-for-availability aria-label="Design Checklist for Availability">Design Checklist for Availability</a></li></ul></li><li><a href=#performance aria-label=Performance>Performance</a><ul><li><a href=#design-checklist-for-performance aria-label="Design Checklist for Performance">Design Checklist for Performance</a></li></ul></li><li><a href=#security aria-label=Security>Security</a><ul><li><a href=#a-design-checklist-for-security aria-label="A Design Checklist for Security">A Design Checklist for Security</a></li></ul></li><li><a href=#connectors aria-label=Connectors>Connectors</a><ul><li><a href=#select-connectors aria-label="Select Connectors">Select Connectors</a></li></ul></li><li><a href=#architectural-patterns aria-label="Architectural Patterns">Architectural Patterns</a><ul><li><a href=#module-patterns aria-label="Module Patterns">Module Patterns</a></li><li><a href=#component-and-connector-patterns aria-label="Component-and-Connector Patterns">Component-and-Connector Patterns</a></li><li><a href=#deploymentallocation-patterns aria-label="Deployment/Allocation Patterns">Deployment/Allocation Patterns</a><ul><li><a href=#allocation-map-reduce-pattern aria-label="Allocation: Map-Reduce Pattern">Allocation: Map-Reduce Pattern</a></li></ul></li><li><a href=#relationships-between-tactics-and-patterns aria-label="Relationships between Tactics and Patterns">Relationships between Tactics and Patterns</a></li></ul></li><li><a href=#testability aria-label=Testability>Testability</a><ul><li><a href=#a-design-checklist-for-testability aria-label="A Design Checklist for Testability">A Design Checklist for Testability</a></li></ul></li><li><a href=#modifiability aria-label=Modifiability>Modifiability</a><ul><li><a href=#gpes-example aria-label="GPES Example">GPES Example</a></li><li><a href=#design-checklist-for-modifiability aria-label="Design checklist for Modifiability">Design checklist for Modifiability</a></li></ul></li><li><a href=#architectural-modelling aria-label="Architectural Modelling">Architectural Modelling</a><ul><li><a href=#analyzing-performance aria-label="Analyzing Performance">Analyzing Performance</a></li><li><a href=#analyzing-availability aria-label="Analyzing Availability">Analyzing Availability</a></li><li><a href=#analysis-at-different-stages-of-the-life-cycle aria-label="Analysis at Different Stages of the Life Cycle">Analysis at Different Stages of the Life Cycle</a></li></ul></li><li><a href=#architecture-in-the-life-cycles aria-label="Architecture in the Life Cycles">Architecture in the Life Cycles</a><ul><li><a href=#agile-vs-plan-driven aria-label="Agile vs. Plan Driven">Agile vs. Plan Driven</a></li><li><a href=#analysis-techniques aria-label="Analysis Techniques">Analysis Techniques</a></li></ul></li><li><a href=#product-line-architecture aria-label="Product Line Architecture">Product Line Architecture</a><ul><li><a href=#example-bosch-gasoline-systems aria-label="Example: Bosch Gasoline Systems">Example: Bosch Gasoline Systems</a></li></ul></li><li><a href=#devops aria-label=DevOps>DevOps</a><ul><li><a href=#microservices aria-label=Microservices>Microservices</a></li></ul></li><li><a href=#architecture-evaluation aria-label="Architecture Evaluation">Architecture Evaluation</a><ul><li><a href=#the-architecture-tradeoff-analysis-method-atam aria-label="The Architecture Tradeoff Analysis Method (ATAM)">The Architecture Tradeoff Analysis Method (ATAM)</a><ul><li><a href=#atam-evaluation-team-roles-and-responsibilities aria-label="ATAM evaluation team roles and responsibilities">ATAM evaluation team roles and responsibilities</a></li><li><a href=#atam-outputs aria-label="ATAM Outputs">ATAM Outputs</a></li><li><a href=#steps-of-evaluation-phase aria-label="Steps of Evaluation Phase">Steps of Evaluation Phase</a></li></ul></li></ul></li><li><a href=#general-practice-extraction-service-gpes aria-label="General Practice Extraction Service (GPES)">General Practice Extraction Service (GPES)</a></li></ul></div></details></div><div class=post-content><p>爱丁堡大学信息学院课程笔记 Software Architecture, Process, and Management, Informatics, University of Edinburgh</p><p>Reference:
<a href=https://msdn.microsoft.com/en-us/library/ff650706.aspx>microsoft</a>
<a href=https://www.ibm.com/developerworks/rational/library/feb06/eeles/>IBM</a>
Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman</p><h2 id=what-is-software-architecture>What is Software Architecture?<a hidden class=anchor aria-hidden=true href=#what-is-software-architecture>#</a></h2><p>Software architecture is often described as the organization or structure of a system, where the system represents a collection of components that accomplish a specific function or set of functions.</p><ul><li>grouping components into areas of <strong>concern (layers)</strong>: For example, the UI, business processing, and data access.</li><li>focus on interaction between the components and how different components work together.</li></ul><p>在书中的定义：</p><blockquote><p>The software architecture of a system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both.
&ndash; Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman</p></blockquote><p>架构的关注点在于系统内各个应用和模块的交互和调用。软件架构的设计，需要考虑满足什么样的需求（用户或甲方），如何解决和优化问题（不同的方向各有偏重），操作中如何做选择（在不同的方面平衡，妥协）。</p><p>Architecture and <strong>design concerns</strong> very often overlap - The selection of data structures and algorithms or the implementation details of individual components are design concerns.</p><p>没必要强硬区分二者，而应该综合起来看待。某些情况下，决策是自然而然的结构层面的；在某些情况下，决策更多是关于于设计层面，以及设计如何帮助实现架构。</p><p>软件架构的定义有如下隐含意思：
1, Architecture Is a Set of Software Structures
Three frequently occurring types of structure:
– <strong>Modular structure</strong>: static structure that focus on how functionality is divided up, structured, and assigned to development and implementation teams.
– <strong>Component and Connector structure</strong>: runtime structures that focus on how components interact (e.g. information passing, synchronisation, interference,…)
– <strong>Allocation structures</strong>: mapping to organizational, development, installation, execution environments. (e.g. Components are deployed onto hardware to execute)</p><p>2, Architecture Is an abstraction
Architecture specifcally omits certain information about elements that is not useful for reasoning about the system - in particular, it omits information that has no ramifcations outside of a single element.</p><p>3, Every Software System Has a Software architecture</p><p>4, Architecture Includes behavior
Behavior embodies how elements interact with each other.</p><p>在本课程, 一个软件项目成功与否, 基于如下三点考量:
– The software is delivered on <strong>schedule</strong>
– Development costs were within <strong>budget</strong>
– The software meets the <strong>needs</strong> of users</p><h2 id=contexts-for-software-architecture>Contexts for Software Architecture<a hidden class=anchor aria-hidden=true href=#contexts-for-software-architecture>#</a></h2><ul><li>Technical: where architecture supports technical activity like measurement, V&amp;V, compliance,…<ul><li>Controlling <strong>Quality Attributes</strong><ul><li><strong>Availability</strong> - ensuring there is a system to take over if a system fails.</li><li><strong>Safety</strong> - ensuring that the system only behaves as intended and has no additonal behaviour.</li><li><strong>Testability</strong> - ensuring:<ul><li>elements are clearly able to be isolated</li><li>we know what behaviour to expect of components of the system</li><li>we know how components relate to modules so we can track down faulty code</li><li>We know how components are intended to integrate to give the overall behaviour</li></ul></li><li>Other qa: <strong>performance</strong>, usability, interoperability,..</li></ul></li><li><strong>Design</strong> - Patterns, Styles, Domain Specific Architecture (DSSA)<ul><li>A DSSA is collection of (pre-decided) design decisions that:<ul><li>Capture important aspects of particular tasks (domain),</li><li>Common across a range of systems in the domain</li><li>Typically they will have some predefined structures</li><li>These are not general purpose because they incorporate many specific characteristics of the domain.</li></ul></li><li>Architectural pattern is a set of architectural design decisions that are applicable to a recurring design problem, and parameterized to account for different software development contexts in which that problem appears.<ul><li>Similar to DSSAs but capture less of the behaviour and attributes of the system</li><li>More general because they are intended to abstract a common pattern over several domains.</li><li>Three-Tiered Pattern: State(database)-Logic(Business)-Display(UI)</li><li>Model-View-Controller (MVC): to separate between information, presentation and user interaction.</li><li>Sense-Compute-Control: Structuring embedded control applications</li></ul></li></ul></li></ul></li><li><strong>Project lifecycle</strong>: where architecture interacts with and supports development process<ul><li>Lifecycle Models: <strong>V-model</strong>, iterative models (Boehm’s spiral model), <strong>Agile</strong></li></ul></li><li>Business: where architecture supports organisations, e.g. customer organisations and development organisations.</li><li>Professional: where the role of architect defines requirements and constraints on architects.</li></ul><h2 id=quality-attributes-qa>Quality Attributes (QA)<a hidden class=anchor aria-hidden=true href=#quality-attributes-qa>#</a></h2><p>Architecture is the right level of abstraction to resolve conflicts between Stakeholders.<img loading=lazy src=/images/Architecture_Influence_Cycle.png title="Architecture Influence Cycle. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Quality Attributes specify, usually quantitative, requirements on particular bits of functionality or on the whole systems (e.g. that the system should be available 99% of the time).</p><p>Problems With QA
1, Often QA requirements are not “testable”, for example modifiable, usable, dependable or resilient.
2, It can be difficult to map from a concern about the system to a QA. For example, a high failure rate in some transaction could be a performance issue or it could be an availability issue.
3, Communities around a particular quality attribute have developed their own terminology (e.g. security has attacks, performance has events, etc).</p><p>The solution for 1 and 2 is to use <strong>quality attribute scenarios</strong> to provide sufficient specificity to avoid some of these issues.</p><h3 id=quality-attributes-scenarios-场景>Quality Attributes Scenarios 场景<a hidden class=anchor aria-hidden=true href=#quality-attributes-scenarios-场景>#</a></h3><p>A quality attribute requirement should be unambiguous and testable. To specify quality attribute requirements, we capture them formally as six-part scenarios:</p><ol><li><strong>Source of stimulus</strong>. This is some entity (a human, a computer system, or a system administrator) that generated the stimulus.</li><li><strong>Stimulus</strong>. A condition (event) that requires a response when it arrives at a system. e.g. a user operation to the usability community, or an attack to the security community.</li><li>Environment. The stimulus occurs under certain conditions. The system may be in an overload condition or in normal operation. For many systems, “normal” operation can refer to one of a number of modes. For these kinds of systems, the environment should specify in which mode the system is executing.</li><li>Artifact. A collection of systems, the whole system, or part of the system that is stimulated e.g. the configuration checker in the system.</li><li><strong>Response</strong>. The response is the activity undertaken as the result of the arrival of the stimulus. e.g. the configuration issue is identified and then repaired.</li><li><strong>Response measure</strong>. how to measure the response so the scenario is testable. e.g. time to detect the wrong configuration and the time to repair.</li></ol><p><img loading=lazy src=/images/quality_attribute_scenario.png title="The parts of a quality attribute scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Each QA has a <strong>General Scenario</strong> associated with it that tries to capture the possible components involved in that particular QA. This acts as a template or guide for the architect specifying a specific QA Scenario.</p><p><strong>Specific QA Scenarios</strong> take account of specific stimuli and measures on response, they capture the specification of the QA for a particular system.</p><h3 id=achieving-qa-through-tactics>Achieving QA through tactics<a hidden class=anchor aria-hidden=true href=#achieving-qa-through-tactics>#</a></h3><p>Architectural tactics are design decisions to achieve the required quality attributes, more specifcally, to control responses to stimuli.</p><p>The focus of a tactic is on a single quality attribute response. Within a tactic, there is no consideration of tradeoffs (differ from architectural patterns, where tradeoffs are built into the pattern).</p><p>By cataloging tactics, we provide a way of making design more systematic within some limitations.</p><p>An architecture can be viewed as the result of applying a collection of design decisions. A systematic categorization of these decisions:</p><ol><li>Allocation of responsibilities 责任分配: Identifying the important responsibilities, and determining how these responsibilities are allocated to static and runtime elements (namely, modules, components, and connectors).</li><li>Coordination model 模型协调 - Components in the architecture interact with one another via a collection of mechanisms.<ul><li>What elements in the system need to coordinate with one another.</li><li>What properties the coordination needs to have (e.g. timing properties, security of coordination, …)</li><li>Choosing the mechanisms (ideally a small number) that realize properties like statefulness, synchrony, delivery guarantees, performance.</li></ul></li><li>Data model: Every system must represent artifacts of system-wide interest—data—in some internal fashion<ul><li>Choosing abstractions, operations, and properties. How data is created and destroyed, access methods, &mldr;</li><li>Maintaining metadata that controls the interpretation of the data.</li><li>Organising the data, what kind of system will be used to store it, how will it be backed up, how do we recover from data loss</li></ul></li><li>Management of resources: hard (CPU, memory, battery, I/O ports…) or soft resources(system locks, software buffers, thread pools…):<ul><li>Identifying resources to be managed</li><li>What system element should manage a resource</li><li>资源共享策略和争端仲裁 Work out sharing strategies and how to arbitrate in contention situations</li><li>Consider the consequences of resource starvation(e.g. Memory).</li></ul></li><li>Mapping among architectural elements<ul><li>two important types of mapping:<ul><li>Mapping between different types of elements in the architecture, e.g. from static development structures (modules) to execution elements e.g. threads or processes.</li><li>Mappings between software elements and environment elements, e.g. from processes to specific processors and other hardware.</li></ul></li><li>Useful mappings include: code to runtime structure; runtime elements to environment; data model elements to data stores.</li></ul></li><li>Binding time decisions: introduce allowable ranges of variation.<ul><li>This variation can range from design time by a designer to runtime by an end user might allocate a responsibility.</li><li>The decisions in the other six categories have an associated binding time decision: we might want some variability in the resources to be managed determined at run time or we might make the coordination model negotiable at runtime if we want to inter-operate with a range of systems.</li></ul></li><li>Choice of technology: critical to being able to realize all the other decisions in a concrete system.<ul><li>What technologies are available</li><li>What tools are available to support technologies</li><li>How much training will it take to be able to use a technology?</li><li>What are the full range of consequences of the choice of a technology (e.g. it may restrict markets because it is incompatible with some other technologies).</li><li>If the technology is new, how does it fit into the existing preferred technologies for the organisation.</li></ul></li></ol><h2 id=availability>Availability<a hidden class=anchor aria-hidden=true href=#availability>#</a></h2><blockquote><p>Availability refers to a property of software that it is there and ready to carry out its task when you need it to be. The availability of a system is usually defined to be the probability it will be there when you ask it to work: $\frac{mtbf}{mtbf+mttr}$</p></blockquote><p>$mtbf$ – mean time between failures: MTBF of a component is the sum of the lengths of the operational periods divided by the number of observed failures: $mtbf = \frac{t}{N(t)}$, $t$ is the cumulative operating time, $N(t)$ is the observed number of failures by time $t$. 假设恒定的故障率 $\lambda$，则 $mtbf = \frac{1}{\lambda}$</p><p>$mttr$ – mean time to repair</p><p>Availability measures the quality of service in terms of running versus down time</p><p><strong>Reliability</strong> indicates the fraction of all attempted operations that complete successfully. The reliability of the system is: $R(t) = e^{-\lambda t}$ where the parameter $\lambda$ is called the failure rate.
由于MTBF主要针对可以修复的系统，因此建议针对不可修复的系统（在故障后选择更换而不是修复系统的情况）使用平均故障时间（MTTF），在数学上二者是等价的。
MTTF: Mean Time To (first) Failure, or Expected Life.
$ MTTF = E(t_f) = \int_0^\infty R(t)dt = \frac{1}{\lambda}$</p><p><strong>Faults, Errors, Failures</strong>: A <strong>fault</strong> is something in the system (e.g. failed component, wrong bit of code,…) that can cause the system to move into an <strong>error</strong> state when the fault is activated, an error may then eventually cause an externally observable deviation from the intended operation - <strong>failure</strong>.</p><p>Generic Scenario
<img loading=lazy src=/images/general_scenario_for_availability.png title="A general scenario for availability. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p><img loading=lazy src=/images/Availability_tactics.png title="Availability tactics. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id=design-checklist-for-availability>Design Checklist for Availability<a hidden class=anchor aria-hidden=true href=#design-checklist-for-availability>#</a></h3><p><strong>Allocation of Responsibilities</strong>
■ Determine the system responsibilities that need to be highly available.
■ Within those responsibilities, ensure that additional responsibilities have been allocated to detect an omission, crash, incorrect timing, or incorrect response.
■ Additionally, ensure that there are responsibilities to do the following:
• Log the fault
• Notify appropriate entities (people or systems)
• Disable the source of events causing the fault
• Be temporarily unavailable
• Fix or mask the fault/failure
• Operate in a degraded mode</p><p><strong>Coordination Model</strong>
Determine the system responsibilities that need to be highly available. With respect to those responsibilities, do the following:
■ Ensure that coordination mechanisms can detect an omission, crash, incorrect timing, or incorrect response. For example, whether guaranteed delivery is necessary. Will the coordination work under conditions of degraded communication?
■ Ensure that coordination mechanisms enable the logging of the fault, notification of appropriate entities, disabling of the source of the events causing the fault, fxing or masking the fault, or operating in a <strong>degraded mode</strong>.
■ Ensure that the coordination model supports the replacement of the artifacts used (processors, communications channels, persistent storage, and processes). For example, does replacement of a server allow the system to continue to operate?
■ Determine if the coordination will work under conditions of degraded communication, at startup/shutdown, in repair mode, or under overloaded operation. For example, how much lost information can the coordination model withstand and with what consequences?</p><p><strong>Data Model</strong>
■ Determine which portions of the system need to be highly available.
■ Within those portions, determine which data abstractions, along with their operations or their properties, could cause a fault of omission, a crash, incorrect timing behavior, or an incorrect response.
■ For those data abstractions, operations, and properties, ensure that they can be disabled, be temporarily unavailable, or be fxed or masked in the event of a fault.
■ For example, ensure that write requests are cached if a server is temporarily unavailable and performed when the server is returned to service.</p><p><strong>Mapping among Architectural Elements</strong>
■ Determine which artifacts (processors, communication channels, persistent storage, or processes) may produce a fault.
■ Ensure that the mapping (or remapping) of architectural elements is ﬂexible enough to permit the recovery from the fault. This may involve a consideration of the following:
• Which processes on failed processors need to be reassigned at runtime
• Which processors, data stores, or communication channels can be activated or reassigned at runtime
• How data on failed processors or storage can be served by replacement units
• How quickly the system can be reinstalled based on the units of delivery provided
• How to (re)assign runtime elements to processors, communication channels, and data stores
• When employing tactics that depend on redundancy of functionality, the mapping from modules to redundant components is important. For example, it is possible to write one module that contains code appropriate for both the active component and backup components in a protection group.</p><p><strong>Resource Management</strong>
■ Determine what critical resources are necessary to continue operating in the presence of a fault.
■ Ensure there are suffcient remaining resources in the event of a fault to log the fault; notify appropriate entities (people or systems); disable the source of events causing the fault; be temporarily unavailable; fx or mask the fault/failure; operate normally, in startup, shutdown, repair mode, degraded operation, and overloaded operation.
■ Determine the <strong>availability time</strong> for critical resources, what critical resources must be available during specifed time intervals, time intervals during which the critical resources may be in a degraded mode, and repair time for critical resources. Ensure that the critical resources are available during these time intervals.
■ For example, ensure that input queues are large enough to buffer anticipated messages if a server fails so that the messages are not permanently lost.</p><p><strong>Binding Time</strong>
■ Determine how and when architectural elements are bound.
■ If late binding is used to alternate between components that can themselves be sources of faults (e.g., processes, processors, communication channels), ensure the chosen availability strategy is suffcient to cover faults introduced by all sources.
■ For example:
• If late binding is used to switch between artifacts such as processors that will receive or be the subject of faults, will the chosen fault detection and recovery mechanisms work for all possible bindings?
• If late binding is used to change the defnition or tolerance of what constitutes a fault (e.g., how long a process can go without responding before a fault is assumed), is the recovery strategy chosen suffcient to handle all cases? For example, if a fault is ﬂagged after 0.1 milliseconds, but the recovery mechanism takes 1.5 seconds to work, that might be an unacceptable mismatch.
• What are the availability characteristics of the late binding mechanism itself? Can it fail?</p><p><strong>Choice of Technology</strong>
■ Determine the available technologies that can (help) detect faults, recover from faults, or reintroduce failed components.
■ Determine what technologies are available that help the response to a fault (e.g., event loggers).
■ Determine the availability characteristics of chosen technologies themselves: What faults can they recover from? What faults might they introduce into the system?</p><h2 id=performance>Performance<a hidden class=anchor aria-hidden=true href=#performance>#</a></h2><p><img loading=lazy src=/images/Performance_General_Scenario.png title="Performance General Scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman">
To ensure resource is effectively monitored and managed.</p><p><img loading=lazy src=/images/Performance_tactics.png title="Performance tactics. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id=design-checklist-for-performance>Design Checklist for Performance<a hidden class=anchor aria-hidden=true href=#design-checklist-for-performance>#</a></h3><p><strong>Allocation of Responsibilities</strong>
■ Work out areas responsibility of that require heavy resource use to ensure time-critical events take place.
■ Work out processing requirements.
■ Take account of:
• Responsibilites arising from threads crossing boundaries of responsibility
• Responsibilities for thread management
• Responsibilities for scheduling shared resources</p><p><strong>Coordination Model</strong>
■ What needs to coordinate.
■ Is there concurrency? Ensure it is safe.
■ Ensure coordination is appropriate for the style of stimulus.
■ Ensure the properties of the coordination model are good for the stimuli and concurrency control?</p><p><strong>Data Model</strong>
■ Determine what parts of the data model will be heavily loaded or behaves tight time constraints.
■ For those data abstractions, determine:
• Would keeping multiple copies help?
• Would partitioning the data help?
• Is it possible to reduce processing requirements for the data?
• Does adding resource help deal with data bottlenecks?</p><p><strong>Mapping Among Architecture Elements</strong>
■ Does colocation of some components reduce latencies?
■ Ensure components with high processing needs are allocated to big processors
■ Consider introducing concurrency when you map.
■ Consider whether some mappings introduce bottlenecks (e.g. allocating non-interfering tasks to the same thread)</p><p><strong>Resource Management</strong>
■ Work out what needs high levels of resource
■ Ensure these are monitoredand managed under all operating modes.
■ For example:
• Time critical components
• Thread management
• Prioritization
• Locking and scheduling strategies
• Deploying additional resource to meet elevated load.</p><p><strong>Binding time</strong>
■ Look at when you bind.
■ Consider the cost of binding at different times
■ Try to avoid performance penalties caused by late binding.</p><p><strong>Choice of Technology</strong>
■ Is the technology right to let you meet hard deadlines and resource use (e.g. use a real-time OS with proper scheduling).
■ Do you know its characteristics under load and its limits?
■ Does your choice of technology give you the ability to set the following:
• Good scheduling
• Priorities
• Policies for demand reduction
• Allocating processing to tasks
• Other performance-related parameters.
■ Does your choice of technology introduce excessive overhead for heavily used operations?</p><h2 id=security>Security<a hidden class=anchor aria-hidden=true href=#security>#</a></h2><p>最简单的表征安全的三个特征 - confdentiality, integrity, and availability (CIA):</p><ol><li>机密性 Confidentiality: Only those who should have access are given access.</li><li>完整性 Integrity: Data or services are not subject to unauthorised manipulation.</li><li>可用性 Availability: the system is available for legitimate use.</li></ol><p>其他用于支撑 CIA 的特征:
4. 认证识别 Authentication verifes the identities of the parties to a transaction and checks if they are truly who they claim to be.
5. 不可否认性 Nonrepudiation guarantees that the sender of a message cannot later deny having sent the message, and that the recipient cannot deny having received the message.
6. 授权 Authorization grants a user the privileges to perform a task.</p><p>Security General Scenario
<img loading=lazy src=/images/Security_General_Scenario.png title="Security General Scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p><img loading=lazy src=/images/Security_tactics.png title="Security tactics. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id=a-design-checklist-for-security>A Design Checklist for Security<a hidden class=anchor aria-hidden=true href=#a-design-checklist-for-security>#</a></h3><p><strong>Allocation of Responsibilities</strong>
■ Ensure all actors have identities
■ Authenticate identities
■ Check authorizations
■ Ensure authorization is required for all such actors
■ Log attempts, successes and failures on all sensitive operations
■ Ensure data is encrypted
■ Ensure responsibilities are allocated to appropriate actors.</p><p><strong>Coordination Model</strong>
■ Ensure coordination mechanisms use authentication and authorisation.
■ Ensure coordination mechanisms are not vulnerable to impersonation, tampering, interception, …
■ Ensure data involved in coordination is protected using encryption.
■ Monitor level of demand for communication to identify excessive demands</p><p><strong>Data Model</strong>
■ Ensure there is a valid data model that disallows invalid data flows.
■ Ensure logging of access, modification and attempted access or modification.
■ Data is protected in flight and at rest using appropriate encryption.
■ Ensure appropriate backup/recovery mechanisms are in place.</p><p><strong>Mapping among Architectural Elements</strong>
■ Explore how different mappings change the way users can access resources.
■ Ensure for all of these mappings the models of access and authorisation are preserved.
• Actors should be identified and authenticated
• Use appropriate authorisation mechanisms
• Ensure logging is enabled
• Ensure data is protected by encryption
• Recognise impact of attack on resources
■ Ensure recovery from attack is possible</p><p><strong>Resource Management</strong>
■ Explore the overheads resulting from monitoring, detecting, preventing and recovering from attacks.
■ Analyse how a user can access and make demands on critical resources.
■ Manage resource access to ensure malicious use of resource is detected and managed.
■ Identify the potential for corruption/contamination and how to manage this.
■ Explore the potential for resource use to be used as a covert channel to transmit data.
■ Limit resources used to manage attempts at unauthorised use</p><p><strong>Binding Time</strong>
■ Explore the consequences of varying binding times on the ability to trust an actor or component.
■ Put in place appropriate mechanisms to ensure trust given binding time.
■ Explore potential impact on resource use, capacity/throughput, response time
■ Ensure appropriate encryption of all data around binding.
■ Explore the potential of variation in binding time as a covert channel.</p><p><strong>Choice of Technologies</strong>
■ Ensure limitations of technologies are understood and the potential for future compromise is well identified.
■ Ensure your chosen technologies support the tactics you want to deploy to protect the system.</p><h2 id=connectors>Connectors<a hidden class=anchor aria-hidden=true href=#connectors>#</a></h2><p>Key part of Architectures
■ Connect components and define the rules of interaction between components
• Simple: shared variable access; method calls; …
• Complex: database access; client-server; scheduler; load balancer
■ Connectors provide: Interaction ducts;</p><p>In coding often connectors are implicit, but in software architecture:
■ They are identified and have an identity
■ Capture system interaction (at the level of components)
■ They have a specification that can be complex</p><p>Relationship between Connectors and components:
■ Components have application-specific functionality.
■ Connectors provide interaction mechanisms that are generic across different applications.
■ Interaction may involve multiple components
■ Interaction may have a protocol associated to it. The specification of the connector protocols determine: the types of interface that it works with; properties of interaction; rules about ordering of interaction; measurable features of interaction.</p><p>Benefits of Explicit Connectors
■ Interaction is defined by the arrangement of the connectors (as far as possible)
■ Component interaction is defined by the pattern of connectors in the architecture
■ Interaction is “independent” of the components</p><p>The main roles(services) of Connectors are:</p><ul><li>Communication<ul><li>Information is transmitted between components (e.g. message passing; method call; remote procedure call,…).</li><li>Connectors constrain things: Direction of flow (e.g. pipes), Capacity, rates of flow, etc.</li><li>May have other effects e.g. coordination (e.g. blocking I/O)</li><li>Influences measurable Quality Attributes of the system</li><li>Separates communication from functional aspects (components do the functional part).</li></ul></li><li>Coordination: Controls the timing relationship of functional aspects of the system, e.g. coordinating the arrival of data at a collection of components</li><li>Conversion<ul><li>How to get components to interact that don&rsquo;t have the right means of interaction. 如何让兼容性差的组件进行交互？</li><li>Incompatibilities might be related to: datatypes, ordering, frequency, structure of parameters etc.</li><li>Examples of types of converters: Wrappers (deal with structural issues), Adaptors (deal with datatype incompatibilities)</li></ul></li><li>Facilitation<ul><li>Enable interaction among a group of components that are intended to interact.</li><li>Help manage the interaction</li><li>Examples: load balancer; replication management; redundancy management; scheduler</li><li>Can also relate to coordination, e.g. synchronization (critical sections; monitors)</li></ul></li></ul><h3 id=select-connectors>Select Connectors<a hidden class=anchor aria-hidden=true href=#select-connectors>#</a></h3><p>Types of Connector: • Method/Procedure call • Data access • Events • Stream • Distributor • Arbitrator • Adaptor</p><p>Selection</p><ul><li>Determine a system’s interconnection and interaction needs</li><li>Determine roles to be fulfilled by the system’s connectors: Communication, coordination, conversion, facilitation</li><li>For each connector<ul><li>Determine its appropriate type(s)</li><li>Determine its dimensions of interest</li><li>Select appropriate values for each dimension</li></ul></li><li>For multi-type, i.e., composite connectors, determine the atomic connector compatibilities</li></ul><h2 id=architectural-patterns>Architectural Patterns<a hidden class=anchor aria-hidden=true href=#architectural-patterns>#</a></h2><blockquote><p>An architectural patterns is a package of design decisions that is <strong>found repeatedly in practice</strong>, has known properties that permit reuse, and describes a class of architectures.</p></blockquote><p>An architectural pattern comprises:</p><ul><li>A <strong>context</strong> that provides the frame for a problem.</li><li>A <strong>problem</strong> that is a generalised description of a class of problems often with QA requirements that should be met.</li><li>A <strong>solution</strong> that is suitably generalised in the same way as the problem. A solution:<ul><li>Describes the architectural structures that solve the problem, including how to balance the many forces at work.</li><li>The solution might be static, runtime or deployment oriented.</li><li>The solution for a pattern is determined and described by:<ul><li>A set of element types (for example, data repositories, processes, and objects)</li><li>A set of interaction mechanisms or connectors (for example, method calls, events, or message bus)</li><li>A topological layout of the components</li><li>A set of semantic constraints covering topology, element behavior, and interaction mechanisms</li></ul></li></ul></li></ul><h3 id=module-patterns>Module Patterns<a hidden class=anchor aria-hidden=true href=#module-patterns>#</a></h3><p>Static Pattern: <strong>Layered Pattern</strong></p><p>Overview: The layered pattern defines layers (groupings of modules that offer a cohesive set of services) and a <strong>unidirectional</strong> allowed-to-use relation among the layers. The pattern is usually shown graphically by stacking boxes representing layers on top of each other. Suitable for controlling <strong>static</strong> aspects of architecture.</p><p>Elements: Layer, a kind of module. The description of a layer should define what modules the layer contains and a characterization of the cohesive set of services that the layer provides.</p><p>Relations: <strong>Allowed to use</strong>, which is a specialization of a more generic depends-on relation. The design should define what the layer usage rules are (e.g., “a layer is allowed to use any lower layer” or “a layer is allowed to use only the layer immediately below it”) and any allowable exceptions.
<img loading=lazy src=/images/layer_pattern_relations.png title="A simple layer diagram, with a simple key answering the uses, Clear Access Rules. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Constraints:
■ Every piece of software is allocated to exactly one layer.
■ There are at least two layers (but usually there are three or more).
■ The allowed-to-use relations should not be circular (i.e., a lower layer cannot use a layer above).</p><p>Weaknesses:
■ The addition of layers adds up-front cost and complexity to a system.
■ Layers contribute a performance penalty.</p><h3 id=component-and-connector-patterns>Component-and-Connector Patterns<a hidden class=anchor aria-hidden=true href=#component-and-connector-patterns>#</a></h3><p><strong>Model-View-Controller Pattern</strong></p><p>Context: User interface software is typically the most frequently modifed portion of an interactive application. For this reason it is important to keep modifcations to the user interface software separate from the rest of the system.</p><p>Problem:
• Isolating the UI functionality from the Application functionality.
• Maintaining multiple views in the presence of change in the underlying data.</p><p>Solution:
<img loading=lazy src=/images/Model_View_Controller_Pattern_Solution.png title="Model-View-Controller Pattern Solution. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p><img loading=lazy src=/images/model_view_controller_pattern.png title="The relationships between the components of Model-View-Controller Pattern. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Other Component-Connector Patterns
• Pipe and Filter Pattern
• Broker Pattern
• Client-Server Pattern
• Peer-to-Peer Pattern
• Service-Oriented Architecture Pattern
• Publish-Subscribe Pattern
• Shared Data Pattern</p><h3 id=deploymentallocation-patterns>Deployment/Allocation Patterns<a hidden class=anchor aria-hidden=true href=#deploymentallocation-patterns>#</a></h3><p>Context:
– we are concerned with resource use
– We might consider flexible deployment of resource
– The QAs we care about are sensitive to the pattern of deployment and the use of resources.</p><h4 id=allocation-map-reduce-pattern>Allocation: Map-Reduce Pattern<a hidden class=anchor aria-hidden=true href=#allocation-map-reduce-pattern>#</a></h4><p>Context:
– We have large quantities of data we wish to treat as “population” data.
– This encourages an approach that involves significant amounts of independent processing.</p><p>Problem: Where for ultra-large data sets doing some individual processing to a portion of the data set and then sorting and analyzing grouped data, map-reduce provides a simple way of doing this processing.</p><p>Solution:
<img loading=lazy src=/images/Map_Reduce_Pattern_Solution.png title="Map-Reduce Pattern Solution. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Other Allocation Patterns
• Multi-tier architecture pattern
• Cloud architectures</p><h3 id=relationships-between-tactics-and-patterns>Relationships between Tactics and Patterns<a hidden class=anchor aria-hidden=true href=#relationships-between-tactics-and-patterns>#</a></h3><p>Architectural patterns and tactics are ways of capturing proven good design structures and making them reusable.</p><p>Tactics are simpler and more atomic than patterns
• Tactics capture one step to take for a particular Quality Attribute to change behaviour with respect to that QA.
• use just a single structure or computational mechanism, and they are meant to address a single architectural force.
• Tactics can be seen as the building blocks of patterns; Most patterns consist of (are constructed from) several different tactics.
<img loading=lazy src=/images/Architecture_Patterns_and_Corresponding_Tactics.png title="Architecture Patterns and Corresponding Tactics ([Bachmann 07]). image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h2 id=testability>Testability<a hidden class=anchor aria-hidden=true href=#testability>#</a></h2><p>Testability illustrate QAs from a <strong>static</strong> perspective.</p><p>A system or element of a system is testable if it is possible to test it in the way required by a particular development or maintenance process.</p><p>Testability Concerns
• Unlike the other QA (availability, performance and security), testability is concerned with the code structure rather than the connector/component view or deployment view.
• The system elements we consider are code modules and the relationships are dependencies involved in building the code for components.</p><p>Testability General Scenario
<img loading=lazy src=/images/Testability_General_Scenario.png title="Testability General Scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>举例 Coverage Concrete Scenario
• Source: Regression Tester
• Stimulus: Completion of maintenance development to repair a critical bug
• Artifact: Modules for the full system
• Environment: Maintenance Development
• Response: Results from path coverage tool
• Response Measure: Path coverage is better than 95% of non-looping paths inside modules</p><p>Testability <strong>Tactics</strong></p><ul><li>adding controllability and observability to the system.<ul><li>Specialized Interfaces</li><li>Record/Playback</li><li>Localize State Storage</li><li>Abstract Data Sources</li><li>Sandbox</li><li>Executable Assertions</li></ul></li><li>limiting complexity in the system’s designs: If it could be broken into smaller modules with lower complexity that could allow the regression test to achieve higher path coverage.<ul><li>Limit Structural Complexity</li><li>Limit behavioral complexity - Nondeterminism</li></ul></li></ul><h3 id=a-design-checklist-for-testability>A Design Checklist for Testability<a hidden class=anchor aria-hidden=true href=#a-design-checklist-for-testability>#</a></h3><p><strong>Allocation of Responsibilities</strong>
■ Determine which system responsibilities are most critical and hence need to be most thoroughly tested.
■ Ensure that additional system responsibilities have been allocated to do the following:
Execute test suite and capture results (external test or self-test)
• Capture (log) the activity that resulted in a fault or that resulted in unexpected (perhaps emergent) behavior that was not necessarily a fault
• Control and observe relevant system state for testing Make sure the allocation of functionality provides high cohesion, low coupling, strong separation of concerns, and low structural complexity.</p><p><strong>Coordination Model</strong>
Ensure the system&rsquo;s coordination and communication mechanisms
■ Support the execution of a test suite and capture the results within a system or between systems
■ Support capturing activity that resulted in a fault within a system or between systems
■ Support injection and monitoring of state into the communication channels for use in testing, within a system or between systems
■ Do not introduce needless nondeterminism</p><p><strong>Data Model</strong>
Determine the major data abstractions that must be tested to ensure the correct operation of the system.
■ Ensure that it is possible to capture the values of instances of these data abstractions
■ Ensure that the values of instances of these data abstractions can be set when state is injected into the system, so that system state leading to a fault may be re-created
■ Ensure that the creation, initialization, persistence, manipulation, translation, and destruction of instances of these data abstractions can be exercised and captured</p><p><strong>Mapping among Architectural Elements</strong>
■ Determine how to test the possible mappings of architectural elements (especially mappings of processes to processors, threads to processes, and modules to components) so that the desired test response is achieved and potential race conditions identifed.
■ In addition, determine whether it is possible to test for illegal mappings of architectural elements.</p><p><strong>Resource Management</strong>
■ Ensure there are suffcient resources available to execute a test suite and capture the results.
■ Ensure that your test environment is representative of (or better yet, identical to) the environment in which the system will run.
■ Ensure that the system provides the means to do the following:
• Test resource limits
• Capture detailed resource usage for analysis in the event of a failure
• Inject new resource limits into the system for the purposes of testing
• Provide virtualized resources for testing</p><p><strong>Binding Time</strong>
■ Ensure that components that are bound later than compile time can be tested in the late-bound context.
■ Ensure that late bindings can be captured in the event of a failure, so that you can re-create the system’s state leading to the failure.
■ Ensure that the full range of binding possibilities can be tested</p><p><strong>Choice of Technology</strong>
■ Determine what technologies are available to help achieve the testability scenarios that apply to your architecture. Are technologies available to help with regression testing, fault injection, recording and playback, and so on?
■ Determine how testable the technologies are that you have chosen (or are considering choosing in the future) and ensure that your chosen technologies support the level of testing appropriate for your system. For example, if your chosen technologies do not make it possible to inject state, it may be diffcult to re-create fault scenarios.</p><h2 id=modifiability>Modifiability<a hidden class=anchor aria-hidden=true href=#modifiability>#</a></h2><p>Modifiability illustrate QAs from a <strong>static</strong> perspective. Measure how easy it might be to modify. This is a key area because change incurs cost.</p><p>Four key questions:
– What can change?
– How likely is something to change?
– When, where, how and by whom will changes be made?
– What is the cost of making the change?</p><p>General Scenario
<img loading=lazy src=/images/Modifiability_General_Scenario.png title="Modifiability General Scenario. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><p>Tactics to control modifiability
<img loading=lazy src=/images/Modifiability_tactics.png title="Modifiability tactics. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id=gpes-example>GPES Example<a hidden class=anchor aria-hidden=true href=#gpes-example>#</a></h3><p>Version 1: General purpose query facility in each GP system.
Version 2: Building a specific piece of business logic for each different query.
Think about:
– What changes can happen?
– How likely is a change?
– When, where, how and by whom?
– How mush will it cost?</p><p><strong>GPES-relevant Scenario</strong>
• Source: One of the stakeholders e.g. Medicines and Healthcare Products Regulatory Agency
• Stimulus: Wants prescribing data on NSAIDs
• Artifacts: Code (but depending on the architecture this could be configuration data)
• Environment: Operation
• Response: Develop the code
• Response Measure: Data available 5 weeks after request</p><p><strong>GPES Version 1</strong>
• Design and validate the query with the Medicines agency.
• Code the query.
• Test on some systems to ensure it does not have bad effects.
• Rollout to all systems.
• Make the query available to Medicines agency.</p><p><strong>GPES Version 2</strong>
• Design and validate the query with Medicines agency.
• Negotiate with the GP system providers on the design of the business logic (different in all systems?)
• Are the providers the only vendor of such services? Should it go to a procurement?
• Validate the queries on each system
• Integrate the results
• Roll out to all systems
• Make the query available to the Medicines Agency</p><p>It seems likely that the GPES V2 architecture will not pass the modifiability scenario we describe. Are any of the modifiability tactics appropriate to change the architecture to enable it to pass the scenario?
■ Reduce Coupling is the category of tactics we need to consider.
■ Each of the following offer potential routes with slightly different emphases:
• Use an intermediary
• Restrict dependencies
• Refactor
• Abstract common services
■ Defer Binding: can we do this later in the process so it is more likely to be done by a computer than a human? Here this is unlikely.
■ More on Binding Time
• Compile time/Build Time: component replacement, compile time parameters,…
• Deployment time: configuration scripts that bind at deployment, …
• Initialization time: resource files
• Runtime: dynamic lookup, service lookup, name servers, plugins, publish-subscribe, shared repositories, (Maybe just in time compilation fits here too)</p><h3 id=design-checklist-for-modifiability>Design checklist for Modifiability<a hidden class=anchor aria-hidden=true href=#design-checklist-for-modifiability>#</a></h3><p><strong>Allocation of responsibilities</strong>
Work out how things are likely to change e.g. technical, legal, organisational, social, markets, customers..
■ Work out what responsibilities change.
■ Try to modularise so a change does not affect responsibilities that span many modules.</p><p><strong>Coordination model</strong>
Look at how changes are likely to affect coordination and try to ensure that the most likely changes impact coordination across a small number of modules</p><p><strong>Data model</strong>
Similar to coordination model – see how a change impacts on data models and try to esnure data model changes span as few modules as possible.</p><p><strong>Mapping among architectural elements</strong>
■ Looking at potential changes to the system, assess whether some may best be responded to by changing the mapping to elements.
■ Explore issues such as dependencies between elements, data holdings in elements, assignment of elements to processes, threads or processors.</p><p><strong>Resource Management</strong>
■ Determine how a change in responsibility or quality attribute will change resource.
■ Attempt to localise resourcing change resulting from a likely change to a small number of modules.
■ Look at ways of using policies or configuration to manage resource change more effectively</p><p><strong>Binding Time</strong>
■ Control choice of binding times so there are not too many combinations to consider.
■ Consider attempting to defer binding to later, balance this against the cost of providing a later binding mechanism.</p><p><strong>Choice of Technology</strong>
Choose technologies that make the most likely changes easier (e.g. choose a technology that allows runtime alteration of critical parameters rather than one where parameters are chosen at compile time) but balance this agains the cost of the different technologies.</p><h2 id=architectural-modelling>Architectural Modelling<a hidden class=anchor aria-hidden=true href=#architectural-modelling>#</a></h2><p>Software Architecture is intended to give us control over Quality Attributes. Ideally we’d like to be able to use Software Architecture to predict Quality Attributes. We should be able to build a predictive model of the Software Architecture and use the model to predict QAs. The current situation is patchy…</p><p>Some quality attributes, most notably performance and availability, have well-understood, time-tested <strong>analytic models</strong> that can be used to assist in an analysis. Analytic model means one that supports quantitative analysis.</p><p><strong>Types of Analysis</strong>
• Thought experiment: just a sort of discussion using informed people.
• Back of the envelope: using very approximate techniques with unreliable assumptions.
• Checklist: collated experience.
• Analytic Model: based on sound abstractions – heavily dependent on estimates being correct
• Simulation: higher level of detail – less analytic, more concrete.
• Prototype: approximate system in an experimental setup.
• Experiment: fielded system, simulated load
• Instrumentation: measuring the variable of interest</p><p><img loading=lazy src=/images/Summary_of_the_Analytic_Model_Space.png title="A Summary of the Analytic Model Space. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h3 id=analyzing-performance>Analyzing Performance<a hidden class=anchor aria-hidden=true href=#analyzing-performance>#</a></h3><p>Models have parameters, which are values you can set to predict values about the entity being modeled. Model can be used to understand the <strong>latency characteristics</strong> of an architectural design.
<img loading=lazy src=/images/queuing_model_of_performance.png title="A queuing model of performance. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman">
Data Needed for the <strong>Queuing Model</strong>
■ We need the following information in order to model effectively:
• The distribution for the arrival of service requests
• The queuing discipline
• The scheduling algorithm
• The distribution of service times for service requests
• Network characteristics
■ The theory places restrictions on the distributions
• Arrivals are usually expected to be Poisson Distributions specified by arrival rate
• Service times are usually exponentially distributed on the service rate.
• Some queuing behaviors are excluded such as reneging or jockying</p><p><strong>Example: MVC</strong>, says nothing about its deployment. That is, there is no specifcation of how the model, the view, and the controller are assigned to processes and processors; that’s not part of the pattern’s concern. These and other design decisions have to be made to transform a pattern into an architecture. Until that happens, one cannot say anything with authority about how an MVC-based implementation will perform.
<img loading=lazy src=/images/Queueing_Model_of_MVC.png title="A queuing model of performance for MVC. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman">
<strong>Data for MVC</strong>
• Rate of service requests: the View component will service them at some rate.
• Service requests to the Controller are generated by the View component.
• Service requests from the Controller to the View component
• Service requests from the Controller to the model
• Service requests from the Model to the View Component</p><p><strong>Modelling MVC</strong>
We need estimates of:
■ Distribution of external service demands
■ Queuing Disciplines within the queues in front of each component.
■ Network latencies
■ Transfer characteristics:
• View – Controller
• Controller – View
• Controller – Model
• Model – View
■ Scaling to large numbers of components is an issue</p><h3 id=analyzing-availability>Analyzing Availability<a hidden class=anchor aria-hidden=true href=#analyzing-availability>#</a></h3><p>One key issue is how long it takes to detect that a failure has taken place. Example is a <strong>Broker system</strong>.
<img loading=lazy src=/images/Redundancy_tactics_to_a_broker_pattern.png title="Redundancy tactics, as applied to a broker pattern. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman">
<strong>Hot Spare 热备用 (Active Redundancy)</strong>
• Active and redundant both receive identical request stream.
• Synchronous maintenance of broker state.
• Fast failover in the event of failure of the active system.</p><p><strong>Warm Spare (Passive Redundancy)</strong>
• Warm broker is maintained at the most recent checkpoint state.
• In the event of failure the system rolls back to the most recent checkpoint.
• This is slower than the hot spare approach</p><p><strong>Cold Spare</strong>
• No attempt to synchronise.
• In the event of failure the cold spare is started.
• The system state is recovered via interaction with other systems (so they have to be resilient to failure in the broker)</p><h3 id=analysis-at-different-stages-of-the-life-cycle>Analysis at Different Stages of the Life Cycle<a hidden class=anchor aria-hidden=true href=#analysis-at-different-stages-of-the-life-cycle>#</a></h3><p><img loading=lazy src=/images/Analysis_at_Different_Stages_of_the_Life_Cycle.png title="Forms of Analysis, Their Life-Cycle Stage, Cost, and Confdence in Their Outputs. image from: Software Architecture in Practice (3rd edition), Bass, Clements, and Kazman"></p><h2 id=architecture-in-the-life-cycles>Architecture in the Life Cycles<a hidden class=anchor aria-hidden=true href=#architecture-in-the-life-cycles>#</a></h2><p>前面部分关注软件架构的 technical context。这里开始关注 life cycles。
The role of software architecture is different for different lifecycles.</p><p><strong>Balancing Agility and Discipline</strong>
• Lifecycles generally impose some discipline on the development process.
• Software Architectures often feature in Lifecycles as a stage or support for analysis or design
• Lifecycles exist because they codify useful patterns of activity and save us time and effort
• Agility focusses on getting adequate solutions to stakeholders <strong>with less time and effort</strong>
• We need to balance the discipline of lifecycles against the delivery focus of agility</p><p><strong>Lifecycles</strong>
• Lifecycles underpin development processes by ordering stages and activities.
• Any good organisation is always looking to improve its processes so there is usually an <strong>ongoing process improvement cycle</strong> focussed on making the process better.</p><p>V-Model approach works well when you understand the concept and requirements.
<img loading=lazy src=/images/v_model_in_lifecycle.png title="V-Model. image from: https://davenicolette.files.wordpress.com/2012/02"></p><p><strong>Agile Practice</strong>
• Test-first programming
• Refactoring
• Continuous integration
• Simple Design
• Pair Programming
• Common Codebase
• Coding Standards
• Open Work Area</p><h3 id=agile-vs-plan-driven>Agile vs. Plan Driven<a hidden class=anchor aria-hidden=true href=#agile-vs-plan-driven>#</a></h3><blockquote><p>Early software development methods that emerged in the 1970s - such as the Waterfall method - is plan-driven and inﬂexible. But having a strong 先期 up-front plan provides for considerable predictability (as long as the requirements don’t change too much) and makes it easier to coordinate large numbers of teams.</p></blockquote><blockquote><p>Agile methods and practitioners, on the other hand, often 轻视 scorn planning, preferring teamwork, frequent face-to-face communication, ﬂexibility, and adaptation. This enhances invention and creativity.</p></blockquote><p><img loading=lazy src=/images/agile_vs_plan_application.png title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/">
<img loading=lazy src=/images/agile_vs_plan_management.png title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/">
<img loading=lazy src=/images/agile_vs_plan_tech.png title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/">
<img loading=lazy src=/images/agile_vs_plan_personnel.png title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"></p><p>• Work <strong>top-down</strong> and <strong>bottom-up</strong> simultaneously - balance will depend on the size and complexity of the project.
• <strong>Top-down</strong> does architectural work based on things like <strong>patterns, product-line</strong>.
• <strong>Bottom-up</strong> develops implementation and environment-specific constraints and solutions.
• Focus on QAs, scenarios, tactics and processes to 调和 reconcile competing aspects provides a bottomup/top-down link
• Balancing commitment and flexibility</p><h3 id=analysis-techniques>Analysis Techniques<a hidden class=anchor aria-hidden=true href=#analysis-techniques>#</a></h3><p><img loading=lazy src=/images/Analysis_Techniques.png title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/">
<img loading=lazy src=/images/Analysis_Techniques_and_Stage.png title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"></p><h2 id=product-line-architecture>Product Line Architecture<a hidden class=anchor aria-hidden=true href=#product-line-architecture>#</a></h2><p>One of the early success areas for Software Architecture was the development of Product Line Architectures. Product Line Architecture is an approach to adopt systematic <strong>reuse of architectural elements</strong> that involves changes in development process supported by specific practices that encourage reuse.</p><blockquote><p>A collection of software-intensive systems sharing a common, managed, set of features that satisfy the specific needs of a market segment or mission that are developed from a set of core assets in a prescribed way.</p></blockquote><p>Software Product Lines are directed by business goals in a particular application domain.
• The products in a product line share a software product line architecture
• Products are structured by the product line architecture and are built from services and components.
• Architercture and components are the core assets used to satisfy the business goals.
• Product line leverage commonality and limit variability of the product.</p><p><strong>Benefits to the organisation</strong>
• Large-scale productivity gains
• Improve time to market
• Maintian market presence (rapidly evolving variants)
• Sustain growth
• Improved market agility
• Better use of skills
• Enable mass customisation
• Gain control of configuration
• Improve product quality
• Better predictability of cost, schedule and quality</p><p><strong>Costs of a product line</strong>
• Architecture: flexible enough to support variation in the products
• Software components: general enough to support variability
• Test plans, cases, data: take account of variation in components
• Business cases: must operate at the level of a product family
• Project plans: generic and extensible to deal with variation
• Tools and processes: must support architecture, variation, configuration, ..
• People, skills, training: need to be skilled in architecture and product lines.
<img loading=lazy src=/images/Product_Line_Economics.png title="image from: Software Product-Line Engineering: A Family-Based Software Development Process. Weiss,D.M. & Lay, C.T.R. 1999">
Product lines spread costs over several products:• Requirements and requirements analysis • Domain model • Architecture and design • Performance engineering • Documentation • Test cases, data, and plans • Skills • Processes, methods and tools • Defect fixing • Components and services</p><p><strong>Core Process Activities</strong>
• Core asset development: improving the base components in terms of qualities, products they support, and architecture.
• Product development: identifying and building products to meet market need inside the product line.
• Management: monitoring and improving the processes, tools and practices.</p><p><strong>Introducing Product Lines</strong>
• Proactive: <strong>Up-front</strong> investment to develop the core assets - need to know the market well (maybe have an already established set of products)
• Reactive: Start with one or two products and use them to generate core assets.
• Incremental: Develop core assets as the business need evolves.</p><h3 id=example-bosch-gasoline-systems>Example: Bosch Gasoline Systems<a hidden class=anchor aria-hidden=true href=#example-bosch-gasoline-systems>#</a></h3><p>Goals
■ Competitiveness:
• Reduced hardware resource consumption
• Reduced time to market for new features
■ Development efficiency
• Reuse: Applications can be used across different generations of system; “core” software is highly configurable and is reused via reconfiguration; “Vehicle functions” can be used across gasoline and diesel engines
• Easy configuration of software products
• Increased planning accuracy
■ Quality
• Interface integrity
• Reuse of core assets
■ Customer needs
• Differentiation by individual software solutions
• Clear feature-cost mapping</p><p>Component Redesign
■ Focussed on: reuse; simplification of calibration; resource consumption; stabilisation of interfaces (within the architecture)
■ Redesign progressed by:
• Analysing existing software inventory: features, sources of variability; relation to product line; document interdependency.
• Concept development and design of components: simplification; configurability; architecture driven structure; document relations between features and components;
• Baselines for variants of software components: document baselines; implement; maintain up-to-date document and implementation.</p><p>Phased Introduction
■ Investigate and customise product line engineering.
■ Design and pilot adequate processes and methods.
■ Roll out and institutionalise in the standard development process.
<img loading=lazy src=/images/product_line_Roll_out.png title="image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"></p><h2 id=devops>DevOps<a hidden class=anchor aria-hidden=true href=#devops>#</a></h2><p>The line between development and operation becomes more blurred and the use of the live environment to test innovations becomes more common. DevOps is a set of practices that span development and operation.</p><p>Operations have the direct experience of use of the system
– monitoring that use is a way of empirically verifying quality
– operations have the data that is used to regulate operations and is essential information for development.</p><p>Development is responsible for building in the right monitoring to ensure operations can operate effectively.</p><blockquote><p>DevOps is a set of practices intended to reduce the time between committing a change to a system and the change being placed into normal operation while ensuring necessary quality.</p></blockquote><p><a href=http://open-services.net/>Open Services for Lifecycle Collaboration (OSLC)</a>: OSLC is an open and scalable approach to lifecycle integration. It simplifies key integration scenarios across heterogeneous tools.</p><p>Traditionally we use test as the way of delivering quality change but we can “shepherd” committed change into use by controlling quantities of change, users experiencing change, results of monitoring than this may offer a better way. Delivery mechanism needs to be high quality: reliable, repeatable, available.</p><p>Critical points
• Making the decision to commit the code to be introduced into the system.
• Transitioning from being under consideration into part of the production deployment that will be used by all users.
• Issues is how to have enough confidence to make each of these transitions. Monitoring is critical.
• The question is how to ensure the transitions are as reliable as possible.</p><p>The extent of the lifecycle
• Involves all people involved in the delivery of the service/application
• Operations and development people are in continuous interaction.
• We need architecture to achieve this.
• Microservices architectural pattern is often used.</p><h3 id=microservices>Microservices<a hidden class=anchor aria-hidden=true href=#microservices>#</a></h3><blockquote><p>The term &ldquo;Microservice Architecture&rdquo; has sprung up over the last few years to describe a particular way of designing software applications as <strong>suites of independently deployable services</strong>.</p></blockquote><blockquote><p>The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API.
&mdash; <a href=https://martinfowler.com/articles/microservices.html>https://martinfowler.com/articles/microservices.html</a></p></blockquote><p><img loading=lazy src=https://martinfowler.com/articles/microservices/images/sketch.png title="Monoliths and Microservices. Image from: https://martinfowler.com/articles/microservices/images/sketch.png">
Attributes of Microservice Architecture
• Separately deployed units
• Very small service components
• Single purpose function or an independent portion of functionality
• Distributed
• Loosely coupled
• Multiple versions are acceptable
• Asynchronous
• No Orchestration</p><h2 id=architecture-evaluation>Architecture Evaluation<a hidden class=anchor aria-hidden=true href=#architecture-evaluation>#</a></h2><p>Evaluation by Designer
• The consequences of the decision making regulate how much effort to put into the process – more importance means more effort in evaluation.
• Try to use iterative approaches that get deeper in order to eliminate unpromising alternatives early.
• Don’t strive for perfection, good enough for the context is usually enough.</p><p>Peer Evaluation
• Fix on the QAs to consider as part of the review – may be determined by the process or the business case.
• The architect presents the architecture to the reviewers – questions are for information.
• The review is driven by the relevant scenarios – the architect talks the review team through a scenario demonstrating the architecture meets the requirements captured in the scenario.
• The outcome is a list of potential issues with actions: fix, mitigate, tolerate, …</p><p>External Evaluation
• Means to bring in additional expertise.
• May represent some stakeholder interests.
• More expensive and difficult to organise so this will often correspond to some major hurdle in the process.</p><h3 id=the-architecture-tradeoff-analysis-method-atam>The Architecture Tradeoff Analysis Method (ATAM)<a hidden class=anchor aria-hidden=true href=#the-architecture-tradeoff-analysis-method-atam>#</a></h3><blockquote><p>ATAM is a risk-mitigation process. Its purpose is to help choose a suitable architecture for a software system by discovering trade-offs and sensitivity points, to capture project risks.
ATAM is most beneficial when done <strong>early</strong> in the software development life-cycle, when the cost of changing architectures is minimal.</p></blockquote><p>Designed to be usable where:
– Evaluators are not expert in the architecture
– Evaluators need not be familiar with the business goals.
– The system need not be fully developed
– There may be large numbers of stakeholders</p><p>Participants in ATM
• <strong>The evaluation team</strong>: 3-5 people with designated roles (people may have multiple roles). Team members should be seen to be neutral with respect to the project.
• <strong>Project decision takers</strong>: manager of the project, funder of the project, main architect
• <strong>Architecture stakeholders</strong>: developers, testers, integrators, maintainers, performance engineers, …</p><h4 id=atam-evaluation-team-roles-and-responsibilities>ATAM evaluation team roles and responsibilities<a hidden class=anchor aria-hidden=true href=#atam-evaluation-team-roles-and-responsibilities>#</a></h4><p>Team Leader
Sets up the evaluation; coordinates with client, making sure client&rsquo;s needs are met; establishes evaluation contract; forms evaluation team; sees that final report is produced and delivered (although the writing may be delegated)</p><p>Evaluation Leader
Runs evaluation; facilitates elicitation of scenarios; administers scenario selection/prioritization process; facilitates evaluation of scenarios against architecture; facilitates onsite analysis</p><p>Scenario Scribe
Writes scenarios on flipchart or whiteboard during scenario elicitation; captures agreed-on wording of each scenario, halting discussion until exact wording is captured</p><p>Proceedings Scribe
Captures proceedings in electronic form on laptop or workstation, raw scenarios, issue(s) that motivate each scenario (often lost in the wording of the scenario itself), and resolution of each scenario when applied to architecture(s); also generates a printed list of adopted scenarios for handout to all participants</p><p>Timekeeper
Helps evaluation leader stay on schedule; helps control amount of time devoted to each scenario during the evaluation phase</p><p>Process Observer
Keeps notes on how evaluation process could be improved or deviated from; usually keeps silent but may make discreet process-based suggestions to the evaluation leader during the evaluation; after evaluation, reports on how the process went and lessons learned for future improvement; also responsible for reporting experience to architecture evaluation team at large</p><p>Process Enforcer
Helps evaluation leader remember and carry out the steps of the evaluation method</p><p>Questioner
Raise issues of architectural interest that stakeholders may not have thought of</p><h4 id=atam-outputs>ATAM Outputs<a hidden class=anchor aria-hidden=true href=#atam-outputs>#</a></h4><p>• Concise presentation of the architecture – needs to be presentable in around one hour.
• Articulation of the business goals – clearly communicated to all participants
• Prioritized QA requirements expressed as scenarios – testable QA requirements.
• Risks and non-risks – architecture decision that carries risks (or not).
• Risk themes – attempt to identify systemic risk by grouping risks into themes.
• Mapping of Architecture Decisions to QA requirements – motivating architecture decisions by QA requirements
• Identified sensitivity and tradeoff decisions – critical decisions that have significant impact on QA requirements.</p><p><img loading=lazy src=/images/ATAM_Phases_and_Their_Characteristics.png title="ATAM Phases and Their Characteristics. image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/">
Partnership and preparation: Getting the schedule, agendas and list of stakeholders prepared, preparing necessary documents and presentations, and gettting documents to the evaluation team</p><h4 id=steps-of-evaluation-phase>Steps of Evaluation Phase<a hidden class=anchor aria-hidden=true href=#steps-of-evaluation-phase>#</a></h4><p>The ATAM analysis phases (phase 1 and phase 2) consist of nine steps.</p><p>Steps 1 through 6 are carried out in phase 1</p><ol><li>Presentation of the ATAM approach – remind participants of the approach</li><li>Business drivers presentation – functions; constraints; business goals; major stakeholders; architectural drivers</li><li>Architecture presentation:<ul><li>Context for the system</li><li>Static modular view</li><li>Component and connector view</li><li>Deployment view</li><li>Main QA requirements and how the architecture addresses them:<ul><li>What has been reused</li><li>Trace of key use cases</li><li>Trace of key change scenarios</li><li>Main issues/risks driving architectural change</li></ul></li></ul></li><li>Identify architectural approaches – create a catalogue of patterns and tactics used in the architecture.</li><li>Generate Quality Attribute Utility Tree<ul><li>this is an approach to identifying <strong>architecturally significant requirements (ASR)</strong> by looking through the QAs - identifying particular aspects of the QA that are relevant and any requirements related to that aspect of the QA.</li><li>Each ASR is ranked High, Medium or Low in importance.</li></ul></li><li>Analyze architectural approaches – look at the most important QA requirement scenarios as identified at <strong>stage 5</strong> and probe how the architecture meets the QA scenario.</li></ol><p>In phase 2, with all stakeholders present, those steps are summarized
7. Brainstorm prioritization of scenarios – revisit the prioritization for additional scenarios, e.g. a particular stakeholder (performance engineer) might propose a scenario on the response time of the system.
8. Analyze Architectural Approaches – revisit <strong>stage 6</strong> but with an expanded and reprioritized set of scenarios
9. Present results – the evaluation group tries to group risks into risk themes to identify systemic issues and results are presented.</p><p><img loading=lazy src=/images/Steps_of_Evaluation_Phase.png title="Lightweight version of Evaluation ATAM Phases steps. image from:  http://www.inf.ed.ac.uk/teaching/courses/sapm/"></p><p>ATAM Results
• Documentation of architectural approaches taken by the project.
• Prioritized list of scenarios
• Utility tree
• Risks discovered
• Non-risks identified
• Sensitivity and Tradeoff points identified</p><h2 id=general-practice-extraction-service-gpes><a href=https://www.nao.org.uk/report/general-practice-extraction-service-investigation/>General Practice Extraction Service (GPES)</a><a hidden class=anchor aria-hidden=true href=#general-practice-extraction-service-gpes>#</a></h2><p>An IT system designed to allow NHS organizations to <strong>extract data from GP practice computer systems</strong> in England. This data would be used to monitor quality, plan and pay for health services and help medical research.
数据的请求和返回不需要实时，更多的是定期的请求，一定时间内返回数据。</p><blockquote><p>General practitioner (GP), 全科医生。在英国，每个人都需要注册一个全科医生的诊所，当人们感到身体不适后首先会去联系的自己的全科医生。全科医生只进行有限的治疗，并建议是否有必要去医院看专科医生。每个 GP 都像小公司一样运作，有自己的 GP 系统，为患者保留病患记录。在英国，各种不同的机构组织可能需要了解GP正在做什么，因此需要从所有这些GP系统中提取数据。GPES 系统允许那些已经得到授权的机构组织，通过 NHSCIC（国家卫生和社会保健信息中心）提取各种GP数据。因为不同机构需要的信息不同，NHSCIC 需要研究制定如何提取指定的数据，并运行 GPES 系统从英国的所有GP系统提取数据。GP 可以从四种不同的 GP 系统中四选一。而 GPES 的挑战在于整合来自各个不同系统的GP的数据。</p></blockquote><p>问题</p><ul><li>The project has been significantly <strong>delayed</strong> and many customers have yet to receive data.</li><li>Mistakes in the original 采购 procurement and contract management contributed to <strong>losses of public funds</strong>, through asset write-offs and settlements with suppliers.</li><li>Only one customer, NHS England has so far received data from GPES. The time needed to design a new type of extract and restrictions in the contracts severely limits HSCIC’s ability to provide data to those who request it. It is unlikely that GPES in its current form can provide the NHS-wide service planned.
<img loading=lazy src=/images/GPES_customers.png>
<img loading=lazy src=/images/GPES_structure.png></li></ul><p>Data Extract Issue</p><ul><li>NHS did a technical review of GPES in early 2011, which recommended several <strong>significant changes</strong> to its design. In the original design, each GP system supplier would use <strong>a common query language</strong> as part of their extraction system. This would allow the NHSIC to design a single extract centrally using the query tool, which all GP clinical systems could understand.</li><li>The technical review recommended an <strong>alternative</strong> where each supplier would be <strong>free to develop their own query methods</strong>. New queries would no longer be designed in the query tool using a common language, but would instead need to be designed as logical ‘business rules’ and sent to GP system suppliers to implement.</li><li>The NHSIC decided to abandon both the GPSOC contract approach and the common query language, as they could not agree either with the Department and GP system suppliers. They then procured the extraction systems by negotiating direct with the GP clinical system suppliers.</li><li>NHSIC is using a non-competitive procurement approach, plus the changes in design, contributed to the restrictive process for designing new extracts.</li><li>The HSCIC, has continued to use the GPSOC framework to require data sharing between NHS systems. The new framework, effective from 2014, says that principal clinical system suppliers must provide an interface method for third-party systems to use. This would improve interoperability between systems in GP practices and the health community.</li><li>The HSCIC cannot do the wide range and scale of data extracts the NHS requests, because of the design of the GPES system and restrictions in supplier contracts. Customers have requested over 100 different data extracts from GPES, but the HSCIC estimate they will be able to design only 24 new extracts in 2015-16.</li><li>Figure shows a summary of the HSCIC’s process to develop a new extract, each of which the supplier designs and programmes from scratch. The HSCIC have limited flexibility to amend extracts once developed, for example to change a time period and the specific organisations it will extract data from.
<img loading=lazy src=/images/GPES_extract_develop_process.png></li><li>GPES will continue to operate in the short term, as its data is critical for determining payments to GPs. Its coverage of all practices in England cannot currently be replicated by other primary care data extraction systems.</li><li>However, limited capacity and the difficulty of developing new extracts deters wider use. The HSCIC has acknowledged there is unlikely to be a long-term future for all or part of the GPES. However, they intend to reuse parts for a replacement system if possible. The HSCIC estimate that they will achieve less than two more years of use from the GPES in its current form, in contrast to the five-year minimum lifetime assumed for new IT systems.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/software-engineer/>Software Engineer</a></li><li><a href=https://congchan.github.io/tags/inf-course-note/>Inf Course Note</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/inf-course-note-parallel-programming-language-and-systems/><span class=title>« Prev</span><br><span>Inf Course Note - Parallel Programming Language and Systems</span>
</a><a class=next href=https://congchan.github.io/posts/inf-course-note-software-testing/><span class=title>Next »</span><br><span>Inf Course Note - Software Testing</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Architecture, Process, and Management on x" href="https://x.com/intent/tweet/?text=Inf%20Course%20Note%20-%20Software%20Architecture%2c%20Process%2c%20and%20Management&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-architecture-process-and-management%2f&amp;hashtags=SoftwareEngineer%2cInfCourseNote"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Architecture, Process, and Management on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-architecture-process-and-management%2f&amp;title=Inf%20Course%20Note%20-%20Software%20Architecture%2c%20Process%2c%20and%20Management&amp;summary=Inf%20Course%20Note%20-%20Software%20Architecture%2c%20Process%2c%20and%20Management&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-architecture-process-and-management%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Architecture, Process, and Management on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-architecture-process-and-management%2f&title=Inf%20Course%20Note%20-%20Software%20Architecture%2c%20Process%2c%20and%20Management"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Architecture, Process, and Management on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-architecture-process-and-management%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Architecture, Process, and Management on whatsapp" href="https://api.whatsapp.com/send?text=Inf%20Course%20Note%20-%20Software%20Architecture%2c%20Process%2c%20and%20Management%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-architecture-process-and-management%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Architecture, Process, and Management on telegram" href="https://telegram.me/share/url?text=Inf%20Course%20Note%20-%20Software%20Architecture%2c%20Process%2c%20and%20Management&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-architecture-process-and-management%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Inf Course Note - Software Architecture, Process, and Management on ycombinator" href="https://news.ycombinator.com/submitlink?t=Inf%20Course%20Note%20-%20Software%20Architecture%2c%20Process%2c%20and%20Management&u=https%3a%2f%2fcongchan.github.io%2fposts%2finf-course-note-software-architecture-process-and-management%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>