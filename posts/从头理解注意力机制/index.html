<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从头理解注意力机制 | Cong's Log</title><meta name=keywords content="Attention,NLP"><meta name=description content='注意力机制如何起源的
神经网络中的注意力机制启发自人类的视觉注意力机制，能够（高分辨率地）聚焦于图像中需要重点关注的目标区域（节省大脑资源），同时（低分辨率地）感知周围的图像，然后随着时间的推移调整焦点（状态调整）。
在神经网路中，注意力机制是为了解决什么问题？

在深度学习还没流行的时候, 传统的算法早已应用了注意力机制的思想.
比如一个非线性回归问题，对于代表位置的输入变量${x_1, ..., x_m}$ 和 代表位置对应的输出值${y_1, ..., y_m}$, 如何预测新的$x_n$对应的输出? Baseline 就是求均值, 
$$\frac{1}{m} \sum_{i=1}^{m} y_i$$ 当然更好的方案(Watson, Nadaraya, 1964)是根据不同的输入$x_i$给与$y_i$不同的权重, 
$$y = \sum_{i=1}^{m} \alpha(x, x_i) y_i $$这里$x$代表一个新的输入(作为query), 根据$x$和已有的位置$x_i$(作为key)进行某种运算, 得到$x_i$对应的输出$y_i$(作为value)的权重. 如果每一个权重都是一个Guassians分布, 并正则化, 则一个加权的回归预测模型就是:
$$f(x) = \sum_i y_i \frac{k(x_i, x)}{\sum_j k(x_j, x)}$$这个算法的"深度学习"版本, 就是其权重是通过优化器(如sgd)学习得来, 并且把平均运算改为加权池化(weighted pooling).
如何简单直观地理解注意力机制
虽然注意力机制一开始被应用于图像识别领域，但是后来推广到神经机器翻译(NMT)中(Seq2Seq for Machine Translation, Sutskever, Vinyals, Le ‘14). NMT也是注意力机制在NLP领域最早最成功的应用之一.

在上图中，Echt，Dicke和Kiste词被送到编码器中，并且在特殊信号（未显示）之后，解码器开始生成翻译后的句子。解码器不断生成单词，直到产生特殊的句子结尾标记(如<eos>)。也就是说解码器仅根据最后一个隐含状态$h_3$来生成序列. 假如这个句子很短, 那么效果其实是很好的.
不过对于比较长的句子, 那么这个架构的弱点就暴露无疑了.

首先, 编码器能否把句子的所有信息(语言学上的和常识等知识)都理解/捕捉到?
其次, 受限于目前的实现技术(主要是硬件), 单个隐含状态(如$h_3$这个向量)的维度大小是有限的, 而句子长度以及语言的组合情况是无限的, 单靠$h_3$自身是存储信息能力是有限的.
再者, 解码器是否有足够的解码能力从一个隐含状态中解码出所有的信息?

虽然大部分句子是相对紧凑的, 但语言有个特点, 就是一个词有可能和前面好几步之外的词有联系, 比如一些指代词用于指代文本最开头出现的名词; 语义上, 某个句子的理解, 可能依赖于前面多个句子; 当然往大了说, 要理解一篇文章或一本书, 我们通常需要理解并联系多个段落, 多个章节. 这种现象称之为语言的长距离依赖(long-term dependency), 在一般性的序列数据中, 这个现象称之为的Long-range dependence(LRD). 即使是使用了LSTM这种理论上可以克服长距离依赖问题地网络, 也无法很好的克服语言的长距离依赖问题, 究其原因, 除了LSTM自身的局限性之外, 更主要是深度学习的梯度学习方法的局限性(在梯度反向传播中, 会出现梯度消失).'><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/%E4%BB%8E%E5%A4%B4%E7%90%86%E8%A7%A3%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/%E4%BB%8E%E5%A4%B4%E7%90%86%E8%A7%A3%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/%E4%BB%8E%E5%A4%B4%E7%90%86%E8%A7%A3%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="从头理解注意力机制"><meta property="og:description" content='注意力机制如何起源的 神经网络中的注意力机制启发自人类的视觉注意力机制，能够（高分辨率地）聚焦于图像中需要重点关注的目标区域（节省大脑资源），同时（低分辨率地）感知周围的图像，然后随着时间的推移调整焦点（状态调整）。
在神经网路中，注意力机制是为了解决什么问题？
在深度学习还没流行的时候, 传统的算法早已应用了注意力机制的思想.
比如一个非线性回归问题，对于代表位置的输入变量${x_1, ..., x_m}$ 和 代表位置对应的输出值${y_1, ..., y_m}$, 如何预测新的$x_n$对应的输出? Baseline 就是求均值, $$\frac{1}{m} \sum_{i=1}^{m} y_i$$ 当然更好的方案(Watson, Nadaraya, 1964)是根据不同的输入$x_i$给与$y_i$不同的权重, $$y = \sum_{i=1}^{m} \alpha(x, x_i) y_i $$这里$x$代表一个新的输入(作为query), 根据$x$和已有的位置$x_i$(作为key)进行某种运算, 得到$x_i$对应的输出$y_i$(作为value)的权重. 如果每一个权重都是一个Guassians分布, 并正则化, 则一个加权的回归预测模型就是:
$$f(x) = \sum_i y_i \frac{k(x_i, x)}{\sum_j k(x_j, x)}$$这个算法的"深度学习"版本, 就是其权重是通过优化器(如sgd)学习得来, 并且把平均运算改为加权池化(weighted pooling).
如何简单直观地理解注意力机制 虽然注意力机制一开始被应用于图像识别领域，但是后来推广到神经机器翻译(NMT)中(Seq2Seq for Machine Translation, Sutskever, Vinyals, Le ‘14). NMT也是注意力机制在NLP领域最早最成功的应用之一.
在上图中，Echt，Dicke和Kiste词被送到编码器中，并且在特殊信号（未显示）之后，解码器开始生成翻译后的句子。解码器不断生成单词，直到产生特殊的句子结尾标记(如<eos>)。也就是说解码器仅根据最后一个隐含状态$h_3$来生成序列. 假如这个句子很短, 那么效果其实是很好的.
不过对于比较长的句子, 那么这个架构的弱点就暴露无疑了.
首先, 编码器能否把句子的所有信息(语言学上的和常识等知识)都理解/捕捉到? 其次, 受限于目前的实现技术(主要是硬件), 单个隐含状态(如$h_3$这个向量)的维度大小是有限的, 而句子长度以及语言的组合情况是无限的, 单靠$h_3$自身是存储信息能力是有限的. 再者, 解码器是否有足够的解码能力从一个隐含状态中解码出所有的信息? 虽然大部分句子是相对紧凑的, 但语言有个特点, 就是一个词有可能和前面好几步之外的词有联系, 比如一些指代词用于指代文本最开头出现的名词; 语义上, 某个句子的理解, 可能依赖于前面多个句子; 当然往大了说, 要理解一篇文章或一本书, 我们通常需要理解并联系多个段落, 多个章节. 这种现象称之为语言的长距离依赖(long-term dependency), 在一般性的序列数据中, 这个现象称之为的Long-range dependence(LRD). 即使是使用了LSTM这种理论上可以克服长距离依赖问题地网络, 也无法很好的克服语言的长距离依赖问题, 究其原因, 除了LSTM自身的局限性之外, 更主要是深度学习的梯度学习方法的局限性(在梯度反向传播中, 会出现梯度消失).'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-10T00:00:00+00:00"><meta property="article:modified_time" content="2018-07-10T00:00:00+00:00"><meta property="article:tag" content="Attention"><meta property="article:tag" content="NLP"><meta name=twitter:card content="summary"><meta name=twitter:title content="从头理解注意力机制"><meta name=twitter:description content='注意力机制如何起源的
神经网络中的注意力机制启发自人类的视觉注意力机制，能够（高分辨率地）聚焦于图像中需要重点关注的目标区域（节省大脑资源），同时（低分辨率地）感知周围的图像，然后随着时间的推移调整焦点（状态调整）。
在神经网路中，注意力机制是为了解决什么问题？

在深度学习还没流行的时候, 传统的算法早已应用了注意力机制的思想.
比如一个非线性回归问题，对于代表位置的输入变量${x_1, ..., x_m}$ 和 代表位置对应的输出值${y_1, ..., y_m}$, 如何预测新的$x_n$对应的输出? Baseline 就是求均值, 
$$\frac{1}{m} \sum_{i=1}^{m} y_i$$ 当然更好的方案(Watson, Nadaraya, 1964)是根据不同的输入$x_i$给与$y_i$不同的权重, 
$$y = \sum_{i=1}^{m} \alpha(x, x_i) y_i $$这里$x$代表一个新的输入(作为query), 根据$x$和已有的位置$x_i$(作为key)进行某种运算, 得到$x_i$对应的输出$y_i$(作为value)的权重. 如果每一个权重都是一个Guassians分布, 并正则化, 则一个加权的回归预测模型就是:
$$f(x) = \sum_i y_i \frac{k(x_i, x)}{\sum_j k(x_j, x)}$$这个算法的"深度学习"版本, 就是其权重是通过优化器(如sgd)学习得来, 并且把平均运算改为加权池化(weighted pooling).
如何简单直观地理解注意力机制
虽然注意力机制一开始被应用于图像识别领域，但是后来推广到神经机器翻译(NMT)中(Seq2Seq for Machine Translation, Sutskever, Vinyals, Le ‘14). NMT也是注意力机制在NLP领域最早最成功的应用之一.

在上图中，Echt，Dicke和Kiste词被送到编码器中，并且在特殊信号（未显示）之后，解码器开始生成翻译后的句子。解码器不断生成单词，直到产生特殊的句子结尾标记(如<eos>)。也就是说解码器仅根据最后一个隐含状态$h_3$来生成序列. 假如这个句子很短, 那么效果其实是很好的.
不过对于比较长的句子, 那么这个架构的弱点就暴露无疑了.

首先, 编码器能否把句子的所有信息(语言学上的和常识等知识)都理解/捕捉到?
其次, 受限于目前的实现技术(主要是硬件), 单个隐含状态(如$h_3$这个向量)的维度大小是有限的, 而句子长度以及语言的组合情况是无限的, 单靠$h_3$自身是存储信息能力是有限的.
再者, 解码器是否有足够的解码能力从一个隐含状态中解码出所有的信息?

虽然大部分句子是相对紧凑的, 但语言有个特点, 就是一个词有可能和前面好几步之外的词有联系, 比如一些指代词用于指代文本最开头出现的名词; 语义上, 某个句子的理解, 可能依赖于前面多个句子; 当然往大了说, 要理解一篇文章或一本书, 我们通常需要理解并联系多个段落, 多个章节. 这种现象称之为语言的长距离依赖(long-term dependency), 在一般性的序列数据中, 这个现象称之为的Long-range dependence(LRD). 即使是使用了LSTM这种理论上可以克服长距离依赖问题地网络, 也无法很好的克服语言的长距离依赖问题, 究其原因, 除了LSTM自身的局限性之外, 更主要是深度学习的梯度学习方法的局限性(在梯度反向传播中, 会出现梯度消失).'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"从头理解注意力机制","item":"https://congchan.github.io/posts/%E4%BB%8E%E5%A4%B4%E7%90%86%E8%A7%A3%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从头理解注意力机制","name":"从头理解注意力机制","description":"注意力机制如何起源的 神经网络中的注意力机制启发自人类的视觉注意力机制，能够（高分辨率地）聚焦于图像中需要重点关注的目标区域（节省大脑资源），同时（低分辨率地）感知周围的图像，然后随着时间的推移调整焦点（状态调整）。\n在神经网路中，注意力机制是为了解决什么问题？\n在深度学习还没流行的时候, 传统的算法早已应用了注意力机制的思想.\n比如一个非线性回归问题，对于代表位置的输入变量${x_1, ..., x_m}$ 和 代表位置对应的输出值${y_1, ..., y_m}$, 如何预测新的$x_n$对应的输出? Baseline 就是求均值, $$\\frac{1}{m} \\sum_{i=1}^{m} y_i$$ 当然更好的方案(Watson, Nadaraya, 1964)是根据不同的输入$x_i$给与$y_i$不同的权重, $$y = \\sum_{i=1}^{m} \\alpha(x, x_i) y_i $$这里$x$代表一个新的输入(作为query), 根据$x$和已有的位置$x_i$(作为key)进行某种运算, 得到$x_i$对应的输出$y_i$(作为value)的权重. 如果每一个权重都是一个Guassians分布, 并正则化, 则一个加权的回归预测模型就是:\n$$f(x) = \\sum_i y_i \\frac{k(x_i, x)}{\\sum_j k(x_j, x)}$$这个算法的\u0026quot;深度学习\u0026quot;版本, 就是其权重是通过优化器(如sgd)学习得来, 并且把平均运算改为加权池化(weighted pooling).\n如何简单直观地理解注意力机制 虽然注意力机制一开始被应用于图像识别领域，但是后来推广到神经机器翻译(NMT)中(Seq2Seq for Machine Translation, Sutskever, Vinyals, Le ‘14). NMT也是注意力机制在NLP领域最早最成功的应用之一.\n在上图中，Echt，Dicke和Kiste词被送到编码器中，并且在特殊信号（未显示）之后，解码器开始生成翻译后的句子。解码器不断生成单词，直到产生特殊的句子结尾标记(如\u0026lt;eos\u0026gt;)。也就是说解码器仅根据最后一个隐含状态$h_3$来生成序列. 假如这个句子很短, 那么效果其实是很好的.\n不过对于比较长的句子, 那么这个架构的弱点就暴露无疑了.\n首先, 编码器能否把句子的所有信息(语言学上的和常识等知识)都理解/捕捉到? 其次, 受限于目前的实现技术(主要是硬件), 单个隐含状态(如$h_3$这个向量)的维度大小是有限的, 而句子长度以及语言的组合情况是无限的, 单靠$h_3$自身是存储信息能力是有限的. 再者, 解码器是否有足够的解码能力从一个隐含状态中解码出所有的信息? 虽然大部分句子是相对紧凑的, 但语言有个特点, 就是一个词有可能和前面好几步之外的词有联系, 比如一些指代词用于指代文本最开头出现的名词; 语义上, 某个句子的理解, 可能依赖于前面多个句子; 当然往大了说, 要理解一篇文章或一本书, 我们通常需要理解并联系多个段落, 多个章节. 这种现象称之为语言的长距离依赖(long-term dependency), 在一般性的序列数据中, 这个现象称之为的Long-range dependence(LRD). 即使是使用了LSTM这种理论上可以克服长距离依赖问题地网络, 也无法很好的克服语言的长距离依赖问题, 究其原因, 除了LSTM自身的局限性之外, 更主要是深度学习的梯度学习方法的局限性(在梯度反向传播中, 会出现梯度消失).\n","keywords":["Attention","NLP"],"articleBody":"注意力机制如何起源的 神经网络中的注意力机制启发自人类的视觉注意力机制，能够（高分辨率地）聚焦于图像中需要重点关注的目标区域（节省大脑资源），同时（低分辨率地）感知周围的图像，然后随着时间的推移调整焦点（状态调整）。\n在神经网路中，注意力机制是为了解决什么问题？\n在深度学习还没流行的时候, 传统的算法早已应用了注意力机制的思想.\n比如一个非线性回归问题，对于代表位置的输入变量${x_1, ..., x_m}$ 和 代表位置对应的输出值${y_1, ..., y_m}$, 如何预测新的$x_n$对应的输出? Baseline 就是求均值, $$\\frac{1}{m} \\sum_{i=1}^{m} y_i$$ 当然更好的方案(Watson, Nadaraya, 1964)是根据不同的输入$x_i$给与$y_i$不同的权重, $$y = \\sum_{i=1}^{m} \\alpha(x, x_i) y_i $$这里$x$代表一个新的输入(作为query), 根据$x$和已有的位置$x_i$(作为key)进行某种运算, 得到$x_i$对应的输出$y_i$(作为value)的权重. 如果每一个权重都是一个Guassians分布, 并正则化, 则一个加权的回归预测模型就是:\n$$f(x) = \\sum_i y_i \\frac{k(x_i, x)}{\\sum_j k(x_j, x)}$$这个算法的\"深度学习\"版本, 就是其权重是通过优化器(如sgd)学习得来, 并且把平均运算改为加权池化(weighted pooling).\n如何简单直观地理解注意力机制 虽然注意力机制一开始被应用于图像识别领域，但是后来推广到神经机器翻译(NMT)中(Seq2Seq for Machine Translation, Sutskever, Vinyals, Le ‘14). NMT也是注意力机制在NLP领域最早最成功的应用之一.\n在上图中，Echt，Dicke和Kiste词被送到编码器中，并且在特殊信号（未显示）之后，解码器开始生成翻译后的句子。解码器不断生成单词，直到产生特殊的句子结尾标记(如)。也就是说解码器仅根据最后一个隐含状态$h_3$来生成序列. 假如这个句子很短, 那么效果其实是很好的.\n不过对于比较长的句子, 那么这个架构的弱点就暴露无疑了.\n首先, 编码器能否把句子的所有信息(语言学上的和常识等知识)都理解/捕捉到? 其次, 受限于目前的实现技术(主要是硬件), 单个隐含状态(如$h_3$这个向量)的维度大小是有限的, 而句子长度以及语言的组合情况是无限的, 单靠$h_3$自身是存储信息能力是有限的. 再者, 解码器是否有足够的解码能力从一个隐含状态中解码出所有的信息? 虽然大部分句子是相对紧凑的, 但语言有个特点, 就是一个词有可能和前面好几步之外的词有联系, 比如一些指代词用于指代文本最开头出现的名词; 语义上, 某个句子的理解, 可能依赖于前面多个句子; 当然往大了说, 要理解一篇文章或一本书, 我们通常需要理解并联系多个段落, 多个章节. 这种现象称之为语言的长距离依赖(long-term dependency), 在一般性的序列数据中, 这个现象称之为的Long-range dependence(LRD). 即使是使用了LSTM这种理论上可以克服长距离依赖问题地网络, 也无法很好的克服语言的长距离依赖问题, 究其原因, 除了LSTM自身的局限性之外, 更主要是深度学习的梯度学习方法的局限性(在梯度反向传播中, 会出现梯度消失).\n在没有更好地参数学习方法替代, 以及隐含层容量有限的前提下, 注意力机制通过为各个时间步的词分配注意力, 从理论上赋予了模型回望源头任意时间步的能力. 注意力机制自身包含的参数是一般神经网络的重要补充, 而它的机能也一定程度上解决了梯度消失的问题.\n注意力机制在NMT的具体作用过程是这样, 训练过程中, 给定一对输入序列知识就是力量和输出序列Knowledge is power 。解码器可以在输出序列的时间步1(当前时间步就是一个query), 使用集中编码了知识信息的背景变量来生成Knowledge，在时间步2使用更集中编码了就是的信息的背景变量来生成is，依此类推。这看上去就像是在解码器的每一时间步对输入序列中不同时间步编码的信息分配不同的注意力。这样注意力矩阵参数就编码了这种\"注意力\", 同时也更好的协助其他网络部件学习参数. 在预测阶段的每一个时间步, 注意力也参与其中.\n一个经典的(目前也还在不断发展的)NLP问题是文本编码, 即把非结构化的文本, 映射为结构化的数字/向量. 较早有纯统计的Bag of words(Salton \u0026 McGill, 1986), 后期发展出了经典的Word2Vec(Mikolov et al., 2013). 现在主流的神经网络文本编码方法是Word2Vec, fasttext, rnn(lstm/gru)等, 核心思想是把文本中的每个字符都映射到一个embedding向量空间中, 全部加在一起得到整个文本的向量表示, $f(x)=\\rho \\bigg( \\sum_{i=1}^n \\phi(x_i) \\bigg)$, 再拿去给后续的网络做分类等任务. 这种算法的缺陷是, 最终编码出来的向量, 会偏向统计频率高的元素, 这导致其在很多实际应用中表现不好, 比如情感分析中, 很多转折句, 前后态度是反转的, 但核心是转折后的部分.\nThey respect you, they really do, but you have to… Why are you laughing?\n如何让编码模型重点关注句子的关键部分呢? 这得分情况, 一种如这样 They respect you, they really do, but you have to... Why are you laughing?, 整个句子的意思, 是着重于but后面的部分. 亦或者如Wang et al, ’16中提到的“The appetizers are ok, but the service is slow.”, 一个句子中其实分为两个意思, 对于外观口味，评价为积极，而对于服务，评价为消极。\n那么这个时候就需要用注意力机制来给句子的编码分配权重了, $$f(x)=\\rho \\bigg( \\sum_{i=1}^{n} \\alpha(w_i, X) \\phi(x_i) \\bigg)$$ 通过注意力机制，我们不再需要竭尽全力把完整的句子输入编码为固定长度的向量，二十允许解码器在输出生成的每个步骤中“关注”源语句的不同部分。\n所以 Attention 在神经网络模型中的作用就是改进池化(pooling): 没有Attention的池化:\n$$f(X)=\\rho \\bigg( \\sum_{x \\in X} \\phi(x) \\bigg)$$ 有Attention后: $$f(X)=\\rho \\bigg( \\sum_{x \\in X} \\alpha(x, w) \\phi(x) \\bigg)$$如何表达注意力机制 把Attention机制从encoder-decoder架构中抽象出来理解, 如下图: 注意力三个核心组件是:\nQuery: decoder当前待解码的输出. 如果是seq2seq模型, 那就是当前解码器待生成的时间步(用前一时间步的解码器隐含状态来表达). Key-Value: 每个key(输入序列经过编码后的隐含状态)都对应一个value. 在文本任务中, 一般Key和Value一样, 都是输入序列的编码。 Query和Key的相关性: $\\alpha(q, k)$, 告诉模型如何根据Query和各个Key的相关性来分配权重. 计算注意力的主要步骤:\n计算Query和每个key之间的相关性$\\alpha_c(q,k_i)$, 常用的相关性函数包括点积(Scaled Dot-Product Attention)，拼接，神经网路等 归一化(如softmax)后获得分配权重${\\theta_1, ..., \\theta_k}$ 计算Value的加权平均值, 作为Attention输出值. $$\\begin{eqnarray} A(q, \\{(k,v)\\}) \\xrightarrow[\\text{output}]{\\text{maps as}} \\sum_{i=1}^k{\\overbrace{\\alpha_c(q,k_i)}^{\\theta_i}}v_i, q \\in Q, k \\in K, v \\in V \\end{eqnarray}$$在编码器-解码器架构中，Query通常是解码器的隐含状态。而Key和Value，都是编码器的隐含状态。加权求和作为输出: $$\\begin{eqnarray} out = \\sum_{i=1}^k \\theta_i v_i = \\sum_{i=1}^k \\theta_i h(x_i) \\end{eqnarray}$$Attention和Memory对比 从上面的描述看Attention更像是对神经网络(如LSTM等)的记忆功能的改进. 也就是说, 注意力机制只是让网络能够访问其内存，比如编码器的隐含状态. 网络选择从内存中检索什么，并给与不同程度的“关注度”. 换句话说, 何种内存访问机制是soft的，网络将检索所有内存并加权组合。使soft的内存访问好处是可以使用反向传播轻松地进行端对端网络训练（当然也有其他办法-采样方法来计算梯度）。\n而另一方面, 更复杂的Memory机制的研究也发展地如火如荼。比如End-To-End Memory Networks(Sainbayar 2015)中提到的网络结构, 允许网络在输出之前多次读取相同的输入序列，并在每个步骤中更新内存。可以应用于, 例如通过对输入故事进行多个推理步骤来回答问题。 Joe went to the kitchen. Fred went to the kitchen. Joe picked up the milk. Joe travelled to the office. Joe left the milk. Joe went to the bathroom.\nWhere is the milk?\n此时, 当网络参数以某种方式绑定在一起时，这个内存结构就和上面介绍的注意力机制一样了，只是它在内存上进行了多次跃迁（因为它试图集成来自多个句子的信息）。\n在这种情境下, 注意力机制也可以很灵活地应用, 比如分别在字符级使用注意力机制来编码单词, 在单词级上编码句子, 在句子级上编码段落, 即 Hierarchical attention. Neural Turing Machines(Graves et al., ‘14)的思想也是在内存机制上, 通过将神经网络和外部存储资源耦合来扩展神经网络的功能，这些资源可以通过注意力机制与之交互。组合后的系统类似于图灵机或冯·诺依曼架构，具有端到端的可微分性(因此可以通过梯度下降来进行训练)。除此之外, 神经图灵机但具有更复杂的寻址类型，既可以使用基于内容的寻址（如上下文），也可以使用基于位置的寻址，从而使网络可以学习寻址模式以执行简单的计算机程序，例如排序算法。\n这里并不是要给出Attention和Memory机制的确切的定义区别(也给不了, 有的人觉得二者就是一个东西, 比如有人就称Attention其实软寻址, 应该称为Soft Attention), 而是从主流角度给出类比和解读.\n实战案例: 注意力机制应用到机器翻译中 还是以机器翻译为例: 对于解码器的每一个时间步$t'$, 生成一个背景向量$c_{t'}$来捕捉相关的解码器信息, 以用于预测输出目标值$y_{t'}$. 解码器在时间步 $t'$ 的隐藏状态 $$s_{t'} = g(y_{t'-1}, c_{t'}, s_{t'-1}).$$ 令编码器在时间 $t$ 的隐藏状态为 $h_t$，且总时间步数为 $T$。解码器在时间步 $t'$ 的背景变量为 $$c_{t'} = \\sum_{t=1}^T A{t' t} h_t,$$ 其中 $A{t' t}$ 是注意力分配的权重，用于给定解码器的当前隐藏状态 $s_{t'}$，对编码器中不同时间步的隐藏状态$h_t$求加权平均。\n$$A{t' t} = align(s_{t'}, h_t) = \\frac{\\exp(score(t' t))}{ \\sum_{t=1}^T \\exp(score(t' t)) },$$ 其中 $score(t' t) \\in \\mathbb{R}$ 的计算为 $$score(t' t) = \\alpha(s_{t' - 1}, h_t).$$上式中的score打分函数 $score(t' t)$ 有多种设计方法。Bahanau 等使用了MLP感知机：\n$$e_{t't} = v^\\top \\tanh(W_s s_{t' - 1} + W_h h_t),$$其中 $v$、$W_s$、$W_h$ 以及编码器与解码器中的各个权重和偏差都是模型参数。\nBahanau 等在编码器和解码器中分别使用了门控循环单元GRU。在解码器中，我们需要对门控循环单元的设计稍作修改。解码器在 $t' $ 时间步的隐藏状态为\n$$s_{t'} = z_{t'} \\odot s_{t'-1} + (1 - z_{t'}) \\odot \\tilde{s}_{t'},$$其中的重置门、更新门和候选隐含状态分别为\n$$ \\begin{aligned} r_{t'} \u0026= \\sigma(W_{yr} y_{t'-1} + W_{sr} s_{t' - 1} + W_{cr} c_{t'} + b_r), \\\\\\ z_{t'} \u0026= \\sigma(W_{yz} y_{t'-1} + W_{sz} s_{t' - 1} + W_{cz} c_{t'} + b_z),\\\\\\ \\tilde{s_{t'}} \u0026= \\text{tanh}(W_{ys} y_{t'-1} + W_{ss} (s_{t' - 1} \\odot r_{t'}) + W_{cs} c_{t'} + b_s). \\end{aligned} $$然后，给定目标(解码器)隐藏状态$h_{t'}$, 以及背景向量$c_{t'}$, 通过使用简单的并联层合并这两个向量的信息, 来生成所谓的注意力隐藏状态:\n$$\\tilde{h_{t'}} = \\tanh(W_c[c_{t'} : h_{t'}]) $$这个注意力向量 $\\tilde{h_t}$ 之后会通过一个softmax层来生成预测的概率分布.\n延伸阅读:全局注意力机制 Effective Approaches to Attention-based Neural Machine Translation(Luong et al. 2015)对应用于NMT的注意力机制进行了一定的总结：分为全局（global）和局部（local）注意力机制。区别在于“注意力”是放在所有源位置或仅放置在少数源位置。\nThe idea of a global attentional model is to consider all the hidden states of the encoder when deriving the context vector $c_t$.\n两种注意力机制区别就在于如何生成背景向量$c_{t'}$.\nLuong et al. (2015) 给出了几种打分函数的计算\n$$ \\begin{aligned} score_{dot}(t' t) \u0026= s^\\top_{t'}h_t \\\\\\ score_{general}(t' t) \u0026= s^\\top_{t'} W_\\alpha h_t, \\\\\\ score_{concat}(t' t) \u0026= v^\\top_\\alpha \\tanh (W_\\alpha[s_{t'} : h_t]) \\end{aligned} $$参考资料 Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. 2014. Neural machine translation by jointly learning to align and translate. arXiv preprint arXiv:1409.0473 Wang, Yequan, Minlie Huang, and Li Zhao. “Attention-based LSTM for aspect-level sentiment classification.” Proceedings of the 2016 conference on empirical methods in natural language processing. 2016. Yang, Zichao, et al. “Hierarchical attention networks for document classification.” Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. 2016. http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/ 目前主流的attention方法都有哪些？ - 张俊林的回答 - 知乎 https://www.zhihu.com/question/68482809/answer/264632289 https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis Attention in Deep Learning, Elex Smola, ICML 2019, Long Beach, CA ","wordCount":"647","inLanguage":"en","datePublished":"2018-07-10T00:00:00Z","dateModified":"2018-07-10T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/%E4%BB%8E%E5%A4%B4%E7%90%86%E8%A7%A3%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">从头理解注意力机制</h1><div class=post-meta><span title='2018-07-10 00:00:00 +0000 UTC'>2018-07-10</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/NLP-attention-01.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6%e5%a6%82%e4%bd%95%e8%b5%b7%e6%ba%90%e7%9a%84 aria-label=注意力机制如何起源的>注意力机制如何起源的</a></li><li><a href=#%e5%a6%82%e4%bd%95%e7%ae%80%e5%8d%95%e7%9b%b4%e8%a7%82%e5%9c%b0%e7%90%86%e8%a7%a3%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6 aria-label=如何简单直观地理解注意力机制>如何简单直观地理解注意力机制</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%a1%a8%e8%be%be%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6 aria-label=如何表达注意力机制>如何表达注意力机制</a></li><li><a href=#attention%e5%92%8cmemory%e5%af%b9%e6%af%94 aria-label=Attention和Memory对比>Attention和Memory对比</a></li><li><a href=#%e5%ae%9e%e6%88%98%e6%a1%88%e4%be%8b-%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6%e5%ba%94%e7%94%a8%e5%88%b0%e6%9c%ba%e5%99%a8%e7%bf%bb%e8%af%91%e4%b8%ad aria-label="实战案例: 注意力机制应用到机器翻译中">实战案例: 注意力机制应用到机器翻译中</a></li><li><a href=#%e5%bb%b6%e4%bc%b8%e9%98%85%e8%af%bb%e5%85%a8%e5%b1%80%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6 aria-label=延伸阅读:全局注意力机制>延伸阅读:全局注意力机制</a></li><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li></ul></div></details></div><div class=post-content><h3 id=注意力机制如何起源的>注意力机制如何起源的<a hidden class=anchor aria-hidden=true href=#注意力机制如何起源的>#</a></h3><p>神经网络中的注意力机制启发自人类的<strong>视觉注意力机制</strong>，能够（高分辨率地）聚焦于图像中需要重点关注的目标区域（节省大脑资源），同时（低分辨率地）感知周围的图像，然后随着时间的推移调整焦点（状态调整）。</p><p>在神经网路中，注意力机制是为了解决什么问题？</p><p>在深度学习还没流行的时候, 传统的算法早已应用了注意力机制的思想.</p><p>比如一个非线性回归问题，对于代表位置的输入变量${x_1, ..., x_m}$ 和 代表位置对应的输出值${y_1, ..., y_m}$, 如何预测新的$x_n$对应的输出? Baseline 就是求均值,</p>$$\frac{1}{m} \sum_{i=1}^{m} y_i$$<p>当然更好的方案(Watson, Nadaraya, 1964)是根据不同的输入$x_i$给与$y_i$不同的权重,</p>$$y = \sum_{i=1}^{m} \alpha(x, x_i) y_i $$<p>这里$x$代表一个新的输入(作为<strong>query</strong>), 根据$x$和已有的位置$x_i$(作为<strong>key</strong>)进行某种运算, 得到$x_i$对应的输出$y_i$(作为<strong>value</strong>)的权重. 如果每一个权重都是一个Guassians分布, 并正则化, 则一个<strong>加权的回归预测模型</strong>就是:</p>$$f(x) = \sum_i y_i \frac{k(x_i, x)}{\sum_j k(x_j, x)}$$<p>这个算法的"深度学习"版本, 就是其权重是通过优化器(如sgd)学习得来, 并且把平均运算改为<strong>加权池化(weighted pooling)</strong>.</p><h3 id=如何简单直观地理解注意力机制>如何简单直观地理解注意力机制<a hidden class=anchor aria-hidden=true href=#如何简单直观地理解注意力机制>#</a></h3><p>虽然注意力机制一开始被应用于图像识别领域，但是后来推广到神经机器翻译(NMT)中(<code>Seq2Seq for Machine Translation, Sutskever, Vinyals, Le ‘14</code>). NMT也是注意力机制在NLP领域最早最成功的应用之一.</p><p><img loading=lazy src=http://www.wildml.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-17-at-10.39.06-AM.png title="一个典型的seq2seq(encoder-decoder)翻译模型, 向量h表示编码器的内部状态">
在上图中，<code>Echt</code>，<code>Dicke</code>和<code>Kiste</code>词被送到编码器中，并且在特殊信号（未显示）之后，解码器开始生成翻译后的句子。解码器不断生成单词，直到产生特殊的句子结尾标记(如<code>&lt;eos></code>)。也就是说解码器仅根据最后一个隐含状态$h_3$来生成序列. 假如这个句子很短, 那么效果其实是很好的.</p><p>不过对于比较长的句子, 那么这个架构的弱点就暴露无疑了.</p><ol><li>首先, 编码器能否把句子的所有信息(语言学上的和常识等知识)都理解/捕捉到?</li><li>其次, 受限于目前的实现技术(主要是硬件), 单个隐含状态(如$h_3$这个向量)的维度大小是有限的, 而句子长度以及语言的组合情况是无限的, 单靠$h_3$自身是存储信息能力是有限的.</li><li>再者, 解码器是否有足够的解码能力从一个隐含状态中解码出所有的信息?</li></ol><p>虽然大部分句子是相对紧凑的, 但语言有个特点, 就是一个词有可能和前面好几步之外的词有联系, 比如一些指代词用于指代文本最开头出现的名词; 语义上, 某个句子的理解, 可能依赖于前面多个句子; 当然往大了说, 要理解一篇文章或一本书, 我们通常需要理解并联系多个段落, 多个章节. 这种现象称之为语言的长距离依赖(<strong>long-term dependency</strong>), 在一般性的序列数据中, 这个现象称之为的Long-range dependence(LRD). 即使是使用了LSTM这种理论上可以克服长距离依赖问题地网络, 也无法很好的克服语言的长距离依赖问题, 究其原因, 除了LSTM自身的局限性之外, 更主要是深度学习的梯度学习方法的局限性(在梯度反向传播中, 会出现梯度消失).</p><p>在没有更好地参数学习方法替代, 以及隐含层容量有限的前提下, 注意力机制通过为各个时间步的词分配注意力, 从理论上赋予了模型回望源头任意时间步的能力. 注意力机制自身包含的参数是一般神经网络的重要补充, 而它的机能也一定程度上解决了梯度消失的问题.</p><p>注意力机制在NMT的具体作用过程是这样, 训练过程中, 给定一对输入序列<code>知识就是力量&lt;end></code>和输出序列<code>Knowledge is power &lt;end></code>。解码器可以在输出序列的时间步<code>1</code>(当前时间步就是一个<code>query</code>), 使用集中编码了<code>知识</code>信息的背景变量来生成<code>Knowledge</code>，在时间步<code>2</code>使用更集中编码了<code>就是</code>的信息的背景变量来生成<code>is</code>，依此类推。这看上去就像是在解码器的每一时间步对输入序列中不同时间步编码的信息分配不同的注意力。这样注意力矩阵参数就编码了这种"注意力", 同时也更好的协助其他网络部件学习参数. 在预测阶段的每一个时间步, 注意力也参与其中.</p><p><img loading=lazy src=https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/img/EncDecAttention.gif title="注意力机制; 蓝色连线透明度表示解码器关注编码字的程度。透明度越低，注意力越强. image from https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis"></p><p>一个经典的(目前也还在不断发展的)NLP问题是文本编码, 即把非结构化的文本, 映射为结构化的数字/向量. 较早有纯统计的<strong>Bag of words</strong>(Salton & McGill, 1986), 后期发展出了经典的<strong>Word2Vec</strong>(Mikolov et al., 2013). 现在主流的神经网络文本编码方法是Word2Vec, fasttext, rnn(lstm/gru)等, 核心思想是把文本中的每个字符都映射到一个embedding向量空间中, 全部加在一起得到整个文本的向量表示, $f(x)=\rho \bigg( \sum_{i=1}^n \phi(x_i) \bigg)$, 再拿去给后续的网络做分类等任务. 这种算法的缺陷是, 最终编码出来的向量, 会偏向统计频率高的元素, 这导致其在很多实际应用中表现不好, 比如情感分析中, 很多转折句, 前后态度是反转的, 但核心是转折后的部分.</p><blockquote><p>They respect you, they really do, but you have to&mldr; Why are you laughing?</p></blockquote><p><img loading=lazy src=/images/everything_before_the_word_but_is_horse_shit.gif></p><p>如何让编码模型重点关注句子的关键部分呢? 这得分情况, 一种如这样 <code>They respect you, they really do, </code><strong><code>but you have to... Why are you laughing?</code></strong>, 整个句子的意思, 是着重于<code>but</code>后面的部分. 亦或者如<code>Wang et al, ’16</code>中提到的<code>“The appetizers are ok, but the service is slow.”</code>, 一个句子中其实分为两个意思, <code>对于外观口味，评价为积极，而对于服务，评价为消极</code>。</p><p>那么这个时候就需要用注意力机制来给句子的编码分配权重了,</p>$$f(x)=\rho \bigg( \sum_{i=1}^{n} \alpha(w_i, X) \phi(x_i) \bigg)$$<p>通过注意力机制，我们不再需要竭尽全力把完整的句子输入编码为固定长度的向量，二十允许解码器在输出生成的每个步骤中“关注”源语句的不同部分。</p><p><strong>所以 Attention 在神经网络模型中的作用就是改进池化(pooling):</strong>
没有Attention的池化:</p>$$f(X)=\rho \bigg( \sum_{x \in X} \phi(x) \bigg)$$<p>有Attention后:</p>$$f(X)=\rho \bigg( \sum_{x \in X} \alpha(x, w) \phi(x) \bigg)$$<h3 id=如何表达注意力机制>如何表达注意力机制<a hidden class=anchor aria-hidden=true href=#如何表达注意力机制>#</a></h3><p>把Attention机制从encoder-decoder架构中抽象出来理解, 如下图: <img loading=lazy src=/images/attention_mechanism.png></p><p>注意力三个核心组件是:</p><ol><li><code>Query</code>: decoder当前待解码的输出. 如果是seq2seq模型, 那就是当前解码器待生成的时间步(用前一时间步的解码器隐含状态来表达).</li><li><code>Key-Value</code>: 每个<code>key</code>(输入序列经过编码后的隐含状态)都对应一个<code>value</code>. 在文本任务中, 一般<code>Key</code>和<code>Value</code>一样, 都是输入序列的编码。</li><li><code>Query</code>和<code>Key</code>的相关性: $\alpha(q, k)$, 告诉模型如何根据<code>Query</code>和各个<code>Key</code>的相关性来分配权重.</li></ol><p>计算注意力的主要步骤:</p><ol><li>计算<code>Query</code>和每个<code>key</code>之间的相关性$\alpha_c(q,k_i)$, 常用的相关性函数包括点积(Scaled Dot-Product Attention)，拼接，神经网路等</li><li>归一化(如softmax)后获得分配权重${\theta_1, ..., \theta_k}$</li><li>计算<code>Value</code>的加权平均值, 作为Attention输出值.</li></ol>$$\begin{eqnarray} A(q, \{(k,v)\}) \xrightarrow[\text{output}]{\text{maps as}} \sum_{i=1}^k{\overbrace{\alpha_c(q,k_i)}^{\theta_i}}v_i, q \in Q, k \in K, v \in V \end{eqnarray}$$<p>在编码器-解码器架构中，<code>Query</code>通常是解码器的隐含状态。而<code>Key</code>和<code>Value</code>，都是编码器的隐含状态。加权求和作为输出:</p>$$\begin{eqnarray} out = \sum_{i=1}^k \theta_i v_i = \sum_{i=1}^k \theta_i h(x_i) \end{eqnarray}$$<h3 id=attention和memory对比>Attention和Memory对比<a hidden class=anchor aria-hidden=true href=#attention和memory对比>#</a></h3><p>从上面的描述看Attention更像是对神经网络(如LSTM等)的<strong>记忆功能</strong>的改进. 也就是说, 注意力机制只是让网络能够访问其内存，比如编码器的隐含状态. 网络选择从内存中检索什么，并给与不同程度的“关注度”. 换句话说, 何种内存访问机制是soft的，网络将检索所有内存并加权组合。使soft的内存访问好处是可以使用反向传播轻松地进行端对端网络训练（当然也有其他办法-采样方法来计算梯度）。</p><p>而另一方面, 更复杂的Memory机制的研究也发展地如火如荼。比如End-To-End Memory Networks(Sainbayar 2015)中提到的网络结构, 允许网络在输出之前多次读取相同的输入序列，并在每个步骤中更新内存。可以应用于, 例如通过对输入故事进行多个推理步骤来回答问题。
<code>Joe went to the kitchen.</code>
<code>Fred went to the kitchen.</code>
<strong><code>Joe picked up the milk.</code></strong>
<code>Joe travelled to the office.</code>
<strong><code>Joe left the milk.</code></strong>
<code>Joe went to the bathroom.</code></p><p><code>Where is the milk?</code></p><p>此时, 当网络参数以某种方式绑定在一起时，这个内存结构就和上面介绍的注意力机制一样了，只是它在内存上进行了多次跃迁（因为它试图集成来自多个句子的信息）。</p><p>在这种情境下, 注意力机制也可以很灵活地应用, 比如分别在字符级使用注意力机制来编码单词, 在单词级上编码句子, 在句子级上编码段落, 即 Hierarchical attention. <img loading=lazy src=/images/hierarchical_attention_network.png></p><p>Neural Turing Machines(Graves et al., ‘14)的思想也是在内存机制上, 通过将神经网络和外部存储资源耦合来扩展神经网络的功能，这些资源可以通过注意力机制与之交互。组合后的系统类似于图灵机或冯·诺依曼架构，具有端到端的可微分性(因此可以通过梯度下降来进行训练)。除此之外, 神经图灵机但具有更复杂的寻址类型，既可以使用基于内容的寻址（如上下文），也可以使用基于位置的寻址，从而使网络可以学习寻址模式以执行简单的计算机程序，例如排序算法。</p><p>这里并不是要给出Attention和Memory机制的确切的定义区别(也给不了, 有的人觉得二者就是一个东西, 比如有人就称Attention其实软寻址, 应该称为Soft Attention), 而是从主流角度给出类比和解读.</p><h3 id=实战案例-注意力机制应用到机器翻译中>实战案例: 注意力机制应用到机器翻译中<a hidden class=anchor aria-hidden=true href=#实战案例-注意力机制应用到机器翻译中>#</a></h3><p>还是以机器翻译为例: 对于解码器的每一个时间步$t'$, 生成一个背景向量$c_{t'}$来捕捉相关的解码器信息, 以用于预测输出目标值$y_{t'}$. 解码器在时间步 $t'$ 的隐藏状态</p>$$s_{t'} = g(y_{t'-1}, c_{t'}, s_{t'-1}).$$<p>令编码器在时间 $t$ 的隐藏状态为 $h_t$，且总时间步数为 $T$。解码器在时间步 $t'$ 的背景变量为</p>$$c_{t'} = \sum_{t=1}^T A{t' t} h_t,$$<p>其中 $A{t' t}$ 是注意力分配的权重，用于给定解码器的当前隐藏状态 $s_{t'}$，对编码器中不同时间步的隐藏状态$h_t$求加权平均。</p>$$A{t' t} = align(s_{t'}, h_t) = \frac{\exp(score(t' t))}{ \sum_{t=1}^T \exp(score(t' t)) },$$<p>其中 $score(t' t) \in \mathbb{R}$ 的计算为</p>$$score(t' t) = \alpha(s_{t' - 1}, h_t).$$<p>上式中的score打分函数 $score(t' t)$ 有多种设计方法。Bahanau 等使用了MLP感知机：</p>$$e_{t't} = v^\top \tanh(W_s s_{t' - 1} + W_h h_t),$$<p>其中 $v$、$W_s$、$W_h$ 以及编码器与解码器中的各个权重和偏差都是模型参数。</p><p>Bahanau 等在编码器和解码器中分别使用了门控循环单元GRU。在解码器中，我们需要对门控循环单元的设计稍作修改。解码器在 $t' $ 时间步的隐藏状态为</p>$$s_{t'} = z_{t'} \odot s_{t'-1} + (1 - z_{t'}) \odot \tilde{s}_{t'},$$<p>其中的重置门、更新门和候选隐含状态分别为</p>$$
\begin{aligned}
r_{t'} &= \sigma(W_{yr} y_{t'-1} + W_{sr} s_{t' - 1} + W_{cr} c_{t'} + b_r), \\\
z_{t'} &= \sigma(W_{yz} y_{t'-1} + W_{sz} s_{t' - 1} + W_{cz} c_{t'} + b_z),\\\
\tilde{s_{t'}} &= \text{tanh}(W_{ys} y_{t'-1} + W_{ss} (s_{t' - 1} \odot r_{t'}) + W_{cs} c_{t'} + b_s).
\end{aligned}
$$<p>然后，给定目标(解码器)隐藏状态$h_{t'}$, 以及背景向量$c_{t'}$, 通过使用简单的并联层合并这两个向量的信息, 来生成所谓的注意力隐藏状态:</p>$$\tilde{h_{t'}} = \tanh(W_c[c_{t'} : h_{t'}]) $$<p>这个注意力向量 $\tilde{h_t}$ 之后会通过一个softmax层来生成预测的概率分布.</p><h3 id=延伸阅读全局注意力机制>延伸阅读:全局注意力机制<a hidden class=anchor aria-hidden=true href=#延伸阅读全局注意力机制>#</a></h3><p><a href=https://arxiv.org/pdf/1508.04025.pdf>Effective Approaches to Attention-based Neural Machine Translation(Luong et al. 2015)</a>对应用于NMT的注意力机制进行了一定的总结：分为全局（global）和局部（local）注意力机制。区别在于“注意力”是放在所有源位置或仅放置在少数源位置。</p><blockquote><p>The idea of a global attentional model is to consider all the hidden states of the encoder when deriving the context vector $c_t$.</p></blockquote><p><img loading=lazy src=/images/global_attention.png title="image from: lLuong  et  al. (2015)">
两种注意力机制区别就在于如何生成背景向量$c_{t'}$.</p><p>Luong et al. (2015) 给出了几种打分函数的计算</p>$$
\begin{aligned}
score_{dot}(t' t) &= s^\top_{t'}h_t \\\
score_{general}(t' t) &= s^\top_{t'} W_\alpha h_t, \\\
score_{concat}(t' t) &= v^\top_\alpha \tanh (W_\alpha[s_{t'} : h_t])
\end{aligned}
$$<h3 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h3><ol><li>Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. 2014. Neural machine translation by jointly learning to align and translate. arXiv preprint arXiv:1409.0473</li><li>Wang, Yequan, Minlie Huang, and Li Zhao. &ldquo;Attention-based LSTM for aspect-level sentiment classification.&rdquo; Proceedings of the 2016 conference on empirical methods in natural language processing. 2016.</li><li>Yang, Zichao, et al. &ldquo;Hierarchical attention networks for document classification.&rdquo; Proceedings of the 2016 Conference of the North
American Chapter of the Association for Computational Linguistics: Human Language Technologies. 2016.</li><li><a href=http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/>http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/</a></li><li>目前主流的attention方法都有哪些？ - 张俊林的回答 - 知乎 <a href=https://www.zhihu.com/question/68482809/answer/264632289>https://www.zhihu.com/question/68482809/answer/264632289</a></li><li><a href=https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis>https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis</a></li><li><a href=alex.smola.org/talks/ICML19-attention.pdf>Attention in Deep Learning, Elex Smola, ICML 2019, Long Beach, CA</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/attention/>Attention</a></li><li><a href=https://congchan.github.io/tags/nlp/>NLP</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/value-based-reinforcement-learning/><span class=title>« Prev</span><br><span>Value-based Reinforcement Learning</span>
</a><a class=next href=https://congchan.github.io/posts/percolations-problem/><span class=title>Next »</span><br><span>Percolations problem</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 从头理解注意力机制 on x" href="https://x.com/intent/tweet/?text=%e4%bb%8e%e5%a4%b4%e7%90%86%e8%a7%a3%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BB%258E%25E5%25A4%25B4%25E7%2590%2586%25E8%25A7%25A3%25E6%25B3%25A8%25E6%2584%258F%25E5%258A%259B%25E6%259C%25BA%25E5%2588%25B6%2f&amp;hashtags=Attention%2cNLP"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从头理解注意力机制 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BB%258E%25E5%25A4%25B4%25E7%2590%2586%25E8%25A7%25A3%25E6%25B3%25A8%25E6%2584%258F%25E5%258A%259B%25E6%259C%25BA%25E5%2588%25B6%2f&amp;title=%e4%bb%8e%e5%a4%b4%e7%90%86%e8%a7%a3%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6&amp;summary=%e4%bb%8e%e5%a4%b4%e7%90%86%e8%a7%a3%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BB%258E%25E5%25A4%25B4%25E7%2590%2586%25E8%25A7%25A3%25E6%25B3%25A8%25E6%2584%258F%25E5%258A%259B%25E6%259C%25BA%25E5%2588%25B6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从头理解注意力机制 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BB%258E%25E5%25A4%25B4%25E7%2590%2586%25E8%25A7%25A3%25E6%25B3%25A8%25E6%2584%258F%25E5%258A%259B%25E6%259C%25BA%25E5%2588%25B6%2f&title=%e4%bb%8e%e5%a4%b4%e7%90%86%e8%a7%a3%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从头理解注意力机制 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BB%258E%25E5%25A4%25B4%25E7%2590%2586%25E8%25A7%25A3%25E6%25B3%25A8%25E6%2584%258F%25E5%258A%259B%25E6%259C%25BA%25E5%2588%25B6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从头理解注意力机制 on whatsapp" href="https://api.whatsapp.com/send?text=%e4%bb%8e%e5%a4%b4%e7%90%86%e8%a7%a3%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BB%258E%25E5%25A4%25B4%25E7%2590%2586%25E8%25A7%25A3%25E6%25B3%25A8%25E6%2584%258F%25E5%258A%259B%25E6%259C%25BA%25E5%2588%25B6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从头理解注意力机制 on telegram" href="https://telegram.me/share/url?text=%e4%bb%8e%e5%a4%b4%e7%90%86%e8%a7%a3%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BB%258E%25E5%25A4%25B4%25E7%2590%2586%25E8%25A7%25A3%25E6%25B3%25A8%25E6%2584%258F%25E5%258A%259B%25E6%259C%25BA%25E5%2588%25B6%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 从头理解注意力机制 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e4%bb%8e%e5%a4%b4%e7%90%86%e8%a7%a3%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6&u=https%3a%2f%2fcongchan.github.io%2fposts%2f%25E4%25BB%258E%25E5%25A4%25B4%25E7%2590%2586%25E8%25A7%25A3%25E6%25B3%25A8%25E6%2584%258F%25E5%258A%259B%25E6%259C%25BA%25E5%2588%25B6%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>