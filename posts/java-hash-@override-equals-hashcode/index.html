<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java Hash @Override equals() hashcode() | Cong's Log</title><meta name=keywords content="Java,Software Engineer"><meta name=description content='主要介绍：

Hashcode（哈希码）与 equals（判断相等）的关系
Hashcode 方法的底层实现原理
开发中需要掌握的原则和方法

HashSet, HashMap, HashTable
HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。

拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似): 假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:

if (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了
else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等
else hashCode 相同，那么需要进一步调用obj1.equals(obj2)

下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。
HashSet<String> wordSet = new HashSet<String>();
String a = "hello";
String b = "hello";
wordSet.add(a);
return wordSet.contains(b); // return true
根据Javadoc for Set.

adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).'><meta name=author content="Cong Chan"><link rel=canonical href=https://congchan.github.io/posts/java-hash-@override-equals-hashcode/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://congchan.github.io/posts/java-hash-@override-equals-hashcode/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/posts/java-hash-@override-equals-hashcode/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="Java Hash @Override equals() hashcode()"><meta property="og:description" content='主要介绍：
Hashcode（哈希码）与 equals（判断相等）的关系 Hashcode 方法的底层实现原理 开发中需要掌握的原则和方法 HashSet, HashMap, HashTable HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。
拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似): 假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:
if (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了 else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等 else hashCode 相同，那么需要进一步调用obj1.equals(obj2) 下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。
HashSet<String> wordSet = new HashSet<String>(); String a = "hello"; String b = "hello"; wordSet.add(a); return wordSet.contains(b); // return true 根据Javadoc for Set.
adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-02-26T00:00:00+00:00"><meta property="article:modified_time" content="2017-02-26T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Software Engineer"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java Hash @Override equals() hashcode()"><meta name=twitter:description content='主要介绍：

Hashcode（哈希码）与 equals（判断相等）的关系
Hashcode 方法的底层实现原理
开发中需要掌握的原则和方法

HashSet, HashMap, HashTable
HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。

拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似): 假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:

if (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了
else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等
else hashCode 相同，那么需要进一步调用obj1.equals(obj2)

下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。
HashSet<String> wordSet = new HashSet<String>();
String a = "hello";
String b = "hello";
wordSet.add(a);
return wordSet.contains(b); // return true
根据Javadoc for Set.

adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://congchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java Hash @Override equals() hashcode()","item":"https://congchan.github.io/posts/java-hash-@override-equals-hashcode/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java Hash @Override equals() hashcode()","name":"Java Hash @Override equals() hashcode()","description":"主要介绍：\nHashcode（哈希码）与 equals（判断相等）的关系 Hashcode 方法的底层实现原理 开发中需要掌握的原则和方法 HashSet, HashMap, HashTable HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。\n拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似): 假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:\nif (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了 else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等 else hashCode 相同，那么需要进一步调用obj1.equals(obj2) 下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。\nHashSet\u0026lt;String\u0026gt; wordSet = new HashSet\u0026lt;String\u0026gt;(); String a = \u0026#34;hello\u0026#34;; String b = \u0026#34;hello\u0026#34;; wordSet.add(a); return wordSet.contains(b); // return true 根据Javadoc for Set.\nadds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).\n","keywords":["Java","Software Engineer"],"articleBody":"主要介绍：\nHashcode（哈希码）与 equals（判断相等）的关系 Hashcode 方法的底层实现原理 开发中需要掌握的原则和方法 HashSet, HashMap, HashTable HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。\n拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似): 假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:\nif (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了 else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等 else hashCode 相同，那么需要进一步调用obj1.equals(obj2) 下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。\nHashSet\u003cString\u003e wordSet = new HashSet\u003cString\u003e(); String a = \"hello\"; String b = \"hello\"; wordSet.add(a); return wordSet.contains(b); // return true 根据Javadoc for Set.\nadds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).\n根据Javadoc for String.equals\nCompares this string to the specified object. The result is true if and only if the argument is not null and is a String object that represents the same sequence of characters as this object.\nJava的set是使用它包含的元素（对象）的 equals()来比较 b 和 a 的。这里 String 类的equals()method 是比较字符串值是否相等(准确的说，是先检查是不是引用同一个对象，再看是不是同一个类，再比较值)，而不是引用的对象是否一样，故b.equals(a)是 true。\n同样的，remove 和 add 也会先进行类似检查。\n问题是，为何 hashCode 不同，就没有进一步调用equals()的必要呢？因为有一个前提是代码遵守The hashCode contract。\nHashcode and equals 在Java中，每个对象都有一个hashCode，它有时容易被人遗忘或误用。有以下三点需要注意，避免掉入常见的陷阱。\n根据 The hashCode contract:\nObjects that are equal must have the same hash code within a running process.\n除了字面意思，也有其他隐含的意思: 不相等的对象的hashcode也可能一样; 具有相同 hash code 的对象不一定相等.\nYou must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable. — Effective Java, by Joshua Bloch\n根据这个contract，可以延伸出以下实践原则：\n一、 每当你 override equals 时，也要 override hashCode 假如你需要使用不一样的equals判断标准，那么就需要重写equals。但假如仅仅重写equals，而不重写hashcode()，就可能会违背 The hashCode contract。\n为什么？因为 hashCode method 需要同时适配真正使用到的 equals method 的判断标准。通过重写equals，我们重新声明了一种判断对象是否相等的标准，但原始的 hashCode method还是会将所有对象视为不同的对象。所以如果没有不重写hashcode，那么根据@Override equals 判断为相同的对象将拥有不同的hashcode（可能）。这样，即使已经有了这个object，在HashMap上调用 contains() 也会返回false。\n例子：在Java的创建街道street这个类，在判断两条街道是否相同时，我们有自定义的规则 - 只要是在同一个城市，有同样的街道名，那么两个street就相等，即使他们是存放在不同内存位置的两个对象（Java 的 Object 原生的equals是根据引用的对象内存地址来比较判断的）。\npublic class Street { private String name; private String city; // ... @Override public boolean equals(Object obj) { if (!(obj instanceof Street)) return false; if (obj == this) return true; Street rhs = (Street) obj; return new EqualsBuilder(). // if deriving: appendSuper(super.equals(obj)). append(name, rhs.name). append(age, rhs.city). isEquals(); } @Override public int hashCode() { return new HashCodeBuilder(17, 31). // two randomly chosen prime numbers // if deriving: appendSuper(super.hashCode()). append(name). append(city). toHashCode(); } } 如果没有重写hashCode()， 那么两个名字和所在城市一样的，但引用不同地址的street就会按照默认的 hashcode() 返回不一样的code，但是根据重写的equals(), 他们是一样的, 这样就违背了 hashCode contract。\n为了安全起见，让Eclipse IDE 生成 equals 和 hashCode 函数：Source \u003e Generate hashCode() and equals()... 为了提醒自己, 还可以配置Eclipse以检测是否有违反此规则的情况，并为仅重写了equals但没重写hashCode的情况显示错误：Preferences \u003e Java \u003e Compiler \u003e Errors/Warnings, then use the quick filter to search for “hashcode” HashCode collisions HashCode collisions 指两个不同的对象具有相同的hashcode这种情况, 这不是什么严重的问题. 只是会导致更多的搜索步骤，太多collisions就可能会降低系统性能\n但是，如果将HashCode错误地用作对象的唯一句柄，例如将其用作Map中的key，那么有时会得到错误的对象。虽然collisions一般很少见，但却是不可避免的。例如，字符串“Aa”和“BB”产生相同的hashCode：2112. 因此衍生出第二个原则\n二、永远不要把hashcode当做key来使用\nJava中有4,294,967,296个（232)可能的int值）。既然拥有40亿个插槽，collisions似乎几乎不可能对吧？\n但事实上，也不是那么不可能。试想，一个房间里有23名随机人员。你如何估计里面有两个人生日一样的概率？很低？因为一年有365天？事实上，概率约为50％！这种现象被称为生日问题(悖论)。\n如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。\n问题的本质是\"23人之中两两之间存在生日相同的概率\"\",而不是\"其他22人与其中一个人的生日相同的概率\".\n类比到hashcode里，这意味着有77,163个不同的对象，collisions概率是50%（假设有一个理想的hashCode函数，将对象均匀分布在所有可用的buckets中）。\nHashCodes 会变 HashCode 不保证在不同的执行过程中总能返回相同的code。根据JavaDoc：Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.\n这种情况并不常见，实际上，库中的某些类甚至指定了用于计算hashcode的精确公式（例如String）。对于这些类，hashcode总是相同的。但是，尽管大多数的hashCode方法提供了稳定的值，但我们不能依赖它。正如这篇文章所指出的那样，Java库实际上在不同的进程中返回不同的hashCode值，这往往会让人们感到困惑。 Google的Protocol Buffers就是一个例子。 因此，您不应该在分布式应用程序中使用hash code。即使两者相等，远程对象的 hash code 也可能与本地的不同。\n三、不要在分布式应用程序中使用 hashCode 此外，要意识到，hashCode函数的实现可能会随着版本的更改而改变。因此我们的代码最好不依赖任何特定的hash code 值。例如，你不应该使用hash code来保持某种状态，不然下次运行时，“相同”对象的hash code可能会不同。\n所以最好的建议可能是：除非自己创建了基于 hashcode 算法，否则根本就不要使用 hashCode 呵呵……\n总结 在依赖于 HashSet, HashMap, HashTable … 等数据结构的程序中： 3. 仅重写 equals()，会导致业务出错 4. 仅重写 hashcode(), 在比较两个对象时不会强制Java忽略内存地址 3. 如果不涉及对象比较(比如仅仅是iteration), 那么不需要hashCode and/or equals\n参考： https://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/ https://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java\n","wordCount":"479","inLanguage":"en","datePublished":"2017-02-26T00:00:00Z","dateModified":"2017-02-26T00:00:00Z","author":{"@type":"Person","name":"Cong Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://congchan.github.io/posts/java-hash-@override-equals-hashcode/"},"publisher":{"@type":"Organization","name":"Cong's Log","logo":{"@type":"ImageObject","url":"https://congchan.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Java Hash @Override equals() hashcode()</h1><div class=post-meta><span title='2017-02-26 00:00:00 +0000 UTC'>2017-02-26</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Cong Chan&nbsp;|&nbsp;<a href=https://github.com/%3cgitlab%20user%3e/%3crepo%20name%3e/tree/%3cbranch%20name%3e/%3cpath%20to%20content%3e//posts/java-hashcode-equals.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#hashset-hashmap-hashtable aria-label="HashSet, HashMap, HashTable">HashSet, HashMap, HashTable</a><ul><li><a href=#hashcode-and-equals aria-label="Hashcode and equals">Hashcode and equals</a></li><li><a href=#hashcode-collisions aria-label="HashCode collisions">HashCode collisions</a></li><li><a href=#hashcodes-%e4%bc%9a%e5%8f%98 aria-label="HashCodes 会变">HashCodes 会变</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li></ul></div></details></div><div class=post-content><p>主要介绍：</p><ol><li>Hashcode（哈希码）与 equals（判断相等）的关系</li><li>Hashcode 方法的底层实现原理</li><li>开发中需要掌握的原则和方法</li></ol><h2 id=hashset-hashmap-hashtable>HashSet, HashMap, HashTable<a hidden class=anchor aria-hidden=true href=#hashset-hashmap-hashtable>#</a></h2><p>HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。</p><p>拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似): 假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:</p><ol><li>if (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了</li><li>else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等</li><li>else hashCode 相同，那么需要进一步调用obj1.equals(obj2)</li></ol><p>下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>HashSet</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>wordSet</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashSet</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>wordSet</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>return</span><span class=w> </span><span class=n>wordSet</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>b</span><span class=p>);</span><span class=w> </span><span class=c1>// return true</span><span class=w>
</span></span></span></code></pre></div><p>根据<a href=https://docs.oracle.com/javase/6/docs/api/java/util/Set.html#add%28E%29>Javadoc for Set</a>.</p><blockquote><p>adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).</p></blockquote><p>根据<a href=https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object->Javadoc for String.equals</a></p><blockquote><p>Compares this string to the specified object. The result is true if and only if the argument is not null and is a String object that represents the same sequence of characters as this object.</p></blockquote><p>Java的set是使用它包含的元素（对象）的 <code>equals()</code>来比较 b 和 a 的。这里 String 类的<code>equals()</code>method 是比较字符串值是否相等(准确的说，是先检查是不是引用同一个对象，再看是不是同一个类，再比较值)，而不是引用的对象是否一样，故<code>b.equals(a)</code>是 true。</p><p>同样的，remove 和 add 也会先进行类似检查。</p><p>问题是，为何 hashCode 不同，就没有进一步调用<code>equals()</code>的必要呢？因为有一个前提是代码遵守The hashCode contract。</p><h3 id=hashcode-and-equals>Hashcode and equals<a hidden class=anchor aria-hidden=true href=#hashcode-and-equals>#</a></h3><p>在Java中，每个对象都有一个hashCode，它有时容易被人遗忘或误用。有以下三点需要注意，避免掉入常见的陷阱。</p><p>根据 The hashCode contract:</p><blockquote><p>Objects that are equal must have the same hash code within a running process.</p></blockquote><p>除了字面意思，也有其他隐含的意思: 不相等的对象的hashcode也可能一样; 具有相同 hash code 的对象不一定相等.</p><blockquote><p>You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable. &mdash; Effective Java, by Joshua Bloch</p></blockquote><p>根据这个contract，可以延伸出以下实践原则：</p><p><strong>一、 每当你 override equals 时，也要 override hashCode</strong>
假如你需要使用不一样的equals判断标准，那么就需要重写equals。但假如仅仅重写equals，而不重写hashcode()，就可能会违背 The hashCode contract。</p><p>为什么？因为 hashCode method 需要同时适配真正使用到的 equals method 的判断标准。通过重写equals，我们重新声明了一种判断对象是否相等的标准，但原始的 hashCode method还是会将所有对象视为不同的对象。所以如果没有不重写hashcode，那么根据@Override equals 判断为相同的对象将拥有不同的hashcode（可能）。这样，即使已经有了这个object，在HashMap上调用 contains() 也会返回false。</p><p>例子：在Java的创建街道street这个类，在判断两条街道是否相同时，我们有自定义的规则 - 只要是在同一个城市，有同样的街道名，那么两个street就相等，即使他们是存放在不同内存位置的两个对象（Java 的 Object 原生的equals是根据引用的对象内存地址来比较判断的）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Street</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>city</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>equals</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>obj</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>obj</span><span class=w> </span><span class=k>instanceof</span><span class=w> </span><span class=n>Street</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>obj</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=k>this</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Street</span><span class=w> </span><span class=n>rhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Street</span><span class=p>)</span><span class=w> </span><span class=n>obj</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>EqualsBuilder</span><span class=p>().</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// if deriving: appendSuper(super.equals(obj)).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>append</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=na>name</span><span class=p>).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>append</span><span class=p>(</span><span class=n>age</span><span class=p>,</span><span class=w> </span><span class=n>rhs</span><span class=p>.</span><span class=na>city</span><span class=p>).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>isEquals</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hashCode</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashCodeBuilder</span><span class=p>(</span><span class=n>17</span><span class=p>,</span><span class=w> </span><span class=n>31</span><span class=p>).</span><span class=w> </span><span class=c1>// two randomly chosen prime numbers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// if deriving: appendSuper(super.hashCode()).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>append</span><span class=p>(</span><span class=n>name</span><span class=p>).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>append</span><span class=p>(</span><span class=n>city</span><span class=p>).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>toHashCode</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如果没有重写hashCode()， 那么两个名字和所在城市一样的，但引用不同地址的street就会按照默认的 hashcode() 返回不一样的code，但是根据重写的equals(), 他们是一样的, 这样就违背了 hashCode contract。</p><p>为了安全起见，让Eclipse IDE 生成 equals 和 hashCode 函数：<code>Source > Generate hashCode() and equals()...</code>
<img loading=lazy src=https://eclipsesource.com/wp-content/uploads/2012/09/generate-hashcode-equals.png></p><p>为了提醒自己, 还可以配置Eclipse以检测是否有违反此规则的情况，并为仅重写了equals但没重写hashCode的情况显示错误：<code>Preferences > Java > Compiler > Errors/Warnings, then use the quick filter to search for “hashcode”</code>
<img loading=lazy src=https://eclipsesource.com/wp-content/uploads/2012/09/hashcode-error-config.png></p><h3 id=hashcode-collisions>HashCode collisions<a hidden class=anchor aria-hidden=true href=#hashcode-collisions>#</a></h3><p>HashCode collisions 指两个不同的对象具有相同的hashcode这种情况, 这不是什么严重的问题. 只是会导致更多的搜索步骤，太多collisions就可能会降低系统性能</p><p>但是，如果将HashCode错误地用作对象的唯一句柄，例如将其用作Map中的key，那么有时会得到错误的对象。虽然collisions一般很少见，但却是不可避免的。例如，字符串“Aa”和“BB”产生相同的hashCode：2112. 因此衍生出第二个原则</p><p><strong>二、永远不要把hashcode当做key来使用</strong></p><p>Java中有4,294,967,296个（2<sup>32</sup>)可能的int值）。既然拥有40亿个插槽，collisions似乎几乎不可能对吧？</p><p>但事实上，也不是那么不可能。试想，一个房间里有23名随机人员。你如何估计里面有两个人生日一样的概率？很低？因为一年有365天？事实上，概率约为50％！这种现象被称为<a href=http://en.wikipedia.org/wiki/Birthday_paradox>生日问题(悖论)</a>。</p><blockquote><p>如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。</p></blockquote><p>问题的本质是"23人之中两两之间存在生日相同的概率"",而不是"其他22人与其中一个人的生日相同的概率".</p><p>类比到hashcode里，这意味着有77,163个不同的对象，collisions概率是50%（假设有一个理想的hashCode函数，将对象均匀分布在所有可用的buckets中）。</p><h3 id=hashcodes-会变>HashCodes 会变<a hidden class=anchor aria-hidden=true href=#hashcodes-会变>#</a></h3><p>HashCode 不保证在不同的执行过程中总能返回相同的code。根据JavaDoc：Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. <strong>This integer need not remain consistent from one execution of an application to another execution</strong> of the same application.</p><p>这种情况并不常见，实际上，库中的某些类甚至指定了用于计算hashcode的精确公式（例如String）。对于这些类，hashcode总是相同的。但是，尽管大多数的hashCode方法提供了稳定的值，但我们不能依赖它。正如<a href=http://martin.kleppmann.com/2012/06/18/java-hashcode-unsafe-for-distributed-systems.html>这篇文章</a>所指出的那样，Java库实际上在不同的进程中返回不同的hashCode值，这往往会让人们感到困惑。 Google的<a href=http://code.google.com/p/protobuf/>Protocol Buffers</a>就是一个例子。 因此，您不应该在分布式应用程序中使用hash code。即使两者相等，远程对象的 hash code 也可能与本地的不同。</p><p><strong>三、不要在分布式应用程序中使用 hashCode</strong>
此外，要意识到，hashCode函数的实现可能会随着版本的更改而改变。因此我们的代码最好不依赖任何特定的hash code 值。例如，你不应该使用hash code来保持某种状态，不然下次运行时，“相同”对象的hash code可能会不同。</p><p>所以最好的建议可能是：除非自己创建了基于 hashcode 算法，否则根本就不要使用 hashCode 呵呵……</p><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>在依赖于 HashSet, HashMap, HashTable &mldr; 等数据结构的程序中：
3. 仅重写 equals()，会导致业务出错
4. 仅重写 hashcode(), 在比较两个对象时不会强制Java忽略内存地址
3. 如果不涉及对象比较(比如仅仅是iteration), 那么不需要hashCode and/or equals</p><p>参考：
<a href=https://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/>https://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/</a>
<a href=https://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java>https://stackoverflow.com/questions/27581/what-issues-should-be-considered-when-overriding-equals-and-hashcode-in-java</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://congchan.github.io/tags/java/>Java</a></li><li><a href=https://congchan.github.io/tags/software-engineer/>Software Engineer</a></li></ul><nav class=paginav><a class=prev href=https://congchan.github.io/posts/java-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%9B%9E%E8%B0%83/><span class=title>« Prev</span><br><span>Java 高阶函数和回调</span>
</a><a class=next href=https://congchan.github.io/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/><span class=title>Next »</span><br><span>Java 多线程</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash @Override equals() hashcode() on x" href="https://x.com/intent/tweet/?text=Java%20Hash%20%40Override%20equals%28%29%20hashcode%28%29&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-%40override-equals-hashcode%2f&amp;hashtags=Java%2cSoftwareEngineer"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash @Override equals() hashcode() on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-%40override-equals-hashcode%2f&amp;title=Java%20Hash%20%40Override%20equals%28%29%20hashcode%28%29&amp;summary=Java%20Hash%20%40Override%20equals%28%29%20hashcode%28%29&amp;source=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-%40override-equals-hashcode%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash @Override equals() hashcode() on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-%40override-equals-hashcode%2f&title=Java%20Hash%20%40Override%20equals%28%29%20hashcode%28%29"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash @Override equals() hashcode() on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-%40override-equals-hashcode%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash @Override equals() hashcode() on whatsapp" href="https://api.whatsapp.com/send?text=Java%20Hash%20%40Override%20equals%28%29%20hashcode%28%29%20-%20https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-%40override-equals-hashcode%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash @Override equals() hashcode() on telegram" href="https://telegram.me/share/url?text=Java%20Hash%20%40Override%20equals%28%29%20hashcode%28%29&amp;url=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-%40override-equals-hashcode%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Java Hash @Override equals() hashcode() on ycombinator" href="https://news.ycombinator.com/submitlink?t=Java%20Hash%20%40Override%20equals%28%29%20hashcode%28%29&u=https%3a%2f%2fcongchan.github.io%2fposts%2fjava-hash-%40override-equals-hashcode%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>