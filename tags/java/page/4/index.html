<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java | Cong's Log</title><meta name=keywords content><meta name=description content="Hi, this is Cong. I’m documenting my learning notes in this blog."><meta name=author content="Cong"><link rel=canonical href=https://congchan.github.io/tags/java/><link crossorigin=anonymous href=/assets/css/stylesheet.1f908d890a7e84b56b73a7a0dc6591e6e3f782fcba048ce1eb46319195bedaef.css integrity="sha256-H5CNiQp+hLVrc6eg3GWR5uP3gvy6BIzh60YxkZW+2u8=" rel="preload stylesheet" as=style><link rel=icon href=https://congchan.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://congchan.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://congchan.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://congchan.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://congchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://congchan.github.io/tags/java/index.xml><link rel=alternate hreflang=en href=https://congchan.github.io/tags/java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6T0DPR6SMC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6T0DPR6SMC")}</script><meta property="og:url" content="https://congchan.github.io/tags/java/"><meta property="og:site_name" content="Cong's Log"><meta property="og:title" content="Java"><meta property="og:description" content="Hi, this is Cong. I’m documenting my learning notes in this blog."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java"><meta name=twitter:description content="Hi, this is Cong. I’m documenting my learning notes in this blog."></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://congchan.github.io/ accesskey=h title="Cong's Log (Alt + H)">Cong's Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://congchan.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://congchan.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://congchan.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://congchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://congchan.github.io/tags/>Tags</a></div><h1>Java
<a href=/tags/java/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 泛型</h2></header><div class=entry-content><p>泛型 泛型意味着更好的类型安全性。主要目的是支持类型安全性的集合，让问题尽可能在编译阶段就能捉到。
泛型定义在类声明中 public class ArrayLiat&lt;E> extends AbstractLìst&lt;E> implements List&lt;E> { public boolean add (E o); } E代表用来创建赋予初始ArrayList的类型
ArrayList&lt;String> list = new ArrayList&lt;String>; 编译器会自动把E看做String.
泛型方法 使用未定义在类声明的类型参数: 在返回类型之前指定泛型
maxKey: 返回给定ArrayMap中所有keys的最大值（仅在key可以比较的情况下）。假如这样写public static K maxKey(Map61B&lt;K, V> map) { ... }会报错. 要将方法声明为泛型，必须在返回类型前面指定正式的类型参数
public static &lt;K extends Comparable&lt;K>, V> K maxKey(Map61B&lt;K, V> map) { List&lt;K> keylist = map.keys(); K largest = map.get(0); for (K k: keylist) { if (k.compareTo(largest)) { largest = k; } } return largest; } K extends Comparable&lt;K> 保证了keys必须实现Comparable接口（也是一个generic接口）, 并可以与其他K进行比较。
...</p></div><footer class=entry-footer><span title='2017-05-29 00:00:00 +0000 UTC'>2017-05-29</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 泛型" href=https://congchan.github.io/posts/java-%E6%B3%9B%E5%9E%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 迭代 Iteration</h2></header><div class=entry-content><p>Java提供了 foreach (enhanced for) 的循环简写语法:
ArrayMap&lt;String, Integer> am = new ArrayMap&lt;String, Integer>(); for (String s : am) { System.out.println(s); } 实现的关键原理是使用Iterable接口使一个类变成可迭代的: 该接口包含一个iterator()方法用于返回一个Iterator对象。Iterator接口定义Iterator对象和hasNext(), next()方法来进行实际的迭代操作。
public class ArrayMap&lt;K, V> implements Map61B&lt;K, V>, Iterable&lt;K> { private K[] keys; private V[] values; int size; public ArrayMap() { keys = (K[]) new Object[100]; values = (V[]) new Object[100]; size = 0; } @Override public Iterator&lt;T> iterator() { return new KeyIterator(); } public class KeyIterator implements Iterator&lt;K> { private int ptr; public KeyIterator() { ptr = 0; } public boolean hasNext() { return (ptr != size); } public K next() { K returnItem = keys[ptr]; ptr = ptr + 1; return returnItem; } } } 不同的数据结构，Iterator有不同的实现方式.
...</p></div><footer class=entry-footer><span title='2017-05-29 00:00:00 +0000 UTC'>2017-05-29</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 迭代 Iteration" href=https://congchan.github.io/posts/java-%E8%BF%AD%E4%BB%A3-iteration/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 高阶函数和回调</h2></header><div class=entry-content><p>Higher Order Functions A higher order function is a function that treats other functions as data.
在 Java 7 及之前的版本, memory boxes (variables) 不能包含指向 functions 的 pointers, 也就是无法给 functions 指定 types. 所以不能像Python一样直接把 function 作为参数传递到另一个 function 中。只能借用 interface：
public interface IntUnaryFunction { int apply(int x); } // 定义一个方法 public class TenX implements IntUnaryFunction { /* Returns ten times the argument. */ public int apply(int x) { return 10 * x; } } // 高阶方法 public static int do_twice(IntUnaryFunction f, int x) { return f.apply(f.apply(x)); } // 调用高阶方法 System.out.println(do_twice(new TenX(), 2)); 在JAVA 8中，提供了很多函数式的接口。Java 8 引入 java.util.Function&lt;T, R>接口, 可以接受存储一个函数，&lt;T, R>对应该函数的参数和返回对象
...</p></div><footer class=entry-footer><span title='2017-05-29 00:00:00 +0000 UTC'>2017-05-29</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 高阶函数和回调" href=https://congchan.github.io/posts/java-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%9B%9E%E8%B0%83/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java Hash @Override equals() hashcode()</h2></header><div class=entry-content><p>主要介绍：
Hashcode（哈希码）与 equals（判断相等）的关系 Hashcode 方法的底层实现原理 开发中需要掌握的原则和方法 HashSet, HashMap, HashTable HashSet底层是调用HashMap. HashMap 使用hashCode和equals来进行对象比较。
拿HashSet和add()举例(其余的数据结构,和 remove, contains等方法类似): 假设HashSet里面已经有了obj1, 那么当调用HashSet.add(obj2)时:
if (obj1 == obj2), 那么没有必要调用 hashCode(), 已经有了这个对象, 没必要添加了 else, if hashCode 不同，那么可以直接添加了, 没必要进一步调用 obj1.equals(obj2) 来判断对象是否相等 else hashCode 相同，那么需要进一步调用obj1.equals(obj2) 下面这段代码虽然 HashSet 只存了 a 对象，但当检查是否包含 b 对象时，返回true。
HashSet&lt;String> wordSet = new HashSet&lt;String>(); String a = "hello"; String b = "hello"; wordSet.add(a); return wordSet.contains(b); // return true 根据Javadoc for Set.
adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)).
...</p></div><footer class=entry-footer><span title='2017-02-26 00:00:00 +0000 UTC'>2017-02-26</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java Hash @Override equals() hashcode()" href=https://congchan.github.io/posts/java-hash-@override-equals-hashcode/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 多线程</h2></header><div class=entry-content><p>多线程 线程是独立的执行空间，Java语言内置多线程功能，用类Thread来表达。每个Java应用程序会启动一个主线程 – 将main()放在自己的执行空间的最开始处. JVM会负责主线程的启动(以及其他比如GC的系统线程). 程序员负责启动自己的建立的线程.
启动新线程
建立Runnable对象作为线程任务Runnable job = new MyRunnable(), Runnable接口只有一个方法run() 建立Thread对象并赋值Runnable Thread thread1 = new Thread(job); Thread thread2 = new Thread(job) 启动thread.start(); 另一种创建线程的方法是用Thread的子类覆盖掉run(), 构造新线程Thread t = new Thread();. 从OO的角度看待, 此时Thread 与线程任务是不同概念的. 让子类继承Thread的目的通常是需要更特殊的Thread, 需要特殊的行为, 如果没有这种需求, 就没必要继承Thread.
线程调度器 多线程间的切换由调度器scheduler来管理, 线程有多种状态:
执行中, sleep(2000): 睡眠2000ms, 时间到之前不会被执行, 但时间到了并不保证一定会被执行. 可能会抛出InterruptedException, 所以对它的调用要包含在try/catch中. locked. 线程的run完成执行后, 将无法重新启动.
调度器在不同的JVM有不同的做法. 测试多线程时需要在不同机器上测试.
并发 Concurrency并发环境中, 为了避免冲突, 需要上锁, 使用synchronized来修饰方法使之每次只能被单一线程读写. 同步化是有代价的, 查询钥匙有性能上的损耗, 同步化也会强制线程排队执行, 还可能出现死锁.
死锁 因为两个线程互相持有对方正在等待的东西, 导致没有一方可以脱离等待. 数据库有事务回滚机制来复原死锁的事务, 但Java没有处理死锁的机制.
...</p></div><footer class=entry-footer><span title='2017-02-26 00:00:00 +0000 UTC'>2017-02-26</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 多线程" href=https://congchan.github.io/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 套接字Socket</h2></header><div class=entry-content><p>Socket 网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket，确切的说Socket是个代表两台机器之间网络连接的对象。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。 Socket socket = new Socket("192.168.2.1", 5000), 第一个参数是IP地址, 第二个参数是端口. Socket连接的建立代表两台机器之间存有对方的信息, 包括网络地址和TCP端口号.
但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。
使用BufferedReader从Socket上读取数据：
建立对服务器的Socket连接Socket socket = new Socket("192.168.2.1", 5000) 建立连接到Socket上低层输入串流的InputStreamReader InputStreamReader stream = new InputStreamReader(socket.getInputStream());, 作为从低层和高层串流间的桥梁, 把来自服务器的字节转换为字符 建立缓冲区BufferedReader来读取 BufferedReader reader = new BufferedReader(stream); String msg = reader.readLine(); 用PrintWriter写数据到Socket上:
建立对服务器的Socket连接 建立链接到Socket的PrintWriter PrintWriter writer = new PrintWriter(socket.getOutputStream()), 作为字符数据和字节间的转换桥梁, 可以衔接Strings和Socket两端 写入数据 writer.println("You have a message"); TCP/IP TCP/IP协议集包括应用层, 传输层，网络层，网络访问层。
应用层协议主要包括如下几个：FTP、TELNET、DNS、SMTP、NFS、HTTP。
FTP(File Transfer Protocol）是文件传输协议，一般上传下载用FTP服务，数据端口是20H，控制端口是21H。 Telnet服务是用户远程登录服务，使用23H端口，使用明码传送，保密性差、简单方便。 DNS(Domain Name Service）是域名解析服务，提供域名到IP地址之间的转换，使用端口53。 SMTP(Simple Mail Transfer Protocol）是简单邮件传输协议，用来控制信件的发送、中转，使用端口25。 NFS（Network File System）是网络文件系统，用于网络中不同主机间的文件共享。 HTTP(Hypertext Transfer Protocol）是超文本传输协议，用于实现互联网中的WWW服务，使用端口80。 网络接口层:
...</p></div><footer class=entry-footer><span title='2017-02-26 00:00:00 +0000 UTC'>2017-02-26</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 套接字Socket" href=https://congchan.github.io/posts/java-%E5%A5%97%E6%8E%A5%E5%AD%97socket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 抽象类</h2></header><div class=entry-content><p>抽象类 有些情况下，有些父类在实际应用中只有被继承的和产生多态的意义，而没有实例化的意义（比如抽象的Animal, Canine等，实例化这些抽象概念没有实际意义），所以不希望这种父类会被初始化。通过标记类为抽象类，编译器就知道该类不能创建实例(不能作为new实例, 但可以用于声明类型).
abstract class Canine extends Animal { ... } Canine c = new Dog; // Canine c = new Canine(); 无法编译 反之，不抽象的类就是具体类.
有抽象类自然就有抽象方法，抽象的方法没有实体，所有就不会含有具体的实现public abstract void doSomething();. 只有抽象类才能拥有抽象方法. 在抽象父类中定义可继承的抽象方法, 可以定义出一组子类共同的协议, 这样能够保证多态. 但因为抽象方法只是为了标记处多态而存在, 它们没有具体的内容, 这样在继承树结构下的第一个具体类就必须要实现所有的抽象方法. 当然, 树结构中的抽象类也可以提前把抽象方法实现了(default方法).
抽象类和接口的比较 接口是抽象类的极端形式，接口是完全抽象的，不包含实现（新的特性支持default method）。
有很多情景需要某个类继承多种父类。比如，因为原来的业务需求比较单一，只需要Animal - Canine - Dog这种类结构就满足需求了, 此时Dog只是Animal的子类. 但后来有了新的功能需求, 上线了宠物功能, 理论上可以为每一种具体的属于宠物的子类添加宠物功能, 这就涉及大量的人工和bug. 但假如额外设计一种Pet类, 那么Pet和Animal会有交叉重叠, 如果让宠物子类同时继承两种超类, 那就是多重继承. 因为多重继承会有致命方块的问题. 所以Java不支持这种方式.
而接口这个概念, 就是用于解决这个问题的:
public interface Pet { public abstract void beFriendly(); public abstract void play(); } // 对于属于宠物的子类，让其实现接口`Pet`. public class Dog extends Canine implements Pet {} 基本上，接口能做的抽象类都可以做。 但接口的最大意义就是其无比的适用性, 若以接口取代具体的子类或抽象类作为参数或返回类型, 那么就可以传入任何有实现该接口的东西. 有了接口,
...</p></div><footer class=entry-footer><span title='2017-02-26 00:00:00 +0000 UTC'>2017-02-26</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 抽象类" href=https://congchan.github.io/posts/java-%E6%8A%BD%E8%B1%A1%E7%B1%BB/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 类的继承扩展 Extends</h2></header><div class=entry-content><p>类的继承扩展 定义class之间的层次关系.
假设要构建一个RotatingSLList，它具有与SLList相同的功能，如addFirst, size等，但是需要额外的rotateRight操作将最后一项放到列表的前面，因为继承允许子类重用已经定义的类中的代码。所以让RotatingSLList类从SLList继承部分代码:
public class RotatingSLList&lt;Item> extends SLList&lt;Item> {} RotatingSLList“是一种”SLList, extends可以让我们继承SLList的原始功能，并能修改或添加其他功能。
/** The rotateRight method takes in an existing list, and rotates every element one spot to the right, moving the last item to the front of the list. For example, input [5, 9, 15, 22] should return [22, 5, 9, 15]. */ public void rotateRight() { Item x = removeLast(); addFirst(x); } 通过extends, 子类继承父类的所有成员，成员包括：
...</p></div><footer class=entry-footer><span title='2017-02-25 00:00:00 +0000 UTC'>2017-02-25</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 类的继承扩展 Extends" href=https://congchan.github.io/posts/java-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%89%A9%E5%B1%95-extends/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 13 | 接口默认方法</h2></header><div class=entry-content><p>除了单纯提供声明之外，Java 8 也允许接口提供具体的实现方法。
缺省方法 从 Java 8开始支持 Default method。
我们可以在List中列出已实现的method。这些方法就是 default method，定义了List hypernyms的一些默认行为：default public void method() { ... }.
我们可以自由调用interface中定义的方法，而不用操心具体的实现。Default method 适用于实现接口的任何类型的对象！子类可以直接调用，而不必重新实现 default method。
// List default public void print() { ... } 不过，我们仍然可以override default method，在子类中重新定义该方法。这样，只要我们在LinkedLList上调用print()，它就会调用子类override的方案，而不是父类的。
// LinkedList @Override public void print() { ... } Dynamic type Java是通过一个叫“dynamic method selection”的特性，来确定要调用 default method 还是已经被子类override的method。
当实例声明List&lt;String> l = new LinkedList&lt;String>();, 则指明l是 static 类型的 List。由 new 生成的 object 是LinkedList类型，也从属于 List 类型。但是，因为这个对象本身是使用 LinkedList 构造函数实例化的，所以我们称之为 dynamic type。
...</p></div><footer class=entry-footer><span title='2017-02-24 00:00:00 +0000 UTC'>2017-02-24</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 13 | 接口默认方法" href=https://congchan.github.io/posts/java-13-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Java 12 | 接口 Interface</h2></header><div class=entry-content><p>子类在什么情况下需要多个父类？
比如，因为原来的业务需求比较单一，只需要Animal - Canine - Dog这种类结构就满足需求了, 此时Dog只是Animal的子类. 但后来有了新的功能需求, 上线了宠物功能, 理论上可以为每一种具体的属于宠物的子类添加宠物功能, 这就涉及大量的人工和bug. 但假如额外设计一种Pet类, 那么Pet和Animal会有交叉重叠, 如果让宠物子类同时继承两种超类, 那就是多重继承. 因为多重继承会有致命方块的问题, 不同父类对同一个方法的可能有不同的实现方式, 这会导致冲突. 所以Java不支持这种方式.
接口 而接口这个概念, 就可以用于解决这个问题的. 类不需要继承多个父类, 只需要实现一个或多个接口指定的所有方法/行为的关系.
public interface Pet { public abstract void beFriendly(); public abstract void play(); } // 对于属于宠物的子类，让其实现接口`Pet`. public class Dog extends Canine implements Pet {} 接口作为参数 我们前面创建的 LinkedList and ArrayList 其实很相似 - 所有的method都一样.
如果我们需要写一个需要用到数组的类比如WordUtils class,
public class WordUtils { /** Returns the length of the longest word. */ public static String longest(LinkedList&lt;String> list) { ... return list.get(maxDex); } } 我们如何让longest方法也适配ArrayList？简单的方法及时写两个同名不同参数的methods。即所谓method overloading。 public static String longest(LinkedList&lt;String> list) public static String longest(ArrayList&lt;String> list)
...</p></div><footer class=entry-footer><span title='2017-02-23 00:00:00 +0000 UTC'>2017-02-23</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Cong Chan</footer><a class=entry-link aria-label="post link to Java 12 | 接口 Interface" href=https://congchan.github.io/posts/java-12-%E6%8E%A5%E5%8F%A3-interface/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://congchan.github.io/tags/java/page/3/>«&nbsp;Prev&nbsp;3/6
</a><a class=next href=https://congchan.github.io/tags/java/page/5/>Next&nbsp;5/6&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://congchan.github.io/>Cong's Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>